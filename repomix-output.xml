This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/Assets.ts
src/BaseScene.ts
src/BestiarySystem.ts
src/Card.ts
src/cards/CardType.ts
src/cards/FireCard.ts
src/cards/IceCard.ts
src/cards/index.ts
src/cards/MinigunCard.ts
src/cards/MultishotCard.ts
src/cards/SniperCard.ts
src/CardSelectionUI.ts
src/CardStackingSystem.ts
src/CardSystem.ts
src/CollisionSystem.ts
src/Config.ts
src/config/Enemies.ts
src/config/Levels.ts
src/config/Towers.ts
src/CrashHandler.ts
src/DayNightCycle.ts
src/design/borders.ts
src/design/colors.ts
src/design/fonts.ts
src/design/index.ts
src/design/shadows.ts
src/design/spacing.ts
src/design/transitions.ts
src/editor/components/BaseComponent.ts
src/editor/components/EnemyGroupRow.ts
src/editor/components/ThreatMeter.ts
src/editor/components/WaveList.ts
src/editor/editor.css
src/editor/EditorHistory.ts
src/editor/EditorToolbar.ts
src/editor/EnemyRegistry.ts
src/editor/ThreatService.ts
src/editor/WaveModel.ts
src/editor/WaypointManager.ts
src/effects/animators/README.md
src/effects/DeathAnimations.ts
src/effects/index.ts
src/effects/types.ts
src/EffectSystem.ts
src/Enemy.ts
src/EntityFactory.ts
src/EventBus.ts
src/Events.ts
src/FogRenderer.ts
src/FogStructure.ts
src/FogSystem.ts
src/ForgeSystem.ts
src/Game.ts
src/index.ts
src/InputSystem.ts
src/InspectorSystem.ts
src/Map.ts
src/MapData.ts
src/MetricsSystem.ts
src/ObjectRenderer.ts
src/Pathfinder.ts
src/ProceduralPatterns.ts
src/Projectile.ts
src/RendererFactory.ts
src/renderers/EnemyRenderer.ts
src/renderers/ProceduralGrass.ts
src/renderers/ProceduralRoad.ts
src/renderers/SpriteProjectileRenderer.ts
src/renderers/TowerRenderer.ts
src/renderers/turrets/FireTurretRenderer.ts
src/renderers/turrets/IceTurretRenderer.ts
src/renderers/turrets/index.ts
src/renderers/turrets/MinigunTurretRenderer.ts
src/renderers/turrets/SniperTurretRenderer.ts
src/renderers/turrets/SplitTurretRenderer.ts
src/renderers/turrets/TurretRenderer.ts
src/renderers/units/GoblinUnitRenderer.ts
src/renderers/units/HellhoundUnitRenderer.ts
src/renderers/units/MagmaUnitRenderer.ts
src/renderers/units/OrcUnitRenderer.ts
src/renderers/units/RatUnitRenderer.ts
src/renderers/units/SkeletonCommanderUnitRenderer.ts
src/renderers/units/SkeletonUnitRenderer.ts
src/renderers/units/SpiderUnitRenderer.ts
src/renderers/units/TrollUnitRenderer.ts
src/renderers/units/UnitRenderer.ts
src/renderers/units/WraithUnitRenderer.ts
src/SaveManager.ts
src/Scene.ts
src/scenes/EditorScene.ts
src/scenes/EntityManager.ts
src/scenes/GameController.ts
src/scenes/GameScene.ts
src/scenes/GameState.ts
src/scenes/IGameScene.ts
src/scenes/MenuScene.ts
src/SimplexNoise.ts
src/SoundManager.ts
src/SpatialGrid.ts
src/systems/AcidPuddleSystem.ts
src/systems/AtmosphereSystem.ts
src/systems/LightingSystem.ts
src/systems/NotificationSystem.ts
src/systems/ProjectileSystem.ts
src/systems/SkeletonCommanderSystem.ts
src/Tower.ts
src/types.ts
src/ui/bestiary/BestiaryUI.ts
src/ui/bestiary/WaveAnalyst.ts
src/ui/DevConsole.ts
src/ui/GameHUD.ts
src/ui/GameOverUI.ts
src/ui/PauseMenu.ts
src/ui/ShopUI.ts
src/UIManager.ts
src/UIUtils.ts
src/Utils.ts
src/utils/Logger.ts
src/utils/SafeJson.ts
src/VisualConfig.ts
src/vite-env.d.ts
src/WaveEditor.ts
src/WaveManager.ts
src/WeaponSystem.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/CardStackingSystem.ts">
import { ICard } from './CardSystem';
import { ICardModifiers, ICardEffect } from './cards/CardType';
import { getCardUpgrade } from './cards';

/**
 * Card Stacking System
 * 
 * Implements the advanced card stacking logic where:
 * - Different card types: All bonuses sum normally
 * - Same card types: Highest level = 100%, others contribute by level:
 *   - Level 3: 70% of stats
 *   - Level 2: 50% of stats
 *   - Level 1: 35% of stats
 */

/**
 * Get stacking bonus percentage based on card level
 */
export function getStackingBonus(level: number): number {
    switch (level) {
        case 3: return 0.70;
        case 2: return 0.50;
        case 1: return 0.35;
        default: return 0.35;
    }
}

/**
 * Group cards by type ID
 */
function groupCardsByType(cards: ICard[]): Map<string, ICard[]> {
    const grouped = new Map<string, ICard[]>();

    for (const card of cards) {
        const typeId = card.type.id;
        if (!grouped.has(typeId)) {
            grouped.set(typeId, []);
        }
        grouped.get(typeId)!.push(card);
    }

    return grouped;
}

export interface MergedCardData {
    modifiers: ICardModifiers;
    effects: ICardEffect[];
}

/**
 * Merge modifiers and effects from cards with advanced stacking rules
 */
export function mergeCardsWithStacking(cards: ICard[]): MergedCardData {
    const result: ICardModifiers = {
        damage: 0,
        damageMultiplier: undefined,
        attackSpeedMultiplier: 1.0,
        range: 0,
        rangeMultiplier: 1.0,
        critChance: 0,
    };
    const allEffects: ICardEffect[] = [];

    // Group cards by type
    const grouped = groupCardsByType(cards);

    // Process each card type group
    for (const [typeId, typeCards] of grouped) {
        // Sort by level (highest first)
        typeCards.sort((a, b) => b.level - a.level);

        if (typeId === 'minigun') {
            // Special handling for Minigun
            processMinigunGroup(typeCards, result, allEffects);
        } else if (typeId === 'multi') {
            // Multishot doesn't add modifiers, skip in this loop
            // (handled separately in Tower.ts)
            continue;
        } else if (typeCards.length === 1) {
            // Single card of this type: 100% bonus
            const upgrade = getCardUpgrade(typeId, typeCards[0].level);
            if (upgrade) {
                applyModifiers(result, upgrade.modifiers, 1.0);
                allEffects.push(...upgrade.effects);
            }
        } else {
            // Multiple cards of same type: use stacking rules
            processSameTypeGroup(typeCards, result, allEffects);
        }
    }

    return { modifiers: result, effects: allEffects };
}

/**
 * Process multiple cards of the same type (non-minigun)
 */
function processSameTypeGroup(
    cards: ICard[],
    result: ICardModifiers,
    allEffects: ICardEffect[]
) {
    // Already sorted by level (highest first)

    // First card (highest level): 100%
    const mainCard = cards[0];
    const mainUpgrade = getCardUpgrade(mainCard.type.id, mainCard.level);
    if (mainUpgrade) {
        applyModifiers(result, mainUpgrade.modifiers, 1.0);
        allEffects.push(...mainUpgrade.effects);
    }

    // Rest of the cards: apply stacking bonus
    for (let i = 1; i < cards.length; i++) {
        const card = cards[i];
        const upgrade = getCardUpgrade(card.type.id, card.level);
        if (!upgrade) continue;

        const bonus = getStackingBonus(card.level);

        // Apply modifiers with bonus percentage
        applyModifiers(result, upgrade.modifiers, bonus);

        // Apply effects with bonus (if they have numeric values)
        applyEffectsWithBonus(upgrade.effects, allEffects, bonus);
    }
}

/**
 * Special processing for Minigun cards
 * 
 * - Takes highest level card for base damageMultiplier
 * - Additional minigun cards add penalties:
 *   - LVL 1: -5% damage
 *   - LVL 2: -7% damage
 *   - LVL 3: -9% damage
 *   - Penalties are summed
 */
function processMinigunGroup(
    cards: ICard[],
    result: ICardModifiers,
    allEffects: ICardEffect[]
) {
    // Already sorted by level
    const mainCard = cards[0];
    const mainUpgrade = getCardUpgrade('minigun', mainCard.level);

    if (!mainUpgrade) return;

    // Start with main card's damageMultiplier
    let baseDamageMultiplier = mainUpgrade.modifiers.damageMultiplier || 0.30;

    // Calculate penalties from additional minigun cards
    let totalPenalty = 0;
    for (let i = 1; i < cards.length; i++) {
        const level = cards[i].level;
        switch (level) {
            case 1:
                totalPenalty += 0.05; // 5%
                break;
            case 2:
                totalPenalty += 0.07; // 7%
                break;
            case 3:
                totalPenalty += 0.09; // 9%
                break;
        }
    }

    // Apply penalty to damageMultiplier (subtract from multiplier)
    baseDamageMultiplier -= totalPenalty;

    // Ensure minimum multiplier (can't go below 10%)
    baseDamageMultiplier = Math.max(0.10, baseDamageMultiplier);

    // Apply to result
    result.damageMultiplier = baseDamageMultiplier;
    result.attackSpeedMultiplier! *= mainUpgrade.modifiers.attackSpeedMultiplier || 1.0;

    // Add effects from main card only
    allEffects.push(...mainUpgrade.effects);
}

/**
 * Apply modifiers with a bonus multiplier
 */
function applyModifiers(
    result: ICardModifiers,
    modifiers: ICardModifiers,
    bonus: number
) {
    // Flat bonuses: multiply by bonus percentage
    if (modifiers.damage !== undefined) {
        result.damage! += modifiers.damage * bonus;
    }

    if (modifiers.range !== undefined) {
        result.range! += modifiers.range * bonus;
    }

    // Multipliers: scale the effect
    if (modifiers.attackSpeedMultiplier !== undefined) {
        // Effect = (multiplier - 1.0), e.g., 0.85 -> effect = -0.15
        const effect = modifiers.attackSpeedMultiplier - 1.0;
        const scaledEffect = effect * bonus;
        const finalMultiplier = 1.0 + scaledEffect;
        result.attackSpeedMultiplier! *= finalMultiplier;
    }

    if (modifiers.rangeMultiplier !== undefined) {
        const effect = modifiers.rangeMultiplier - 1.0;
        const scaledEffect = effect * bonus;
        const finalMultiplier = 1.0 + scaledEffect;
        result.rangeMultiplier! *= finalMultiplier;
    }

    // Crit chance: sum with bonus (not just max)
    if (modifiers.critChance !== undefined) {
        result.critChance! += modifiers.critChance * bonus;
    }

    // DamageMultiplier: only used by Minigun, handled specially
    // Don't merge here
}

/**
 * Apply effects with bonus percentage and deduplication
 */
function applyEffectsWithBonus(
    effects: ICardEffect[],
    allEffects: ICardEffect[],
    bonus: number
) {
    // Add effects with deduplication - only keep strongest version of each effect type
    for (const effect of effects) {
        const existing = allEffects.find(e => e.type === effect.type);

        if (!existing) {
            // New effect type - add it
            allEffects.push({ ...effect });
        } else {
            // Effect already exists - update to maximum values
            if (effect.splashRadius !== undefined && existing.splashRadius !== undefined) {
                existing.splashRadius = Math.max(existing.splashRadius, effect.splashRadius);
            }
            if (effect.slowDuration !== undefined && existing.slowDuration !== undefined) {
                existing.slowDuration = Math.max(existing.slowDuration, effect.slowDuration);
            }
            if (effect.slowPower !== undefined && existing.slowPower !== undefined) {
                existing.slowPower = Math.max(existing.slowPower, effect.slowPower);
            }
            if (effect.damageToSlowed !== undefined && existing.damageToSlowed !== undefined) {
                existing.damageToSlowed = Math.max(existing.damageToSlowed, effect.damageToSlowed);
            }
            if (effect.pierceCount !== undefined && existing.pierceCount !== undefined) {
                existing.pierceCount = Math.max(existing.pierceCount, effect.pierceCount);
            }
            if (effect.explosionDamagePercent !== undefined && existing.explosionDamagePercent !== undefined) {
                existing.explosionDamagePercent = Math.max(existing.explosionDamagePercent, effect.explosionDamagePercent);
            }
            if (effect.explosionRadius !== undefined && existing.explosionRadius !== undefined) {
                existing.explosionRadius = Math.max(existing.explosionRadius, effect.explosionRadius);
            }
            if (effect.chainRadius !== undefined && existing.chainRadius !== undefined) {
                existing.chainRadius = Math.max(existing.chainRadius, effect.chainRadius);
            }
            // Spinup effects - keep from main card (already handled in processMinigunGroup)
        }
    }
}
</file>

<file path="src/config/Levels.ts">
export const ECONOMY_CONFIG = {
    WAVE_CLEAR_REWARD: 2,
    WAVE_BASE_REWARD: 20,          // NEW: Base reward for completing a wave
    WAVE_SCALING_FACTOR: 2,        // NEW: Additional reward per wave number (+2 per wave)
    DROP_CHANCE: 0.15,
    EARLY_WAVE_BONUS: 15,          // Reduced from 30 to 15
    PERFECT_WAVE_BONUS: 10,        // NEW: Bonus for no enemy leaks
    TOWER_COST: 55,
    FORGE_COST_LVL1: 50,           // LVL1‚Üí2 forge cost
    FORGE_COST_LVL2: 65,           // LVL2‚Üí3 forge cost (was FORGE_COST: 50)
    SHOP_COST: 100,
    SHOP_REROLL_COST: 25,          // Increased from 15 to 25
    SELL_REFUND: 0.5,
    CARD_SELL_PRICES: [0, 5, 10, 25], // Index = level (0 unused, 1-3 are actual prices)
};

export const WAVE_CONFIG = [
    // –í–æ–ª–Ω–∞ 1: –û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
    {
        enemies: [
            { type: 'GRUNT', count: 10, spawnPattern: 'normal' }
        ]
    },
    // –í–æ–ª–Ω–∞ 2: –†–∞–Ω–¥–æ–º–Ω—ã–π —Ä–µ–∂–∏–º –¥–ª—è –Ω–µ–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ—Å—Ç–∏
    {
        enemies: [
            { type: 'SCOUT', count: 12, spawnPattern: 'random' }
        ]
    },
    // –í–æ–ª–Ω–∞ 3: –ö–æ–º–±–∏–Ω–∞—Ü–∏—è –æ–±—ã—á–Ω–æ–≥–æ –∏ —Ä–æ—è
    {
        enemies: [
            { type: 'GRUNT', count: 15, spawnPattern: 'normal' },
            { type: 'TANK', count: 2, spawnPattern: 'normal' }
        ]
    },
    // –í–æ–ª–Ω–∞ 4: –†–æ–π —Å–∫–∞—É—Ç–æ–≤ + —Ç–∞–Ω–∫–∏ —Ä–∞–Ω–¥–æ–º–Ω–æ
    {
        enemies: [
            { type: 'SCOUT', count: 20, spawnPattern: 'swarm' },
            { type: 'TANK', count: 3, spawnPattern: 'random' }
        ]
    },
    // –í–æ–ª–Ω–∞ 5: –§–∏–Ω–∞–ª—å–Ω–∞—è –≤–æ–ª–Ω–∞ —Å –±–æ—Å—Å–æ–º
    {
        enemies: [
            { type: 'GRUNT', count: 25, spawnPattern: 'random' },
            { type: 'BOSS', count: 1, spawnPattern: 'normal' }
        ]
    }
];
</file>

<file path="src/config/Towers.ts">
export const TOWER_CONFIG = {
    BASE_RANGE: 120,
    BASE_DMG: 5,
    BASE_CD: 0.9, // 54 / 60 = 0.9 seconds
    BUILD_TIME: 1.0, // 60 / 60 = 1.0 second
    MAX_CARDS: 3,
    BARREL_LENGTH: 22,
    TURN_SPEED: 9.0, // 0.15 * 60 = 9.0 radians per second
    AIM_TOLERANCE: 0.1,
};

export const TARGETING_MODES = {
    FIRST: { id: 'first', name: '–ü–µ—Ä–≤—ã–π', icon: 'üèÉ', desc: '–ë–ª–∏–∂–µ –∫ —Ü–µ–ª–∏' },
    CLOSEST: { id: 'closest', name: '–ë–ª–∏–∂–∞–π—à–∏–π', icon: 'üìç', desc: '–†—è–¥–æ–º —Å –±–∞—à–Ω–µ–π' },
    STRONGEST: { id: 'strongest', name: '–°–∏–ª—å–Ω—ã–π', icon: 'üí™', desc: '–ú–∞–∫—Å. –∑–¥–æ—Ä–æ–≤—å–µ' },
    WEAKEST: { id: 'weakest', name: '–°–ª–∞–±—ã–π', icon: 'üíî', desc: '–ú–∏–Ω. –∑–¥–æ—Ä–æ–≤—å–µ' },
    LAST: { id: 'last', name: '–ü–æ—Å–ª–µ–¥–Ω–∏–π', icon: 'üê¢', desc: '–î–∞–ª—å—à–µ –æ—Ç —Ü–µ–ª–∏' },
};
</file>

<file path="src/design/borders.ts">
/**
 * UI Design Tokens - Borders
 * Border radius, width, and style definitions
 */

export const UI_BORDERS = {
    radius: {
        none: '0',
        sm: '4px',
        md: '8px',
        lg: '12px',
        xl: '16px',
        full: '9999px'
    },

    width: {
        none: '0',
        thin: '1px',
        normal: '2px',
        thick: '3px',
        bold: '4px'
    },

    style: {
        solid: 'solid',
        dashed: 'dashed',
        dotted: 'dotted'
    }
} as const;
</file>

<file path="src/design/colors.ts">
/**
 * UI Design Tokens - Color System
 * Centralized color definitions for consistent theming
 */

export const UI_COLORS = {
    // Primary palette
    primary: '#00ffff',      // Cyan - –¥–ª—è –∞–∫—Ü–µ–Ω—Ç–æ–≤, –≤—ã–±–æ—Ä–∞
    secondary: '#ff6b6b',    // Coral Red
    success: '#4caf50',      // Green
    warning: '#ff9800',      // Orange
    danger: '#f44336',       // Red
    info: '#2196f3',         // Blue

    // Glass-morphism effects
    glass: {
        bg: 'rgba(30, 30, 40, 0.85)',
        bgLight: 'rgba(30, 30, 40, 0.6)',
        bgDark: 'rgba(20, 20, 30, 0.95)',
        border: 'rgba(255, 255, 255, 0.1)',
        borderHover: 'rgba(255, 255, 255, 0.2)',
        shadow: '0 8px 32px rgba(0, 0, 0, 0.3)'
    },

    // Text colors
    text: {
        primary: '#ffffff',
        secondary: '#b0b0b0',
        disabled: '#666666',
        hint: '#888888'
    },

    // Neutral palette (–¥–ª—è –∫–Ω–æ–ø–æ–∫, —Ñ–æ–Ω–æ–≤)
    neutral: {
        dark: '#222',
        medium: '#333',
        light: '#555',
        lighter: '#777'
    },

    // Overlays
    overlay: 'rgba(0, 0, 0, 0.8)',
    overlayLight: 'rgba(0, 0, 0, 0.4)',
} as const;
</file>

<file path="src/design/fonts.ts">
/**
 * UI Design Tokens - Typography
 * Font family, size, and weight definitions
 */

export const UI_FONTS = {
    family: {
        primary: 'Segoe UI, sans-serif',
        mono: 'Consolas, monospace'
    },

    size: {
        xs: '11px',
        sm: '12px',
        md: '14px',
        lg: '16px',
        xl: '20px',
        xxl: '24px',
        huge: '42px',
        massive: '60px'
    },

    weight: {
        normal: '400',
        medium: '500',
        bold: '700'
    }
} as const;
</file>

<file path="src/design/index.ts">
/**
 * Design System - Main Export
 * Centralizes all UI design tokens
 */

export { UI_COLORS } from './colors';
export { UI_SPACING, getSpacing } from './spacing';
export { UI_TRANSITIONS, getTransition } from './transitions';
export { UI_BORDERS } from './borders';
export { UI_SHADOWS } from './shadows';
export { UI_FONTS } from './fonts';

// Re-export as single UI object for convenience
import { UI_COLORS } from './colors';
import { UI_SPACING } from './spacing';
import { UI_TRANSITIONS } from './transitions';
import { UI_BORDERS } from './borders';
import { UI_SHADOWS } from './shadows';
import { UI_FONTS } from './fonts';

export const UI = {
    COLORS: UI_COLORS,
    SPACING: UI_SPACING,
    TRANSITIONS: UI_TRANSITIONS,
    BORDERS: UI_BORDERS,
    SHADOWS: UI_SHADOWS,
    FONTS: UI_FONTS
} as const;
</file>

<file path="src/design/shadows.ts">
/**
 * UI Design Tokens - Shadows
 * Box shadow definitions for depth
 */

export const UI_SHADOWS = {
    none: 'none',
    sm: '0 2px 4px rgba(0, 0, 0, 0.1)',
    md: '0 4px 8px rgba(0, 0, 0, 0.2)',
    lg: '0 8px 16px rgba(0, 0, 0, 0.3)',
    xl: '0 12px 24px rgba(0, 0, 0, 0.4)',
    glass: '0 8px 32px rgba(0, 0, 0, 0.3)',

    // Glow effects
    glow: {
        primary: '0 4px 15px rgba(0, 255, 255, 0.4)',
        success: '0 4px 15px rgba(76, 175, 80, 0.4)',
        danger: '0 4px 15px rgba(211, 47, 47, 0.5)'
    }
} as const;
</file>

<file path="src/design/spacing.ts">
/**
 * UI Design Tokens - Spacing System
 * Consistent spacing scale for layouts
 */

export const UI_SPACING = {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
    xxl: 48
} as const;

// Helper function
export const getSpacing = (size: keyof typeof UI_SPACING): string => {
    return `${UI_SPACING[size]}px`;
};
</file>

<file path="src/design/transitions.ts">
/**
 * UI Design Tokens - Transitions
 * Standard animation timings and easing curves
 */

export const UI_TRANSITIONS = {
    // Duration values
    duration: {
        instant: '0ms',
        fast: '150ms',
        normal: '300ms',
        slow: '500ms'
    },

    // Easing curves (Material Design)
    easing: {
        standard: 'cubic-bezier(0.4, 0, 0.2, 1)',
        decelerate: 'cubic-bezier(0.0, 0, 0.2, 1)',
        accelerate: 'cubic-bezier(0.4, 0, 1, 1)',
        sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
    },

    // Preset combinations (duration + easing)
    presets: {
        fast: '150ms cubic-bezier(0.4, 0, 0.2, 1)',
        normal: '300ms cubic-bezier(0.4, 0, 0.2, 1)',
        slow: '500ms cubic-bezier(0.4, 0, 0.2, 1)'
    }
} as const;

// Helper function
export const getTransition = (preset: keyof typeof UI_TRANSITIONS.presets): string => {
    return UI_TRANSITIONS.presets[preset];
};
</file>

<file path="src/editor/components/BaseComponent.ts">
/**
 * Abstract base class for UI components.
 * enforcing a standard lifecycle: constructor -> mount -> render -> partial updates -> destroy.
 */
export abstract class BaseComponent<T = any> {
    protected element: HTMLElement;
    protected parent: HTMLElement | null = null;
    protected data: T;

    constructor(data: T) {
        this.data = data;
        this.element = this.createRootElement();
    }

    /**
     * Creates the main container for this component.
     * Override this to customize the tag and classes.
     */
    protected createRootElement(): HTMLElement {
        return document.createElement('div');
    }

    /**
     * Mounts the component to a parent element.
     */
    public mount(parent: HTMLElement): void {
        this.parent = parent;
        this.parent.appendChild(this.element);
        this.render();
    }

    /**
     * Renders the component content.
     * Should be idempotent or handle clearing.
     */
    public abstract render(): void;

    /**
     * Cleanup listeners and remove from DOM.
     */
    public destroy(): void {
        if (this.parent && this.element.parentNode === this.parent) {
            this.parent.removeChild(this.element);
        }
        this.element.innerHTML = '';
        this.parent = null;
    }

    // --- Helpers ---

    protected createElement<K extends keyof HTMLElementTagNameMap>(
        tag: K,
        className?: string,
        text?: string
    ): HTMLElementTagNameMap[K] {
        const el = document.createElement(tag);
        if (className) el.className = className;
        if (text) el.textContent = text;
        return el;
    }
}
</file>

<file path="src/editor/components/ThreatMeter.ts">
import { BaseComponent } from './BaseComponent';
import { ThreatService } from '../ThreatService';

interface ThreatMeterProps {
    threat: number;
}

export class ThreatMeter extends BaseComponent<ThreatMeterProps> {
    private fillElement!: HTMLElement;
    private badgeElement!: HTMLElement;

    protected createRootElement(): HTMLElement {
        const container = document.createElement('div');
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.gap = '8px';
        return container;
    }

    public render(): void {
        this.element.innerHTML = '';

        // Create Badge
        const color = ThreatService.getThreatColor(this.data.threat);
        const label = ThreatService.getThreatLabel(this.data.threat);

        this.badgeElement = this.createElement('span', 'we-threat-badge', label);
        this.badgeElement.style.color = color;
        this.badgeElement.style.border = `1px solid ${color}`;
        this.element.appendChild(this.badgeElement);

        // Create Wrapper for Bar
        const barWrapper = this.createElement('div', 'we-threat-meter');
        barWrapper.style.flex = '1';

        // Create Fill
        this.fillElement = this.createElement('div', 'we-threat-fill');
        this.updateFill(this.data.threat);

        barWrapper.appendChild(this.fillElement);
        this.element.appendChild(barWrapper);

        // Value Text
        const valueText = this.createElement('span', '', Math.round(this.data.threat).toString());
        valueText.style.fontSize = '11px';
        valueText.style.color = '#aaa';
        this.element.appendChild(valueText);
    }

    public update(threat: number) {
        this.data.threat = threat;
        const color = ThreatService.getThreatColor(threat);
        const label = ThreatService.getThreatLabel(threat);

        if (this.badgeElement) {
            this.badgeElement.textContent = label;
            this.badgeElement.style.color = color;
            this.badgeElement.style.border = `1px solid ${color}`;
        }

        this.updateFill(threat);

        // Update number
        if (this.element.lastElementChild) {
            this.element.lastElementChild.textContent = Math.round(threat).toString();
        }
    }

    private updateFill(threat: number) {
        if (!this.fillElement) return;

        const color = ThreatService.getThreatColor(threat);
        // Normalize 0-3000 to 0-100%
        const percentage = Math.min(100, Math.max(5, (threat / 2500) * 100));

        this.fillElement.style.width = `${percentage}%`;
        this.fillElement.style.backgroundColor = color;
        this.fillElement.style.boxShadow = `0 0 10px ${color}`;
    }
}
</file>

<file path="src/editor/components/WaveList.ts">
import { BaseComponent } from './BaseComponent';
import { WaveModel } from '../WaveModel';
import { EnemyGroupRow } from './EnemyGroupRow';
import { ThreatMeter } from './ThreatMeter';

export class WaveList extends BaseComponent<WaveModel> {
    private expandedWaveIndex: number = 0; // Default open first wave

    public render(): void {
        this.element.innerHTML = '';
        this.element.className = 'we-wave-list';
        this.element.style.display = 'flex';
        this.element.style.flexDirection = 'column';
        this.element.style.gap = '10px';

        const waves = this.data.getWaves();

        waves.forEach((wave, index) => {
            this.renderWaveItem(index);
        });

        // Add Wave Button
        const addBtn = this.createElement('button', 'we-btn we-btn-secondary we-btn-full', '+ Add Wave');
        addBtn.onclick = () => this.data.addWave();
        this.element.appendChild(addBtn);
    }

    private renderWaveItem(index: number) {
        const wave = this.data.getWave(index);
        const threat = this.data.getThreat(index);

        const container = this.createElement('div', 'we-wave-item');

        // --- Header ---
        const header = this.createElement('div', 'we-wave-header');
        header.onclick = (e) => {
            // Prevent toggling if clicking delete button
            if ((e.target as HTMLElement).tagName === 'BUTTON') return;

            if (this.expandedWaveIndex === index) {
                this.expandedWaveIndex = -1; // Collapse
            } else {
                this.expandedWaveIndex = index; // Expand
            }
            this.render(); // Re-render to update view
        };

        const title = this.createElement('span', 'we-wave-title', `Wave ${index + 1}`);
        header.appendChild(title);

        // Preview of threat in header if collapsed
        if (this.expandedWaveIndex !== index) {
            const threatPreview = this.createElement('span', '', `${Math.round(threat)} üíÄ`);
            threatPreview.style.fontSize = '12px';
            threatPreview.style.color = '#888';
            threatPreview.style.marginLeft = 'auto'; // Right align
            threatPreview.style.marginRight = '10px';
            header.appendChild(threatPreview);
        }

        const delBtn = this.createElement('button', 'we-btn we-btn-icon', '‚úï');
        delBtn.style.marginLeft = this.expandedWaveIndex !== index ? '0' : 'auto';
        delBtn.onclick = () => this.data.removeWave(index);
        header.appendChild(delBtn);

        container.appendChild(header);

        // --- Content (if expanded) ---
        if (this.expandedWaveIndex === index) {
            const content = this.createElement('div', 'we-wave-content');

            // 1. Threat Meter
            const meter = new ThreatMeter({ threat });
            meter.mount(content);

            // 2. Enemy Groups
            const groupsContainer = this.createElement('div');
            groupsContainer.style.marginTop = '10px';

            wave.enemies.forEach((group, gIndex) => {
                const row = new EnemyGroupRow({
                    type: group.type,
                    count: group.count,
                    spawnPattern: group.spawnPattern || 'normal',
                    onChange: (updates) => {
                        this.data.updateEnemyGroup(index, gIndex, updates);
                    },
                    onRemove: () => {
                        this.data.removeEnemyGroup(index, gIndex);
                    }
                });
                row.mount(groupsContainer);
            });
            content.appendChild(groupsContainer);

            // 3. Add Enemy Button
            const addEnemyBtn = this.createElement('button', 'we-btn we-btn-secondary', '+ Add Enemy Group');
            addEnemyBtn.style.marginTop = '8px';
            addEnemyBtn.style.fontSize = '12px';
            addEnemyBtn.style.padding = '4px 8px';
            addEnemyBtn.style.width = '100%';
            addEnemyBtn.onclick = () => this.data.addEnemyGroup(index);
            content.appendChild(addEnemyBtn);

            container.appendChild(content);
        }

        this.element.appendChild(container);
    }
}
</file>

<file path="src/editor/editor.css">
/* Wave Editor Core Styles */

.wave-editor-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.5);
    z-index: 2000;
    display: flex;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(2px);
}

.wave-editor-container {
    width: 500px;
    max-height: 85vh;
    background: rgba(30, 30, 35, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
}

/* Header */
.we-header {
    padding: 16px;
    background: rgba(255, 255, 255, 0.05);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.we-header h2 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    color: #fff;
    letter-spacing: 0.5px;
}

/* Content Area */
.we-content {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* Scrollbar */
.we-content::-webkit-scrollbar {
    width: 8px;
}
.we-content::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.2);
}
.we-content::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.2);
    border-radius: 4px;
}

/* Footer */
.we-footer {
    padding: 16px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    gap: 12px;
    background: rgba(20, 20, 25, 0.95);
}

/* Buttons */
.we-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}

.we-btn-primary {
    background: #4caf50;
    color: white;
}
.we-btn-primary:hover { background: #43a047; }

.we-btn-danger {
    background: #f44336;
    color: white;
}
.we-btn-danger:hover { background: #e53935; }

.we-btn-secondary {
    background: rgba(255,255,255,0.1);
    color: #eee;
}
.we-btn-secondary:hover { background: rgba(255,255,255,0.2); }

.we-btn-icon {
    padding: 4px;
    width: 24px;
    height: 24px;
    border-radius: 4px;
    background: transparent;
    color: #aaa;
}
.we-btn-icon:hover {
    background: rgba(255,255,255,0.1);
    color: #fff;
}

.we-btn-full {
    width: 100%;
}

/* Wave Item */
.we-wave-item {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    overflow: hidden;
    transition: background 0.2s;
}

.we-wave-item:hover {
    background: rgba(255, 255, 255, 0.06);
    border-color: rgba(255, 255, 255, 0.1);
}

.we-wave-header {
    padding: 10px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(0,0,0,0.2);
    cursor: pointer;
}

.we-wave-title {
    font-weight: 600;
    font-size: 14px;
    color: #bbb;
}

.we-wave-content {
    padding: 10px;
    border-top: 1px solid rgba(255,255,255,0.05);
}

/* Enemy Row */
.we-enemy-row {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-bottom: 8px;
    padding: 4px;
    border-radius: 4px;
    background: rgba(0,0,0,0.2);
}

.we-enemy-row select, .we-enemy-row input {
    background: rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.1);
    color: #fff;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 13px;
}

.we-enemy-row select:focus, .we-enemy-row input:focus {
    border-color: #2196f3;
    outline: none;
}

/* Threat Meter */
.we-threat-meter {
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 4px;
    width: 100px;
}

.we-threat-fill {
    height: 100%;
    transition: width 0.3s ease, background-color 0.3s ease;
}

.we-threat-badge {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 10px;
    background: rgba(0,0,0,0.4);
    font-weight: bold;
}
</file>

<file path="src/editor/EditorHistory.ts">
interface IEditorAction {
    type: 'tile' | 'waypoint' | 'fog';
    undo: () => void;
    redo: () => void;
}

export class EditorHistory {
    private undoStack: IEditorAction[] = [];
    private redoStack: IEditorAction[] = [];
    private readonly maxSize = 50;

    public push(action: IEditorAction): void {
        this.undoStack.push(action);

        // Clear redo stack when new action is added
        this.redoStack = [];

        // Maintain max size
        if (this.undoStack.length > this.maxSize) {
            this.undoStack.shift();
        }
    }

    public undo(): boolean {
        const action = this.undoStack.pop();
        if (!action) return false;

        action.undo();
        this.redoStack.push(action);

        return true;
    }

    public redo(): boolean {
        const action = this.redoStack.pop();
        if (!action) return false;

        action.redo();
        this.undoStack.push(action);

        return true;
    }

    public clear(): void {
        this.undoStack = [];
        this.redoStack = [];
    }

    public canUndo(): boolean {
        return this.undoStack.length > 0;
    }

    public canRedo(): boolean {
        return this.redoStack.length > 0;
    }
}

// Action factory helpers
export class EditorActions {
    /**
     * Create a tile change action
     */
    static createTileAction(
        grid: any[][],
        col: number,
        row: number,
        oldType: number,
        newType: number
    ): IEditorAction {
        return {
            type: 'tile',
            undo: () => {
                grid[row][col].type = oldType;
            },
            redo: () => {
                grid[row][col].type = newType;
            }
        };
    }

    /**
     * Create a fog change action
     */
    static createFogAction(
        fog: any,
        col: number,
        row: number,
        oldDensity: number,
        newDensity: number
    ): IEditorAction {
        return {
            type: 'fog',
            undo: () => {
                fog.setFog(col, row, oldDensity);
            },
            redo: () => {
                fog.setFog(col, row, newDensity);
            }
        };
    }

    /**
     * Create a waypoint action
     */
    static createWaypointAction(
        waypointMgr: any,
        actionType: 'addWaypoint' | 'setStart' | 'setEnd',
        position: { x: number; y: number },
        oldState?: any
    ): IEditorAction {
        return {
            type: 'waypoint',
            undo: () => {
                // Restore old state (for simplicity, clear and rebuild)
                if (oldState) {
                    waypointMgr.clearAll();
                    if (oldState.start) waypointMgr.setStart(oldState.start);
                    if (oldState.end) waypointMgr.setEnd(oldState.end);
                    oldState.waypoints?.forEach((wp: any) => waypointMgr.addWaypoint(wp));
                }
            },
            redo: () => {
                if (actionType === 'addWaypoint') {
                    waypointMgr.addWaypoint(position);
                } else if (actionType === 'setStart') {
                    waypointMgr.setStart(position);
                } else if (actionType === 'setEnd') {
                    waypointMgr.setEnd(position);
                }
            }
        };
    }
}
</file>

<file path="src/editor/ThreatService.ts">
import { IWaveConfig, SpawnPattern } from '../MapData';
import { EnemyRegistry } from './EnemyRegistry';

export class ThreatService {

    /**
     * Multipliers for different spawn patterns.
     * Swarms are more dangerous due to burst density.
     */
    private static PATTERN_MULTIPLIERS: Record<SpawnPattern, number> = {
        'normal': 1.0,
        'random': 1.1,
        'swarm': 1.3
    };

    /**
     * Calculates the threat level of a single enemy group.
     */
    public static calculateGroupThreat(group: { type: string; count: number; spawnPattern?: SpawnPattern }): number {
        const powerPerUnit = EnemyRegistry.getPowerRating(group.type);
        const patternMult = this.PATTERN_MULTIPLIERS[group.spawnPattern || 'normal'] || 1.0;

        return powerPerUnit * group.count * patternMult;
    }

    /**
     * Calculates the total threat level of a wave.
     */
    public static calculateWaveThreat(wave: IWaveConfig): number {
        if (!wave.enemies) return 0;

        return wave.enemies.reduce((total, group) => {
            return total + this.calculateGroupThreat(group);
        }, 0);
    }

    /**
     * Returns a color code representing the threat level.
     * Green -> Yellow -> Orange -> Red -> Purple
     */
    public static getThreatColor(threat: number): string {
        if (threat < 300) return '#4caf50'; // Green (Easy)
        if (threat < 800) return '#ffd700'; // Gold (Warning)
        if (threat < 1500) return '#ff9800'; // Orange (Hard)
        if (threat < 2500) return '#f44336'; // Red (Very Hard)
        return '#9c27b0'; // Purple (Insane)
    }

    /**
     * Returns a human-readable label for the threat level.
     */
    public static getThreatLabel(threat: number): string {
        if (threat < 300) return 'SAFE';
        if (threat < 800) return 'NORMAL';
        if (threat < 1500) return 'DANGEROUS';
        if (threat < 2500) return 'LETHAL';
        return 'NIGHTMARE';
    }
}
</file>

<file path="src/editor/WaveModel.ts">
import { IWaveConfig, SpawnPattern } from '../MapData';
import { ThreatService } from './ThreatService';

type ChangeListener = () => void;

/**
 * Model class for the Wave Editor.
 * Manages the data state and ensures we work on a draft copy.
 */
export class WaveModel {
    private waves: IWaveConfig[];
    private listeners: ChangeListener[] = [];

    constructor(initialWaves: IWaveConfig[]) {
        // Deep copy to ensure we hold a draft state
        this.waves = JSON.parse(JSON.stringify(initialWaves || []));

        // Ensure at least one wave if empty
        if (this.waves.length === 0) {
            this.addWave();
        }
    }

    // --- Data Access ---

    public getWaves(): IWaveConfig[] {
        return this.waves;
    }

    public getWave(index: number): IWaveConfig {
        return this.waves[index];
    }

    public getWaveCount(): number {
        return this.waves.length;
    }

    public getThreat(waveIndex: number): number {
        return ThreatService.calculateWaveThreat(this.waves[waveIndex]);
    }

    // --- Mutation Methods ---

    public addWave() {
        this.waves.push({
            enemies: [{ type: 'GRUNT', count: 5, spawnPattern: 'normal' }]
        });
        this.notify();
    }

    public removeWave(index: number) {
        if (index >= 0 && index < this.waves.length) {
            this.waves.splice(index, 1);
            this.notify();
        }
    }

    public addEnemyGroup(waveIndex: number) {
        const wave = this.waves[waveIndex];
        if (wave) {
            wave.enemies.push({ type: 'GRUNT', count: 1, spawnPattern: 'normal' });
            this.notify();
        }
    }

    public removeEnemyGroup(waveIndex: number, groupIndex: number) {
        const wave = this.waves[waveIndex];
        if (wave && wave.enemies.length > groupIndex) {
            wave.enemies.splice(groupIndex, 1);
            this.notify();
        }
    }

    public updateEnemyGroup(waveIndex: number, groupIndex: number, updates: {
        type?: string;
        count?: number;
        spawnPattern?: SpawnPattern
    }) {
        const wave = this.waves[waveIndex];
        if (wave && wave.enemies[groupIndex]) {
            Object.assign(wave.enemies[groupIndex], updates);
            this.notify();
        }
    }

    public moveWave(fromIndex: number, toIndex: number) {
        if (fromIndex < 0 || fromIndex >= this.waves.length || toIndex < 0 || toIndex >= this.waves.length) return;

        const element = this.waves[fromIndex];
        this.waves.splice(fromIndex, 1);
        this.waves.splice(toIndex, 0, element);
        this.notify();
    }

    // --- Validation ---

    public validate(): boolean {
        // Basic validation: must have waves, each wave must have enemies
        if (this.waves.length === 0) return false;

        for (const wave of this.waves) {
            if (!wave.enemies || wave.enemies.length === 0) return false;
            for (const group of wave.enemies) {
                if (group.count < 1) return false;
            }
        }
        return true;
    }

    // --- Observer Pattern ---

    public subscribe(listener: ChangeListener) {
        this.listeners.push(listener);
    }

    public unsubscribe(listener: ChangeListener) {
        this.listeners = this.listeners.filter(l => l !== listener);
    }

    private notify() {
        this.listeners.forEach(l => l());
    }

    public destroy() {
        this.listeners = [];
    }
}
</file>

<file path="src/editor/WaypointManager.ts">
import { CONFIG } from '../Config';

export class WaypointManager {
    private start: { x: number; y: number } | null = null;
    private waypoints: { x: number; y: number }[] = [];
    private end: { x: number; y: number } | null = null;

    /**
     * Strict ordering: Start ‚Üí WP1 ‚Üí WP2 ‚Üí ... ‚Üí End
     */

    public setStart(pos: { x: number; y: number }): void {
        this.start = pos;
    }

    public setEnd(pos: { x: number; y: number }): void {
        this.end = pos;
    }

    public canAddWaypoint(): boolean {
        // Can only add waypoints if Start is set
        return this.start !== null;
    }

    public addWaypoint(pos: { x: number; y: number }): void {
        if (!this.canAddWaypoint()) {
            console.warn('Cannot add waypoint: Start point not set');
            return;
        }

        this.waypoints.push(pos);
    }

    public removeLastWaypoint(): void {
        this.waypoints.pop();
    }

    public clearAll(): void {
        this.start = null;
        this.waypoints = [];
        this.end = null;
    }

    public clearWaypoints(): void {
        this.waypoints = [];
    }

    public getStart(): { x: number; y: number } | null {
        return this.start;
    }

    public getEnd(): { x: number; y: number } | null {
        return this.end;
    }

    public getWaypoints(): { x: number; y: number }[] {
        return [...this.waypoints];
    }

    /**
     * Get full path: Start ‚Üí WP1 ‚Üí WP2 ‚Üí ... ‚Üí End
     */
    public getFullPath(): { x: number; y: number }[] {
        const path: { x: number; y: number }[] = [];

        if (this.start) path.push(this.start);
        path.push(...this.waypoints);
        if (this.end) path.push(this.end);

        return path;
    }

    public isValid(): boolean {
        // Valid if at least Start and End are set
        return this.start !== null && this.end !== null;
    }

    /**
     * Draw waypoints with lines and arrows
     */
    public draw(ctx: CanvasRenderingContext2D): void {
        const fullPath = this.getFullPath();

        if (fullPath.length < 2) {
            // Draw only start/end markers if they exist
            if (this.start) this.drawMarker(ctx, this.start, 'üèÅ', '#00bcd4', 0);
            if (this.end) this.drawMarker(ctx, this.end, 'üõë', '#e91e63', -1);
            return;
        }

        // Draw connecting lines with arrows
        ctx.strokeStyle = '#00ff00';
        ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
        ctx.lineWidth = 3;

        ctx.beginPath();
        for (let i = 0; i < fullPath.length; i++) {
            const wp = fullPath[i];
            const wpX = wp.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
            const wpY = wp.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

            if (i === 0) {
                ctx.moveTo(wpX, wpY);
            } else {
                ctx.lineTo(wpX, wpY);
            }
        }
        ctx.stroke();

        // Draw arrows between points
        for (let i = 0; i < fullPath.length - 1; i++) {
            const from = fullPath[i];
            const to = fullPath[i + 1];
            this.drawArrow(ctx, from, to);
        }

        // Draw numbered waypoint markers
        fullPath.forEach((wp, idx) => {
            let label: string;
            let color: string;

            if (idx === 0) {
                // Start
                label = 'üèÅ';
                color = '#00bcd4';
            } else if (idx === fullPath.length - 1) {
                // End
                label = 'üõë';
                color = '#e91e63';
            } else {
                // Waypoint
                label = (idx).toString();
                color = '#9c27b0';
            }

            this.drawMarker(ctx, wp, label, color, idx);
        });
    }

    private drawMarker(
        ctx: CanvasRenderingContext2D,
        pos: { x: number; y: number },
        label: string,
        color: string,
        index: number
    ): void {
        const wpX = pos.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const wpY = pos.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        // Circle
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(wpX, wpY, 14, 0, Math.PI * 2);
        ctx.fill();

        // White border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Label
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, wpX, wpY);
    }

    private drawArrow(
        ctx: CanvasRenderingContext2D,
        from: { x: number; y: number },
        to: { x: number; y: number }
    ): void {
        const fromX = from.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const fromY = from.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const toX = to.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const toY = to.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        // Calculate angle
        const angle = Math.atan2(toY - fromY, toX - fromX);

        // Arrow position (midpoint)
        const midX = (fromX + toX) / 2;
        const midY = (fromY + toY) / 2;

        // Arrow size
        const arrowSize = 12;

        ctx.save();
        ctx.translate(midX, midY);
        ctx.rotate(angle);

        // Draw arrow head
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-arrowSize, -arrowSize / 2);
        ctx.lineTo(-arrowSize, arrowSize / 2);
        ctx.closePath();
        ctx.fill();

        // Arrow outline
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
    }
}
</file>

<file path="src/effects/animators/README.md">
# Animators Directory

–ü–∞–ø–∫–∞ –¥–ª—è –≤—ã–Ω–æ—Å–∞ —Å–ª–æ–∂–Ω—ã—Ö –∞–Ω–∏–º–∞—Ç–æ—Ä–æ–≤ –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã.

## –ö–æ–≥–¥–∞ –≤—ã–Ω–æ—Å–∏—Ç—å

- –ï—Å–ª–∏ –∞–Ω–∏–º–∞—Ç–æ—Ä > 50 —Å—Ç—Ä–æ–∫
- –ï—Å–ª–∏ –Ω—É–∂–Ω—ã —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
- –ï—Å–ª–∏ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è —Ñ–∞–∑—ã –∞–Ω–∏–º–∞—Ü–∏–∏

## –ü—Ä–∏–º–µ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```
animators/
‚îú‚îÄ‚îÄ skeleton.ts
‚îú‚îÄ‚îÄ hellhound.ts
‚îî‚îÄ‚îÄ wraith.ts
```
</file>

<file path="src/effects/index.ts">
/**
 * Effects Module - Barrel Export
 * 
 * –ï–¥–∏–Ω–∞—è —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã —ç—Ñ—Ñ–µ–∫—Ç–æ–≤.
 */

export { playDeathAnimation } from './DeathAnimations';
export type { IDeathAnimator, IDeathEffectConfig } from './types';
</file>

<file path="src/effects/types.ts">
/**
 * Death Animation System Types
 * 
 * –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è –º–æ–¥—É–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã –∞–Ω–∏–º–∞—Ü–∏–π —Å–º–µ—Ä—Ç–∏ –≤—Ä–∞–≥–æ–≤.
 * –ì–æ—Ç–æ–≤–æ –∫ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—é: –º–æ–∂–Ω–æ –≤—ã–Ω–µ—Å—Ç–∏ –∞–Ω–∏–º–∞—Ç–æ—Ä—ã –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã.
 */

import { EffectSystem } from '../EffectSystem';
import { IEnemyTypeConfig } from '../types';

/**
 * –§—É–Ω–∫—Ü–∏—è-–∞–Ω–∏–º–∞—Ç–æ—Ä —Å–º–µ—Ä—Ç–∏.
 * –î–æ–±–∞–≤–ª—è–µ—Ç –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –≤ EffectSystem.
 */
export interface IDeathAnimator {
    (effects: EffectSystem, x: number, y: number, config: IEnemyTypeConfig): void;
}

/**
 * –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–Ω–∏–º–∞—Ü–∏–π (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ).
 */
export interface IDeathEffectConfig {
    debrisCount: number;
    particleCount: number;
    color: string;
    velocityX: number;
    velocityY: number;
    size: number;
}
</file>

<file path="src/FogStructure.ts">
/**
 * Fog Structure - represents a connected region of fog tiles
 */
export interface FogTile {
    x: number;
    y: number;
    density: number; // 0-5
}

export interface FogStructure {
    id: number;
    tiles: FogTile[];
    bounds: {
        minX: number;
        maxX: number;
        minY: number;
        maxY: number;
    };
    // Animation state
    noiseOffsetX: number;
    noiseOffsetY: number;
    noiseOffsetRot: number;
}

/**
 * Build fog structures using flood-fill algorithm
 */
export function buildFogStructures(
    fogData: number[],
    width: number,
    height: number
): FogStructure[] {
    const structures: FogStructure[] = [];
    const visited = new Set<number>();
    let structureId = 0;

    const getIndex = (x: number, y: number) => y * width + x;
    const isValid = (x: number, y: number) =>
        x >= 0 && x < width && y >= 0 && y < height;

    // Flood fill from a starting point
    const floodFill = (startX: number, startY: number): FogTile[] => {
        const tiles: FogTile[] = [];
        const queue: { x: number; y: number }[] = [{ x: startX, y: startY }];
        const startIndex = getIndex(startX, startY);
        visited.add(startIndex);

        while (queue.length > 0) {
            const { x, y } = queue.shift()!;
            const density = fogData[getIndex(x, y)];

            tiles.push({ x, y, density });

            // Check 4 neighbors (N, S, E, W)
            const neighbors = [
                { x: x, y: y - 1 },
                { x: x, y: y + 1 },
                { x: x + 1, y: y },
                { x: x - 1, y: y },
            ];

            for (const neighbor of neighbors) {
                if (!isValid(neighbor.x, neighbor.y)) continue;

                const nIndex = getIndex(neighbor.x, neighbor.y);
                if (visited.has(nIndex)) continue;
                if (fogData[nIndex] === 0) continue; // No fog

                visited.add(nIndex);
                queue.push(neighbor);
            }
        }

        return tiles;
    };

    // Find all structures
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = getIndex(x, y);
            if (visited.has(index)) continue;
            if (fogData[index] === 0) continue; // No fog

            const tiles = floodFill(x, y);
            if (tiles.length === 0) continue;

            // Calculate bounds
            let minX = Infinity,
                maxX = -Infinity;
            let minY = Infinity,
                maxY = -Infinity;

            for (const tile of tiles) {
                minX = Math.min(minX, tile.x);
                maxX = Math.max(maxX, tile.x);
                minY = Math.min(minY, tile.y);
                maxY = Math.max(maxY, tile.y);
            }

            structures.push({
                id: structureId++,
                tiles,
                bounds: { minX, maxX, minY, maxY },
                noiseOffsetX: Math.random() * 1000,
                noiseOffsetY: Math.random() * 1000,
                noiseOffsetRot: Math.random() * 1000,
            });
        }
    }

    return structures;
}
</file>

<file path="src/ProceduralPatterns.ts">
import { SimplexNoise } from './SimplexNoise';

/**
 * Procedural Pattern Generation Library
 * Provides algorithms for creating organic and technical textures
 * Used by Assets.ts for layered texture generation
 */
export class ProceduralPatterns {
    private static noise = new SimplexNoise();

    /**
     * Perlin Noise overlay (uses existing SimplexNoise)
     * Adds subtle texture variation to surfaces
     */
    static perlinNoise(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        scale: number = 0.05,
        opacity: number = 0.1
    ): void {
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const value = this.noise.noise2D(x * scale, y * scale); // -1 to 1
                const brightness = Math.floor(value * 25); // -25 to 25

                const idx = (y * width + x) * 4;
                // Darken/lighten based on noise
                data[idx] = Math.max(0, Math.min(255, data[idx] + brightness));     // R
                data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + brightness)); // G
                data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + brightness)); // B
            }
        }

        ctx.putImageData(imageData, 0, 0);
    }

    /**
     * Organic Veins (Dark Fantasy)
     * Draws wandering lines like roots or cracks
     */
    static organicVeins(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        density: number = 0.3,
        seed: number = 0
    ): void {
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 1;
        ctx.lineCap = 'round';

        const veinCount = Math.floor(width * height * density / 1000);

        for (let i = 0; i < veinCount; i++) {
            // Pseudo-random based on seed + index
            const s = seed + i * 137;

            // Simple deterministic random function for this scope
            const rnd = (mod: number) => {
                const x = Math.sin(s + mod) * 10000;
                return x - Math.floor(x);
            };

            let x = rnd(1) * width;
            let y = rnd(2) * height;
            let angle = rnd(3) * Math.PI * 2;

            ctx.beginPath();
            ctx.moveTo(x, y);

            // Wandering path
            const steps = 15 + Math.floor(rnd(4) * 10);
            for (let step = 0; step < steps; step++) {
                angle += (rnd(step * 5) - 0.5) * 0.6; // Slight turns
                x += Math.cos(angle) * 3;
                y += Math.sin(angle) * 3;

                // Keep within bounds
                if (x < 0 || x > width || y < 0 || y > height) break;

                ctx.lineTo(x, y);
            }

            ctx.stroke();
        }

        ctx.restore();
    }

    /**
     * Voronoi Grid (Techno)
     * Creates cell-like patterns mimicking circuits/microchips
     */
    static voronoiGrid(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        cellCount: number = 10
    ): void {
        // Generate random points
        const points: { x: number; y: number }[] = [];
        for (let i = 0; i < cellCount; i++) {
            points.push({
                x: Math.random() * width,
                y: Math.random() * height
            });
        }

        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        // For each pixel, find closest point
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                let minDist = Infinity;
                let closestIdx = 0;

                for (let i = 0; i < points.length; i++) {
                    const dist = Math.hypot(points[i].x - x, points[i].y - y);
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = i;
                    }
                }

                // Color by cell index
                const idx = (y * width + x) * 4;
                const shade = 30 + (closestIdx % 5) * 15; // Subtle variation
                data[idx] = Math.max(0, Math.min(255, data[idx] + shade));
                data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + shade));
                data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + shade));
            }
        }

        ctx.putImageData(imageData, 0, 0);

        // Draw cell borders
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 1;

        for (let y = 0; y < height; y += 2) { // Sample every 2 pixels for performance
            for (let x = 0; x < width - 1; x++) {
                let minDist1 = Infinity, minDist2 = Infinity;
                let closest1 = 0, closest2 = 0;

                // Find closest point for current and next pixel
                for (let i = 0; i < points.length; i++) {
                    const dist1 = Math.hypot(points[i].x - x, points[i].y - y);
                    const dist2 = Math.hypot(points[i].x - (x + 1), points[i].y - y);

                    if (dist1 < minDist1) {
                        minDist1 = dist1;
                        closest1 = i;
                    }
                    if (dist2 < minDist2) {
                        minDist2 = dist2;
                        closest2 = i;
                    }
                }

                // Draw border if different cells
                if (closest1 !== closest2) {
                    ctx.beginPath();
                    ctx.moveTo(x + 0.5, y);
                    ctx.lineTo(x + 0.5, y + 1);
                    ctx.stroke();
                }
            }
        }

        ctx.restore();
    }

    /**
     * Bioluminescent Spots (Dark Fantasy accent)
     * Adds glowing spots using deterministic seed
     */
    static biolumSpots(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        color: string,
        density: number = 0.2,
        seed: number = 0
    ): void {
        ctx.save();
        ctx.fillStyle = color;
        ctx.shadowBlur = 3;  // Reduced from 8 for subtler glow
        ctx.shadowColor = color;

        // Deterministic spot placement (–∑–∞–º–µ—á–∞–Ω–∏–µ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ #3!)
        const spotCount = Math.floor(width * height * density / 1000);

        for (let i = 0; i < spotCount; i++) {
            // Pseudo-random –Ω–æ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
            const pseudoX = ((seed + i) * 73) % width;
            const pseudoY = ((seed + i) * 137) % height;
            const size = 0.5 + ((seed + i) % 2) * 0.5;  // Reduced from 1-3px to 0.5-1.5px

            ctx.beginPath();
            ctx.arc(pseudoX, pseudoY, size, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }
}
</file>

<file path="src/renderers/ProceduralGrass.ts">
import { CONFIG } from '../Config';
import { VISUALS } from '../VisualConfig';

/**
 * –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∂–∏–≤–æ–π —Ç—Ä–∞–≤—ã
 * –î–æ–±–∞–≤–ª—è–µ—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ç—Ä–∞–≤–∏–Ω–∫–∏, –∫–∞–º–µ—à–∫–∏ –∏ –º–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏ –ø–æ–≤–µ—Ä—Ö –±–∞–∑–æ–≤–æ–≥–æ —Å–ª–æ—è
 * 
 * –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:
 * - –¢—Ä–∞–≤–∏–Ω–∫–∏: 12-18 –Ω–∞ —Ç–∞–π–ª, –≤—ã—Å–æ—Ç–∞ 4-8px, –Ω–∞–∫–ª–æ–Ω ¬±15¬∞
 * - –ö–∞–º–µ—à–∫–∏: 1-3 –Ω–∞ —Ç–∞–π–ª (60% —Ç–∞–π–ª–æ–≤)
 * - –¶–≤–µ—Ç–æ—á–∫–∏: 0-1 –Ω–∞ —Ç–∞–π–ª (5% —à–∞–Ω—Å)
 * 
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ö–ê–ñ–î–û–ì–û –≤–∞—Ä–∏–∞–Ω—Ç–∞ grass_0...grass_3
 */
export class ProceduralGrass {
    /**
     * –†–µ–Ω–¥–µ—Ä–∏—Ç —Å–ª–æ–π –¥–µ—Ç–∞–ª–µ–π –Ω–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –±–∞–∑—É
     * @param ctx Canvas context
     * @param x Pixel X (–æ–±—ã—á–Ω–æ 0 –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ Assets)
     * @param y Pixel Y (–æ–±—ã—á–Ω–æ 0 –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ Assets)
     * @param size –†–∞–∑–º–µ—Ä —Ç–∞–π–ª–∞ (64px)
     * @param seed –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –¥–ª—è –≤–∞—Ä–∏–∞—Ü–∏–π
     */
    public static draw(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // 1. –¢—Ä–∞–≤–∏–Ω–∫–∏ (–æ—Å–Ω–æ–≤–Ω–æ–π –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç)
        this.drawGrassBlades(ctx, x, y, size, seed);

        // 2. –ú–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏ (–∫–∞–º–µ—à–∫–∏)
        this.drawPebbles(ctx, x, y, size, seed);

        // 3. –¶–≤–µ—Ç–æ—á–∫–∏ (–æ—á–µ–Ω—å —Ä–µ–¥–∫–æ)
        this.drawTinyFlowers(ctx, x, y, size, seed);
    }

    /**
     * –°–ª–æ–π 1: –û—Ç–¥–µ–ª—å–Ω—ã–µ —Ç—Ä–∞–≤–∏–Ω–∫–∏
     */
    private static drawGrassBlades(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–∞–≤–∏–Ω–æ–∫: 12-18
        const bladeCount = 12 + (seed % 7); // 12-18

        ctx.strokeStyle = VISUALS.ENVIRONMENT.GRASS.BLADE; // #8bc34a
        ctx.lineWidth = 1;

        for (let i = 0; i < bladeCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const bx = x + ((seed * 7 + i * 13) % size);
            const by = y + ((seed * 11 + i * 19) % size);

            // –í—ã—Å–æ—Ç–∞ —Ç—Ä–∞–≤–∏–Ω–∫–∏: 4-8px
            const height = 4 + ((seed + i * 3) % 5); // 4-8px

            // –ù–∞–∫–ª–æ–Ω: ¬±15¬∞
            const angleVariation = ((seed + i * 7) % 30) - 15; // -15 to +15
            const angle = angleVariation * Math.PI / 180;

            // –†–∏—Å—É–µ–º —Ç—Ä–∞–≤–∏–Ω–∫—É
            ctx.save();
            ctx.translate(bx, by);
            ctx.rotate(angle);

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -height); // –í–≤–µ—Ä—Ö –æ—Ç —Ç–æ—á–∫–∏
            ctx.stroke();

            ctx.restore();
        }
    }

    /**
     * –°–ª–æ–π 2: –ú–µ–ª–∫–∏–µ –∫–∞–º–µ—à–∫–∏
     */
    private static drawPebbles(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –ù–µ –Ω–∞ –≤—Å–µ—Ö —Ç–∞–π–ª–∞—Ö –µ—Å—Ç—å –∫–∞–º–µ—à–∫–∏ (60% —à–∞–Ω—Å)
        if (seed % 5 === 0 || seed % 5 === 1) {
            return; // –ù–µ—Ç –∫–∞–º–µ—à–∫–æ–≤ –Ω–∞ —ç—Ç–æ–º —Ç–∞–π–ª–µ
        }

        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–º–µ—à–∫–æ–≤: 1-3
        const pebbleCount = 1 + (seed % 3); // 1-3

        ctx.fillStyle = VISUALS.ENVIRONMENT.GRASS.DETAIL; // #757575

        for (let i = 0; i < pebbleCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const px = x + ((seed * 17 + i * 23) % size);
            const py = y + ((seed * 19 + i * 29) % size);

            // –†–∞–∑–º–µ—Ä: 1-2px
            const pebbleSize = 1 + ((seed + i) % 2);

            ctx.fillRect(px, py, pebbleSize, pebbleSize);
        }
    }

    /**
     * –°–ª–æ–π 3: –ú–µ–ª–∫–∏–µ —Ü–≤–µ—Ç–æ—á–∫–∏ (–æ—á–µ–Ω—å —Ä–µ–¥–∫–æ)
     */
    private static drawTinyFlowers(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –û—á–µ–Ω—å —Ä–µ–¥–∫–æ: 5% —à–∞–Ω—Å
        if (seed % 20 !== 0) {
            return; // –ù–µ—Ç —Ü–≤–µ—Ç–æ—á–∫–∞ –Ω–∞ —ç—Ç–æ–º —Ç–∞–π–ª–µ
        }

        // –ü–æ–∑–∏—Ü–∏—è: –±–ª–∏–∂–µ –∫ –∫—Ä–∞—è–º —Ç–∞–π–ª–∞
        const edge = seed % 4; // 0=top, 1=right, 2=bottom, 3=left
        let fx = x;
        let fy = y;

        switch (edge) {
            case 0: // Top
                fx = x + size / 2 + ((seed % 20) - 10);
                fy = y + 5 + (seed % 10);
                break;
            case 1: // Right
                fx = x + size - 10 - (seed % 10);
                fy = y + size / 2 + ((seed % 20) - 10);
                break;
            case 2: // Bottom
                fx = x + size / 2 + ((seed % 20) - 10);
                fy = y + size - 10 - (seed % 10);
                break;
            case 3: // Left
                fx = x + 5 + (seed % 10);
                fy = y + size / 2 + ((seed % 20) - 10);
                break;
        }

        // –†–∞–∑–º–µ—Ä: 2-3px
        const flowerSize = 2 + (seed % 2);

        // –Ø—Ä–∫–∞—è —Ç–æ—á–∫–∞
        ctx.fillStyle = VISUALS.ENVIRONMENT.GRASS.FLOWER; // #ffeb3b
        ctx.beginPath();
        ctx.arc(fx, fy, flowerSize, 0, Math.PI * 2);
        ctx.fill();

        // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –±–ª–∏–∫ (–µ—â–µ —è—Ä—á–µ)
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(fx, fy, flowerSize / 2, 0, Math.PI * 2);
        ctx.fill();
    }
}
</file>

<file path="src/renderers/ProceduralRoad.ts">
import { CONFIG } from '../Config';
import { VISUALS } from '../VisualConfig';

/**
 * –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∫–∞–º–µ–Ω–Ω–æ–π –¥–æ—Ä–æ–≥–∏
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –±–∏—Ç–º–∞—Å–∫–∏–Ω–≥ –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ø–ª–∏—Ç
 * 
 * –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:
 * - –°–≤–µ—Ç–ª–æ-–±–µ–∂–µ–≤—ã–π –∫–∞–º–µ–Ω—å —Å –≤–∞—Ä–∏–∞—Ü–∏—è–º–∏
 * - –¢—Ä–µ—â–∏–Ω—ã (2-4 –Ω–∞ –ø–ª–∏—Ç—É)
 * - –ó–µ—Ä–Ω–∏—Å—Ç–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ (–∫—Ä–∞–ø–∏–Ω–∫–∏)
 * - –¢—ë–º–Ω—ã–µ –∫—Ä–∞—è –º–µ–∂–¥—É –ø–ª–∏—Ç–∞–º–∏
 * - –†–µ–¥–∫–∏–µ –º–æ—Ö–æ–≤—ã–µ –ø—è—Ç–Ω–∞
 */
export class ProceduralRoad {
    /**
     * –†–µ–Ω–¥–µ—Ä–∏—Ç –æ–¥–Ω—É –∫–∞–º–µ–Ω–Ω—É—é –ø–ª–∏—Ç—É —Å —É—á—ë—Ç–æ–º —Å–æ—Å–µ–¥–µ–π
     * @param ctx Canvas context
     * @param x Pixel X (–∫—Ä–∞—Ç–Ω–æ TILE_SIZE)
     * @param y Pixel Y (–∫—Ä–∞—Ç–Ω–æ TILE_SIZE)
     * @param bitmask –ë–∏—Ç–º–∞—Å–∫–∞ —Å–æ—Å–µ–¥–µ–π 0-15 (NORTH|WEST|EAST|SOUTH)
     */
    public static draw(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        bitmask: number
    ): void {
        const TS = CONFIG.TILE_SIZE;
        const col = Math.floor(x / TS);
        const row = Math.floor(y / TS);

        // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –¥–ª—è –≤–∞—Ä–∏–∞—Ü–∏–π
        const seed = col * 73 + row * 37;

        // 1. –ë–∞–∑–æ–≤–∞—è –ø–ª–∏—Ç–∞ (—Å –≤–∞—Ä–∏–∞—Ü–∏—è–º–∏)
        this.drawBaseTile(ctx, x, y, TS, seed);

        // 2. –ö—Ä–∞—è/–≥—Ä–∞–Ω–∏—Ü—ã (—Ç–æ–ª—å–∫–æ —Ç–∞–º –≥–¥–µ –Ω–µ—Ç —Å–æ—Å–µ–¥–µ–π)
        this.drawEdges(ctx, x, y, TS, bitmask, seed);

        // 3. –î–µ—Ç–∞–ª–∏ (—Ç—Ä–µ—â–∏–Ω—ã, –∫—Ä–∞–ø–∏–Ω–∫–∏)
        this.drawDetails(ctx, x, y, TS, seed);
    }

    /**
     * –°–ª–æ–π 1: –ë–∞–∑–æ–≤–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ –∫–∞–º–Ω—è
     */
    private static drawBaseTile(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –í–∞—Ä–∏–∞—Ü–∏—è —è—Ä–∫–æ—Å—Ç–∏: ¬±10%
        const brightness = 0.9 + (seed % 20) * 0.01; // 0.9 - 1.09

        // –í—ã–±—Ä–∞—Ç—å –±–∞–∑–æ–≤—ã–π –æ—Ç—Ç–µ–Ω–æ–∫
        const baseColors = [
            VISUALS.ENVIRONMENT.PATH.STONE_BASE,   // #c5b8a1
            VISUALS.ENVIRONMENT.PATH.STONE_LIGHT,  // #d4c5a9
            VISUALS.ENVIRONMENT.PATH.STONE_DARK    // #b6a890
        ];
        const colorIndex = seed % 3;
        let baseColor = baseColors[colorIndex];

        // –ü—Ä–∏–º–µ–Ω–∏—Ç—å –≤–∞—Ä–∏–∞—Ü–∏—é —è—Ä–∫–æ—Å—Ç–∏
        baseColor = this.adjustBrightness(baseColor, brightness);

        // –ó–∞–ø–æ–ª–Ω–∏—Ç—å –ø–ª–∏—Ç—É
        ctx.fillStyle = baseColor;
        ctx.fillRect(x, y, size, size);

        // –¢–µ–∫—Å—Ç—É—Ä–∞: –º–µ–ª–∫–æ–∑–µ—Ä–Ω–∏—Å—Ç–∞—è (–∫—Ä–∞–ø–∏–Ω–∫–∏)
        this.drawGrainTexture(ctx, x, y, size, seed);
    }

    /**
     * –ó–µ—Ä–Ω–∏—Å—Ç–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ (–º–µ–ª–∫–∏–µ –∫—Ä–∞–ø–∏–Ω–∫–∏)
     */
    private static drawGrainTexture(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        const speckCount = 8 + (seed % 8); // 8-15 –∫—Ä–∞–ø–∏–Ω–æ–∫

        ctx.fillStyle = '#5a5a5a'; // –¢—ë–º–Ω–æ-—Å–µ—Ä—ã–π

        for (let i = 0; i < speckCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const sx = x + ((seed * 7 + i * 13) % size);
            const sy = y + ((seed * 11 + i * 19) % size);
            const speckSize = 1 + ((seed + i) % 3); // 1-3px

            ctx.fillRect(sx, sy, speckSize, speckSize);
        }
    }

    /**
     * –°–ª–æ–π 2: –ö—Ä–∞—è –º–µ–∂–¥—É –ø–ª–∏—Ç–∞–º–∏
     * –†–∏—Å—É–µ–º —Ç–µ–º–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–æ–ª—å–∫–æ —Ç–∞–º, –≥–¥–µ –ù–ï–¢ —Å–æ—Å–µ–¥–µ–π
     */
    private static drawEdges(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        bitmask: number,
        seed: number
    ): void {
        const NORTH = (bitmask & 1) !== 0;
        const WEST = (bitmask & 2) !== 0;
        const EAST = (bitmask & 4) !== 0;
        const SOUTH = (bitmask & 8) !== 0;

        ctx.strokeStyle = VISUALS.ENVIRONMENT.PATH.EDGE; // #9a8d7a
        ctx.lineWidth = 2;

        // –°–µ–≤–µ—Ä–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!NORTH) {
            ctx.beginPath();
            ctx.moveTo(x, y + 1);
            ctx.lineTo(x + size, y + 1);
            ctx.stroke();
        }

        // –Æ–∂–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!SOUTH) {
            ctx.beginPath();
            ctx.moveTo(x, y + size - 1);
            ctx.lineTo(x + size, y + size - 1);
            ctx.stroke();
        }

        // –ó–∞–ø–∞–¥–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!WEST) {
            ctx.beginPath();
            ctx.moveTo(x + 1, y);
            ctx.lineTo(x + 1, y + size);
            ctx.stroke();
        }

        // –í–æ—Å—Ç–æ—á–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!EAST) {
            ctx.beginPath();
            ctx.moveTo(x + size - 1, y);
            ctx.lineTo(x + size - 1, y + size);
            ctx.stroke();
        }
    }

    /**
     * –°–ª–æ–π 3: –î–µ—Ç–∞–ª–∏ (—Ç—Ä–µ—â–∏–Ω—ã, –º–æ—Ö)
     */
    private static drawDetails(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –¢—Ä–µ—â–∏–Ω—ã: 2-4 –Ω–∞ –ø–ª–∏—Ç—É
        const crackCount = 2 + (seed % 3); // 2-4

        ctx.strokeStyle = VISUALS.ENVIRONMENT.PATH.CRACK; // #8b7e6a
        ctx.lineWidth = 1 + (seed % 2); // 1-2px

        for (let i = 0; i < crackCount; i++) {
            this.drawCrack(ctx, x, y, size, seed + i * 100);
        }

        // –ú–æ—Ö (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, —Ä–µ–¥–∫–æ): 0-1 –ø—è—Ç–Ω–æ
        if (seed % 5 === 0) { // 20% —à–∞–Ω—Å
            this.drawMoss(ctx, x, y, size, seed);
        }
    }

    /**
     * –†–∏—Å—É–µ—Ç –æ–¥–Ω—É —Ç—Ä–µ—â–∏–Ω—É
     */
    private static drawCrack(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –°—Ç–∞—Ä—Ç–æ–≤–∞—è —Ç–æ—á–∫–∞ (–∫—Ä–∞–π –ø–ª–∏—Ç—ã –∏–ª–∏ —Ü–µ–Ω—Ç—Ä)
        const startX = x + ((seed * 3) % size);
        const startY = y + ((seed * 7) % size);

        // –î–ª–∏–Ω–∞ —Ç—Ä–µ—â–∏–Ω—ã: 20-40px
        const length = 20 + (seed % 21);
        const angle = (seed % 360) * Math.PI / 180;

        // –ö–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞
        const endX = startX + Math.cos(angle) * length;
        const endY = startY + Math.sin(angle) * length;

        ctx.beginPath();
        ctx.moveTo(startX, startY);

        // –õ–æ–º–∞–Ω–∞—è –ª–∏–Ω–∏—è (3-5 —Å–µ–≥–º–µ–Ω—Ç–æ–≤)
        const segments = 3 + (seed % 3);
        for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            const midX = startX + (endX - startX) * t;
            const midY = startY + (endY - startY) * t;

            // –°–ª—É—á–∞–π–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ ¬±5px
            const offsetX = ((seed * i * 11) % 11) - 5;
            const offsetY = ((seed * i * 13) % 11) - 5;

            ctx.lineTo(midX + offsetX, midY + offsetY);
        }

        ctx.stroke();
    }

    /**
     * –†–∏—Å—É–µ—Ç –º–æ—Ö–æ–≤–æ–µ –ø—è—Ç–Ω–æ
     */
    private static drawMoss(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –ü–æ–∑–∏—Ü–∏—è: —É–≥–æ–ª –ø–ª–∏—Ç—ã
        const corner = seed % 4; // 0=NW, 1=NE, 2=SW, 3=SE
        let mossX = x;
        let mossY = y;

        switch (corner) {
            case 0: mossX = x + 5; mossY = y + 5; break;         // NW
            case 1: mossX = x + size - 10; mossY = y + 5; break; // NE
            case 2: mossX = x + 5; mossY = y + size - 10; break; // SW
            case 3: mossX = x + size - 10; mossY = y + size - 10; break; // SE
        }

        const mossSize = 3 + (seed % 4); // 3-6px

        ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.MOSS; // #7a8f63
        ctx.globalAlpha = 0.6; // –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π
        ctx.beginPath();
        ctx.arc(mossX, mossY, mossSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0; // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å
    }

    /**
     * –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –∏–∑–º–µ–Ω–µ–Ω–∏–µ —è—Ä–∫–æ—Å—Ç–∏ —Ü–≤–µ—Ç–∞
     */
    private static adjustBrightness(color: string, factor: number): string {
        // –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è: –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å HEX ‚Üí RGB ‚Üí —É–º–Ω–æ–∂–∏—Ç—å ‚Üí HEX
        const hex = color.replace('#', '');
        const r = Math.min(255, Math.round(parseInt(hex.substr(0, 2), 16) * factor));
        const g = Math.min(255, Math.round(parseInt(hex.substr(2, 2), 16) * factor));
        const b = Math.min(255, Math.round(parseInt(hex.substr(4, 2), 16) * factor));

        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }
}
</file>

<file path="src/renderers/turrets/index.ts">
/**
 * Turret Renderer Registry
 * Central export point for all turret renderers (Strategy Pattern)
 */

import { ITurretRenderer, DefaultTurretRenderer } from './TurretRenderer';
import { FireTurretRenderer } from './FireTurretRenderer';
import { IceTurretRenderer } from './IceTurretRenderer';
import { SniperTurretRenderer } from './SniperTurretRenderer';
import { SplitTurretRenderer } from './SplitTurretRenderer';
import { MinigunTurretRenderer } from './MinigunTurretRenderer';

// Export types
export type { ITurretRenderer };
export { DefaultTurretRenderer };

// Registry of turret renderers (singleton instances)
const TURRET_RENDERERS: Record<string, ITurretRenderer> = {
    'fire': new FireTurretRenderer(),
    'ice': new IceTurretRenderer(),
    'sniper': new SniperTurretRenderer(),
    'multi': new SplitTurretRenderer(),
    'minigun': new MinigunTurretRenderer(),
};

const defaultRenderer = new DefaultTurretRenderer();

/**
 * Get turret renderer for a card type
 * @param cardId - The card type ID (e.g., 'fire', 'ice', 'sniper', 'multi', 'minigun')
 * @returns The turret renderer for the card type, or default if not found
 */
export function getTurretRenderer(cardId: string): ITurretRenderer {
    return TURRET_RENDERERS[cardId] || defaultRenderer;
}
</file>

<file path="src/renderers/units/GoblinUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import { CONFIG } from '../../Config';
import type { Enemy } from '../../Enemy';

export class GoblinUnitRenderer implements UnitRenderer {
    // üé® Palette (Gritty & Detailed)
    private static readonly SKIN_BASE = '#689f38';  // Olive Green
    private static readonly SKIN_DARK = '#33691e';  // Shadow
    private static readonly CLOTH_RAGS = '#5d4037'; // Dark Leather/Rags
    private static readonly SACK_COLOR = '#8d6e63'; // Loot Sack
    private static readonly METAL_RUST = '#8d6e63'; // Rusty Dagger
    private static readonly METAL_EDGE = '#cfd8dc'; // Sharpened Edge
    private static readonly EYE_COLOR = '#ffeb3b';  // Yellow Eyes

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.001;
        // Sneaky, loping gait (slower rhythm)
        const walkCycle = time * (enemy.baseSpeed * 0.25);
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;

        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        ctx.save();

        if (enemy.hitFlashTimer > 0) ctx.filter = 'brightness(500%)';

        if (facing === 'SIDE') {
            if (Math.abs(rotation) > Math.PI / 2) ctx.scale(-1, 1);
            this.drawSide(ctx, scale, walkCycle, isMoving);
        } else if (facing === 'UP') {
            this.drawBack(ctx, scale, walkCycle, isMoving);
        } else {
            this.drawFront(ctx, scale, walkCycle, isMoving);
        }

        ctx.restore();
    }

    // === FRONT VIEW ===
    private drawFront(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        // Sneaking Bob (Deep)
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;

        // Feet (Wide Stance, Knees out)
        const kneeOut = 3 * scale;
        const leftLift = isMoving ? Math.max(0, Math.sin(walkCycle)) * 5 * scale : 0;
        const rightLift = isMoving ? Math.max(0, Math.sin(walkCycle + Math.PI)) * 5 * scale : 0;

        ctx.translate(0, -bounce);

        // Legs (Thin & Spindly)
        this.drawLeg(ctx, -5 * scale, 10 * scale - leftLift, scale, -0.2);
        this.drawLeg(ctx, 5 * scale, 10 * scale - rightLift, scale, 0.2);

        // Loincloth / Rags
        ctx.fillStyle = GoblinUnitRenderer.CLOTH_RAGS;
        ctx.beginPath();
        ctx.moveTo(-5 * scale, 4 * scale);
        ctx.lineTo(5 * scale, 4 * scale);
        ctx.lineTo(3 * scale, 10 * scale); // Ragged bottom
        ctx.lineTo(0, 8 * scale);
        ctx.lineTo(-3 * scale, 10 * scale);
        ctx.fill();

        // Torso (Lean & Hunched)
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        // Narrow chest, wider belly (potbelly?)
        ctx.ellipse(0, 0, 4.5 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Ribs detail
        ctx.strokeStyle = GoblinUnitRenderer.SKIN_DARK;
        ctx.lineWidth = 1 * scale;
        ctx.beginPath(); ctx.moveTo(-2 * scale, -2 * scale); ctx.lineTo(2 * scale, -2 * scale); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-3 * scale, 0); ctx.lineTo(3 * scale, 0); ctx.stroke();

        // Arms (Long, dangling)
        const armSway = isMoving ? Math.sin(walkCycle) * 0.4 : 0;
        // Left Arm (Sack Strap?)
        this.drawArm(ctx, -6 * scale, 2 * scale + armSway * 4 * scale, scale, 0.2);
        // Right Arm (Dagger)
        this.drawArm(ctx, 6 * scale, 2 * scale - armSway * 4 * scale, scale, -0.2, true);

        // Head (Low on neck)
        ctx.translate(0, -5 * scale);
        this.drawHeadFront(ctx, scale);
    }

    // === BACK VIEW ===
    private drawBack(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;
        ctx.translate(0, -bounce);

        const leftLift = isMoving ? Math.max(0, Math.sin(walkCycle)) * 5 * scale : 0;
        const rightLift = isMoving ? Math.max(0, Math.sin(walkCycle + Math.PI)) * 5 * scale : 0;

        this.drawLeg(ctx, -5 * scale, 10 * scale - leftLift, scale, -0.2);
        this.drawLeg(ctx, 5 * scale, 10 * scale - rightLift, scale, 0.2);

        // Torso Back
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 4.5 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Giant Loot Sack (Defining Feature)
        ctx.save();
        const sackBounce = isMoving ? Math.sin(walkCycle * 2) * 1 * scale : 0;
        ctx.translate(0, -2 * scale + sackBounce);
        ctx.rotate(0.1); // Slightly askew

        ctx.fillStyle = GoblinUnitRenderer.SACK_COLOR;
        ctx.beginPath();
        ctx.ellipse(0, 0, 7 * scale, 8 * scale, 0, 0, Math.PI * 2); // Huge sack
        ctx.fill();
        // Patch
        ctx.fillStyle = '#6d4c41';
        ctx.fillRect(-3 * scale, 2 * scale, 3 * scale, 3 * scale);
        // Tie at top
        ctx.fillStyle = '#4e342e';
        ctx.fillRect(-2 * scale, -8 * scale, 4 * scale, 2 * scale);
        ctx.restore();

        // Arms visible at sides
        const armSway = isMoving ? Math.sin(walkCycle) * 0.4 : 0;
        this.drawArm(ctx, -7 * scale, 2 * scale - armSway * 4 * scale, scale, 0.3);
        this.drawArm(ctx, 7 * scale, 2 * scale + armSway * 4 * scale, scale, -0.3, true); // Weapon visible?

        // Head Back
        ctx.translate(0, -6 * scale); // Head is in front of sack? No, sack covers back. Head sits on top.
        this.drawHeadBack(ctx, scale);
    }

    // === SIDE VIEW ===
    private drawSide(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;
        ctx.translate(0, -bounce);

        // Sneaky Stride (Stay low)
        const stride = 6 * scale;
        const legX = isMoving ? Math.sin(walkCycle) * stride : 0;
        const liftFar = isMoving && legX > 0 ? Math.sin(walkCycle) * 4 * scale : 0;
        const liftNear = isMoving && legX < 0 ? -Math.sin(walkCycle) * 4 * scale : 0;

        // Crouch legs
        this.drawLeg(ctx, legX, 8 * scale - liftFar, scale, 0);  // Far
        this.drawLeg(ctx, -legX, 8 * scale - liftNear, scale, 0); // Near

        // Body (Hunched Forward Curve)
        ctx.save();
        ctx.rotate(0.4); // Deep lean forward (Sneaking)

        // Sack on back
        ctx.fillStyle = GoblinUnitRenderer.SACK_COLOR;
        ctx.beginPath();
        ctx.ellipse(-4 * scale, -2 * scale, 5 * scale, 7 * scale, -0.2, 0, Math.PI * 2);
        ctx.fill();

        // Torso
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 4 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Arms (Reaching)
        const armSway = isMoving ? Math.cos(walkCycle) * 0.5 : 0;
        this.drawArm(ctx, 4 * scale, 4 * scale + armSway * 5 * scale, scale, -0.4, true);

        // Head (Crane forward)
        ctx.translate(6 * scale, -4 * scale); // Way forward
        this.drawHeadSide(ctx, scale);
    }

    // --- PARTS ---

    private drawLeg(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number, ang: number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(ang);

        // Thigh
        ctx.fillStyle = GoblinUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.ellipse(0, -2 * scale, 2 * scale, 4 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Shin/Foot (Big foot)
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 3 * scale, 1.5 * scale, 3 * scale, 0.2, 0, Math.PI * 2); // Skinny shin
        ctx.fill();

        // Foot
        ctx.fillStyle = GoblinUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.ellipse(1 * scale, 5 * scale, 3 * scale, 1.5 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    private drawArm(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number, ang: number, hasWeapon: boolean = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(ang);

        // Long lanky arm
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 1.5 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        if (hasWeapon) {
            ctx.translate(0, 6 * scale); // Hand pos
            // Dagger
            ctx.rotate(0.5); // Point forward
            // Hilt
            ctx.fillStyle = '#4e342e';
            ctx.fillRect(-1 * scale, -1 * scale, 2 * scale, 3 * scale);
            // Guard
            ctx.fillStyle = GoblinUnitRenderer.METAL_RUST;
            ctx.fillRect(-2 * scale, 2 * scale, 4 * scale, 1 * scale);
            // Blade (Jagged)
            ctx.fillStyle = GoblinUnitRenderer.METAL_EDGE;
            ctx.beginPath();
            ctx.moveTo(-1.5 * scale, 3 * scale);
            ctx.lineTo(1.5 * scale, 3 * scale);
            ctx.lineTo(0, 9 * scale); // Long blade
            ctx.fill();
            // Rust spots
            ctx.fillStyle = GoblinUnitRenderer.METAL_RUST;
            ctx.beginPath(); ctx.arc(0, 5 * scale, 1 * scale, 0, Math.PI * 2); ctx.fill();
        }

        ctx.restore();
    }

    private drawHeadFront(ctx: CanvasRenderingContext2D, scale: number) {
        // Skull
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 4 * scale, 5 * scale, 0, 0, Math.PI * 2); // Tall head
        ctx.fill();

        // Huge Ears (Notched)
        ctx.fillStyle = GoblinUnitRenderer.SKIN_DARK;
        const drawEar = (mirror: number) => {
            ctx.beginPath();
            ctx.moveTo(mirror * 3 * scale, 0);
            ctx.bezierCurveTo(mirror * 10 * scale, -5 * scale, mirror * 12 * scale, 0, mirror * 4 * scale, 4 * scale);
            ctx.fill();
            // Notch
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath(); ctx.arc(mirror * 9 * scale, 0, 1 * scale, 0, Math.PI * 2); ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
        };
        drawEar(1);
        drawEar(-1);

        // Nose (Long & Crooked)
        ctx.fillStyle = '#558b2f';
        ctx.beginPath();
        ctx.moveTo(0, -1 * scale);
        ctx.lineTo(1.5 * scale, 3 * scale); // Pointy tip
        ctx.lineTo(-1 * scale, 2 * scale);
        ctx.fill();

        // Eyes (Yellow & Mean)
        ctx.fillStyle = GoblinUnitRenderer.EYE_COLOR;
        ctx.beginPath(); ctx.ellipse(-2 * scale, -1 * scale, 1.2 * scale, 0.8 * scale, 0.2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(2 * scale, -1 * scale, 1.2 * scale, 0.8 * scale, -0.2, 0, Math.PI * 2); ctx.fill();

        // Pupils
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(-2 * scale, -1 * scale, 0.3 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(2 * scale, -1 * scale, 0.3 * scale, 0, Math.PI * 2); ctx.fill();

        // Tooth (Snaggletooth)
        ctx.fillStyle = '#fff9c4';
        ctx.beginPath();
        ctx.moveTo(-1 * scale, 3 * scale); ctx.lineTo(-0.5 * scale, 5 * scale); ctx.lineTo(0, 3 * scale);
        ctx.fill();
    }

    private drawHeadSide(ctx: CanvasRenderingContext2D, scale: number) {
        // Ear (Back)
        ctx.fillStyle = GoblinUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(-6 * scale, -2 * scale); ctx.lineTo(-1 * scale, 3 * scale);
        ctx.fill();

        // Skull
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 4.5 * scale, 5 * scale, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Nose Profile
        ctx.fillStyle = '#558b2f';
        ctx.beginPath();
        ctx.moveTo(3 * scale, 0);
        ctx.bezierCurveTo(7 * scale, 1 * scale, 6 * scale, 4 * scale, 3 * scale, 3 * scale);
        ctx.fill();

        // Eye
        ctx.fillStyle = GoblinUnitRenderer.EYE_COLOR;
        ctx.beginPath(); ctx.arc(2 * scale, -1 * scale, 1 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(2.5 * scale, -1 * scale, 0.3 * scale, 0, Math.PI * 2); ctx.fill();
    }

    private drawHeadBack(ctx: CanvasRenderingContext2D, scale: number) {
        // Ears
        ctx.fillStyle = GoblinUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.moveTo(-3 * scale, 0); ctx.lineTo(-10 * scale, -4 * scale); ctx.lineTo(-4 * scale, 4 * scale); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(3 * scale, 0); ctx.lineTo(10 * scale, -4 * scale); ctx.lineTo(4 * scale, 4 * scale); ctx.fill();

        // Head
        ctx.fillStyle = '#33691e'; // Darker back hair/skin
        ctx.beginPath();
        ctx.ellipse(0, 0, 4 * scale, 5 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hair wisps?
        ctx.strokeStyle = '#212121';
        ctx.lineWidth = 1 * scale;
        ctx.beginPath(); ctx.moveTo(0, -5 * scale); ctx.lineTo(-1 * scale, -7 * scale); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -5 * scale); ctx.lineTo(2 * scale, -6 * scale); ctx.stroke();
    }
}
</file>

<file path="src/renderers/units/MagmaUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import type { Enemy } from '../../Enemy';

interface MagmaParticle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    size: number;
    life: number;
    maxLife: number;
    type: 'EMBER' | 'ASH' | 'SMOKE' | 'SPARK';
}

export class MagmaUnitRenderer implements UnitRenderer {
    // --- PALETTE: MOLTEN CORE ---
    // Core is blindingly bright, cooling as it goes out
    private static readonly C_CORE = '#ffffff';       // White-hot core
    private static readonly C_CORE_BRIGHT = '#fff9e6'; // Slightly yellow glow
    private static readonly C_LAVA_LIGHT = '#ff9800'; // Liquid Magma
    private static readonly C_LAVA_DARK = '#bf360c';  // Cooling Magma
    private static readonly C_CRUST = '#212121';      // Obsidian/Slag
    private static readonly C_ASH = '#757575';        // Grey Ash

    // --- DECOY PALETTE: DEAD STONE ---
    private static readonly C_STONE_BASE = '#0d0d0d';
    private static readonly C_STONE_DARK = '#1a1a1a';
    private static readonly C_STONE_HIGHLIGHT = '#424242';
    private static readonly C_EMBER_FAINT = '#3e1c14'; // Dying embers in cracks

    // Particle System (WeakMap for instance isolation)
    private particleSystems = new WeakMap<Enemy, MagmaParticle[]>();

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.002;
        const isBoss = enemy.typeId === 'magma_king';

        // --- PARTICLE UPDATE ---
        this.updateParticles(ctx, enemy, scale, isBoss);

        ctx.save();

        if (isBoss) {
            this.drawDemonBoss(ctx, enemy, scale, time);
        } else {
            this.drawObsidianStatue(ctx, scale, time);
        }

        ctx.restore();
    }

    // =========================================================================
    // 1. THE MOLTEN ARCHDEMON
    // =========================================================================
    private drawDemonBoss(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, time: number) {
        const isMoving = !enemy.finished && enemy.baseSpeed > 5;
        const hpPercent = enemy.currentHealth / enemy.maxHealth;

        // INTENSIFIED Breathing: The core expands MORE, cracking the crust
        const breathe = Math.sin(time * 3) * 0.10 * scale; // Doubled from 0.05

        // Instability: As HP drops, the crust fragments more (jitter)
        const instability = (1 - hpPercent) * 3; // Increased from 2

        // Movement Flow
        const lean = isMoving ? Math.sin(time * 4) * 5 * scale : 0;

        // INCREASED Heavy Step for more impact
        const heavyStep = Math.abs(Math.sin(time * 4)) * 5 * scale; // Increased from 3

        // Low HP Jitter
        const jitterX = hpPercent < 0.3 ? (Math.random() - 0.5) * 2 * scale : 0;
        const jitterY = hpPercent < 0.3 ? (Math.random() - 0.5) * 2 * scale : 0;

        ctx.translate(lean + jitterX, -heavyStep + jitterY);
        ctx.scale(scale + breathe, scale + breathe);

        // A. MAGMA BODY (The Glow)
        this.drawLavaCore(ctx, time, instability, hpPercent);

        // B. OBSIDIAN ARMOR (Floating Plates)
        this.drawCrustPlates(ctx, time, instability);

        // C. HEAD (The Crown)
        this.drawDemonHead(ctx, time, lean);

        // D. ARMS (Heavy Flow with DRIPPING LAVA)
        this.drawLavaArms(ctx, time, isMoving);
    }

    private drawLavaCore(ctx: CanvasRenderingContext2D, time: number, instability: number, hpPercent: number) {
        // More WHITE the lower HP gets (desperation)
        const coreIntensity = 1 - (hpPercent * 0.5); // 0.5 at full HP, 1.0 at 0 HP

        // Complex Gradient: Core -> Lava -> Cooling Edge
        const grad = ctx.createRadialGradient(0, -15, 3, 0, -12, 35);
        grad.addColorStop(0, MagmaUnitRenderer.C_CORE);
        grad.addColorStop(0.15, MagmaUnitRenderer.C_CORE_BRIGHT);
        grad.addColorStop(0.4, MagmaUnitRenderer.C_LAVA_LIGHT);
        grad.addColorStop(0.75, MagmaUnitRenderer.C_LAVA_DARK);
        grad.addColorStop(1, MagmaUnitRenderer.C_CRUST);

        ctx.fillStyle = grad;

        // Shape: Bulky, muscular upper body, tapering to a flow
        ctx.beginPath();
        ctx.moveTo(-15, -25); // Shoulder L
        ctx.quadraticCurveTo(0, -30, 15, -25); // Shoulder R
        ctx.bezierCurveTo(25, -10, 10, 5 + instability, 0, 10); // Torso R
        ctx.bezierCurveTo(-10, 5 + instability, -25, -10, -15, -25); // Torso L
        ctx.fill();

        // INTENSIFIED Inner Glow (Beating Heart)
        ctx.shadowColor = MagmaUnitRenderer.C_LAVA_LIGHT;
        ctx.shadowBlur = 25 + (Math.sin(time * 4) * 10); // Pulsing glow
        ctx.fillStyle = MagmaUnitRenderer.C_CORE;
        ctx.beginPath();
        const coreSize = 6 + coreIntensity * 3; // Bigger at low HP
        ctx.arc(0, -15, coreSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    private drawCrustPlates(ctx: CanvasRenderingContext2D, time: number, instability: number) {
        // Large polygonal plates that float on the magma
        // MORE MOVEMENT at high instability
        ctx.fillStyle = MagmaUnitRenderer.C_CRUST;

        // Chest Plate (Broken) - INCREASED movement
        const shiftX = Math.sin(time * 2) * (2 + instability * 2); // Doubled amplitude
        const shiftY = Math.cos(time * 2) * (2 + instability * 2);

        // Left Plate
        ctx.beginPath();
        ctx.moveTo(-2 + shiftX, -18 + shiftY);
        ctx.lineTo(-12, -22);
        ctx.lineTo(-10, -8);
        ctx.closePath();
        ctx.fill();

        // Right Plate
        ctx.beginPath();
        ctx.moveTo(2 - shiftX, -18 - shiftY);
        ctx.lineTo(12, -22);
        ctx.lineTo(10, -8);
        ctx.closePath();
        ctx.fill();

        // Abdominal Plates with rotation
        ctx.save();
        ctx.translate(0, -5);
        ctx.rotate(shiftX * 0.05);
        ctx.fillRect(-6, 0, 12, 4);
        ctx.restore();
    }

    private drawDemonHead(ctx: CanvasRenderingContext2D, time: number, lean: number) {
        ctx.save();
        ctx.translate(0, -28);

        // Horns (Floating Obsidian Shards) - INCREASED float
        ctx.fillStyle = MagmaUnitRenderer.C_CRUST;
        const hornFloat = Math.sin(time * 4) * 3; // Increased from 2

        // Left Horn
        ctx.beginPath();
        ctx.moveTo(-8, 0); ctx.lineTo(-20, -12 + hornFloat); ctx.lineTo(-10, -2);
        ctx.fill();

        // Right Horn
        ctx.beginPath();
        ctx.moveTo(8, 0); ctx.lineTo(20, -12 - hornFloat); ctx.lineTo(10, -2);
        ctx.fill();

        // Face (Skull-like magma)
        ctx.fillStyle = MagmaUnitRenderer.C_LAVA_LIGHT;
        ctx.beginPath();
        ctx.ellipse(0, 0, 8, 10, lean * 0.05, 0, Math.PI * 2);
        ctx.fill();

        // Obsidian Mask
        ctx.fillStyle = MagmaUnitRenderer.C_CRUST;
        ctx.beginPath();
        ctx.moveTo(-6, -6);
        ctx.lineTo(6, -6);
        ctx.lineTo(0, 8); // Jaw
        ctx.fill();

        // Eyes (INTENSIFIED - Brighter, Larger glow)
        ctx.fillStyle = MagmaUnitRenderer.C_CORE;
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 20; // Increased from 15
        ctx.beginPath();
        ctx.arc(-3, -2, 2, 0, Math.PI * 2); // Slightly larger
        ctx.arc(3, -2, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }

    private drawLavaArms(ctx: CanvasRenderingContext2D, time: number, move: boolean) {
        const sway = Math.sin(time * 2) * 0.2;

        // Arms are heavy, dripping magma
        this.drawHeavyArm(ctx, -16, -22, -0.3 + sway, false, time);
        this.drawHeavyArm(ctx, 16, -22, 0.3 - sway, true, time);
    }

    private drawHeavyArm(ctx: CanvasRenderingContext2D, x: number, y: number, angle: number, flip: boolean, time: number) {
        ctx.save();
        ctx.translate(x, y);
        if (flip) ctx.scale(-1, 1);
        ctx.rotate(angle);

        // Magma Flow Gradient
        const grad = ctx.createLinearGradient(0, 0, 0, 35);
        grad.addColorStop(0, MagmaUnitRenderer.C_CRUST); // Shoulder is hard
        grad.addColorStop(0.4, MagmaUnitRenderer.C_LAVA_LIGHT);
        grad.addColorStop(0.8, MagmaUnitRenderer.C_LAVA_DARK);
        grad.addColorStop(1, MagmaUnitRenderer.C_LAVA_LIGHT); // Dripping tip

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(-10, 10, -5, 25, 0, 35); // Heavy dripping hand
        ctx.bezierCurveTo(5, 25, 10, 10, 0, 0);
        ctx.fill();

        // Floating crust bits + DRIPPING EFFECT
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        const drift = Math.sin(time * 5) * 2;
        ctx.fillRect(-2, 10 + drift, 4, 4);

        // LAVA DRIP (animated)
        const dripY = 35 + Math.abs(Math.sin(time * 3)) * 8;
        ctx.fillStyle = MagmaUnitRenderer.C_LAVA_LIGHT;
        ctx.beginPath();
        ctx.ellipse(0, dripY, 1.5, 3, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }


    // =========================================================================
    // 2. THE OBSIDIAN STATUE (DECOY) - ENHANCED
    // =========================================================================
    private drawObsidianStatue(ctx: CanvasRenderingContext2D, scale: number, time: number) {
        // A "Hollowed Out" shell. 
        // Dark, jagged, lifeless but HEROIC

        ctx.scale(scale, scale);

        // Statue Body (Crystalline, Angular)
        ctx.fillStyle = MagmaUnitRenderer.C_STONE_BASE;
        ctx.strokeStyle = MagmaUnitRenderer.C_STONE_HIGHLIGHT;
        ctx.lineWidth = 1.5;

        ctx.beginPath();
        // HEROIC POSE: Arms raised (victory/defiance)
        ctx.moveTo(-14, -28); // L Horn/shoulder
        ctx.lineTo(-8, -20);  // L arm raised
        ctx.lineTo(-12, -10); // L shoulder
        ctx.lineTo(-8, 0);    // Waist
        ctx.lineTo(-12, 10);  // Hip
        ctx.lineTo(12, 10);   // Hip R
        ctx.lineTo(8, 0);     // Waist R
        ctx.lineTo(12, -10);  // Shoulder R
        ctx.lineTo(8, -20);   // R Arm raised
        ctx.lineTo(14, -28);  // R Horn
        ctx.lineTo(0, -25);   // Top of head
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // CRACK NETWORK (More Complex)
        ctx.strokeStyle = MagmaUnitRenderer.C_STONE_DARK;
        ctx.lineWidth = 2;
        ctx.beginPath();
        // Main crack
        ctx.moveTo(0, -20);
        ctx.lineTo(-5, -10);
        ctx.lineTo(2, -5);
        ctx.lineTo(-3, 2);
        ctx.stroke();

        // Secondary cracks
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-5, -10); ctx.lineTo(-8, -8);
        ctx.moveTo(2, -5); ctx.lineTo(5, -3);
        ctx.moveTo(-3, 2); ctx.lineTo(-6, 5);
        ctx.stroke();

        // DYING EMBERS in Cracks (Red glow)
        ctx.shadowColor = '#ff3d00';
        ctx.shadowBlur = 8;
        ctx.strokeStyle = MagmaUnitRenderer.C_EMBER_FAINT;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(-5, -10);
        ctx.lineTo(2, -5);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Head (Frozen Scream)
        ctx.translate(0, -30);
        ctx.fillStyle = MagmaUnitRenderer.C_STONE_BASE;
        ctx.strokeStyle = MagmaUnitRenderer.C_STONE_HIGHLIGHT;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Eyes (Dead, but faint ember)
        ctx.fillStyle = MagmaUnitRenderer.C_EMBER_FAINT;
        ctx.beginPath();
        ctx.arc(-3, -1, 1, 0, Math.PI * 2);
        ctx.arc(3, -1, 1, 0, Math.PI * 2);
        ctx.fill();
    }

    // =========================================================================
    // 3. PARTICLE SYSTEM (AAA EFFECT) - ENHANCED
    // =========================================================================
    private updateParticles(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, isBoss: boolean) {
        let particles = this.particleSystems.get(enemy);
        if (!particles) {
            particles = [];
            this.particleSystems.set(enemy, particles);
        }

        // SPAWN - INCREASED spawn rate for boss
        const spawnRate = isBoss ? 0.6 : 0.4; // Increased from 0.3
        if (Math.random() < spawnRate) {
            let type: 'EMBER' | 'ASH' | 'SMOKE' | 'SPARK' = 'SMOKE';

            if (isBoss) {
                const rand = Math.random();
                if (rand > 0.7) type = 'SPARK'; // New bright sparks
                else if (rand > 0.4) type = 'EMBER';
                else type = 'SMOKE';
            } else {
                type = Math.random() > 0.5 ? 'ASH' : 'SMOKE';
            }

            particles.push({
                x: (Math.random() * 30 - 15) * scale,
                y: -(Math.random() * 30 + 10) * scale,
                vx: (Math.random() - 0.5) * 0.8,
                vy: type === 'SPARK' ? -(Math.random() * 3 + 2) : // Sparks fly fast
                    type === 'EMBER' ? -(Math.random() * 2 + 1) :
                        -(Math.random() + 0.5),
                size: (Math.random() * 3 + 1) * scale,
                life: 1.0,
                maxLife: 1.0,
                type: type
            });
        }

        // UPDATE & DRAW
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.life -= p.type === 'SPARK' ? 0.03 : 0.015; // Sparks die faster
            p.x += p.vx + Math.sin(p.life * 10) * 0.3; // More wiggle
            p.y += p.vy;

            if (p.life <= 0) {
                particles.splice(i, 1);
                continue;
            }

            // Draw
            ctx.globalAlpha = p.life;
            if (p.type === 'SPARK') {
                ctx.fillStyle = MagmaUnitRenderer.C_CORE;
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 15;
            } else if (p.type === 'EMBER') {
                ctx.fillStyle = MagmaUnitRenderer.C_LAVA_LIGHT;
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 10;
            } else if (p.type === 'ASH') {
                ctx.fillStyle = MagmaUnitRenderer.C_ASH;
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; // Smoke
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            const renderSize = p.size * (p.type === 'SPARK' ? 0.3 : p.type === 'EMBER' ? 0.5 : 1.0);
            ctx.arc(p.x, p.y, renderSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        ctx.globalAlpha = 1.0;
    }

    drawEmissive(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.002;
        if (enemy.typeId === 'magma_king') {
            // INTENSIFIED Heat Haze / Glow with PULSING
            const pulse = Math.sin(time * 3) * 5 + 30; // Oscillates between 25-35
            ctx.shadowColor = MagmaUnitRenderer.C_LAVA_LIGHT;
            ctx.shadowBlur = pulse;

            // DOUBLE LAYER glow for more epic feel
            // Layer 1: Intense close glow
            ctx.fillStyle = 'rgba(255, 87, 34, 0.3)';
            ctx.beginPath();
            ctx.arc(0, -20 * scale, 20 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Layer 2: Wide soft glow
            ctx.shadowBlur = pulse * 1.5;
            ctx.fillStyle = 'rgba(255, 152, 0, 0.15)';
            ctx.beginPath();
            ctx.arc(0, -20 * scale, 35 * scale, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
        } else {
            // Statue: Faint residual heat from cracks
            ctx.shadowColor = '#ff3d00';
            ctx.shadowBlur = 5;
            ctx.fillStyle = 'rgba(62, 28, 20, 0.3)';
            ctx.beginPath();
            ctx.arc(0, -15 * scale, 10 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }
}
</file>

<file path="src/renderers/units/OrcUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import type { Enemy } from '../../Enemy';

export class OrcUnitRenderer implements UnitRenderer {
    // –ü–∞–ª–∏—Ç—Ä–∞: –¢–µ–º–Ω–∞—è, —Ç—è–∂–µ–ª–∞—è, —Ä–∂–∞–≤–∞—è
    private static readonly ARMOR_DARK = '#212121'; // –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–∞–ª–ª
    private static readonly ARMOR_RUST = '#4e342e'; // –†–∂–∞–≤—á–∏–Ω–∞/–ö–æ–∂–∞
    private static readonly SKIN_COLOR = '#33691e'; // –¢–µ–º–Ω–æ-–∑–µ–ª–µ–Ω—ã–π (–ø–æ—á—Ç–∏ –Ω–µ –≤–∏–¥–µ–Ω)
    private static readonly METAL_LIGHT = '#757575'; // –ö–ª–µ–ø–∫–∏/–õ–µ–∑–≤–∏—è
    private static readonly ARMOR_MAIN = '#616161'; // –ß—É—Ç—å —Å–≤–µ—Ç–ª–µ–µ

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now();
        // –°–Ω–∏–∂–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏. baseSpeed ~38-60. 
        // –ë—ã–ª–æ time * 0.004 -> —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ –ø–µ—Ä–µ–±–∏—Ä–∞–µ—Ç –Ω–æ–≥–∞–º–∏.
        // 0.0015 –¥–∞—Å—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ 1.2 —à–∞–≥–∞ –≤ —Å–µ–∫—É–Ω–¥—É –ø—Ä–∏ —Å–∫–æ—Ä–æ—Å—Ç–∏ 50.
        const walkCycle = (time * 0.0015) * (enemy.baseSpeed / 10);
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –ª–æ–≥–∏–∫–∞ —É–≥–ª–æ–≤
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        ctx.save();

        if (facing === 'SIDE') {
            if (Math.abs(rotation) > Math.PI / 2) ctx.scale(-1, 1);
            this.drawSide(ctx, scale, walkCycle, isMoving);
        } else if (facing === 'UP') {
            this.drawBack(ctx, scale, walkCycle, isMoving);
        } else {
            this.drawFront(ctx, scale, walkCycle, isMoving);
        }

        ctx.restore();
    }

    // === FRONT (–í–∏–¥ –°–ø–µ—Ä–µ–¥–∏) ===
    private drawFront(ctx: CanvasRenderingContext2D, scale: number, cycle: number, isMoving: boolean) {
        // –¢—è–∂–µ–ª—ã–π —Ç–æ–ø–æ—Ç: –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –±–∞—É–Ω—Å + –Ω–∞–∫–ª–æ–Ω
        const bounce = isMoving ? Math.abs(Math.sin(cycle)) * 1.5 * scale : 0;
        // –õ–µ–≥–∫–æ–µ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ
        const sway = isMoving ? Math.sin(cycle / 2) * 2 * scale : 0;

        ctx.translate(sway, -bounce);

        // 1. –ù–æ–≥–∏ (–ö–æ—Ä–æ—Ç–∫–∏–µ —Å—Ç–æ–ª–±—ã)
        // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥—ä–µ–º –∫–æ–ª–µ–Ω–µ–π
        const liftL = isMoving ? Math.max(0, Math.sin(cycle)) * 4 * scale : 0;
        const liftR = isMoving ? Math.max(0, Math.sin(cycle + Math.PI)) * 4 * scale : 0;

        this.drawLeg(ctx, -8 * scale, 8 * scale - liftL, scale);
        this.drawLeg(ctx, 8 * scale, 8 * scale - liftR, scale);

        // 2. –¢–µ–ª–æ (–ú–∞—Å—Å–∏–≤–Ω–∞—è –ø–ª–∏—Ç–∞)
        ctx.fillStyle = OrcUnitRenderer.ARMOR_DARK;
        // –†–∏—Å—É–µ–º "–ë–æ—á–∫—É"
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(-12 * scale, -10 * scale, 24 * scale, 18 * scale, 3 * scale);
        } else {
            ctx.rect(-12 * scale, -10 * scale, 24 * scale, 18 * scale);
        }
        ctx.fill();

        // –î–µ—Ç–∞–ª—å: –†–∂–∞–≤—ã–π –Ω–∞–≥—Ä—É–¥–Ω–∏–∫
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.fillRect(-8 * scale, -9 * scale, 16 * scale, 12 * scale);

        // –ó–∞–∫–ª–µ–ø–∫–∏
        ctx.fillStyle = OrcUnitRenderer.METAL_LIGHT;
        ctx.beginPath();
        ctx.arc(-6 * scale, -7 * scale, 1 * scale, 0, Math.PI * 2);
        ctx.arc(6 * scale, -7 * scale, 1 * scale, 0, Math.PI * 2);
        ctx.arc(-6 * scale, 1 * scale, 1 * scale, 0, Math.PI * 2);
        ctx.arc(6 * scale, 1 * scale, 1 * scale, 0, Math.PI * 2);
        ctx.fill();

        // 3. –ì–æ–ª–æ–≤–∞ (–®–ª–µ–º-–≤–µ–¥—Ä–æ, —Å–∏–¥–∏—Ç –Ω–∏–∑–∫–æ, "–≤—Ç—è–Ω—É—Ç")
        ctx.translate(0, -9 * scale);
        this.drawHelmet(ctx, scale);
        ctx.translate(0, 9 * scale);

        // 4. –û—Ä—É–∂–∏–µ –∏ –©–∏—Ç (–ü–æ –±–æ–∫–∞–º)
        // –©–∏—Ç (–°–ª–µ–≤–∞ –æ—Ç –Ω–∞—Å, –¥–µ—Ä–∂–∏—Ç –≤ –ø—Ä–∞–≤–æ–π —Ä—É–∫–µ –≤—Ä–∞–≥–∞)
        ctx.translate(14 * scale, 2 * scale);
        this.drawShieldFront(ctx, scale); // –ß—É—Ç—å –Ω–∏–∂–µ
        ctx.translate(-28 * scale, 0); // –ù–∞ –¥—Ä—É–≥—É—é —Ä—É–∫—É
        this.drawMace(ctx, scale);
    }

    // === SIDE (–í–∏–¥ –°–±–æ–∫—É) ===
    private drawSide(ctx: CanvasRenderingContext2D, scale: number, cycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(cycle)) * 1.5 * scale : 0;
        ctx.translate(0, -bounce);

        // 1. –ù–æ–≥–∏ (–®–∞–≥ —Å —à–∏—Ä–æ–∫–æ–π –ø–æ—Å—Ç–∞–Ω–æ–≤–∫–æ–π)
        // –°–¥–µ–ª–∞–µ–º –±–æ–ª–µ–µ "–≤–±–∏–≤–∞—é—â–∏–π" —à–∞–≥ - –∫–æ—Ä–æ—Ç–∫–∏–π –Ω–æ –º–æ—â–Ω—ã–π
        const step = isMoving ? Math.cos(cycle) * 6 * scale : 0;
        const liftFar = isMoving && step > 0 ? Math.sin(cycle) * 3 * scale : 0;
        const liftNear = isMoving && step < 0 ? -Math.sin(cycle) * 3 * scale : 0;

        this.drawLeg(ctx, step, 8 * scale - liftFar, scale);       // –î–∞–ª—å–Ω—è—è
        this.drawLeg(ctx, -step, 8 * scale - liftNear, scale);      // –ë–ª–∏–∂–Ω—è—è

        // 2. –¢–µ–ª–æ (–ö–æ—Ä–æ–±–∫–∞, –∞ –Ω–µ –æ–≤–∞–ª)
        // –¢–µ–ª–æ –≤ –ø—Ä–æ—Ñ–∏–ª—å —Ç–æ–∂–µ —à–∏—Ä–æ–∫–æ–µ –∏–∑-–∑–∞ –±—Ä–æ–Ω–∏
        ctx.fillStyle = OrcUnitRenderer.ARMOR_DARK;
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(-8 * scale, -9 * scale, 16 * scale, 16 * scale, 4 * scale);
        } else {
            ctx.rect(-8 * scale, -9 * scale, 16 * scale, 16 * scale);
        }
        ctx.fill();

        // –ì–æ—Ä–±/–ü–ª–∞—Å—Ç–∏–Ω—ã —Å–∑–∞–¥–∏
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.fillRect(-9 * scale, -6 * scale, 4 * scale, 10 * scale);

        // 3. –ì–æ–ª–æ–≤–∞ (–°–¥–≤–∏–Ω—É—Ç–∞ –≤–ø–µ—Ä–µ–¥)
        ctx.translate(4 * scale, -8 * scale); // –ß—É—Ç—å –≤—ã—à–µ –∏ –≤–ø–µ—Ä–µ–¥
        this.drawHelmet(ctx, scale);
        ctx.translate(-4 * scale, 8 * scale);

        // 4. –©–ò–¢ (TOWER SHIELD)
        // –ó–∞–∫—Ä—ã–≤–∞–µ—Ç –ø–µ—Ä–µ–¥–Ω—é—é —á–∞—Å—Ç—å
        ctx.translate(9 * scale, 2 * scale); // –°–¥–≤–∏–Ω—É—Ç –≤–ø–µ—Ä–µ–¥ —Å–∏–ª—å–Ω–µ–µ
        this.drawShieldSide(ctx, scale);

        // –†—É–∫–∞/–ü–ª–µ—á–æ –¥–µ—Ä–∂–∞—â–µ–µ —â–∏—Ç
        ctx.fillStyle = OrcUnitRenderer.ARMOR_MAIN;
        ctx.beginPath();
        ctx.arc(0, -6 * scale, 4 * scale, 0, Math.PI * 2);
        ctx.fill();
    }

    // === BACK (–í–∏–¥ –°–∑–∞–¥–∏) ===
    private drawBack(ctx: CanvasRenderingContext2D, scale: number, cycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(cycle)) * 1.5 * scale : 0;
        const sway = isMoving ? Math.sin(cycle / 2) * 2 * scale : 0;
        ctx.translate(sway, -bounce);

        const liftL = isMoving ? Math.max(0, Math.sin(cycle)) * 4 * scale : 0;
        const liftR = isMoving ? Math.max(0, Math.sin(cycle + Math.PI)) * 4 * scale : 0;

        this.drawLeg(ctx, -8 * scale, 8 * scale - liftL, scale);
        this.drawLeg(ctx, 8 * scale, 8 * scale - liftR, scale);

        // –°–ø–∏–Ω–∞ (–°–ø–ª–æ—à–Ω–∞—è –ø–ª–∏—Ç–∞)
        ctx.fillStyle = OrcUnitRenderer.ARMOR_DARK;
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(-12 * scale, -10 * scale, 24 * scale, 18 * scale, 3 * scale);
        } else {
            ctx.rect(-12 * scale, -10 * scale, 24 * scale, 18 * scale);
        }
        ctx.fill();

        // "–ü–æ–∑–≤–æ–Ω–æ—á–Ω–∏–∫" –±—Ä–æ–Ω–∏
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.fillRect(-3 * scale, -10 * scale, 6 * scale, 18 * scale);

        // –ì–æ–ª–æ–≤–∞ (–ó–∞—Ç—ã–ª–æ–∫ —à–ª–µ–º–∞)
        ctx.translate(0, -9 * scale);
        ctx.fillStyle = OrcUnitRenderer.ARMOR_MAIN;
        ctx.beginPath();
        ctx.arc(0, 0, 6 * scale, Math.PI, 0); // –ß—É—Ç—å —à–∏—Ä–µ
        ctx.fill();
        ctx.translate(0, 9 * scale);

        // –©–∏—Ç (–í–∏–¥–µ–Ω —Å —Ç–æ—Ä—Ü–∞ —Å–±–æ–∫—É)
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.fillRect(14 * scale, -5 * scale, 3 * scale, 15 * scale); // –¢–æ—Ä–µ—Ü —â–∏—Ç–∞

        // –î—É–±–∏–Ω–∞ (–í–∏–¥–Ω–∞ —Å –¥—Ä—É–≥–æ–≥–æ –±–æ–∫—É)
        ctx.translate(-14 * scale, 0);
        this.drawMace(ctx, scale);
    }

    // --- –ö–û–ú–ü–û–ù–ï–ù–¢–´ ---

    private drawHelmet(ctx: CanvasRenderingContext2D, scale: number) {
        // –®–ª–µ–º-–í–µ–¥—Ä–æ (Bucket Helm) - –µ—â–µ –±–æ–ª–µ–µ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–π
        ctx.fillStyle = OrcUnitRenderer.ARMOR_MAIN; // –°–µ—Ä—ã–π –º–µ—Ç–∞–ª–ª
        ctx.beginPath();
        // –û—Å–Ω–æ–≤–∞
        if (ctx.roundRect) {
            ctx.roundRect(-6 * scale, -7 * scale, 12 * scale, 11 * scale, 2 * scale);
        } else {
            ctx.rect(-6 * scale, -7 * scale, 12 * scale, 11 * scale);
        }
        ctx.fill();

        // –£—Å–∏–ª–µ–Ω–∏–µ (–∫—Ä–µ—Å—Ç –∏–ª–∏ –ø–æ–ª–æ—Å–∞)
        ctx.fillStyle = '#424242';
        ctx.fillRect(-6 * scale, -3 * scale, 12 * scale, 2 * scale); // –ì–æ—Ä–∏–∑
        ctx.fillRect(-1 * scale, -7 * scale, 2 * scale, 11 * scale); // –í–µ—Ä—Ç

        // –°–º–æ—Ç—Ä–æ–≤–∞—è —â–µ–ª—å (—É–∑–∫–∞—è, –∑–ª–∞—è)
        ctx.fillStyle = '#000';
        ctx.fillRect(-5 * scale, -3 * scale, 10 * scale, 1.5 * scale);

        // –†–æ–≥–∞/–®–∏–ø—ã (—á—É—Ç—å –º–µ–Ω—å—à–µ, —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å —Å–∏–ª—É—ç—Ç –≤–µ–¥—Ä–∞)
        ctx.fillStyle = '#212121';
        ctx.beginPath();
        ctx.moveTo(-5 * scale, -7 * scale); ctx.lineTo(-7 * scale, -10 * scale); ctx.lineTo(-3 * scale, -7 * scale);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(5 * scale, -7 * scale); ctx.lineTo(7 * scale, -10 * scale); ctx.lineTo(3 * scale, -7 * scale);
        ctx.fill();
    }

    private drawLeg(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number) {
        ctx.translate(x, y);
        // –¢—è–∂–µ–ª—ã–π –ª–∞—Ç–Ω—ã–π —Å–∞–ø–æ–≥ - —à–∏—Ä–µ
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(-4 * scale, -5 * scale, 8 * scale, 10 * scale, 2 * scale);
        } else {
            ctx.rect(-4 * scale, -5 * scale, 8 * scale, 10 * scale);
        }
        ctx.fill();
        // –ú–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–π –Ω–æ—Å–æ–∫
        ctx.fillStyle = OrcUnitRenderer.ARMOR_MAIN;
        ctx.fillRect(-4 * scale, 2 * scale, 8 * scale, 3 * scale);
        ctx.translate(-x, -y);
    }

    private drawShieldFront(ctx: CanvasRenderingContext2D, scale: number) {
        // –û–≥—Ä–æ–º–Ω–∞—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∞—è –¥–≤–µ—Ä—å
        ctx.fillStyle = '#3e2723'; // –î–µ—Ä–µ–≤–æ —Å–∑–∞–¥–∏
        ctx.fillRect(-2 * scale, -8 * scale, 4 * scale, 18 * scale);

        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(-7 * scale, -11 * scale, 14 * scale, 22 * scale, 2 * scale);
        } else {
            ctx.rect(-7 * scale, -11 * scale, 14 * scale, 22 * scale);
        }
        ctx.fill();

        // –£–∑–æ—Ä
        ctx.strokeStyle = OrcUnitRenderer.METAL_LIGHT;
        ctx.lineWidth = 3 * scale;
        ctx.strokeRect(-6 * scale, -10 * scale, 12 * scale, 20 * scale);

        // –£–º–±–æ–Ω (—Ü–µ–Ω—Ç—Ä)
        ctx.fillStyle = OrcUnitRenderer.METAL_LIGHT;
        ctx.beginPath();
        ctx.arc(0, 0, 3 * scale, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawShieldSide(ctx: CanvasRenderingContext2D, scale: number) {
        // –í–∏–¥ —â–∏—Ç–∞ —Å–±–æ–∫—É - –ú–∞—Å—Å–∏–≤–Ω—ã–π
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.beginPath();
        // –ë–æ–ª–µ–µ –ø—Ä—è–º–æ–π, —Ç—è–∂–µ–ª—ã–π
        ctx.moveTo(0, -13 * scale);
        ctx.lineTo(2 * scale, 0);
        ctx.lineTo(0, 13 * scale);
        ctx.lineTo(-5 * scale, 13 * scale); // –¢–æ–ª—â–∏–Ω–∞
        ctx.lineTo(-3 * scale, 0); // –í–Ω—É—Ç—Ä –∏–∑–≥–∏–±
        ctx.lineTo(-5 * scale, -13 * scale);
        ctx.fill();

        // –®–∏–ø—ã —Ç–æ—Ä—á–∞—Ç –≤–ø–µ—Ä–µ–¥
        ctx.fillStyle = OrcUnitRenderer.METAL_LIGHT;
        ctx.beginPath(); ctx.moveTo(2 * scale, -6 * scale); ctx.lineTo(5 * scale, -6 * scale); ctx.lineTo(2 * scale, -4 * scale); ctx.fill();
        ctx.beginPath(); ctx.moveTo(2 * scale, 6 * scale); ctx.lineTo(5 * scale, 6 * scale); ctx.lineTo(2 * scale, 8 * scale); ctx.fill();
    }

    private drawMace(ctx: CanvasRenderingContext2D, scale: number) {
        // –†—É–∫–æ—è—Ç—å
        ctx.fillStyle = '#3e2723';
        ctx.fillRect(-1.5 * scale, -6 * scale, 3 * scale, 16 * scale);

        // –ì–æ–ª–æ–≤–∞
        ctx.fillStyle = '#212121';
        ctx.beginPath();
        ctx.arc(0, -8 * scale, 4.5 * scale, 0, Math.PI * 2);
        ctx.fill();

        // –®–∏–ø—ã –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
        ctx.fillStyle = '#bdbdbd';
        const spikes = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
        spikes.forEach(angle => {
            const sx = Math.cos(angle);
            const sy = Math.sin(angle);
            ctx.beginPath();
            ctx.moveTo(sx * 4 * scale, -8 * scale + sy * 4 * scale);
            ctx.lineTo(sx * 8 * scale, -8 * scale + sy * 8 * scale);
            ctx.lineTo(sx * 4 * scale + sy * 2 * scale, -8 * scale + sy * 4 * scale - sx * 2 * scale);
            ctx.fill();
        });
    }
}
</file>

<file path="src/renderers/units/SkeletonCommanderUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import { CONFIG } from '../../Config';
import type { Enemy } from '../../Enemy';

export class SkeletonCommanderUnitRenderer implements UnitRenderer {
    // üé® AAA PALETTE: Deep, Rich, Metallic
    private static readonly PALETTE = {
        BONE: '#cfd8dc',
        BONE_SHADOW: '#90a4ae',
        ARMOR_BASE: '#212121',     // Obsidian
        ARMOR_DARK: '#1a1a1a',      // Dark Obsidian
        ARMOR_HIGHLIGHT: '#424242', // Specular
        ARMOR_SHADOW: '#000000',    // Ambient Occlusion
        GOLD_LIGHT: '#ffecb3',      // Polished Gold
        GOLD_BASE: '#ffc107',       // Gold
        GOLD_DARK: '#ff6f00',       // Old Gold
        CAPE_BASE: '#b71c1c',       // Royal Crimson
        CAPE_DARK: '#7f0000',       // Fold shadow
        CAPE_HIGHLIGHT: '#e53935',  // Cloth sheen
        SWORD_STEEL: '#eceff1',
        SWORD_DARK: '#37474f',
        MAGIC_GLOW: '#ff3d00'       // Burning Ember Eyes/Runes
    };

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.001;
        // Heavy, menacing walk cycle
        const walkCycle = time * (enemy.baseSpeed * 0.15);
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        // "Breathing" idle animation
        const breath = Math.sin(time * 2) * 0.03;

        // Scale boost for "Boss" feel
        const s = scale * 1.35;

        // Orientation
        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        ctx.save();

        // Hit Flash / Status Effects
        if (enemy.hitFlashTimer > 0) ctx.filter = 'brightness(500%) sepia(100%) hue-rotate(-50deg)';

        // 1. Dynamic Aura (Ground Layer)
        this.drawAura(ctx, s, time);

        // 2. Render Order dependent on facing
        if (facing === 'DOWN') {
            this.drawCapeBack(ctx, s, time, isMoving, facing); // Visible edges behind
            this.drawFront(ctx, s, walkCycle, isMoving, breath);
        }
        else if (facing === 'SIDE') {
            if (Math.abs(rotation) > Math.PI / 2) ctx.scale(-1, 1);
            this.drawCapeBack(ctx, s, time, isMoving, facing);
            this.drawSide(ctx, s, walkCycle, isMoving, breath);
        }
        else { // UP (Back)
            this.drawFront(ctx, s, walkCycle, isMoving, breath, true); // Draw body for depth? No, distinct back view.
            this.drawBack(ctx, s, walkCycle, isMoving, breath);
            this.drawCapeBack(ctx, s, time, isMoving, facing); // Cape covers all
        }

        ctx.restore();
    }

    private drawAura(ctx: CanvasRenderingContext2D, s: number, t: number) {
        ctx.save();
        ctx.scale(1, 0.5); // Perspective squash
        const r = 18 * s;
        // Pulsing Ember
        const pulse = Math.sin(t * 3) * 0.2 + 0.8;

        const grad = ctx.createRadialGradient(0, 0, r * 0.4, 0, 0, r);
        grad.addColorStop(0, 'rgba(255, 111, 0, 0.0)'); // Center transparent
        grad.addColorStop(0.7, `rgba(255, 111, 0, ${0.3 * pulse})`); // Ring
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');

        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();

        // Runes/Sparks floor effect (Simplified)
        ctx.restore();
    }

    // === SOPHISTICATED CLOTH PHYSICS ===
    private drawCapeBack(ctx: CanvasRenderingContext2D, s: number, t: number, isMoving: boolean, facing: string) {
        const p = SkeletonCommanderUnitRenderer.PALETTE;
        const cycle = t * (isMoving ? 5 : 2); // Flutter speed
        const wind = Math.cos(t * 1.5) * 4 * s;
        const moveSway = isMoving ? Math.sin(cycle) * 6 * s : 0;

        ctx.save();
        ctx.translate(0, -12 * s); // Neck attachment

        if (facing === 'SIDE') {
            ctx.translate(-4 * s, 2 * s); // Attach to shoulder
            ctx.rotate(0.2 + (isMoving ? Math.sin(cycle * 0.5) * 0.1 : 0));
            // Multi-segment cape for fluid look
            ctx.beginPath();
            ctx.moveTo(0, 0);

            // Bezier Control points for "S" curve
            const tipX = -10 * s + moveSway + wind;
            const tipY = 28 * s;

            // Top curve (billow out)
            ctx.bezierCurveTo(-14 * s, 8 * s, -8 * s + moveSway, 18 * s, tipX, tipY);
            // Return edge (straighter)
            ctx.lineTo(4 * s, 4 * s);

            // Gradient Fill
            const grad = ctx.createLinearGradient(0, 0, 0, 30 * s);
            grad.addColorStop(0, p.CAPE_BASE);
            grad.addColorStop(1, p.CAPE_DARK);
            ctx.fillStyle = grad;
            ctx.fill();

        } else {
            // BACK / DOWN logic
            // Start narrow at neck, widen at bottom
            const neckW = 8 * s;
            const hemW = 22 * s;
            const h = 26 * s;
            const sway = moveSway + wind;

            ctx.beginPath();
            ctx.moveTo(-neckW / 2, 0);
            ctx.lineTo(neckW / 2, 0);

            // Complex Hem with folds
            const hemY = h + Math.sin(cycle * 2) * 1 * s;
            const hemX = sway;

            // Left curve
            ctx.bezierCurveTo(neckW + 4 * s, h * 0.4, hemW + hemX, h * 0.8, (hemW / 2) + hemX, hemY);
            // Bottom jagged edge (folds)
            ctx.lineTo(hemX, hemY + 2 * s);
            ctx.lineTo(-(hemW / 2) + hemX, hemY);
            // Right curve
            ctx.bezierCurveTo(-(hemW + hemX), h * 0.8, -(neckW + 4 * s), h * 0.4, -neckW / 2, 0);

            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, p.CAPE_BASE);
            grad.addColorStop(0.5, p.CAPE_BASE);
            grad.addColorStop(1, p.CAPE_DARK);
            ctx.fillStyle = grad;
            ctx.fill();

            // Highlight fold
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(hemX, hemY + 2 * s); ctx.lineTo(hemX + 2 * s, hemY + 2 * s); ctx.fill();
        }
        ctx.restore();
    }

    // === FRONT (AGGRESSIVE) ===
    private drawFront(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, breath: number, isBackLayer: boolean = false) {
        if (isBackLayer) return; // Handled in drawBack structure usually but here for logic separation 

        const bounce = Math.abs(Math.sin(cycle)) * 1.5 * s;
        ctx.translate(0, -bounce);

        // -- LEGS (Dynamic Stance) --
        // Wide stance for stability
        const ly = 12 * s;
        const legSep = 6 * s; // Wider
        this.drawLeg(ctx, -legSep, ly, s, 0); // Left
        this.drawLeg(ctx, legSep, ly, s, 0);  // Right

        // -- TORSO (Heavy Plate) --
        // Scaled by breath
        ctx.save();
        ctx.scale(1 + breath, 1 + breath);

        // Waist
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_DARK;
        ctx.fillRect(-5 * s, 5 * s, 10 * s, 6 * s);
        this.drawGoldTrim(ctx, -5 * s, 5 * s, 10 * s, 2 * s); // Belt

        // Chest Plate (V-Taper)
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_BASE;
        ctx.beginPath();
        ctx.moveTo(-9 * s, -12 * s); ctx.lineTo(9 * s, -12 * s);
        ctx.lineTo(6 * s, 6 * s); ctx.lineTo(-6 * s, 6 * s);
        ctx.fill();

        // Chest Detail (Ribs relief)
        ctx.strokeStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT;
        ctx.lineWidth = 1 * s;
        ctx.beginPath();
        ctx.moveTo(-4 * s, -4 * s); ctx.lineTo(4 * s, -4 * s);
        ctx.moveTo(-3 * s, 0); ctx.lineTo(3 * s, 0);
        ctx.stroke();

        // Center Emblem (Gold Skull or Ruby)
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE;
        ctx.beginPath(); ctx.arc(0, -5 * s, 2 * s, 0, Math.PI * 2); ctx.fill();

        // -- PAULDRONS (Massive) --
        this.drawPauldron(ctx, -11 * s, -13 * s, s, 1);
        this.drawPauldron(ctx, 11 * s, -13 * s, s, -1);

        ctx.restore(); // End breath transform

        // -- HEAD --
        ctx.translate(0, -14 * s + (breath * 5 * s));
        this.drawHelmet(ctx, s);
        ctx.translate(0, 14 * s - (breath * 5 * s));

        // -- ARMS & WEAPON (Aggressive Front) --
        // Holding sword Diagonally across body, ready to slash up
        const sway = Math.sin(cycle * 0.5) * 0.1;

        ctx.save();
        ctx.translate(0, -2 * s); // Shoulder pivot height center
        ctx.rotate(sway);

        // Sword Angle: Diagonally passing form bottom-left to top-right (or persistent carry)
        // User asked "Aggressive". Pointing at player? Or Sword-Point-Forward?
        // Let's go with "Low Guard" - Sword tip pointed at enemy throat level.

        ctx.translate(6 * s, 4 * s); // Right hand pos

        // Draw Sword (Rotated to point forward/left)
        ctx.save();
        ctx.rotate(-2.2); // Pointing mostly left and slightly up/down
        this.drawGreatsword(ctx, 0, -8 * s, s); // -8s offset to hold handle
        ctx.restore();

        // Right Arm (Holding sword)
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT;
        // Forearm
        // FIX: strokeWidth -> lineWidth
        ctx.lineWidth = 3 * s;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-2 * s, -6 * s); /*elbow*/  ctx.stroke();

        // Left Arm (Guide hand/Claw)
        // Reaching forward? Or two-handing?
        // Two-handing for majesty.
        ctx.translate(-5 * s, 2 * s); // Left hand pos relative to right
        // Just draw a gauntlet gripping the same hilt area roughly

        ctx.restore();
    }

    // === SIDE (AGGRESSIVE) ===
    private drawSide(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, breath: number) {
        const bounce = Math.abs(Math.sin(cycle)) * 1.5 * s;
        ctx.translate(0, -bounce);

        // Legs (Scissor)
        const stride = 8 * s;
        const lx = isMoving ? Math.sin(cycle) * stride : -4 * s; // Idle split
        const rx = isMoving ? -Math.sin(cycle) * stride : 4 * s;
        this.drawLeg(ctx, lx, 12 * s, s, 0);
        this.drawLeg(ctx, rx, 12 * s, s, 0);

        // Body Angle
        ctx.save();
        ctx.rotate(0.1); // Lean into wind/motion

        // Torso Side
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_BASE;
        // Chest bulge
        ctx.beginPath();
        ctx.moveTo(-4 * s, -12 * s); ctx.lineTo(6 * s, -11 * s); // Neck to Chest
        ctx.lineTo(4 * s, 8 * s); ctx.lineTo(-4 * s, 7 * s);
        ctx.fill();

        // Pauldron
        this.drawPauldron(ctx, 0, -12 * s, s, 1);

        // Head
        ctx.translate(2 * s, -14 * s);
        this.drawHelmet(ctx, s);
        ctx.translate(-2 * s, 14 * s);

        // Arms & Weapon (Thrust Stance)
        ctx.translate(4 * s, -2 * s); // Shoulder

        // Arm pointing forward
        const armAngle = -0.5 + Math.sin(cycle) * 0.1;
        ctx.rotate(armAngle);

        // Arm Plate
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT;
        ctx.fillRect(-2 * s, 0, 4 * s, 10 * s); // Upper arm

        // Forearm/Hand
        ctx.translate(0, 10 * s);
        ctx.rotate(-1.0); // Elbow bend

        // Gauntlet
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(0, 2 * s, 3 * s, 0, Math.PI * 2); ctx.fill();

        // Sword (In hand, pointing forward/up)
        // "Aggressive angle" -> Tip pointing at enemy face level
        ctx.rotate(-0.5);
        this.drawGreatsword(ctx, 0, -6 * s, s);

        ctx.restore(); // Undo Body Angle
    }

    // === BACK ===
    private drawBack(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, breath: number) {
        // Legs
        const ly = 12 * s;
        this.drawLeg(ctx, -5 * s, ly, s, 0);
        this.drawLeg(ctx, 5 * s, ly, s, 0);

        // Helmet Back
        ctx.translate(0, -14 * s);
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_BASE;
        ctx.beginPath(); ctx.arc(0, 0, 6 * s, 0, Math.PI * 2); ctx.fill();
        // Crown Back
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_DARK;
        ctx.beginPath();
        ctx.moveTo(-5 * s, 0); ctx.lineTo(-6 * s, -6 * s); ctx.lineTo(-3 * s, -3 * s);
        ctx.moveTo(5 * s, 0); ctx.lineTo(6 * s, -6 * s); ctx.lineTo(3 * s, -3 * s);
        ctx.fill();
    }

    // === COMPONENT LIBRARY ===

    private drawLeg(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, angle: number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        // Thigh / Knee
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT; // Metal
        ctx.beginPath();
        ctx.moveTo(-3 * s, -8 * s);
        ctx.lineTo(3 * s, -8 * s);
        ctx.lineTo(2 * s, 2 * s); // Ankle taper
        ctx.lineTo(-2 * s, 2 * s);
        ctx.fill();

        // Knee Pad (Gold Spike)
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE;
        ctx.beginPath();
        ctx.moveTo(-3 * s, -4 * s); ctx.lineTo(0, -7 * s); ctx.lineTo(3 * s, -4 * s); // Diamond shape
        ctx.lineTo(0, -1 * s);
        ctx.fill();

        // Boot
        ctx.fillStyle = '#0d0d0d';
        ctx.beginPath();
        ctx.ellipse(0, 2 * s, 3.5 * s, 2 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    private drawPauldron(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, dir: number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(dir, 1); // Flip if needing left/right mirroring for lighting? No, just shape.

        // 3-Tiered Pauldron for AAA detail
        const colors = [
            SkeletonCommanderUnitRenderer.PALETTE.ARMOR_DARK,
            SkeletonCommanderUnitRenderer.PALETTE.ARMOR_BASE,
            SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT
        ];

        for (let i = 0; i < 3; i++) {
            ctx.fillStyle = colors[i];
            ctx.beginPath();
            const off = i * 2 * s;
            ctx.arc(0, 0 + off, 6 * s - (i * 1 * s), Math.PI, 0); // Layered plates
            ctx.fill();
        }

        // Gold Trim
        ctx.strokeStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE;
        ctx.lineWidth = 2 * s;
        ctx.beginPath(); ctx.arc(0, 4 * s, 4 * s, Math.PI, 0); ctx.stroke();

        // Spike
        ctx.fillStyle = '#eee';
        ctx.beginPath(); ctx.moveTo(-1 * s, -4 * s); ctx.lineTo(0, -10 * s); ctx.lineTo(1 * s, -4 * s); ctx.fill();

        ctx.restore();
    }

    private drawHelmet(ctx: CanvasRenderingContext2D, s: number) {
        // Base
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath(); ctx.arc(0, 0, 6 * s, 0, Math.PI * 2); ctx.fill();

        // Faceplate: T-Visor Design (Dark Knight)
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT;
        ctx.beginPath();
        ctx.moveTo(-6 * s, -2 * s);
        ctx.quadraticCurveTo(0, 8 * s, 6 * s, -2 * s); // Jaw line
        ctx.lineTo(6 * s, -6 * s);
        ctx.quadraticCurveTo(0, -2 * s, -6 * s, -6 * s); // Brow
        ctx.fill();

        // Eye Slit (Glowing)
        ctx.shadowBlur = 15;
        ctx.shadowColor = SkeletonCommanderUnitRenderer.PALETTE.MAGIC_GLOW;
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.MAGIC_GLOW;

        // Single horizontal slit or two eyes? 
        // Two aggressive angular eyes
        ctx.beginPath();
        // Left eye
        ctx.moveTo(-1 * s, 0); ctx.lineTo(-4 * s, -1 * s); ctx.lineTo(-3 * s, 1 * s); ctx.fill();
        // Right eye
        ctx.moveTo(1 * s, 0); ctx.lineTo(4 * s, -1 * s); ctx.lineTo(3 * s, 1 * s); ctx.fill();

        ctx.shadowBlur = 0;

        // Crown (Gold)
        this.drawGoldTrim(ctx, -6 * s, -6 * s, 12 * s, 2 * s); // Brow band
        // Spikes
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE;
        ctx.beginPath();
        ctx.moveTo(-5 * s, -6 * s); ctx.lineTo(-6 * s, -12 * s); ctx.lineTo(-3 * s, -6 * s);
        ctx.moveTo(5 * s, -6 * s); ctx.lineTo(6 * s, -12 * s); ctx.lineTo(3 * s, -6 * s);
        ctx.moveTo(0, -6 * s); ctx.lineTo(0, -14 * s); ctx.lineTo(2 * s, -6 * s); // Center tall
        ctx.fill();
    }

    private drawGreatsword(ctx: CanvasRenderingContext2D, x: number, y: number, s: number) {
        ctx.save();
        ctx.translate(x, y);

        // Blade with Glow
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(255, 61, 0, 0.4)';

        // Metallic Gradient for Blade
        const grad = ctx.createLinearGradient(-3 * s, 0, 3 * s, 0);
        grad.addColorStop(0, '#cfd8dc');
        grad.addColorStop(0.5, '#ffffff'); // Ridge highlighted
        grad.addColorStop(1, '#b0bec5');

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(-3 * s, 0);
        ctx.lineTo(3 * s, 0);
        ctx.lineTo(0, 24 * s); // Wicked long
        ctx.fill();
        ctx.shadowBlur = 0;

        // Rune Inscription (Pulsing)
        ctx.strokeStyle = SkeletonCommanderUnitRenderer.PALETTE.MAGIC_GLOW;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, 2 * s); ctx.lineTo(0, 18 * s);
        ctx.stroke();

        // Crossguard (Bat wing style)
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_BASE;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-6 * s, -2 * s, -8 * s, 2 * s); // Wing tip
        ctx.lineTo(0, 4 * s);
        ctx.lineTo(8 * s, 2 * s);
        ctx.quadraticCurveTo(6 * s, -2 * s, 0, 0);
        ctx.fill();

        // Gem in guard
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.MAGIC_GLOW;
        ctx.beginPath(); ctx.arc(0, 1 * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();

        // Hilt
        ctx.fillStyle = '#3e2723';
        ctx.fillRect(-1 * s, -8 * s, 2 * s, 8 * s);

        // Pommel
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE;
        ctx.beginPath(); ctx.arc(0, -9 * s, 2.5 * s, 0, Math.PI * 2); ctx.fill();

        ctx.restore();
    }

    private drawGoldTrim(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number) {
        const grad = ctx.createLinearGradient(x, y, x, y + h);
        grad.addColorStop(0, SkeletonCommanderUnitRenderer.PALETTE.GOLD_LIGHT);
        grad.addColorStop(0.5, SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE);
        grad.addColorStop(1, SkeletonCommanderUnitRenderer.PALETTE.GOLD_DARK);
        ctx.fillStyle = grad;
        ctx.fillRect(x, y, w, h);
    }
}
</file>

<file path="src/renderers/units/SpiderUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import { CONFIG } from '../../Config';
import type { Enemy } from '../../Enemy';

export class SpiderUnitRenderer implements UnitRenderer {
    // üé® Sinister Poison Palette
    private static readonly BODY_COLOR = '#051806'; // Nearly black green
    private static readonly ABDOMEN_COLOR = '#0f2910'; // Dark toxic green
    private static readonly LEG_COLOR = '#194d1b'; // Darker Leg
    private static readonly LEG_JOINT = '#4caf50'; // Glowing Joints
    private static readonly EYES_COLOR = '#d500f9'; // Sharp Purple
    private static readonly FANGS_COLOR = '#b388ff'; // Pale Purple
    private static readonly ACID_GLOW = '#76ff03';  // Bright Toxic Green
    private static readonly VEIN_COLOR = '#2e7d32'; // Subtle veins

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.001;
        const walkCycle = time * (enemy.baseSpeed * 0.4); // Faster twitchy movement
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        const spiderScale = scale * 1.1;

        // Orientation
        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        ctx.save();

        if (enemy.hitFlashTimer > 0) ctx.filter = 'brightness(500%) sepia(100%) hue-rotate(50deg)';

        // Twitchy breathing
        const breathe = Math.sin(time * 8) * 0.3 * spiderScale; // Faster breath

        // Draw Legs FIRST (under body)
        this.drawLegs(ctx, facing, spiderScale, walkCycle, isMoving);

        // Draw Acid Trail
        if (isMoving && Math.random() > 0.7) {
            this.drawAcidDrip(ctx, spiderScale);
        }

        // Draw Body
        if (facing === 'SIDE') {
            if (Math.abs(rotation) > Math.PI / 2) ctx.scale(-1, 1);
            this.drawSide(ctx, spiderScale, breathe, time);
        } else if (facing === 'UP') {
            this.drawBack(ctx, spiderScale, breathe, time);
        } else {
            this.drawFront(ctx, spiderScale, breathe, time);
        }

        ctx.restore();
    }

    private drawLegs(ctx: CanvasRenderingContext2D, facing: string, s: number, cycle: number, isMoving: boolean) {
        const drawLeg = (sx: number, sy: number, ex: number, ey: number, kneeDir: number, phase: number, zIndex: number = 0) => {
            let tx = ex;
            let ty = ey;

            // Spider Movement: Legs lift HIGH and stab down
            if (isMoving) {
                const step = (cycle + phase) % (Math.PI * 2);
                if (step < Math.PI) {
                    // Lift phase (High arch)
                    const progress = Math.sin(step);
                    ty -= progress * 8 * s; // High steps
                    tx += Math.cos(step) * 2 * s;
                } else {
                    // Plant phase (Drag back)
                }
            }

            ctx.lineWidth = (zIndex === 0 ? 2 : 1.5) * s;
            ctx.strokeStyle = SpiderUnitRenderer.LEG_COLOR;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(sx, sy);

            // Knee Calculation (Sharp angles)
            const dx = tx - sx;
            const dy = ty - sy; // 3D Topdown perspective flattening
            const dist = Math.hypot(dx, dy);

            // Knee sticks UP in Z (negative Y in 2D)
            const midX = (sx + tx) / 2;
            const midY = (sy + ty) / 2;

            // Calculate a "knee" point that creates an arch
            const archHeight = 10 * s;
            const kx = midX + (dx * 0.1);
            // In top down, knees usually point OUT or UP. 
            // Let's bias Y negative for "Up"
            const ky = midY - archHeight * kneeDir;

            ctx.lineTo(kx, ky);
            ctx.lineTo(tx, ty);
            ctx.stroke();

            // Glowing Joint
            ctx.fillStyle = SpiderUnitRenderer.LEG_JOINT;
            ctx.beginPath(); ctx.arc(kx, ky, 1.2 * s, 0, Math.PI * 2); ctx.fill();
        };

        if (facing === 'SIDE') {
            // Side View Legs (Scuttling)
            // Far Left Legs
            drawLeg(0, -2 * s, -8 * s, 6 * s, 0.8, 0, 0);
            drawLeg(2 * s, -2 * s, 8 * s, 6 * s, 0.8, 1.5, 0);
            drawLeg(-2 * s, -2 * s, -10 * s, 4 * s, 0.9, 3.0, 0);
            drawLeg(4 * s, -2 * s, 12 * s, 4 * s, 0.9, 4.5, 0);
        } else {
            // Front/Back View Legs (Arched around body)
            // 4 Pairs
            const legSpread = [
                { dir: -1, phase: 0, ex: -12, ey: -8 }, // Front L
                { dir: 1, phase: Math.PI, ex: 12, ey: -8 }, // Front R
                { dir: -1, phase: 1.5, ex: -16, ey: 0 },  // Mid L
                { dir: 1, phase: Math.PI + 1.5, ex: 16, ey: 0 },  // Mid R
                { dir: -1, phase: 3, ex: -14, ey: 8 },    // Mid-Back L
                { dir: 1, phase: Math.PI + 3, ex: 14, ey: 8 },    // Mid-Back R
                { dir: -1, phase: 4.5, ex: -10, ey: 12 },   // Back L
                { dir: 1, phase: Math.PI + 4.5, ex: 10, ey: 12 },   // Back R
            ];

            const flipY = facing === 'UP' ? -1 : 1;

            legSpread.forEach(l => {
                const sx = l.dir * 3 * s; // Body attach width
                const sy = 0; // Center body

                // Front view: Legs arch DOWN
                // Back view: Legs arch DOWN
                // My knee logic (negative Y = UP) works for side view.
                // For top-downish front view:

                // Draw manual polylines for better shape
                this.drawLegArc(ctx, sx, sy, l.ex * s, l.ey * s * flipY, cycle + l.phase, s, isMoving);
            });
        }
    }

    private drawLegArc(ctx: CanvasRenderingContext2D, sx: number, sy: number, ex: number, ey: number, cycle: number, s: number, isMoving: boolean) {
        let finalEx = ex;
        let finalEy = ey;

        if (isMoving) {
            const lift = Math.sin(cycle);
            if (lift > 0) {
                finalEy -= lift * 6 * s; // Lift leg UP (negative Y)
            }
        }

        ctx.strokeStyle = SpiderUnitRenderer.LEG_COLOR;
        ctx.lineWidth = 1.8 * s;
        ctx.beginPath();
        ctx.moveTo(sx, sy);

        // Elbow point (High)
        const mx = (sx + finalEx) / 2;
        const my = (sy + finalEy) / 2 - 8 * s; // Arch UP

        ctx.quadraticCurveTo(mx, my, finalEx, finalEy);
        ctx.stroke();

        // Tip (claw)
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(finalEx, finalEy, 1 * s, 0, Math.PI * 2); ctx.fill();
    }

    // === VIEWS ===

    private drawFront(ctx: CanvasRenderingContext2D, s: number, breathe: number, t: number) {
        // Abdomen (Behind) - Darker
        ctx.fillStyle = SpiderUnitRenderer.ABDOMEN_COLOR;
        ctx.beginPath();
        ctx.ellipse(0, -3 * s, 6.5 * s, 5.5 * s + breathe, 0, 0, Math.PI * 2);
        ctx.fill();

        // Pulsing Veins
        this.drawVeins(ctx, 0, -3 * s, 6 * s, t);

        // Cephalothorax (Head)
        ctx.fillStyle = SpiderUnitRenderer.BODY_COLOR;
        ctx.beginPath();
        // Spiky shape
        ctx.moveTo(-3 * s, 0); ctx.lineTo(0, 4 * s); ctx.lineTo(3 * s, 0); ctx.lineTo(0, -3 * s);
        ctx.fill();

        // Eyes (Many)
        ctx.fillStyle = SpiderUnitRenderer.EYES_COLOR;
        ctx.shadowBlur = 5; ctx.shadowColor = SpiderUnitRenderer.EYES_COLOR;
        [[-1, 1], [1, 1], [-2.5, 0.5], [2.5, 0.5]].forEach(p => {
            ctx.beginPath(); ctx.arc(p[0] * s, p[1] * s, 0.8 * s, 0, Math.PI * 2); ctx.fill();
        });
        ctx.shadowBlur = 0;

        // Fangs (Sharp)
        ctx.fillStyle = SpiderUnitRenderer.FANGS_COLOR;
        ctx.beginPath();
        ctx.moveTo(-1.5 * s, 3 * s); ctx.lineTo(-1 * s, 7 * s); ctx.lineTo(-0.5 * s, 3 * s);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(1.5 * s, 3 * s); ctx.lineTo(1 * s, 7 * s); ctx.lineTo(0.5 * s, 3 * s);
        ctx.fill();
    }

    private drawBack(ctx: CanvasRenderingContext2D, s: number, breathe: number, t: number) {
        // Cephalothorax (Front)
        ctx.fillStyle = SpiderUnitRenderer.BODY_COLOR;
        ctx.beginPath();
        ctx.arc(0, -2 * s, 3.5 * s, 0, Math.PI * 2);
        ctx.fill();

        // Abdomen (Huge, foreground)
        const abY = 3 * s;
        ctx.fillStyle = SpiderUnitRenderer.ABDOMEN_COLOR;
        ctx.beginPath();
        ctx.ellipse(0, abY, 7.5 * s, 6.5 * s + breathe, 0, 0, Math.PI * 2);
        ctx.fill();

        // Pulsing Veins
        this.drawVeins(ctx, 0, abY, 7 * s, t);

        // Hourglass (Glowing)
        this.drawHourglass(ctx, 0, abY, s, t);
    }

    private drawSide(ctx: CanvasRenderingContext2D, s: number, breathe: number, t: number) {
        // Abdomen (Back)
        ctx.fillStyle = SpiderUnitRenderer.ABDOMEN_COLOR;
        ctx.beginPath();
        ctx.ellipse(-5 * s, -1 * s, 6.5 * s, 5 * s + breathe, -0.2, 0, Math.PI * 2);
        ctx.fill();

        this.drawVeins(ctx, -5 * s, -1 * s, 6 * s, t);

        // Cephalothorax (Front)
        ctx.fillStyle = SpiderUnitRenderer.BODY_COLOR;
        ctx.beginPath();
        ctx.ellipse(3 * s, 1 * s, 3.5 * s, 3 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = SpiderUnitRenderer.EYES_COLOR;
        ctx.shadowBlur = 4; ctx.shadowColor = SpiderUnitRenderer.EYES_COLOR;
        ctx.beginPath(); ctx.arc(5.5 * s, 0.5 * s, 0.8 * s, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;

        // Fangs
        ctx.fillStyle = SpiderUnitRenderer.FANGS_COLOR;
        ctx.beginPath();
        ctx.moveTo(4.5 * s, 2 * s); ctx.lineTo(4 * s, 6 * s); ctx.lineTo(5.5 * s, 2 * s);
        ctx.fill();
    }

    private drawHourglass(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, t: number) {
        const glow = Math.sin(t * 5) * 5;
        ctx.fillStyle = SpiderUnitRenderer.ACID_GLOW;
        ctx.shadowBlur = 10 + glow; ctx.shadowColor = SpiderUnitRenderer.ACID_GLOW;
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(1, 1.5);
        ctx.beginPath();
        ctx.moveTo(-1.5 * s, -1.5 * s); ctx.lineTo(1.5 * s, 1.5 * s); ctx.lineTo(-1.5 * s, 1.5 * s); ctx.lineTo(1.5 * s, -1.5 * s);
        ctx.fill();
        ctx.restore();
        ctx.shadowBlur = 0;
    }

    private drawVeins(ctx: CanvasRenderingContext2D, x: number, y: number, r: number, t: number) {
        ctx.strokeStyle = SpiderUnitRenderer.VEIN_COLOR;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.3 + Math.sin(t * 3) * 0.2;
        ctx.beginPath();
        // Web pattern on back
        for (let i = 0; i < 8; i++) {
            const angle = i * (Math.PI / 4);
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(angle) * r, y + Math.sin(angle) * r);
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }

    private drawAcidDrip(ctx: CanvasRenderingContext2D, s: number) {
        ctx.fillStyle = SpiderUnitRenderer.ACID_GLOW;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(0, 5 * s, 1.5 * s, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}
</file>

<file path="src/renderers/units/TrollUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import type { Enemy } from '../../Enemy';

export class TrollUnitRenderer implements UnitRenderer {
    // üé® Palette (Snow Troll)
    private static readonly FUR_BASE = '#eceff1';    // Snow White
    private static readonly FUR_SHADOW = '#cfd8dc';  // Blue-ish Grey Shadow
    private static readonly SKIN_DARK = '#b0bec5';   // Face/Hands
    private static readonly CLUB_WOOD = '#5d4037';   // Dark Wood
    private static readonly CLUB_LIGHT = '#8d6e63';  // Wood Highlight
    private static readonly EYE_COLOR = '#455a64';   // Dark Eyes (not glowing)

    // Config
    private static readonly CLUB_LENGTH = 24;
    private static readonly CLUB_WIDTH = 8;

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.001;
        // Heavy, slow movement (baseSpeed is 42, ~0.7 tiles/sec)
        // Adjusted walk cycle speed for "heaviness"
        const walkCycle = time * (enemy.baseSpeed * 0.15);
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        // Angles: -PI..PI. 0 is Right. 
        // UP: -PI/2 approx (-1.57). range -2.35 to -0.78
        // DOWN: PI/2 approx (1.57). range 0.78 to 2.35
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        ctx.save();

        if (facing === 'SIDE') {
            if (Math.abs(rotation) > Math.PI / 2) {
                ctx.scale(-1, 1); // Flip for Left
            }
            this.drawSide(ctx, scale, walkCycle, isMoving);
        } else if (facing === 'UP') {
            this.drawBack(ctx, scale, walkCycle, isMoving);
        } else {
            this.drawFront(ctx, scale, walkCycle, isMoving);
        }

        ctx.restore();
    }

    // === FRONT VIEW ===
    private drawFront(ctx: CanvasRenderingContext2D, s: number, wc: number, moving: boolean) {
        // Heavy plodding bounce
        const bounce = moving ? Math.abs(Math.sin(wc)) * 2 * s : 0;

        ctx.translate(0, -bounce);

        // 1. Back/Legs (Behind)
        this.drawLegsFront(ctx, s, wc, moving);

        // 2. Club (Dragging BEHIND to the side)
        // Hand is at (11, -4). Club should go down and back.
        // We simulate "dragging" by angling it.
        const dragAngle = -0.4; // Tilted back/out
        ctx.save();
        ctx.translate(11 * s, -4 * s); // Pivot at hand
        ctx.rotate(dragAngle);
        // Draw club extending down from hand
        this.drawClub(ctx, s, true);
        ctx.restore();

        // 3. Body (Hunchback Main Mass)
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        // Big round belly/chest
        ctx.ellipse(0, -2 * s, 10 * s, 11 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Fur Details (Chest)
        this.drawFurPatches(ctx, 0, -2 * s, 8 * s, s);

        // 4. Arms (Heavy, hanging low)
        const sway = moving ? Math.sin(wc) * 0.1 : 0;

        // Left Arm (Empty) - Thick muscles
        this.drawArmFront(ctx, -11 * s, -4 * s, s, 0.2 + sway);

        // Right Arm (Holding Club) - Firm grip on the pivoted club
        // We draw the arm on top of the club pivot
        this.drawArmFront(ctx, 11 * s, -4 * s, s, dragAngle);

        // 5. Head (Low, sunken)
        ctx.translate(0, -8 * s); // Neck is low
        this.drawHeadFront(ctx, s);
    }

    // === BACK VIEW ===
    private drawBack(ctx: CanvasRenderingContext2D, s: number, wc: number, moving: boolean) {
        const bounce = moving ? Math.abs(Math.sin(wc)) * 2 * s : 0;
        ctx.translate(0, -bounce);

        // 1. Legs
        this.drawLegsFront(ctx, s, wc, moving);

        // 2. Club (Dragging)
        // Hand is at Right (User's Right is Unit's Right) -> (12, -8)
        const dragAngle = 0.4;
        ctx.save();
        ctx.translate(12 * s, -8 * s); // Shoulder/Hand area
        ctx.rotate(dragAngle);
        // Club extends down
        this.drawClub(ctx, s, true);
        ctx.restore();

        // 3. Body (Massive Back)
        ctx.fillStyle = TrollUnitRenderer.FUR_SHADOW; // Darker back
        ctx.beginPath();
        ctx.ellipse(0, -4 * s, 11 * s, 12 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Fur Texture
        this.drawFurPatches(ctx, 0, -4 * s, 9 * s, s, true);

        // 4. Shoulders
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        ctx.arc(-11 * s, -8 * s, 5.5 * s, 0, Math.PI * 2); // Left Shoulder
        ctx.arc(11 * s, -8 * s, 5.5 * s, 0, Math.PI * 2);  // Right Shoulder
        ctx.fill();

        // 5. Head (Back)
        ctx.translate(0, -10 * s);
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        ctx.arc(0, 0, 6.5 * s, 0, Math.PI * 2);
        ctx.fill();
    }

    // === SIDE VIEW ===
    private drawSide(ctx: CanvasRenderingContext2D, s: number, wc: number, moving: boolean) {
        const bounce = moving ? Math.abs(Math.sin(wc)) * 2 * s : 0;

        // Stride
        const stride = 7 * s;
        const leftLegX = moving ? Math.sin(wc) * stride : 0; // Far leg
        const rightLegX = moving ? -Math.sin(wc) * stride : 0; // Near leg

        // 1. Far Leg (Left)
        this.drawFoot(ctx, leftLegX + 3 * s, 12 * s, s, true);

        ctx.translate(0, -bounce);

        // 2. Club (Dragging Behind)
        // Hand approx at (4, -4)
        // Club should drag way back
        const dragLift = moving ? Math.sin(wc) * 0.1 : 0; // Slight bump
        ctx.save();
        ctx.translate(4 * s, -4 * s); // Hand position
        ctx.rotate(-1.2 + dragLift); // Angled sharply back
        this.drawClub(ctx, s, true);
        ctx.restore();

        // 3. Far Arm (Holding Club)
        ctx.save();
        ctx.translate(4 * s, -6 * s); // Shoulder
        ctx.rotate(-0.8); // Reaching back/down to hold club
        this.drawArmShape(ctx, s, 13);
        ctx.restore();

        // 4. Body (Hunchback Profile)
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        // Hunch shape: ellipse rotated forward
        // More "bean" shaped for hunch
        ctx.moveTo(-6 * s, 8 * s);
        ctx.quadraticCurveTo(-12 * s, -6 * s, 0, -14 * s); // Back curve
        ctx.quadraticCurveTo(10 * s, -8 * s, 6 * s, 8 * s); // Front/Belly
        ctx.fill();

        // 5. Head (Forward/Low)
        ctx.save();
        ctx.translate(6 * s, -12 * s);
        this.drawHeadSide(ctx, s);
        ctx.restore();

        // 6. Near Leg (Right)
        ctx.save();
        ctx.translate(0, bounce); // Cancel bounce
        this.drawFoot(ctx, rightLegX, 12 * s, s, false);
        ctx.restore();

        // 7. Near Arm (Swinging free)
        const armSway = moving ? Math.cos(wc) * 0.4 : 0;
        ctx.save();
        ctx.translate(6 * s, -8 * s); // Shoulder fwd
        ctx.rotate(armSway + 0.3);
        this.drawArmShape(ctx, s, 13);
        ctx.restore();
    }

    // --- COMPONENTS ---

    private drawClub(ctx: CanvasRenderingContext2D, s: number, held: boolean = false) {
        // If held, (0,0) is handle top
        const len = TrollUnitRenderer.CLUB_LENGTH * s;
        const w = TrollUnitRenderer.CLUB_WIDTH * s;

        // Positioning: if held, draw DOWN from 0,0
        // Handle
        const handleLen = 6 * s;

        ctx.fillStyle = TrollUnitRenderer.CLUB_WOOD;

        ctx.beginPath();
        // Start thin at handle (0,0)
        ctx.moveTo(-1.5 * s, 0);
        ctx.lineTo(1.5 * s, 0);

        // Flare out
        ctx.lineTo(w / 2 + 2 * s, len); // Thick end
        ctx.lineTo(-w / 2 - 2 * s, len);
        ctx.fill();

        // Texture / Spikes?
        ctx.fillStyle = TrollUnitRenderer.CLUB_LIGHT;
        ctx.beginPath();
        ctx.arc(0, len * 0.8, 2.5 * s, 0, Math.PI * 2);
        ctx.fill();

        // Shadow on ground if dragging? (Simplified as dark tip)
        ctx.fillStyle = '#3e2723';
        ctx.beginPath();
        ctx.arc(0, len, w / 2, 0, Math.PI, false);
        ctx.fill();
    }

    private drawHeadFront(ctx: CanvasRenderingContext2D, s: number) {
        // Wide, flat head, deep set
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 7.5 * s, 6.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Face Area (No fur)
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.ellipse(0, 1.5 * s, 4.5 * s, 3.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = TrollUnitRenderer.EYE_COLOR;
        ctx.beginPath(); ctx.arc(-2 * s, 0.5 * s, 0.9 * s, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(2 * s, 0.5 * s, 0.9 * s, 0, Math.PI * 2); ctx.fill();

        // Brow Ridge (Heavy)
        ctx.fillStyle = TrollUnitRenderer.FUR_SHADOW;
        ctx.beginPath();
        ctx.roundRect(-5 * s, -2.5 * s, 10 * s, 2 * s, 1 * s);
        ctx.fill();

        // Tusks (Protruding Up)
        ctx.fillStyle = '#fff9c4';
        ctx.beginPath();
        ctx.moveTo(-2.5 * s, 3.5 * s); ctx.lineTo(-3 * s, 6 * s); ctx.lineTo(-1.5 * s, 4 * s);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(2.5 * s, 3.5 * s); ctx.lineTo(3 * s, 6 * s); ctx.lineTo(1.5 * s, 4 * s);
        ctx.fill();
    }

    private drawHeadSide(ctx: CanvasRenderingContext2D, s: number) {
        // Snouty profile
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        // Furry back of head
        ctx.beginPath();
        ctx.arc(-2 * s, -1 * s, 5 * s, 0, Math.PI * 2);
        ctx.fill();

        // Face connection
        ctx.beginPath();
        ctx.ellipse(1 * s, 0, 4 * s, 4 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Snout
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.ellipse(4 * s, 1 * s, 3 * s, 2.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Ear (Pointy)
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.moveTo(-2 * s, 0);
        ctx.lineTo(-5 * s, -2 * s);
        ctx.lineTo(-3 * s, 2 * s);
        ctx.fill();

        // Eye (Deep)
        ctx.fillStyle = TrollUnitRenderer.EYE_COLOR;
        ctx.beginPath(); ctx.arc(2 * s, 0, 0.9 * s, 0, Math.PI * 2); ctx.fill();

        // Tusk Side
        ctx.fillStyle = '#fff9c4';
        ctx.beginPath();
        ctx.moveTo(5 * s, 2 * s); ctx.lineTo(6 * s, -1 * s); ctx.lineTo(4 * s, 1 * s);
        ctx.fill();
    }

    private drawArmFront(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, angle: number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        // Muscle shape
        ctx.ellipse(0, 6 * s, 3.5 * s, 7 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hand
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.arc(0, 13 * s, 4 * s, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    private drawArmShape(ctx: CanvasRenderingContext2D, s: number, length: number) {
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        ctx.ellipse(0, length * 0.4 * s, 3.5 * s, length * 0.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hand
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.arc(0, length * s, 4 * s, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawLegsFront(ctx: CanvasRenderingContext2D, s: number, wc: number, moving: boolean) {
        const strideY = moving ? Math.sin(wc) * 3 * s : 0;
        // Wide stance
        this.drawLeg(ctx, -7 * s, 6 * s + strideY, s, true);
        this.drawLeg(ctx, 7 * s, 6 * s - strideY, s, false);
    }

    private drawLeg(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, isLeft: boolean) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = TrollUnitRenderer.FUR_SHADOW;

        // Thigh
        ctx.beginPath();
        ctx.ellipse(0, 4 * s, 4 * s, 6 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Foot (Paw-like, 3 toes)
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        const toeY = 10 * s;

        // Main foot pad
        ctx.beginPath();
        ctx.ellipse(0, toeY - 1 * s, 4.5 * s, 3 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Toes
        const toes = [-2.5, 0, 2.5];
        toes.forEach(tx => {
            ctx.beginPath();
            ctx.arc(tx * s, toeY + 1.5 * s, 1.8 * s, 0, Math.PI * 2);
            ctx.fill();
        });

        ctx.restore();
    }

    private drawFoot(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, dark: boolean) {
        ctx.save();
        ctx.translate(x, y);

        // Leg stump
        ctx.fillStyle = dark ? TrollUnitRenderer.FUR_SHADOW : TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        ctx.roundRect(-3.5 * s, -8 * s, 7 * s, 8 * s, 2 * s);
        ctx.fill();

        // Foot (Paw)
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;

        // Pad
        ctx.beginPath();
        ctx.ellipse(1 * s, 0, 5 * s, 3 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Toes (Side view - stacked)
        ctx.beginPath(); ctx.arc(5 * s, 1 * s, 1.8 * s, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(3 * s, 1.5 * s, 1.8 * s, 0, Math.PI * 2); ctx.fill();

        ctx.restore();
    }

    private drawFurPatches(ctx: CanvasRenderingContext2D, x: number, y: number, r: number, s: number, dark: boolean = false) {
        ctx.fillStyle = dark ? '#b0bec5' : '#ffffff'; // Highlight patches
        // Random-ish patches to break up the circle
        const patches = [
            { dx: -0.5, dy: -0.5, sz: 0.4 },
            { dx: 0.5, dy: -0.4, sz: 0.5 },
            { dx: 0, dy: 0.2, sz: 0.6 },
        ];

        patches.forEach(p => {
            ctx.beginPath();
            ctx.arc(x + p.dx * r, y + p.dy * r, p.sz * r, 0, Math.PI * 2);
            ctx.fill();
        });
    }
}
</file>

<file path="src/renderers/units/WraithUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import { CONFIG } from '../../Config';
import type { Enemy } from '../../Enemy';

export class WraithUnitRenderer implements UnitRenderer {
    // üé® Palette (Final Polish)
    private static readonly C_ROBE_DARK = '#120524'; // Deepest Void
    private static readonly C_ROBE_MID = '#311b92';  // Indigo
    private static readonly C_ACCENT = '#d500f9';    // Bright Magenta
    private static readonly C_SOUL_CORE = '#e0f7fa'; // White core
    private static readonly C_SOUL_GLOW = '#00e5ff'; // Cyan Glow
    private static readonly C_SHIELD = '#ffd700';    // Gold
    private static readonly C_HORN = '#263238';      // Dark Horn
    private static readonly C_EMERALD_FIRE = '#00e676'; // Emerald Fire

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.002;
        const bossScale = scale * 1.7; // Large Boss Scale

        // Heavy Levitation
        const hover = Math.sin(time * 1.2) * (10 * scale);

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        ctx.save();
        ctx.translate(0, hover - 18 * scale);

        if (facing === 'SIDE') {
            if (Math.abs(rotation) > Math.PI / 2) ctx.scale(-1, 1);
            this.drawSide(ctx, bossScale, time, enemy);
        } else if (facing === 'UP') {
            this.drawBack(ctx, bossScale, time, enemy);
        } else {
            this.drawFront(ctx, bossScale, time, enemy);
        }

        ctx.restore();
    }

    // === FRONT VIEW ===
    private drawFront(ctx: CanvasRenderingContext2D, s: number, t: number, enemy: Enemy) {
        // 1. Robe Back Layer (Inside)
        this.drawRobeSilhouette(ctx, s, t, 0, 'BACK_LAYER');

        // 2. Void Body / Ribs
        ctx.fillStyle = WraithUnitRenderer.C_ROBE_MID;
        ctx.beginPath();
        ctx.moveTo(-10 * s, -14 * s);
        ctx.bezierCurveTo(-5 * s, 10 * s, 5 * s, 10 * s, 10 * s, -14 * s); // Ribs shape
        ctx.fill();

        // 3. Robe Front Layer (Edges)
        this.drawRobeSilhouette(ctx, s, t, 0, 'FRONT_EDGES');

        // 4. Void Heart (Pulsing)
        const pulse = 1.0 + Math.sin(t * 3) * 0.2;
        ctx.shadowBlur = 25 * pulse;
        ctx.shadowColor = WraithUnitRenderer.C_SOUL_GLOW;
        ctx.fillStyle = WraithUnitRenderer.C_SOUL_CORE;
        ctx.beginPath();
        ctx.arc(0, -4 * s, 2 * s * pulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // 5. Claws (Spread out)
        const handFloat = Math.sin(t * 2) * 2 * s;
        this.drawClaw(ctx, -16 * s, -4 * s + handFloat, s, 0.4);
        this.drawClaw(ctx, 16 * s, -4 * s - handFloat, s, -0.4);

        // 6. Head
        ctx.translate(0, -18 * s);
        this.drawHorns(ctx, s, 'FRONT', t);
        this.drawHoodFront(ctx, s, t);

        // 7. FX
        ctx.translate(0, 18 * s);
        this.drawEffects(ctx, s, t, enemy);
    }

    // === BACK VIEW ===
    private drawBack(ctx: CanvasRenderingContext2D, s: number, t: number, enemy: Enemy) {
        // 1. Full Robe
        this.drawRobeSilhouette(ctx, s, t, 0, 'FULL');

        // 2. Spiked Collar
        ctx.fillStyle = '#0f041e';
        ctx.beginPath();
        ctx.moveTo(-12 * s, -16 * s);
        ctx.lineTo(0, -22 * s); // Tall spike
        ctx.lineTo(12 * s, -16 * s);
        ctx.lineTo(0, -5 * s);
        ctx.fill();

        // 3. Claws (Visible at sides)
        const handFloat = Math.sin(t * 2) * 2 * s;
        this.drawClaw(ctx, -16 * s, -4 * s + handFloat, s, 0.4, true);
        this.drawClaw(ctx, 16 * s, -4 * s - handFloat, s, -0.4, true);

        // 4. Head
        ctx.translate(0, -18 * s);
        this.drawHorns(ctx, s, 'BACK', t);

        ctx.fillStyle = WraithUnitRenderer.C_ROBE_DARK;
        ctx.beginPath();
        // Hood from back
        ctx.ellipse(0, 0, 9 * s, 11 * s, 0, Math.PI, 0);
        ctx.lineTo(9 * s, 8 * s);
        ctx.bezierCurveTo(0, 12 * s, 0, 12 * s, -9 * s, 8 * s);
        ctx.fill();

        // Glowing Rune
        ctx.strokeStyle = WraithUnitRenderer.C_ACCENT;
        ctx.lineWidth = 1.8 * s;
        ctx.shadowBlur = 10;
        ctx.shadowColor = WraithUnitRenderer.C_ACCENT;
        ctx.beginPath();
        ctx.moveTo(0, -5 * s); ctx.lineTo(0, 5 * s);
        ctx.moveTo(-3 * s, 0); ctx.lineTo(3 * s, 0);
        ctx.arc(0, 0, 3 * s, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;

        ctx.translate(0, 18 * s);
        this.drawEffects(ctx, s, t, enemy);
    }

    // === SIDE VIEW (RE-DESIGNED) ===
    private drawSide(ctx: CanvasRenderingContext2D, s: number, t: number, enemy: Enemy) {
        // 1. Robe (Dynamic "S" Shape Wind)
        // Instead of a block, we draw a flowing cape behind and exposed void in front

        // Back Cape Flowing
        const wave = Math.sin(t * 2.5) * 3 * s;
        ctx.fillStyle = this.getRobeGradient(ctx, s);
        ctx.beginPath();
        ctx.moveTo(-2 * s, -18 * s); // Shoulder back
        // Flowing back line
        ctx.bezierCurveTo(-15 * s, -5 * s, -10 * s + wave, 20 * s, -20 * s + wave, 35 * s);
        // Bottom jagged
        ctx.lineTo(5 * s, 35 * s);
        // Front line (Cut away to reveal body)
        ctx.bezierCurveTo(0, 20 * s, 5 * s, -5 * s, 2 * s, -18 * s);
        ctx.fill();

        // 2. Void Body (Visible chest)
        ctx.fillStyle = WraithUnitRenderer.C_ROBE_MID;
        ctx.beginPath();
        ctx.ellipse(2 * s, -8 * s, 4 * s, 8 * s, -0.2, 0, Math.PI * 2);
        ctx.fill();

        // 3. Claw (Reaching Forward - MENACING)
        const armWave = Math.sin(t * 2) * 0.1;
        ctx.save();
        ctx.translate(10 * s, -6 * s); // Far forward
        ctx.rotate(-0.3 + armWave);
        this.drawClawSide(ctx, s); // Specialized side claw
        ctx.restore();

        // 4. Head (Properly Seated)
        ctx.translate(2 * s, -17 * s);

        // Horns (Large & Fiery)
        this.drawHorns(ctx, s, 'SIDE', t);

        // Hood Profile
        ctx.fillStyle = WraithUnitRenderer.C_ROBE_DARK;
        ctx.beginPath();
        // Neck connection
        ctx.moveTo(-4 * s, 8 * s);
        ctx.quadraticCurveTo(-8 * s, -5 * s, -2 * s, -10 * s); // Back
        ctx.lineTo(8 * s, -5 * s); // Peak
        ctx.lineTo(7 * s, 3 * s); // Front
        ctx.quadraticCurveTo(2 * s, 6 * s, -4 * s, 8 * s);
        ctx.fill();

        // Face Void (Deep)
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(3 * s, 0, 2 * s, 5 * s, 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Eye (Burning)
        ctx.translate(4 * s, -0.5 * s);
        ctx.fillStyle = WraithUnitRenderer.C_SOUL_GLOW;
        ctx.shadowBlur = 15;
        ctx.shadowColor = WraithUnitRenderer.C_SOUL_GLOW;
        ctx.beginPath();
        ctx.moveTo(-1.5 * s, 0); ctx.lineTo(1.5 * s, -0.8 * s); ctx.lineTo(0.5 * s, 1.5 * s);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.translate(-6 * s, 17 * s);
        this.drawEffects(ctx, s, t, enemy);
    }

    // --- DETAILED COMPONENTS ---

    private getRobeGradient(ctx: CanvasRenderingContext2D, s: number): CanvasGradient {
        const grad = ctx.createLinearGradient(0, -20 * s, 0, 40 * s);
        grad.addColorStop(0, WraithUnitRenderer.C_ROBE_DARK);
        grad.addColorStop(0.5, WraithUnitRenderer.C_ROBE_MID);
        grad.addColorStop(0.85, 'rgba(49, 27, 146, 0.3)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        return grad;
    }

    private drawRobeSilhouette(ctx: CanvasRenderingContext2D, s: number, t: number, tilt: number, mode: 'FULL' | 'BACK_LAYER' | 'FRONT_EDGES') {
        ctx.fillStyle = this.getRobeGradient(ctx, s);
        if (tilt !== 0) ctx.rotate(tilt);

        ctx.beginPath();
        const waveL = Math.sin(t * 2) * 2 * s;
        const waveR = Math.cos(t * 2.5) * 2 * s;

        // Base Cloth Shape
        const drawCloth = () => {
            ctx.moveTo(-12 * s, -18 * s);
            ctx.bezierCurveTo(-18 * s, -5 * s, -14 * s + waveL, 20 * s, -20 * s + waveL, 35 * s);
            ctx.lineTo(20 * s + waveR, 35 * s);
            ctx.bezierCurveTo(14 * s + waveR, 20 * s, 18 * s, -5 * s, 12 * s, -18 * s);
        };

        if (mode === 'FULL') {
            drawCloth();
            ctx.fill();
        } else if (mode === 'BACK_LAYER') {
            // Draw mostly the wide part
            drawCloth();
            ctx.fill();
        } else if (mode === 'FRONT_EDGES') {
            // Draw open cloak
            ctx.beginPath();
            ctx.moveTo(-12 * s, -18 * s);
            ctx.quadraticCurveTo(-14 * s, 0, -8 * s, 30 * s); // Left drapea
            ctx.lineTo(-5 * s, 30 * s);
            ctx.quadraticCurveTo(-8 * s, 0, -6 * s, -14 * s);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(12 * s, -18 * s);
            ctx.quadraticCurveTo(14 * s, 0, 8 * s, 30 * s); // Right drape
            ctx.lineTo(5 * s, 30 * s);
            ctx.quadraticCurveTo(8 * s, 0, 6 * s, -14 * s);
            ctx.fill();
        }

        if (tilt !== 0) ctx.rotate(-tilt);
    }

    private drawClaw(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, angle: number, back: boolean = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        // Palm
        ctx.fillStyle = back ? '#000' : '#2c1e3d';
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.5 * s, 3.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Fingers with Glowing Tips
        const fingers = [-1.5, -0.5, 0.5, 1.5];
        for (let f of fingers) {
            ctx.fillStyle = back ? '#1a1a1a' : '#4a148c';
            ctx.beginPath();
            ctx.moveTo(f * s, 1 * s);
            ctx.lineTo((f * 2.0) * s, 7 * s); // Longer fingers
            ctx.lineTo((f * 0.8) * s, 1 * s);
            ctx.fill();

            // Glow Tip
            if (!back) {
                ctx.fillStyle = WraithUnitRenderer.C_ACCENT;
                ctx.beginPath();
                ctx.arc((f * 2.0) * s, 7 * s, 0.4 * s, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        ctx.restore();
    }

    private drawClawSide(ctx: CanvasRenderingContext2D, s: number) {
        ctx.fillStyle = '#2c1e3d';
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.5 * s, 3.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Reaching Fingers
        const drawFinger = (ang: number, len: number) => {
            ctx.save();
            ctx.rotate(ang);
            ctx.fillStyle = '#4a148c';
            ctx.beginPath();
            ctx.moveTo(0, 2 * s);
            ctx.lineTo(0.5 * s, len * s);
            ctx.lineTo(1.5 * s, 2 * s);
            ctx.fill();
            // Tip
            ctx.fillStyle = WraithUnitRenderer.C_ACCENT;
            ctx.beginPath(); ctx.arc(0.5 * s, len * s, 0.4 * s, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        };

        drawFinger(0.2, 7);
        drawFinger(0, 8);
        drawFinger(-0.3, 6);
    }

    private drawHorns(ctx: CanvasRenderingContext2D, s: number, view: 'FRONT' | 'BACK' | 'SIDE', t: number) {
        // Emerald Fire Gradient
        const fireGrad = ctx.createLinearGradient(0, -10 * s, 0, -22 * s);
        fireGrad.addColorStop(0, WraithUnitRenderer.C_HORN);
        fireGrad.addColorStop(0.6, WraithUnitRenderer.C_HORN);
        fireGrad.addColorStop(1, WraithUnitRenderer.C_EMERALD_FIRE); // Tip glow

        ctx.fillStyle = fireGrad;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 0.5 * s;

        // Flicker effect
        const flicker = Math.sin(t * 15) * 0.5;

        if (view === 'SIDE') {
            // Massive Swept Horn
            ctx.beginPath();
            ctx.moveTo(0, -5 * s);
            // Big curve back
            ctx.bezierCurveTo(4 * s, -14 * s, -6 * s, -18 * s, -12 * s, -14 * s + flicker);
            ctx.lineTo(-10 * s, -11 * s);
            ctx.bezierCurveTo(-6 * s, -14 * s, 2 * s, -12 * s, 0, -5 * s);
            ctx.fill(); ctx.stroke();

            // Emerald Particles
            this.drawHornParticles(ctx, -12 * s, -14 * s, s, t);

        } else {
            // Symmetrical Horns
            const drawHorn = (mirror: number) => {
                ctx.beginPath();
                ctx.moveTo(mirror * 6 * s, -6 * s);
                // Curve Out -> In -> Out
                ctx.bezierCurveTo(mirror * 14 * s, -12 * s, mirror * 8 * s, -20 * s, mirror * 18 * s, -24 * s + flicker);
                // Inner edge
                ctx.lineTo(mirror * 15 * s, -22 * s);
                ctx.bezierCurveTo(mirror * 8 * s, -18 * s, mirror * 10 * s, -10 * s, mirror * 6 * s, -6 * s);
                ctx.fill(); ctx.stroke();

                this.drawHornParticles(ctx, mirror * 18 * s, -24 * s, s, t);
            };
            drawHorn(1);
            drawHorn(-1);
        }
    }

    private drawHornParticles(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, t: number) {
        ctx.fillStyle = WraithUnitRenderer.C_EMERALD_FIRE;
        for (let i = 0; i < 3; i++) {
            const px = x + Math.sin(t * 10 + i) * 2 * s;
            const py = y - Math.abs(Math.cos(t * 8 + i)) * 4 * s;
            const size = (Math.sin(t * 5 + i) + 1.5) * 0.5 * s;
            ctx.globalAlpha = 0.6;
            ctx.beginPath(); ctx.arc(px, py, size, 0, Math.PI * 2); ctx.fill();
        }
        ctx.globalAlpha = 1.0;
    }

    private drawHoodFront(ctx: CanvasRenderingContext2D, s: number, t: number) {
        // Inner Void
        ctx.fillStyle = '#100020';
        ctx.beginPath();
        ctx.arc(0, 0, 9 * s, 0, Math.PI * 2);
        ctx.fill();

        // Cowl
        ctx.fillStyle = WraithUnitRenderer.C_ROBE_DARK;
        ctx.beginPath();
        ctx.moveTo(0, -12 * s);
        ctx.bezierCurveTo(11 * s, -12 * s, 11 * s, 9 * s, 0, 9 * s);
        ctx.bezierCurveTo(-11 * s, 9 * s, -11 * s, -12 * s, 0, -12 * s);
        ctx.fill();

        // Face Hole shape
        ctx.fillStyle = '#000';
        ctx.beginPath();
        // Shield shape face
        ctx.moveTo(-5 * s, -2 * s);
        ctx.lineTo(5 * s, -2 * s);
        ctx.lineTo(0, 8 * s);
        ctx.lineTo(-5 * s, -2 * s);
        ctx.fill();
        // Upper dome
        ctx.beginPath(); ctx.arc(0, -2 * s, 5 * s, Math.PI, 0); ctx.fill();

        // Glowing Eyes
        const eyePulse = 0.8 + Math.sin(t * 8) * 0.2;
        this.drawEye(ctx, -2.5 * s, -1 * s, s * eyePulse, true);
        this.drawEye(ctx, 2.5 * s, -1 * s, s * eyePulse, false);
    }

    private drawEye(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, left: boolean) {
        ctx.translate(x, y);
        ctx.fillStyle = WraithUnitRenderer.C_SOUL_GLOW;
        ctx.shadowBlur = 15;
        ctx.shadowColor = WraithUnitRenderer.C_SOUL_GLOW;
        ctx.beginPath();
        if (left) {
            ctx.moveTo(-1.2 * s, -0.6 * s); ctx.lineTo(1.2 * s, 0); ctx.lineTo(0, 1.2 * s);
        } else {
            ctx.moveTo(1.2 * s, -0.6 * s); ctx.lineTo(-1.2 * s, 0); ctx.lineTo(0, 1.2 * s);
        }
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.translate(-x, -y);
    }

    private drawEffects(ctx: CanvasRenderingContext2D, s: number, t: number, enemy: Enemy) {
        const soulSpeed = enemy.isInvulnerable ? 8 : 2;
        this.drawGhostSouls(ctx, s, t * soulSpeed, enemy.isInvulnerable);
        if (enemy.isInvulnerable) {
            this.drawInvulnerabilityShield(ctx, s, t);
        }
    }

    private drawGhostSouls(ctx: CanvasRenderingContext2D, s: number, t: number, angry: boolean) {
        const count = 5;
        for (let i = 0; i < count; i++) {
            const angle = t + (i * (Math.PI * 2) / count);
            const rx = Math.cos(angle) * 18 * s;
            const ry = Math.sin(angle) * 6 * s;
            const z = Math.sin(angle);

            const scaleFactor = (1.5 + z * 0.5);
            const size = scaleFactor * s * 2.5;
            const alpha = 0.4 + z * 0.2;

            ctx.save();
            ctx.translate(rx, ry - 5 * s);

            const color = angry ? '#ffeb3b' : WraithUnitRenderer.C_SOUL_GLOW;
            ctx.fillStyle = color;
            ctx.globalAlpha = alpha;

            // Ghost Head
            ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.fill();

            // Trail
            ctx.strokeStyle = color;
            ctx.lineWidth = size * 0.8;
            ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(0, 0);
            const trailX = -Math.sin(angle) * -12 * s;
            const trailY = Math.cos(angle) * 3 * s;
            ctx.quadraticCurveTo(trailX * 0.5, trailY * 0.5, trailX, trailY);
            ctx.stroke();

            ctx.restore();
        }
        ctx.globalAlpha = 1.0;
    }

    private drawInvulnerabilityShield(ctx: CanvasRenderingContext2D, s: number, t: number) {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const pulse = Math.sin(t * 10) * 0.1;
        const grad = ctx.createRadialGradient(0, -5 * s, 10 * s, 0, -5 * s, 24 * s);
        grad.addColorStop(0, 'rgba(255, 215, 0, 0)');
        grad.addColorStop(0.7, 'rgba(255, 215, 0, 0.15)');
        grad.addColorStop(1, 'rgba(255, 235, 59, 0.5)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(0, -5 * s, 24 * s, 0, Math.PI * 2); ctx.fill();

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2 * s;
        ctx.setLineDash([6 * s, 4 * s]);
        ctx.beginPath(); ctx.arc(0, -5 * s, 24 * s + pulse * 5, 0 + t, Math.PI * 2 + t); ctx.stroke();
        ctx.restore();
    }
}
</file>

<file path="src/SaveManager.ts">
import { ICard } from './CardSystem';
import { CONFIG } from './Config';

export interface IGlobalSaveData {
    totalMoneyEarned: number;
    enemiesKilled: number;
    wavesCleared: number;
    unlockedCards: string[]; // keys like 'FIRE', 'ICE'
    maxWaveReached: number;
}

export const DEFAULT_SAVE_DATA: IGlobalSaveData = {
    totalMoneyEarned: 0,
    enemiesKilled: 0,
    wavesCleared: 0,
    unlockedCards: ['FIRE', 'ICE', 'SNIPER'], // Default starters
    maxWaveReached: 0,
};

export class SaveManager {
    private static STORAGE_KEY = 'NEWTOWER_CAMPAIGN';

    public static load(): IGlobalSaveData {
        try {
            const raw = localStorage.getItem(this.STORAGE_KEY);
            if (raw) {
                const data = JSON.parse(raw);
                return { ...DEFAULT_SAVE_DATA, ...data };
            }
        } catch (e) {
            console.error('Failed to load save', e);
        }
        return { ...DEFAULT_SAVE_DATA };
    }

    public static save(data: IGlobalSaveData) {
        try {
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
        } catch (e) {
            console.error('Failed to save progress', e);
        }
    }

    public static updateProgress(stats: { money: number; kills: number; waves: number; maxWave: number }) {
        const data = this.load();
        data.totalMoneyEarned += stats.money;
        data.enemiesKilled += stats.kills;
        data.wavesCleared += stats.waves;
        if (stats.maxWave > data.maxWaveReached) {
            data.maxWaveReached = stats.maxWave;
        }
        this.save(data);
        console.log('Campaign Progress Saved', data);
    }
}
</file>

<file path="src/SimplexNoise.ts">
/**
 * Simple Simplex Noise implementation for fog animation
 * Based on Stefan Gustavson's SimplexNoise
 */
export class SimplexNoise {
    private perm: number[] = [];
    private grad3: number[][] = [
        [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
        [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
        [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
    ];

    constructor(seed: number = Math.random()) {
        // Initialize permutation table with seed
        const p: number[] = [];
        for (let i = 0; i < 256; i++) {
            p[i] = i;
        }

        // Shuffle using seed-based random
        let n, q;
        for (let i = 255; i > 0; i--) {
            seed = (seed * 9301 + 49297) % 233280;
            n = Math.floor((seed / 233280.0) * (i + 1));
            q = p[i];
            p[i] = p[n];
            p[n] = q;
        }

        // Extend to 512 for wrapping
        for (let i = 0; i < 512; i++) {
            this.perm[i] = p[i & 255];
        }
    }

    private dot(g: number[], x: number, y: number): number {
        return g[0] * x + g[1] * y;
    }

    /**
     * 2D Simplex Noise
     * @param x X coordinate
     * @param y Y coordinate
     * @returns value between -1 and 1
     */
    public noise2D(x: number, y: number): number {
        const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
        const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;

        // Skew the input space
        const s = (x + y) * F2;
        const i = Math.floor(x + s);
        const j = Math.floor(y + s);

        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = x - X0;
        const y0 = y - Y0;

        // Determine simplex
        let i1, j1;
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } else {
            i1 = 0;
            j1 = 1;
        }

        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1.0 + 2.0 * G2;
        const y2 = y0 - 1.0 + 2.0 * G2;

        // Hash coordinates
        const ii = i & 255;
        const jj = j & 255;
        const gi0 = this.perm[ii + this.perm[jj]] % 12;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
        const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;

        // Calculate contributions
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        let n0 = 0.0;
        if (t0 >= 0) {
            t0 *= t0;
            n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
        }

        let t1 = 0.5 - x1 * x1 - y1 * y1;
        let n1 = 0.0;
        if (t1 >= 0) {
            t1 *= t1;
            n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
        }

        let t2 = 0.5 - x2 * x2 - y2 * y2;
        let n2 = 0.0;
        if (t2 >= 0) {
            t2 *= t2;
            n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
        }

        // Sum and scale to [-1, 1]
        return 70.0 * (n0 + n1 + n2);
    }
}
</file>

<file path="src/SpatialGrid.ts">
/**
 * Spatial Grid for efficient proximity queries
 * Reduces collision detection from O(P √ó E) to O(P √ó avgCandidates)
 */

export interface IGridEntity {
    x: number;
    y: number;
}

export class SpatialGrid<T extends IGridEntity> {
    private cellSize: number;
    private grid: Map<string, T[]>;
    private cols: number;
    private rows: number;

    constructor(worldWidth: number, worldHeight: number, cellSize: number = 128) {
        this.cellSize = cellSize;
        this.cols = Math.ceil(worldWidth / cellSize);
        this.rows = Math.ceil(worldHeight / cellSize);
        this.grid = new Map();
    }

    /**
     * Clear all entities from the grid
     */
    public clear(): void {
        this.grid.clear();
    }

    /**
     * Register an entity in the grid based on its position
     */
    public register(entity: T): void {
        const cellKey = this.getCellKey(entity.x, entity.y);
        
        if (!this.grid.has(cellKey)) {
            this.grid.set(cellKey, []);
        }
        
        this.grid.get(cellKey)!.push(entity);
    }

    /**
     * Get all entities within radius of the given position
     * Only checks cells that could contain entities within the radius
     */
    public getNearby(x: number, y: number, radius: number): T[] {
        const results: T[] = [];
        
        // Calculate which cells to check
        const minCol = Math.max(0, Math.floor((x - radius) / this.cellSize));
        const maxCol = Math.min(this.cols - 1, Math.floor((x + radius) / this.cellSize));
        const minRow = Math.max(0, Math.floor((y - radius) / this.cellSize));
        const maxRow = Math.min(this.rows - 1, Math.floor((y + radius) / this.cellSize));

        // Check all relevant cells
        for (let col = minCol; col <= maxCol; col++) {
            for (let row = minRow; row <= maxRow; row++) {
                const cellKey = this.makeCellKey(col, row);
                const entities = this.grid.get(cellKey);
                
                if (entities) {
                    results.push(...entities);
                }
            }
        }

        return results;
    }

    /**
     * Get cell key for a position
     */
    private getCellKey(x: number, y: number): string {
        const col = Math.floor(x / this.cellSize);
        const row = Math.floor(y / this.cellSize);
        return this.makeCellKey(col, row);
    }

    /**
     * Create cell key from column and row
     */
    private makeCellKey(col: number, row: number): string {
        return `${col},${row}`;
    }

    /**
     * Debug: Get grid statistics
     */
    public getStats(): { totalCells: number; occupiedCells: number; totalEntities: number } {
        let totalEntities = 0;
        for (const entities of this.grid.values()) {
            totalEntities += entities.length;
        }

        return {
            totalCells: this.cols * this.rows,
            occupiedCells: this.grid.size,
            totalEntities,
        };
    }
}
</file>

<file path="src/systems/AcidPuddleSystem.ts">
import { EventBus, Events } from '../EventBus';
import { Enemy } from '../Enemy';
import { getEnemyType } from '../Config';

export class AcidPuddle {
    x: number;
    y: number;
    radius: number;
    duration: number;
    healTimer: number;

    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
        this.radius = 25; // Smaller, concentrated puddle
        this.duration = 5.0; // 5 seconds
        this.healTimer = 0;
    }

    update(dt: number, enemies: Enemy[]) {
        this.duration -= dt;
        this.healTimer += dt;

        // Heal every 0.5 seconds
        if (this.healTimer >= 0.5) {
            this.healTimer = 0;
            const healAmountPercent = 0.03;

            enemies.forEach(e => {
                if (!e.isAlive() || e.finished) return;

                const dist = Math.hypot(e.x - this.x, e.y - this.y);
                if (dist < this.radius) {
                    // Heal 3% of MAX HP
                    const heal = e.maxHealth * healAmountPercent;
                    if (e.currentHealth < e.maxHealth) {
                        e.currentHealth = Math.min(e.maxHealth, e.currentHealth + heal);
                        // Visual feedback maybe?
                    }
                }
            });
        }
    }

    isExpired(): boolean {
        return this.duration <= 0;
    }
}

export class AcidPuddleSystem {
    private puddles: AcidPuddle[] = [];
    private ctx: CanvasRenderingContext2D;

    constructor(ctx: CanvasRenderingContext2D) {
        this.ctx = ctx;
        // Listen for enemy deaths
        EventBus.getInstance().on(Events.ENEMY_DIED, this.onEnemyDied.bind(this));
    }

    private onEnemyDied(data: { enemy: Enemy }) {
        const enemy = data.enemy;
        if (!enemy) return;

        // Try lookup with Upper Case (Config often uses upper keys but ID property might be lower)
        const typeKey = enemy.typeId.toUpperCase();
        let config = getEnemyType(typeKey);

        // Fallback for strict ID match if upper fails
        if (!config) config = getEnemyType(enemy.typeId);

        if (config && config.archetype === 'SPIDER') {
            this.spawnPuddle(enemy.x, enemy.y);
        }
    }

    public spawnPuddle(x: number, y: number) {
        this.puddles.push(new AcidPuddle(x, y));
    }

    public update(dt: number, enemies: Enemy[]) {
        for (const puddle of this.puddles) {
            puddle.update(dt, enemies);
        }
        // Remove expired
        this.puddles = this.puddles.filter(p => !p.isExpired());
    }

    public draw() {
        if (this.puddles.length === 0) return;

        this.ctx.save();

        // Toxic Sludge Colors
        const LIQUID_COLOR = '#33691e';      // Dark swampy base
        const LIQUID_MID = '#64dd17';        // Poison green mid
        const LIQUID_HIGHLIGHT = '#ccff90';  // Pale toxic top

        for (const p of this.puddles) {
            const time = Date.now() * 0.001;
            const remaining = p.duration;

            // Fade out
            let globalAlpha = 1.0;
            if (remaining < 1.0) globalAlpha = remaining;
            this.ctx.globalAlpha = globalAlpha * 0.85;

            // Generate deterministic shape based on position (seed)
            // We want it to look "splattered", not round.
            // Technique: Draw 3-5 overlapping "blobs" with different distortions

            const seed = p.x + p.y; // Static seed for this puddle
            const numBlobs = 3 + (Math.floor(seed) % 3); // 3 to 5 blobs

            this.ctx.translate(p.x, p.y);

            // Draw Blobs
            for (let i = 0; i < numBlobs; i++) {
                const angle = (i / numBlobs) * Math.PI * 2 + seed;
                const dist = (seed % 10) + 5; // Offset from center
                const bx = Math.cos(angle) * dist;
                const by = Math.sin(angle) * dist;

                // Blob Radius
                const br = p.radius * (0.6 + Math.sin(seed * i) * 0.2);

                // Draw distorted blob
                this.ctx.fillStyle = (i % 2 === 0) ? LIQUID_COLOR : LIQUID_MID;
                this.ctx.beginPath();

                const segments = 12;
                for (let j = 0; j <= segments; j++) {
                    const theta = (j / segments) * Math.PI * 2;
                    // High frequency noise for "jagged liquid" edge
                    const noise = Math.sin(theta * 6 + time * 2) * 0.1;
                    const staticNoise = Math.cos(theta * 4 + seed) * 0.2;

                    const r = br * (1 + noise + staticNoise);
                    const px = bx + Math.cos(theta) * r;
                    const py = by + Math.sin(theta) * r;

                    if (j === 0) this.ctx.moveTo(px, py);
                    else this.ctx.lineTo(px, py);
                }
                this.ctx.fill();
            }

            // Bubbles (Popping)
            // Draw bubbles ON TOP
            const numBubbles = 2 + (Math.floor(time * 2) % 3);
            this.ctx.fillStyle = LIQUID_HIGHLIGHT;
            for (let k = 0; k < numBubbles; k++) {
                const bAngle = (time + k) * 2;
                const bDist = (Math.sin(time * 3 + k) + 1) * p.radius * 0.4;
                const bx = Math.cos(bAngle) * bDist;
                const by = Math.sin(bAngle) * bDist;
                const bSize = 2 + Math.sin(time * 10 + k) * 1.5;
                if (bSize > 0.5) {
                    this.ctx.beginPath();
                    this.ctx.arc(bx, by, bSize, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            this.ctx.translate(-p.x, -p.y);
        }
        this.ctx.restore();
    }
}
</file>

<file path="src/systems/SkeletonCommanderSystem.ts">
import { EventBus, Events } from '../EventBus';
import { Enemy } from '../Enemy';
import { getEnemyType } from '../Config';

export class SkeletonCommanderSystem {
    private ctx: CanvasRenderingContext2D;
    private listenersSetup = false;

    // Visual Effects List
    private buffEffects: Array<{
        startX: number, startY: number,
        target: Enemy, // Reference to living target
        currX: number, currY: number,
        life: number,
        maxLife: number
    }> = [];

    private recentDeaths: Array<{ x: number, y: number, typeId: string }> = [];

    constructor(ctx: CanvasRenderingContext2D) {
        this.ctx = ctx;
        if (!this.listenersSetup) {
            EventBus.getInstance().on(Events.ENEMY_DIED, this.onEnemyDied.bind(this));
            this.listenersSetup = true;
        }
    }

    private onEnemyDied(data: { enemy: Enemy }) {
        const deadEnemy = data.enemy;
        if (!deadEnemy) return;
        this.recentDeaths.push({ x: deadEnemy.x, y: deadEnemy.y, typeId: deadEnemy.typeId });
    }

    public update(dt: number, enemies: Enemy[]) {
        // Process recent deaths
        if (this.recentDeaths.length > 0) {

            // Find Active Commanders
            const commanders = enemies.filter(e => {
                if (!e.isAlive() || e.finished) return false;
                const conf = getEnemyType(e.typeId.toUpperCase()) || getEnemyType(e.typeId);
                return conf && conf.archetype === 'SKELETON_COMMANDER';
            });

            if (commanders.length > 0) {
                for (const death of this.recentDeaths) {
                    const deadConf = getEnemyType(death.typeId.toUpperCase()) || getEnemyType(death.typeId);

                    // Allow Buff from SKELETON or COMMANDER chains
                    const isSkeleton = deadConf && (deadConf.archetype === 'SKELETON' || deadConf.archetype === 'SKELETON_COMMANDER');

                    if (isSkeleton) {
                        // Find CLOSEST Commander within range
                        let bestCmd: Enemy | null = null;
                        let minDist = 192; // Max range (3 tiles)

                        for (const cmd of commanders) {
                            const dist = Math.hypot(cmd.x - death.x, cmd.y - death.y);
                            if (dist < minDist) {
                                minDist = dist;
                                bestCmd = cmd;
                            }
                        }

                        if (bestCmd) {
                            this.spawnSoulEffect(bestCmd, death.x, death.y);
                        }
                    }
                }
            }
            this.recentDeaths = []; // Clear queue
        }

        // Update Effects
        this.buffEffects.forEach(fx => {
            fx.life -= dt;

            // Update target pos
            const tx = fx.target.x;
            const ty = fx.target.y;

            // Move towards target
            const t = 1.0 - (fx.life / fx.maxLife); // 0 to 1
            // Ease out cubic
            const ease = 1 - Math.pow(1 - t, 3);

            fx.currX = fx.startX + (tx - fx.startX) * ease;
            fx.currY = fx.startY + (ty - fx.startY) * ease;

            // If extremely close, trigger impact?
            // We do impact logic in update OR draw. 
            // Logic: Healing happens on impact? Or instantly?
            // User asked: "Soul flies to commander". implies delayed effect.
            // But for gameplay responsiveness, instant heal is safer. 
            // However, let's make heal happen when particle arrives for "correctness".
        });

        // Trigger Heal on arrival (approximate check)
        // Actually, let's keep heal instant for now? No, user wants polish.
        // Let's check for arrival.
        for (let i = this.buffEffects.length - 1; i >= 0; i--) {
            const fx = this.buffEffects[i];
            const dist = Math.hypot(fx.currX - fx.target.x, fx.currY - fx.target.y);
            if (dist < 10 && fx.life > 0) {
                // Arrived!
                this.buffCommander(fx.target);
                fx.life = 0; // End effect
            }
        }

        this.buffEffects = this.buffEffects.filter(fx => fx.life > 0 && fx.target.isAlive() && !fx.target.finished);
    }

    private spawnSoulEffect(target: Enemy, startX: number, startY: number) {
        this.buffEffects.push({
            startX: startX, startY: startY,
            target: target,
            currX: startX, currY: startY,
            life: 0.6, // Faster flight
            maxLife: 0.6
        });
    }

    private buffCommander(cmd: Enemy) {
        // Heal
        const heal = cmd.maxHealth * 0.05; // 5%
        if (cmd.currentHealth < cmd.maxHealth) {
            cmd.currentHealth = Math.min(cmd.maxHealth, cmd.currentHealth + heal);
        }
        // Maybe spawn a "Heal Flash" effect here?
        // Rely on draw() to show impact flash.
    }

    public draw() {
        if (this.buffEffects.length === 0) return;

        this.ctx.save();

        for (const fx of this.buffEffects) {
            // "Soul" Particle flying to Commander
            // Smaller size requested
            this.ctx.fillStyle = '#ffd700'; // Gold Soul
            this.ctx.shadowBlur = 5;
            this.ctx.shadowColor = '#ffd700';

            this.ctx.beginPath();
            this.ctx.arc(fx.currX, fx.currY, 2.5, 0, Math.PI * 2); // Smaller (was 4)
            this.ctx.fill();

            // Trail
            this.ctx.shadowBlur = 0;
            this.ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            this.ctx.moveTo(fx.startX, fx.startY);
            this.ctx.lineTo(fx.currX, fx.currY);
            this.ctx.stroke();

            // Flash on commander (Impact visual)
            // If very close to end of life (arrival)
            if (fx.life < 0.1) {
                this.ctx.globalAlpha = 0.6;
                this.ctx.fillStyle = '#fff';
                this.ctx.beginPath();
                this.ctx.arc(fx.target.x, fx.target.y, 12, 0, Math.PI * 2); // Smaller flash
                this.ctx.fill();
            }
        }
        this.ctx.restore();
    }
}
</file>

<file path="src/ui/bestiary/BestiaryUI.ts">
import { IGameScene } from '../../scenes/IGameScene';
import { CONFIG } from '../../Config';
import { VISUALS } from '../../VisualConfig';
import { UIUtils } from '../../UIUtils';
import { WaveAnalyst } from './WaveAnalyst';
import { ENEMY_TYPES } from '../../config/Enemies';
import { SoundManager, SoundPriority } from '../../SoundManager';

export class BestiaryUI {
    private scene: IGameScene;
    private analyst: WaveAnalyst;
    private unlockedEnemies: Set<string>;

    private elOverlay!: HTMLElement;
    private elContent!: HTMLElement;
    private elTabsContainer!: HTMLElement;
    private elTabEnemies!: HTMLElement;
    private elTabIntel!: HTMLElement;

    // Content Containers
    private elEnemiesView!: HTMLElement;
    private elIntelView!: HTMLElement;

    private activeTab: 'enemies' | 'intel' = 'enemies';
    private selectedEnemyId: string | null = null;

    constructor(scene: IGameScene, unlockedEnemies: Set<string>) {
        this.scene = scene;
        this.unlockedEnemies = unlockedEnemies;
        this.analyst = new WaveAnalyst(this.scene.waveManager as any, this.unlockedEnemies);

        this.createUI();
    }

    public show() {
        this.elOverlay.style.display = 'flex';
        this.render();
    }

    public hide() {
        this.elOverlay.style.display = 'none';
        SoundManager.play('click', SoundPriority.LOW);
    }

    public toggle() {
        if (this.elOverlay.style.display === 'flex') {
            this.hide();
        } else {
            this.show();
        }
    }

    public unlockEnemy(id: string) {
        if (!this.unlockedEnemies.has(id)) {
            this.unlockedEnemies.add(id);
            if (this.elOverlay.style.display === 'flex') this.render();
        }
    }

    private createUI() {
        // Overlay
        this.elOverlay = UIUtils.createOverlay('bestiary-overlay');
        this.elOverlay.onclick = (e) => {
            if (e.target === this.elOverlay) this.hide();
        };

        // Main Window
        this.elContent = UIUtils.createContainer({
            width: '800px',
            height: '600px',
            background: 'rgba(20, 20, 30, 0.95)',
            border: `2px solid ${VISUALS.UI.COLORS.neutral.light}`,
            borderRadius: '8px',
            display: 'flex',
            flexDirection: 'column',
            position: 'relative',
            overflowY: 'hidden'
        });
        // Stop clicks from closing overlay
        this.elContent.onclick = (e) => e.stopPropagation();

        // Header (Tabs + Close)
        const header = UIUtils.createContainer({
            height: '50px',
            display: 'flex',
            alignItems: 'center',
            background: 'rgba(0,0,0,0.3)',
            border: 'none', // border is handled by item borders usually
        });
        header.style.borderBottom = `1px solid ${VISUALS.UI.COLORS.neutral.light}`;

        this.elTabsContainer = UIUtils.createContainer({
            display: 'flex',
            height: '100%',
            flexGrow: '1'
        });

        this.elTabEnemies = this.createTab('ENEMIES', 'enemies');
        this.elTabIntel = this.createTab('INTEL', 'intel');

        const closeBtn = UIUtils.createButton(header, '‚úñ', () => this.hide(), {
            background: 'transparent',
            border: 'none',
            color: '#ff4444',
            fontSize: '20px',
            padding: '0 20px',
            fontWeight: 'bold'
        });
        closeBtn.style.marginLeft = 'auto';

        this.elTabsContainer.appendChild(this.elTabEnemies);
        this.elTabsContainer.appendChild(this.elTabIntel);
        header.appendChild(this.elTabsContainer);
        header.appendChild(closeBtn);
        this.elContent.appendChild(header);

        // Views Container
        const viewsContainer = UIUtils.createContainer({
            flexGrow: '1',
            padding: '20px',
            overflowY: 'hidden',
            display: 'flex',
            flexDirection: 'column'
        });

        // Enemies View
        this.elEnemiesView = UIUtils.createContainer({
            width: '100%',
            height: '100%',
            display: 'flex',
            gap: '20px'
        });

        // Intel View
        this.elIntelView = UIUtils.createContainer({
            width: '100%',
            height: '100%',
            display: 'none',
            flexDirection: 'column',
            overflowY: 'auto'
        });

        viewsContainer.appendChild(this.elEnemiesView);
        viewsContainer.appendChild(this.elIntelView);
        this.elContent.appendChild(viewsContainer);

        this.elOverlay.appendChild(this.elContent);
    }

    private createTab(label: string, id: 'enemies' | 'intel'): HTMLElement {
        const tab = document.createElement('div');
        tab.innerText = label;
        Object.assign(tab.style, {
            padding: '0 30px',
            height: '100%',
            display: 'flex',
            alignItems: 'center',
            cursor: 'pointer',
            fontWeight: 'bold',
            color: '#888',
            transition: '0.2s'
        });
        tab.onclick = () => {
            this.activeTab = id;
            SoundManager.play('click', SoundPriority.LOW);
            this.render();
        };
        return tab;
    }

    private render() {
        // Tab States
        const activeColor = '#ffd700';
        const inactiveColor = '#888';
        const activeBg = 'rgba(255, 215, 0, 0.1)';

        this.elTabEnemies.style.color = this.activeTab === 'enemies' ? activeColor : inactiveColor;
        this.elTabEnemies.style.background = this.activeTab === 'enemies' ? activeBg : 'transparent';

        this.elTabIntel.style.color = this.activeTab === 'intel' ? activeColor : inactiveColor;
        this.elTabIntel.style.background = this.activeTab === 'intel' ? activeBg : 'transparent';

        // View Visibility
        this.elEnemiesView.style.display = this.activeTab === 'enemies' ? 'flex' : 'none';
        this.elIntelView.style.display = this.activeTab === 'intel' ? 'flex' : 'none';

        if (this.activeTab === 'enemies') {
            this.renderEnemies();
        } else {
            this.renderIntel();
        }
    }

    // --- ENEMIES TAB ---
    private renderEnemies() {
        this.elEnemiesView.innerHTML = '';

        // Left List
        const list = UIUtils.createContainer({
            width: '30%',
            height: '100%',
            overflowY: 'auto',
            display: 'flex',
            flexDirection: 'column',
            gap: '5px',
            padding: '0 5px 0 0' // padding for scrollbar
        });

        // Right Details
        const details = UIUtils.createContainer({
            width: '70%',
            height: '100%',
            background: 'rgba(0,0,0,0.3)',
            borderRadius: '4px',
            padding: '20px',
            display: 'flex',
            flexDirection: 'column'
        });

        const allEnemies = Object.values(ENEMY_TYPES).filter(e => !e.isHidden);
        let firstUnlockedId = '';

        allEnemies.forEach(e => {
            const isUnlocked = this.unlockedEnemies.has(e.id);
            const item = document.createElement('div');
            Object.assign(item.style, {
                padding: '10px',
                background: this.selectedEnemyId === e.id ? 'rgba(255, 215, 0, 0.2)' : 'rgba(255,255,255,0.05)',
                border: this.selectedEnemyId === e.id ? '1px solid #ffd700' : '1px solid transparent',
                borderRadius: '4px',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '10px'
            });

            if (isUnlocked) {
                if (!firstUnlockedId) firstUnlockedId = e.id;
                item.innerHTML = `<span style="font-size:20px">${e.symbol}</span> <span>${e.name}</span>`;
            } else {
                item.innerHTML = `<span style="filter:grayscale(1)">‚ùì</span> <span style="color:#555">???</span>`;
            }

            item.onclick = () => {
                if (isUnlocked) {
                    this.selectedEnemyId = e.id;
                    SoundManager.play('click', SoundPriority.LOW);
                    this.renderEnemies(); // Re-render to highlight selection and show details
                }
            };

            list.appendChild(item);
        });

        // Auto-select first if none selected
        if (!this.selectedEnemyId && firstUnlockedId) {
            this.selectedEnemyId = firstUnlockedId;
            // Don't re-render here to avoid loop, just rely on next update or user click
        }

        // Render Details
        if (this.selectedEnemyId) {
            const conf = ENEMY_TYPES[this.selectedEnemyId.toUpperCase()];
            if (conf) {
                details.innerHTML = `
                    <div style="display:flex; gap: 20px; margin-bottom: 20px; align-items:center;">
                        <div style="font-size: 64px; background:rgba(0,0,0,0.5); width:100px; height:100px; display:flex; align-items:center; justify-content:center; border-radius:8px;">
                            ${conf.symbol}
                        </div>
                        <div>
                            <h2 style="margin:0; color:${conf.color || '#fff'}">${conf.name}</h2>
                            <div style="color:#aaa; font-style:italic;">${conf.archetype}</div>
                        </div>
                    </div>

                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px;">
                        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:4px;">
                            <div style="color:#888; font-size:12px;">HEALTH</div>
                            <div style="font-size:18px;">${Math.round(CONFIG.ENEMY.BASE_HP * conf.hpMod)} <span style="font-size:12px;color:#aaa">(x${conf.hpMod})</span></div>
                        </div>
                        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:4px;">
                            <div style="color:#888; font-size:12px;">SPEED</div>
                            <div style="font-size:18px;">${conf.speed}</div>
                        </div>
                        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:4px;">
                            <div style="color:#888; font-size:12px;">REWARD</div>
                            <div style="font-size:18px; color:gold;">${conf.reward}üí∞</div>
                        </div>
                        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:4px;">
                            <div style="color:#888; font-size:12px;">THREAT</div>
                            <div style="font-size:18px;">${conf.hpMod > 2 ? 'HIGH' : 'NORMAL'}</div>
                        </div>
                    </div>

                    <div style="background:rgba(0,0,0,0.2); padding:15px; border-radius:4px; border-left: 3px solid ${conf.color}">
                        ${conf.desc}
                    </div>
                `;
            }
        } else {
            details.innerHTML = `<div style="display:flex; align-items:center; justify-content:center; height:100%; color:#555;">Select an enemy</div>`;
        }

        this.elEnemiesView.appendChild(list);
        this.elEnemiesView.appendChild(details);
    }

    // --- INTEL TAB ---
    private renderIntel() {
        this.elIntelView.innerHTML = '';

        const currentWave = this.scene.wave;

        // Show next 5 waves
        for (let i = 0; i < 5; i++) {
            const waveNum = currentWave + i;
            const intel = this.analyst.getWaveIntel(waveNum);

            const card = UIUtils.createContainer({
                width: '100%',
                background: 'rgba(255,255,255,0.03)',
                border: '1px solid rgba(255,255,255,0.1)',
                borderRadius: '6px',
                padding: '15px',
                marginBottom: '10px',
                display: 'flex',
                flexDirection: 'column',
                gap: '10px'
            });

            // Header
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';

            let threatColor = '#4caf50'; // Low
            if (intel.threatLevel === 'MEDIUM') threatColor = '#ffeb3b';
            if (intel.threatLevel === 'HIGH') threatColor = '#ff9800';
            if (intel.threatLevel === 'EXTREME') threatColor = '#f44336';

            header.innerHTML = `
                <div style="font-size: 18px; font-weight: bold; color: ${i === 0 ? '#fff' : '#aaa'}">
                    Wave ${waveNum} ${i === 0 ? '<span style="font-size:12px; background:#4caf50; padding:2px 6px; border-radius:4px; margin-left:10px;">CURRENT</span>' : ''}
                </div>
                <div style="display:flex; gap:15px; font-size:14px;">
                    <span style="color:gold">Est. ${intel.totalReward}üí∞</span>
                    <span style="color:${threatColor}">‚ö†Ô∏è ${intel.threatLevel}</span>
                </div>
            `;
            card.appendChild(header);

            // Enemies List (Redesigned)
            const enemiesContainer = document.createElement('div');
            enemiesContainer.style.display = 'flex';
            enemiesContainer.style.flexDirection = 'column';
            enemiesContainer.style.gap = '4px';

            intel.enemies.forEach((e, idx) => {
                const row = document.createElement('div');
                Object.assign(row.style, {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '10px',
                    padding: '6px 10px',
                    background: (idx % 2 === 0) ? 'rgba(0,0,0,0.2)' : 'transparent',
                    borderRadius: '4px',
                });

                // Add "NEW" tag if applicable
                const newTag = e.isNew ? `<span style="background:#d32f2f; color:#fff; font-size:10px; padding:2px 4px; border-radius:3px; font-weight:bold; margin-right:5px;">NEW</span>` : '';

                // Name & Type
                // If unlocked, show details. If locked, show limited info.
                const nameStyle = e.isNew ? 'color: #aaa; font-style: italic;' : 'color: #fff; font-weight: 500;';
                const nameText = e.isNew ? 'Unknown Threat' : e.name;
                const iconDisplay = e.isNew ? '<span style="filter:blur(2px) grayscale(1); opacity:0.7">‚ùì</span>' : e.icon;

                row.innerHTML = `
                    <div style="width: 30px; text-align:center; font-size: 20px;">${iconDisplay}</div>
                    <div style="flex-grow: 1; ${nameStyle}">
                        ${newTag}${nameText}
                    </div>
                    <div style="font-weight: bold; color: #ddd;">x${e.count}</div>
                `;

                enemiesContainer.appendChild(row);
            });

            if (intel.enemies.length === 0) {
                enemiesContainer.innerHTML = `<span style="color:#555; padding:10px;">No signal...</span>`;
            }

            card.appendChild(enemiesContainer);
            this.elIntelView.appendChild(card);
        }
    }
}
</file>

<file path="src/ui/bestiary/WaveAnalyst.ts">
import { WaveManager } from '../../WaveManager';
import { CONFIG } from '../../Config';
import { ENEMY_TYPES } from '../../config/Enemies';

export interface IWaveSummary {
    waveNumber: number;
    enemies: Array<{
        type: string;
        count: number;
        icon: string;
        name: string;
        isNew: boolean; // Is this the first time this enemy appears?
    }>;
    totalCount: number;
    totalReward: number;
    threatLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'EXTREME';
    threatScore: number;
}

export class WaveAnalyst {
    private waveManager: WaveManager;
    private unlockedEnemies: Set<string>;

    constructor(waveManager: WaveManager, unlockedEnemies: Set<string>) {
        this.waveManager = waveManager;
        this.unlockedEnemies = unlockedEnemies;
    }

    public getWaveIntel(waveNum: number): IWaveSummary {
        const config = this.waveManager.getWaveConfig(waveNum);

        let totalCount = 0;
        let totalReward = 0;
        let totalHP = 0;
        const enemyMap = new Map<string, number>();

        if (config && config.enemies) {
            config.enemies.forEach(group => {
                const count = group.count;
                const type = group.type;

                totalCount += count;
                enemyMap.set(type, (enemyMap.get(type) || 0) + count);

                const stats = ENEMY_TYPES[type.toUpperCase()];
                if (stats) {
                    const hp = CONFIG.ENEMY.BASE_HP * stats.hpMod * Math.pow(CONFIG.ENEMY.HP_GROWTH, waveNum - 1);
                    totalHP += hp * count;
                    totalReward += stats.reward * count;
                }
            });
        }

        // Add base reward
        totalReward += CONFIG.ECONOMY.WAVE_BASE_REWARD + (waveNum * CONFIG.ECONOMY.WAVE_SCALING_FACTOR);

        // Convert map to array
        const enemiesList: IWaveSummary['enemies'] = [];
        enemyMap.forEach((count, type) => {
            const stats = ENEMY_TYPES[type.toUpperCase()];
            const isUnlocked = this.unlockedEnemies.has(type.toLowerCase());

            enemiesList.push({
                type: type,
                count: count,
                icon: isUnlocked ? stats?.symbol || '?' : '?',
                name: isUnlocked ? stats?.name || 'Unknown' : '???',
                isNew: !isUnlocked
            });
        });

        // Threat Calculation
        // Base threat usually increases by ~1.3x per wave in power
        // Simple heuristic: Total HP / Standard Tower DPS (approx 5)
        const dpsBenchmark = 5 * Math.max(1, waveNum * 0.5); // Expected DPS grows with wave
        const timeToKill = totalHP / dpsBenchmark;

        // Normalize threat
        let threat: IWaveSummary['threatLevel'] = 'LOW';
        if (timeToKill > 60) threat = 'MEDIUM';
        if (timeToKill > 120) threat = 'HIGH';
        if (timeToKill > 200) threat = 'EXTREME';

        return {
            waveNumber: waveNum,
            enemies: enemiesList,
            totalCount,
            totalReward: Math.floor(totalReward),
            threatLevel: threat,
            threatScore: Math.floor(timeToKill)
        };
    }
}
</file>

<file path="src/ui/DevConsole.ts">
import { GameScene } from '../scenes/GameScene';
import { Logger, LogLevel, LogChannel, LogEntry } from '../utils/Logger';
import { SafeJson } from '../utils/SafeJson';

export class DevConsole {
    private scene: GameScene;
    private container!: HTMLElement;
    private contentLog!: HTMLElement;
    private contentState!: HTMLElement;
    private contentTools!: HTMLElement;
    private toggleBtn!: HTMLElement;

    // State
    private isVisible: boolean = false;
    private activeTab: 'log' | 'state' | 'tools' = 'log';
    private autoScroll: boolean = true;
    private stateUpdateInterval: any = null;

    // Filters
    private showInfo: boolean = true;
    private showWarn: boolean = true;
    private showError: boolean = true;
    private showVerbose: boolean = false;

    constructor(scene: GameScene) {
        this.scene = scene;
        this.createUI();
        this.setupLogger();

        Logger.info(LogChannel.SYSTEM, 'DevConsole initialized');
    }

    private setupLogger() {
        Logger.subscribe((entry) => {
            this.appendLog(entry);
            // Indication logic: if console is closed and error occurs, flash the button
            if (!this.isVisible && entry.level === LogLevel.ERROR) {
                this.flashButton();
            }
        });
    }

    private flashButton() {
        if (this.toggleBtn) {
            this.toggleBtn.style.background = '#ff0000';
            setTimeout(() => {
                if (!this.isVisible) this.toggleBtn.style.background = 'rgba(0,0,0,0.8)';
            }, 500);
        }
    }

    private createUI() {
        // --- Toggle Button ---
        this.toggleBtn = document.createElement('div');
        this.toggleBtn.innerText = 'üêû';
        this.toggleBtn.title = 'Dev Console (~)';
        Object.assign(this.toggleBtn.style, {
            position: 'absolute',
            top: '10px',
            right: '10px',
            width: '32px',
            height: '32px',
            background: 'rgba(0,0,0,0.8)',
            border: '1px solid #444',
            borderRadius: '50%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            cursor: 'pointer',
            zIndex: '20000',
            userSelect: 'none',
            fontSize: '16px'
        });
        this.toggleBtn.onclick = () => this.toggle();
        document.body.appendChild(this.toggleBtn);

        // --- Main Container ---
        this.container = document.createElement('div');
        Object.assign(this.container.style, {
            position: 'absolute',
            top: '50px',
            right: '10px',
            width: '400px',
            height: '500px',
            background: 'rgba(10, 10, 10, 0.95)',
            border: '1px solid #444',
            borderRadius: '4px',
            display: 'none',
            flexDirection: 'column',
            zIndex: '20000',
            fontFamily: 'Consolas, monospace',
            fontSize: '12px',
            color: '#ccc',
            boxShadow: '0 4px 12px rgba(0,0,0,0.5)'
        });
        document.body.appendChild(this.container);

        // --- Header (Tabs) ---
        const header = document.createElement('div');
        Object.assign(header.style, {
            display: 'flex',
            borderBottom: '1px solid #333',
            background: '#1a1a1a',
            padding: '0 5px'
        });

        ['log', 'state', 'tools'].forEach(tab => {
            const btn = document.createElement('button');
            btn.innerText = tab.toUpperCase();
            Object.assign(btn.style, {
                background: 'transparent',
                border: 'none',
                color: '#888',
                padding: '8px 12px',
                cursor: 'pointer',
                fontWeight: 'bold'
            });
            btn.onclick = () => this.switchTab(tab as any);
            header.appendChild(btn);
            // active style for 'log' handled in switchTab
        });

        // Close Btn
        const closeBtn = document.createElement('button');
        closeBtn.innerText = '‚úï';
        Object.assign(closeBtn.style, {
            marginLeft: 'auto',
            background: 'transparent',
            border: 'none',
            color: '#666',
            cursor: 'pointer',
            padding: '0 10px'
        });
        closeBtn.onclick = () => this.toggle();
        header.appendChild(closeBtn);

        this.container.appendChild(header);

        // --- Content Areas ---
        this.contentLog = document.createElement('div');
        Object.assign(this.contentLog.style, { flex: '1', overflowY: 'auto', padding: '5px', display: 'block' });

        // Log Filters
        const filters = document.createElement('div');
        Object.assign(filters.style, { padding: '5px', background: '#111', borderBottom: '1px solid #222', display: 'flex', gap: '8px' });
        filters.innerHTML = `
            <label><input type="checkbox" id="chk-info" checked> Info</label>
            <label><input type="checkbox" id="chk-warn" checked> Warn</label>
            <label><input type="checkbox" id="chk-err" checked> Err</label>
            <label><input type="checkbox" id="chk-verb"> Verbose</label>
            <button id="btn-clear" style="margin-left:auto; font-size:10px;">CLEAR</button>
        `;
        this.container.appendChild(filters); // Insert filters before log content
        this.container.appendChild(this.contentLog);

        this.contentState = document.createElement('div');
        Object.assign(this.contentState.style, { flex: '1', overflowY: 'auto', padding: '10px', display: 'none', whiteSpace: 'pre-wrap', color: '#8f8' });
        this.container.appendChild(this.contentState);

        this.contentTools = document.createElement('div');
        Object.assign(this.contentTools.style, { flex: '1', overflowY: 'auto', padding: '10px', display: 'none' });
        this.createToolsContent();
        this.container.appendChild(this.contentTools);

        // Filter Logic
        this.container.querySelector('#chk-info')!.addEventListener('change', (e: any) => { this.showInfo = e.target.checked; this.refreshLogs(); });
        this.container.querySelector('#chk-warn')!.addEventListener('change', (e: any) => { this.showWarn = e.target.checked; this.refreshLogs(); });
        this.container.querySelector('#chk-err')!.addEventListener('change', (e: any) => { this.showError = e.target.checked; this.refreshLogs(); });
        this.container.querySelector('#chk-verb')!.addEventListener('change', (e: any) => { this.showVerbose = e.target.checked; this.refreshLogs(); });
        this.container.querySelector('#btn-clear')!.addEventListener('click', () => {
            this.contentLog.innerHTML = '';
            // Note: we don't clear Logger history, just view. Or we could implemented clear in Logger.
        });

        // Global Key
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Backquote') {
                e.preventDefault();
                this.toggle();
            }
        });
    }

    private createToolsContent() {
        // Buttons for common debugging tasks
        const addBtn = (label: string, action: () => void) => {
            const btn = document.createElement('button');
            btn.innerText = label;
            Object.assign(btn.style, {
                display: 'block',
                width: '100%',
                padding: '8px',
                marginBottom: '5px',
                background: '#333',
                color: '#fff',
                border: '1px solid #555',
                cursor: 'pointer'
            });
            btn.onclick = action;
            this.contentTools.appendChild(btn);
        };

        addBtn('üí∞ +1000 Gold', () => { this.scene.addMoney(1000); Logger.info(LogChannel.GAME, 'Added 1000 gold'); });
        addBtn('‚è© Skip Wave', () => {
            this.scene.wave++;
            Logger.info(LogChannel.GAME, `Skipped to wave ${this.scene.wave}`);
        });
        addBtn('üíÄ Kill All', () => {
            this.scene.enemies.forEach(e => e.takeDamage(999999));
            Logger.info(LogChannel.GAME, 'Killed all enemies');
        });
        addBtn('üóë Garbage Collect (Sim)', () => {
            // Can't force GC in JS, but we can clear some internal pools if we had them or reload textures
            Logger.warn(LogChannel.SYSTEM, 'GC Simulation - clearing loose refs not implemented');
        });
        addBtn('üìã Copy Full Report', () => {
            // This will link to CrashHandler later, for now simple dump
            const dump = SafeJson.stringify({ scene: this.scene }, 2);
            navigator.clipboard.writeText(dump);
            Logger.info(LogChannel.SYSTEM, 'State copied to clipboard');
        });
    }

    public toggle() {
        this.isVisible = !this.isVisible;
        this.container.style.display = this.isVisible ? 'flex' : 'none';

        if (this.isVisible) {
            this.startStateUpdater();
            this.refreshLogs(); // Refresh just in case filters changed
            // Reset flash
            this.toggleBtn.style.background = 'rgba(0,0,0,0.8)';
        } else {
            this.stopStateUpdater();
        }
    }

    private switchTab(tab: 'log' | 'state' | 'tools') {
        this.activeTab = tab;
        this.contentLog.style.display = tab === 'log' ? 'block' : 'none';
        this.contentState.style.display = tab === 'state' ? 'block' : 'none';
        this.contentTools.style.display = tab === 'tools' ? 'block' : 'none';
    }

    private startStateUpdater() {
        if (this.stateUpdateInterval) clearInterval(this.stateUpdateInterval);
        this.stateUpdateInterval = setInterval(() => this.updateStateView(), 500);
        this.updateStateView();
    }

    private stopStateUpdater() {
        if (this.stateUpdateInterval) clearInterval(this.stateUpdateInterval);
        this.stateUpdateInterval = null;
    }

    private updateStateView() {
        if (this.activeTab !== 'state' || !this.isVisible) return;

        const state = {
            game: {
                fps: this.scene.gameState?.frames || 0,
                // time: this.scene.gameState?.time || 0, // Removed invalid property
                money: this.scene.money,
                wave: this.scene.wave,
                lives: 100 // Example, should get real lives
            },
            entities: {
                enemies: this.scene.enemies.length,
                towers: this.scene.towers.length,
                projectiles: this.scene.projectiles?.length || 0
            },
            input: {
                mouse: { x: this.scene.input?.mouseX || 0, y: this.scene.input?.mouseY || 0 }
            }
        };

        this.contentState.innerText = SafeJson.stringify(state, 2, true);
    }

    private refreshLogs() {
        this.contentLog.innerHTML = '';
        Logger.getHistory().forEach(entry => this.appendLog(entry));
    }

    private appendLog(entry: LogEntry) {
        if (!this.isVisible) return; // Lazy rendering

        // Check filters
        if (entry.level === LogLevel.INFO && !this.showInfo) return;
        if (entry.level === LogLevel.WARN && !this.showWarn) return;
        if (entry.level === LogLevel.ERROR && !this.showError) return;
        if (entry.level === LogLevel.VERBOSE && !this.showVerbose) return;

        const row = document.createElement('div');
        const time = new Date(entry.timestamp).toISOString().split('T')[1].slice(0, -5);

        let color = '#ccc';
        if (entry.level === LogLevel.WARN) color = '#fc0';
        if (entry.level === LogLevel.ERROR) color = '#f44';
        if (entry.level === LogLevel.VERBOSE) color = '#666';

        row.style.color = color;
        row.style.fontFamily = 'monospace';
        row.style.fontSize = '11px';
        row.style.padding = '2px 0';
        row.style.borderBottom = '1px solid #222';

        const countStr = entry.count > 1 ? ` <span style="background:#555; color:#fff; padding:0 4px; border-radius:4px;">x${entry.count}</span>` : '';

        row.innerHTML = `<span style="color:#666">[${time}]</span> <span style="color:#888">[${entry.channel}]</span> ${entry.message}${countStr}`;

        if (entry.data) {
            const sub = document.createElement('div');
            sub.style.paddingLeft = '20px';
            sub.style.fontSize = '10px';
            sub.style.color = '#888';
            // Simple preview
            try {
                sub.innerText = typeof entry.data === 'object' ? JSON.stringify(entry.data) : String(entry.data);
            } catch (e) { sub.innerText = '[Unserializable Data]'; }
            row.appendChild(sub);
        }

        this.contentLog.appendChild(row);
        if (this.autoScroll) this.contentLog.scrollTop = this.contentLog.scrollHeight;
    }
}
</file>

<file path="src/ui/GameOverUI.ts">
import { IGameScene } from '../scenes/IGameScene';

export class GameOverUI {
    private scene: IGameScene;
    private elGameOver: HTMLElement;
    private elFinalWave: HTMLElement;
    private elRestartBtn: HTMLButtonElement;

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.elGameOver = document.getElementById('game-over')!;
        this.elFinalWave = document.getElementById('final-wave')!;
        this.elRestartBtn = document.getElementById('restart-btn') as HTMLButtonElement;

        this.initListeners();
    }

    private initListeners() {
        this.elRestartBtn.addEventListener('click', () => {
            this.scene.restart();
            this.hide();
        });
    }

    public show(wave: number) {
        this.elFinalWave.innerText = wave.toString();
        this.elGameOver.style.display = 'flex';
    }

    public hide() {
        this.elGameOver.style.display = 'none';
    }
}
</file>

<file path="src/utils/Logger.ts">
export enum LogLevel {
    VERBOSE = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3,
    NONE = 99
}

export enum LogChannel {
    SYSTEM = 'SYS',
    GAME = 'GAME',
    RENDER = 'RNDR',
    AUDIO = 'AUDIO',
    INPUT = 'INPT',
    NETWORK = 'NET'
}

export interface LogEntry {
    timestamp: number;
    level: LogLevel;
    channel: LogChannel;
    message: string;
    data?: any;
    count: number; // For collapsed logs
}

export class Logger {
    private static instance: Logger;

    // Configuration
    public minLevel: LogLevel = LogLevel.INFO;
    public maxHistory: number = 200; // Keep last 200 logs

    // State
    private history: LogEntry[] = [];
    private listeners: ((entry: LogEntry) => void)[] = [];

    // Throttling / De-duplication
    private lastLogSignature: string = '';
    private lastLogEntry: LogEntry | null = null;
    private lastLogTime: number = 0;
    private throttleTimeMs: number = 1000; // Reset "count" logic if spam stops for 1 second

    private constructor() {
        console.log('%c Logger Initialized ', 'background: #222; color: #bada55');
    }

    public static getInstance(): Logger {
        if (!Logger.instance) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }

    // --- Public API ---

    public static verbose(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.VERBOSE, channel, msg, data);
    }

    public static info(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.INFO, channel, msg, data);
    }

    public static warn(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.WARN, channel, msg, data);
    }

    public static error(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.ERROR, channel, msg, data);
    }

    public static getHistory(): LogEntry[] {
        return Logger.getInstance().history;
    }

    public static subscribe(callback: (entry: LogEntry) => void) {
        Logger.getInstance().listeners.push(callback);
    }

    public static unsubscribe(callback: (entry: LogEntry) => void) {
        const i = Logger.getInstance().listeners.indexOf(callback);
        if (i > -1) Logger.getInstance().listeners.splice(i, 1);
    }

    // --- Internal Logic ---

    private log(level: LogLevel, channel: LogChannel, msg: string, data?: any) {
        if (level < this.minLevel) return;

        const now = Date.now();
        const signature = `${level}:${channel}:${msg}`;

        // Check for spam/throttling (same message repeated)
        if (this.lastLogEntry && this.lastLogSignature === signature && (now - this.lastLogTime < this.throttleTimeMs)) {
            this.lastLogEntry.count++;
            this.lastLogEntry.timestamp = now; // Update time to latest occurrence
            this.lastLogTime = now;
            // Notify listeners about update (optional, usually listeners just append, so this might be tricky for UI 
            // - UI should re-render or handle updates. For now we rely on UI refreshing or ignoring updates to existing objects)
            return;
        }

        const entry: LogEntry = {
            timestamp: now,
            level,
            channel,
            message: msg,
            data,
            count: 1
        };

        // Add to history
        this.history.push(entry);
        if (this.history.length > this.maxHistory) {
            this.history.shift(); // Remove oldest
        }

        // Update state
        this.lastLogEntry = entry;
        this.lastLogSignature = signature;
        this.lastLogTime = now;

        // Output to Browser Console (Dual Output)
        this.printToConsole(entry);

        // Notify subscribers (The In-Game Console)
        this.listeners.forEach(l => l(entry));
    }

    private printToConsole(entry: LogEntry) {
        const time = new Date(entry.timestamp).toISOString().split('T')[1].slice(0, -1); // HH:MM:SS.ms
        const css = this.getLevelCSS(entry.level);
        const prefix = `%c[${time}] [${entry.channel}]`;

        // Use native console methods for proper stack tracing and object inspection in F12
        switch (entry.level) {
            case LogLevel.ERROR:
                console.error(prefix, css, entry.message, entry.data || '');
                break;
            case LogLevel.WARN:
                console.warn(prefix, css, entry.message, entry.data || '');
                break;
            case LogLevel.INFO:
                console.log(prefix, css, entry.message, entry.data || '');
                break;
            case LogLevel.VERBOSE:
                console.debug(prefix, css, entry.message, entry.data || '');
                break;
        }
    }

    private getLevelCSS(level: LogLevel): string {
        switch (level) {
            case LogLevel.ERROR: return 'color: #ff4444; font-weight: bold;';
            case LogLevel.WARN: return 'color: #ffbb33; font-weight: bold;';
            case LogLevel.INFO: return 'color: #33b5e5; font-weight: bold;';
            case LogLevel.VERBOSE: return 'color: #999;';
            default: return 'color: #fff;';
        }
    }
}
</file>

<file path="src/utils/SafeJson.ts">
export class SafeJson {
    /**
     * Safely serializes an object to JSON, handling circular references and limiting depth.
     * @param data The object to serialize
     * @param maxDepth Maximum recursion depth (default 3)
     * @param pretty Whether to separate lines (default false)
     */
    public static stringify(data: any, maxDepth: number = 3, pretty: boolean = false): string {
        const seen = new WeakSet();

        const replacer = (key: string, value: any) => {
            // Handle primitives
            if (value === null || typeof value !== 'object') {
                return value;
            }

            // Handle circular references
            if (seen.has(value)) {
                return '[Circular]';
            }
            seen.add(value);

            // Handle DOM elements (too heavy to serialize)
            if (value instanceof HTMLElement) {
                return `[HTMLElement: ${value.tagName}]`;
            }

            // Handle depth manually if needed, but WeakSet handles recursion loops.
            // For true depth limiting, we'd need a recursive custom serializer, 
            // but JSON.stringify compliant replacer is harder to limit by depth directly.
            // So we rely on a custom recursive function instead of standard JSON.stringify if we want strict depth.

            return value;
        };

        // For strict depth control and safety, we implement a custom walker instead of just JSON.stringify
        const sanitized = SafeJson.sanitize(data, maxDepth, new WeakSet());
        return JSON.stringify(sanitized, null, pretty ? 2 : 0);
    }

    private static sanitize(obj: any, depth: number, visited: WeakSet<any>): any {
        // Base cases
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }

        // Check loops
        if (visited.has(obj)) {
            return '[Circular]';
        }

        // Check depth
        if (depth < 0) {
            return '[MaxDepth]';
        }

        // Special types
        if (obj instanceof HTMLElement) return `[HTMLElement: ${obj.tagName}]`;
        if (obj instanceof Function) return `[Function: ${obj.name || 'anonymous'}]`;
        if (obj instanceof Error) return { message: obj.message, stack: obj.stack };

        // Add to visited
        visited.add(obj);

        // Arrays
        if (Array.isArray(obj)) {
            return obj.map(item => SafeJson.sanitize(item, depth - 1, visited));
        }

        // Objects
        const res: any = {};
        for (const key in obj) {
            // Skip large numeric keys usually found in huge lookup tables or large arrays treated as objects
            // Also skip private keys like _private
            if (key.startsWith('_')) continue;

            try {
                res[key] = SafeJson.sanitize(obj[key], depth - 1, visited);
            } catch (e) {
                res[key] = '[Error accessing property]';
            }
        }
        return res;
    }
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="src/BaseScene.ts">
import { Scene } from './Scene';

export class BaseScene implements Scene {
    protected listeners: Array<{ target: EventTarget; type: string; handler: EventListener }> = [];

    public onEnter(): void { }

    public onExit(): void {
        this.dispose();
    }

    public update(dt: number): void { }

    public draw(_ctx: CanvasRenderingContext2D): void { }

    public on(target: EventTarget, type: string, handler: EventListener) {
        target.addEventListener(type, handler);
        this.listeners.push({ target, type, handler });
    }

    public dispose() {
        this.listeners.forEach((l) => l.target.removeEventListener(l.type, l.handler));
        this.listeners = [];
    }
}
</file>

<file path="src/Card.ts">
export enum CardType {
    TOWER = 'tower',
    SPELL = 'spell',
}

export interface ICardConfig {
    id: string;
    name: string;
    description: string;
    cost: number;
    type: CardType;
    value: number;
}

export class Card {
    public id: string;
    public name: string;
    public cost: number;
    public level: number = 1;
    private config: ICardConfig;

    constructor(config: ICardConfig) {
        this.id = config.id;
        this.name = config.name;
        this.cost = config.cost;
        this.config = config;
    }

    public upgrade(): void {
        this.level += 1;
        this.cost = Math.floor(this.cost * 1.5);
    }
}
</file>

<file path="src/cards/index.ts">
/**
 * Card System Module
 * Central export point for all card upgrade definitions
 */

import { IUpgradeCard, ICardModifiers, ICardEffect, mergeModifiers, mergeEffects } from './CardType';
import { FIRE_UPGRADES } from './FireCard';
import { ICE_UPGRADES } from './IceCard';
import { SNIPER_UPGRADES } from './SniperCard';
import { MULTISHOT_UPGRADES, getMultishotConfig } from './MultishotCard';
import { MINIGUN_UPGRADES } from './MinigunCard';

// Export types
export type { IUpgradeCard, ICardModifiers, ICardEffect };
export { mergeModifiers, mergeEffects };

// Export card upgrade data
export { FIRE_UPGRADES, ICE_UPGRADES, SNIPER_UPGRADES, MULTISHOT_UPGRADES, MINIGUN_UPGRADES, getMultishotConfig };

/**
 * Card upgrade registry
 */
const CARD_REGISTRY: Record<string, Record<number, IUpgradeCard>> = {
    'fire': FIRE_UPGRADES,
    'ice': ICE_UPGRADES,
    'sniper': SNIPER_UPGRADES,
    'multi': MULTISHOT_UPGRADES,
    'minigun': MINIGUN_UPGRADES,
};

/**
 * Get upgrade data for a specific card type and level
 * @param cardTypeId - The card type ID (e.g., 'fire', 'ice', 'sniper', 'multi')
 * @param level - The card level (1-3)
 * @returns The upgrade data or null if not found
 */
export function getCardUpgrade(cardTypeId: string, level: number): IUpgradeCard | null {
    const cardUpgrades = CARD_REGISTRY[cardTypeId];
    if (!cardUpgrades) {
        console.warn(`Unknown card type: ${cardTypeId}`);
        return null;
    }

    const upgrade = cardUpgrades[level];
    if (!upgrade) {
        console.warn(`Unknown level ${level} for card type ${cardTypeId}`);
        return null;
    }

    return upgrade;
}
</file>

<file path="src/CardSelectionUI.ts">
import { CONFIG } from './Config';

/**
 * Card Selection System
 * Shows overlay where player select s 3 starting cards
 */
export class CardSelectionUI {
    private overlay: HTMLElement;
    private grid: HTMLElement;
    private counter: HTMLElement;
    private startButton: HTMLButtonElement;
    private selectedCards: string[] = [];
    private onComplete: (cards: string[]) => void;

    constructor(onComplete: (cards: string[]) => void) {
        this.onComplete = onComplete;
        console.log('CardSelectionUI: Constructor called');

        // Don't check elements here - they might not exist yet
        // Elements will be checked in show() method
    }

    public show() {
        console.log('CardSelectionUI.show() called');

        // FIXED: Check elements HERE, not in constructor
        this.overlay = document.getElementById('card-selection-overlay')!;
        this.grid = document.getElementById('card-selection-grid')!;
        this.counter = document.getElementById('selected-count')!;
        this.startButton = document.getElementById('start-game-btn') as HTMLButtonElement;

        if (!this.overlay || !this.grid || !this.counter || !this.startButton) {
            console.error('CardSelectionUI: Required DOM elements not found!');
            console.error('overlay:', this.overlay);
            console.error('grid:', this.grid);
            console.error('counter:', this.counter);
            console.error('startButton:', this.startButton);
            alert('ERROR: Card selection UI elements not found. Check console.');
            return;
        }

        // Add click listener (only once)
        if (!this.startButton.onclick) {
            this.startButton.addEventListener('click', () => this.complete());
        }

        console.log('CardSelectionUI: All elements found successfully');

        this.selectedCards = [];
        this.overlay.classList.add('show');
        this.render();
    }

    public hide() {
        this.overlay.classList.remove('show');
    }

    private render() {
        console.log('CardSelectionUI.render() called');
        this.grid.innerHTML = '';

        // Get all base card types
        const baseCards = Object.keys(CONFIG.CARD_TYPES);
        console.log('Base cards available:', baseCards);

        // Add 2 random cards
        const randomCards = [
            baseCards[Math.floor(Math.random() * baseCards.length)],
            baseCards[Math.floor(Math.random() * baseCards.length)],
        ];

        const availableCards = [...baseCards, ...randomCards];
        console.log('Total cards to display:', availableCards);

        // Render cards
        availableCards.forEach((cardKey, index) => {
            const config = CONFIG.CARD_TYPES[cardKey];
            if (!config) {
                console.warn(`Card config not found for key: ${cardKey}`);
                return;
            }

            const cardEl = document.createElement('div');
            // Use same structure as CardSystem
            cardEl.className = `card type-${config.id} level-1`;
            cardEl.style.animationDelay = `${index * 0.05}s`;
            cardEl.style.cursor = 'pointer';

            // Get stats HTML for level 1
            const statsHTML = this.getCardStatsHTML(config.id);

            cardEl.innerHTML = `
                <div class="card-level">‚òÖ</div>
                <div class="card-icon">${config.icon}</div>
                <div class="card-stats">${statsHTML}</div>
            `;

            cardEl.addEventListener('click', () => this.selectCard(cardKey, cardEl));
            this.grid.appendChild(cardEl);
        });

        console.log(`Rendered ${availableCards.length} cards`);

        // Update counter and button
        this.updateUI();
    }

    private selectCard(cardKey: string, cardEl: HTMLElement) {
        if (cardEl.classList.contains('selected')) {
            // Deselect
            cardEl.classList.remove('selected');
            const index = this.selectedCards.indexOf(cardKey);
            if (index !== -1) {
                this.selectedCards.splice(index, 1);
            }
        } else {
            // Select (if not full)
            if (this.selectedCards.length < 5) {
                cardEl.classList.add('selected');
                this.selectedCards.push(cardKey);
            }
        }

        this.updateUI();
    }

    private updateUI() {
        this.counter.textContent = this.selectedCards.length.toString();
        this.startButton.disabled = this.selectedCards.length !== 5;
    }

    private complete() {
        if (this.selectedCards.length === 5) {
            this.hide();
            this.onComplete(this.selectedCards);
        }
    }

    private getCardStatsHTML(typeId: string): string {
        // Same logic as CardSyst em, but always level 1
        switch (typeId) {
            case 'fire':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +15</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 50</div>`;
            case 'ice':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +3</div><div class="card-stat-line">‚ùÑÔ∏è 30%</div>`;
            case 'sniper':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +14</div><div class="card-stat-line">üéØ +80</div>`;
            case 'multi':
                return `<div class="card-stat-primary">2 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.8x —É—Ä–æ–Ω</div>`;
            case 'minigun':
                return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+3 —É—Ä–æ–Ω/—Å</div>`;
            default:
                return `<div class="card-stat-line">–ö–∞—Ä—Ç–∞</div>`;
        }
    }
}
</file>

<file path="src/DayNightCycle.ts">
/**
 * Day/Night cycle system - simple and configurable
 */
export interface IDayNightConfig {
    cycleDuration: number; // seconds for full cycle
    startTime: number; // 0-1, where to start (0=dawn, 0.5=dusk, 1=midnight)
}

export class DayNightCycle {
    private time: number = 0; // 0-1
    private config: IDayNightConfig;

    constructor(config?: Partial<IDayNightConfig>) {
        this.config = {
            cycleDuration: 240, // 4 minutes default (was reduced from original by 30%)
            startTime: 0.15, // Start closer to dawn for brighter initial lighting
            ...config
        };

        this.time = this.config.startTime;
    }

    /**
     * Update the cycle
     * @param deltaTime - time in seconds since last update
     */
    public update(deltaTime: number): void {
        const increment = deltaTime / this.config.cycleDuration;
        this.time = (this.time + increment) % 1;
    }

    /**
     * Get current time of day
     * @returns 0-1 value (0=dawn, 0.25=noon, 0.5=dusk, 0.75=midnight, 1=dawn again)
     */
    public getTimeOfDay(): number {
        return this.time;
    }

    /**
     * Check if it's currently day time
     */
    public isDay(): boolean {
        return this.time < 0.5;
    }

    /**
     * Check if it's currently night time
     */
    public isNight(): boolean {
        return this.time >= 0.5;
    }

    /**
     * Set time manually (for testing/debugging)
     */
    public setTime(time: number): void {
        this.time = Math.max(0, Math.min(1, time));
    }

    /**
     * Get human-readable time string
     */
    public getTimeString(): string {
        if (this.time < 0.25) return 'Morning';
        if (this.time < 0.5) return 'Afternoon';
        if (this.time < 0.75) return 'Evening';
        return 'Night';
    }

    /**
     * Update configuration at runtime
     */
    public updateConfig(newConfig: Partial<IDayNightConfig>): void {
        this.config = { ...this.config, ...newConfig };
    }
}
</file>

<file path="src/editor/components/EnemyGroupRow.ts">
import { BaseComponent } from './BaseComponent';
import { SpawnPattern } from '../../MapData';
import { EnemyRegistry } from '../EnemyRegistry';
import { ThreatService } from '../ThreatService';
import { IEnemyTypeConfig } from '../../types';

interface EnemyGroupProps {
    type: string;
    count: number;
    spawnPattern: SpawnPattern;
    onChange: (updates: { type?: string; count?: number; spawnPattern?: SpawnPattern }) => void;
    onRemove: () => void;
}

export class EnemyGroupRow extends BaseComponent<EnemyGroupProps> {

    protected createRootElement(): HTMLElement {
        return this.createElement('div', 'we-enemy-row');
    }

    public render(): void {
        this.element.innerHTML = '';

        // 1. Enemy Type Selector
        const typeSelect = document.createElement('select');
        typeSelect.title = 'Enemy Type';
        typeSelect.style.maxWidth = '150px';

        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥ getVisibleForEditor()
        const types: IEnemyTypeConfig[] = EnemyRegistry.getVisibleForEditor();

        types.forEach((config: IEnemyTypeConfig) => {
            const opt = document.createElement('option');
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º ID –∫–∞–∫ value (–Ω–∞–ø—Ä–∏–º–µ—Ä 'grunt', 'boss')
            opt.value = config.id;
            opt.textContent = `${config.symbol} ${config.name}`;

            // BACKWARDS COMPATIBILITY: –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ ID (lowercase) –∏ KEY (UPPERCASE)
            // –°—Ç–∞—Ä—ã–µ –∫–∞—Ä—Ç—ã –∏—Å–ø–æ–ª—å–∑—É—é—Ç 'GRUNT', 'BOSS', –Ω–æ–≤—ã–µ - 'grunt', 'boss'
            const currentType = this.data.type;
            const isMatch = config.id === currentType ||
                config.id === currentType.toLowerCase() ||
                config.id.toUpperCase() === currentType;

            if (isMatch) {
                opt.selected = true;
                // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –∫ lowercase ID –ø—Ä–∏ –ø–µ—Ä–≤–æ–º —Ä–µ–Ω–¥–µ—Ä–µ
                if (currentType !== config.id) {
                    this.data.onChange({ type: config.id });
                }
            }

            typeSelect.appendChild(opt);
        });

        typeSelect.onchange = (e) => {
            this.data.onChange({ type: (e.target as HTMLSelectElement).value });
        };
        this.element.appendChild(typeSelect);

        // 2. Multiplier Label
        const xLabel = document.createElement('span');
        xLabel.textContent = 'x';
        xLabel.style.color = '#888';
        this.element.appendChild(xLabel);

        // 3. Count Input
        const countInput = document.createElement('input');
        countInput.type = 'number';
        countInput.min = '1';
        countInput.max = '100';
        countInput.value = this.data.count.toString();
        countInput.style.width = '40px';

        countInput.onchange = (e) => {
            const val = parseInt((e.target as HTMLInputElement).value) || 1;
            this.data.onChange({ count: val });
        };
        this.element.appendChild(countInput);

        // 4. Pattern Selector
        const patternSelect = document.createElement('select');
        patternSelect.title = 'Spawn Pattern';
        // FIXED: Removed restrictive width, added minWidth and pointer
        patternSelect.style.minWidth = '50px';
        patternSelect.style.cursor = 'pointer';

        const patterns: Array<{ value: SpawnPattern; label: string }> = [
            { value: 'normal', label: '‚è±Ô∏è Norm' },
            { value: 'random', label: 'üé≤ Rand' },
            { value: 'swarm', label: 'üêù Swrm' }
        ];

        patterns.forEach(p => {
            const opt = document.createElement('option');
            opt.value = p.value;
            opt.textContent = p.label;
            opt.title = p.value; // Tooltip
            if (p.value === (this.data.spawnPattern || 'normal')) opt.selected = true;
            patternSelect.appendChild(opt);
        });

        patternSelect.onchange = (e) => {
            this.data.onChange({ spawnPattern: (e.target as HTMLSelectElement).value as SpawnPattern });
        };
        this.element.appendChild(patternSelect);

        // 5. Threat Indicator (Mini)
        // Recalculate threat based on possibly updated type (if we had a mismatch)
        // Actually threat service should handle ID lookup safely too, but let's just pass data.
        const threat = ThreatService.calculateGroupThreat({
            type: this.data.type,
            count: this.data.count,
            spawnPattern: this.data.spawnPattern
        });

        const threatDot = document.createElement('div');
        threatDot.style.width = '10px';
        threatDot.style.height = '10px';
        threatDot.style.borderRadius = '50%';
        threatDot.style.marginLeft = '4px';
        threatDot.style.flexShrink = '0';
        threatDot.style.background = ThreatService.getThreatColor(threat);
        threatDot.title = `Threat: ${Math.round(threat)}`;
        this.element.appendChild(threatDot);

        // 6. Delete Button
        const delBtn = this.createElement('button', 'we-btn we-btn-icon', '‚úï');
        delBtn.style.marginLeft = 'auto'; // Push to right
        delBtn.onclick = () => this.data.onRemove();
        this.element.appendChild(delBtn);
    }
}
</file>

<file path="src/effects/DeathAnimations.ts">
/**
 * Death Animation System
 * 
 * –ú–æ–¥—É–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∞–Ω–∏–º–∞—Ü–∏–π —Å–º–µ—Ä—Ç–∏ –≤—Ä–∞–≥–æ–≤ –ø–æ –∞—Ä—Ö–µ—Ç–∏–ø–∞–º.
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π EffectSystem –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞.
 * 
 * –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –≥–æ—Ç–æ–≤–∞ –∫ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—é:
 * - –ê–Ω–∏–º–∞—Ç–æ—Ä—ã –º–æ–∂–Ω–æ –≤—ã–Ω–æ—Å–∏—Ç—å –≤ /animators/*.ts
 * - –•–µ–ª–ø–µ—Ä—ã –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –º–µ–∂–¥—É –∞–Ω–∏–º–∞—Ç–æ—Ä–∞–º–∏
 */

import { EffectSystem } from '../EffectSystem';
import { Enemy } from '../Enemy';
import { IEnemyTypeConfig } from '../types';
import { IDeathAnimator } from './types';

// ============================================
// –†–ï–ï–°–¢–† –ê–ù–ò–ú–ê–¢–û–†–û–í
// ============================================

const ANIMATORS: Record<string, IDeathAnimator> = {
    SKELETON: playBoneScatter,
    SKELETON_COMMANDER: playGoldBones,
    HELLHOUND: playFireBurst,
    ORC: playHeavyDebris,
    WRAITH: playGhostDissolve,
    GOBLIN: playSmallDebris,
    SPIDER: playAcidPop,
    TROLL: playIceShatter,
    MAGMA: playLavaPop,
    RAT: playToxicExplosion,
    WOLF: playDefaultDeath,
};

// ============================================
// –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø
// ============================================

/**
 * –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∞–Ω–∏–º–∞—Ü–∏—é —Å–º–µ—Ä—Ç–∏ –≤—Ä–∞–≥–∞.
 * –í—ã–±–∏—Ä–∞–µ—Ç –∞–Ω–∏–º–∞—Ç–æ—Ä –ø–æ –∞—Ä—Ö–µ—Ç–∏–ø—É –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞.
 */
export function playDeathAnimation(
    effects: EffectSystem,
    enemy: Enemy,
    config: IEnemyTypeConfig | undefined
): void {
    const archetype = config?.archetype || 'SKELETON';
    const animator = ANIMATORS[archetype] || playDefaultDeath;

    // –°–æ–∑–¥–∞—ë–º fallback –∫–æ–Ω—Ñ–∏–≥ –µ—Å–ª–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω
    const safeConfig: IEnemyTypeConfig = config || {
        id: enemy.typeId,
        name: 'Unknown',
        symbol: '?',
        hpMod: 1,
        speed: 60,
        reward: 5,
        color: '#888888',
        desc: '',
    };

    animator(effects, enemy.x, enemy.y, safeConfig);
}

// ============================================
// –ê–ù–ò–ú–ê–¢–û–†–´ (–≥–æ—Ç–æ–≤—ã –∫ –≤—ã–Ω–æ—Å—É –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã)
// ============================================

/** –ë–∞–∑–æ–≤–∞—è –∞–Ω–∏–º–∞—Ü–∏—è ‚Äî –æ–±–ª–æ–º–∫–∏ –ø–æ —Ü–≤–µ—Ç—É –≤—Ä–∞–≥–∞ */
function playDefaultDeath(e: EffectSystem, x: number, y: number, c: IEnemyTypeConfig) {
    addDebris(e, x, y, 5, c.color || '#888', 200, 120);
}

/** –°–∫–µ–ª–µ—Ç ‚Äî –±–µ–ª—ã–µ –∫–æ—Å—Ç–∏ + –ø—ã–ª—å */
function playBoneScatter(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 6, '#e0d0b0', 280, 180); // –ö–æ—Å—Ç–∏
    addDust(e, x, y, 3, 'rgba(180,160,140,0.5)');
}

/** –ö–æ–º–∞–Ω–¥–∏—Ä —Å–∫–µ–ª–µ—Ç–æ–≤ ‚Äî –∑–æ–ª–æ—Ç—ã–µ –∫–æ—Å—Ç–∏ + —Å–∏—è–Ω–∏–µ */
function playGoldBones(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 5, '#ffd700', 260, 160);
    addDust(e, x, y, 2, 'rgba(255,215,0,0.3)');
}

/** –ê–¥—Å–∫–∞—è –≥–æ–Ω—á–∞—è ‚Äî –æ–≥–æ–Ω—å + —É–≥–ª–∏ */
function playFireBurst(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 5, '#ff6d00', 200, 120);
    addEmbers(e, x, y, 5, '#ffab00');
}

/** –û—Ä–∫ ‚Äî —Ç—è–∂—ë–ª—ã–µ –∫—Ä—É–ø–Ω—ã–µ –æ–±–ª–æ–º–∫–∏ */
function playHeavyDebris(e: EffectSystem, x: number, y: number, c: IEnemyTypeConfig) {
    addDebris(e, x, y, 5, c.color || '#558b2f', 160, 80, 4);
}

/** –ü—Ä–∏–∑—Ä–∞–∫ ‚Äî –¥—É—à–∏ —É–ª–µ—Ç–∞—é—Ç –≤–≤–µ—Ä—Ö */
function playGhostDissolve(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addSoulOrbs(e, x, y, 6, '#7c4dff');
}

/** –ì–æ–±–ª–∏–Ω ‚Äî –º–µ–ª–∫–∏–µ –æ–±–ª–æ–º–∫–∏ */
function playSmallDebris(e: EffectSystem, x: number, y: number, c: IEnemyTypeConfig) {
    addDebris(e, x, y, 4, c.color || '#689f38', 150, 100, 2);
}

/** –ü–∞—É–∫ ‚Äî –∫–∏—Å–ª–æ—Ç–Ω—ã–µ –±—Ä—ã–∑–≥–∏ */
function playAcidPop(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 3, '#76ff03', 120, 60, 2);
    addDust(e, x, y, 2, 'rgba(118,255,3,0.3)');
}

/** –¢—Ä–æ–ª–ª—å ‚Äî –ª–µ–¥—è–Ω—ã–µ –æ—Å–∫–æ–ª–∫–∏ */
function playIceShatter(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 5, '#90caf9', 220, 140);
}

/** –ú–∞–≥–º–∞ ‚Äî –ª–∞–≤–∞ + –¥—ã–º –æ—Å—Ç—ã–≤–∞–Ω–∏—è */
function playLavaPop(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 4, '#ff3d00', 180, 100);
    addDust(e, x, y, 2, 'rgba(50,50,50,0.5)');
}

/** –ö—Ä—ã—Å–∞-—Å–∞–ø—ë—Ä ‚Äî —Ç–æ–∫—Å–∏—á–Ω—ã–π –≤–∑—Ä—ã–≤ (—Ä–∞–¥–∏–∞–ª—å–Ω—ã–µ –∏—Å–∫—Ä—ã) */
function playToxicExplosion(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    // –†–∞–¥–∏–∞–ª—å–Ω—ã–µ –∑–µ–ª—ë–Ω—ã–µ –∏—Å–∫—Ä—ã
    const sparkCount = 6;
    for (let i = 0; i < sparkCount; i++) {
        const angle = (i / sparkCount) * Math.PI * 2;
        const speed = 120 + Math.random() * 60;
        e.add({
            type: 'particle',
            x,
            y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 30,
            life: 0.5 + Math.random() * 0.2,
            radius: 4 + Math.random() * 2,
            color: '#76ff03',
        });
    }
    // –¢–æ–∫—Å–∏—á–Ω—ã–π –¥—ã–º
    addDust(e, x, y, 3, 'rgba(118,255,3,0.4)');
    // –û–±–ª–æ–º–∫–∏ –±–æ—á–∫–∏
    addDebris(e, x, y, 3, '#4e342e', 140, 80, 3);
}

// ============================================
// –•–ï–õ–ü–ï–†–´
// ============================================

/**
 * –î–æ–±–∞–≤–∏—Ç—å —Ä–∞–∑–ª–µ—Ç–∞—é—â–∏–µ—Å—è –æ–±–ª–æ–º–∫–∏
 */
function addDebris(
    e: EffectSystem,
    x: number,
    y: number,
    count: number,
    color: string,
    vxRange: number,
    vyBase: number,
    size = 4
) {
    for (let i = 0; i < count; i++) {
        e.add({
            type: 'debris',
            x,
            y,
            vx: (Math.random() - 0.5) * vxRange * 1.5,
            vy: -(Math.random() * vyBase + vyBase * 0.8),
            life: 0.5 + Math.random() * 0.2,
            size: size + Math.random() * 3,
            color,
            rotation: Math.random() * Math.PI * 2,
            vRot: (Math.random() - 0.5) * 15,
            gravity: 500,
        });
    }
}

/**
 * –î–æ–±–∞–≤–∏—Ç—å –ø—ã–ª—å/–¥—ã–º (–º—è–≥–∫–∏–µ —á–∞—Å—Ç–∏—Ü—ã)
 */
function addDust(
    e: EffectSystem,
    x: number,
    y: number,
    count: number,
    color: string
) {
    for (let i = 0; i < count; i++) {
        e.add({
            type: 'particle',
            x: x + (Math.random() - 0.5) * 20,
            y: y + (Math.random() - 0.5) * 15,
            vx: (Math.random() - 0.5) * 50,
            vy: -20 - Math.random() * 40,
            life: 0.4 + Math.random() * 0.2,
            radius: 6 + Math.random() * 6,
            color,
        });
    }
}

/**
 * –î–æ–±–∞–≤–∏—Ç—å —É–≥–ª–∏/–∏—Å–∫—Ä—ã (–æ–≥–Ω–µ–Ω–Ω—ã–µ —á–∞—Å—Ç–∏—Ü—ã)
 */
function addEmbers(
    e: EffectSystem,
    x: number,
    y: number,
    count: number,
    color: string
) {
    for (let i = 0; i < count; i++) {
        e.add({
            type: 'particle',
            x,
            y,
            vx: (Math.random() - 0.5) * 120,
            vy: -(Math.random() * 100 + 60),
            life: 0.5 + Math.random() * 0.3,
            radius: 3 + Math.random() * 2,
            color,
        });
    }
}

/**
 * –î–æ–±–∞–≤–∏—Ç—å –¥—É—à–∏/–æ—Ä–±—ã (–ø—Ä–∏–∑—Ä–∞—á–Ω—ã–µ —á–∞—Å—Ç–∏—Ü—ã –≤–≤–µ—Ä—Ö)
 */
function addSoulOrbs(
    e: EffectSystem,
    x: number,
    y: number,
    count: number,
    color: string
) {
    for (let i = 0; i < count; i++) {
        e.add({
            type: 'particle',
            x: x + (Math.random() - 0.5) * 30,
            y,
            vx: (Math.random() - 0.5) * 60,
            vy: -(Math.random() * 120 + 80),
            life: 0.7 + Math.random() * 0.3,
            radius: 5 + Math.random() * 3,
            color,
        });
    }
}
</file>

<file path="src/Events.ts">
type Listener = (data?: any) => void;

export class EventEmitter {
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –ø–æ–¥–ø–∏—Å–æ–∫: '–Ω–∞–∑–≤–∞–Ω–∏–µ_—Å–æ–±—ã—Ç–∏—è' -> [—Å–ø–∏—Å–æ–∫ —Ñ—É–Ω–∫—Ü–∏–π]
    private events: { [key: string]: Listener[] };

    constructor() {
        this.events = {};
    }

    // –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏–µ
    public on(event: string, listener: Listener): void {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
    }

    // –û—Ç–ø–∏—Å–∞—Ç—å—Å—è
    public off(event: string, listener: Listener): void {
        if (!this.events[event]) return;
        this.events[event] = this.events[event].filter((l) => l !== listener);
    }

    // –ö—Ä–∏–∫–Ω—É—Ç—å –Ω–∞ –≤—Å—é –∏–≥—Ä—É: "–ü—Ä–æ–∏–∑–æ—à–ª–æ —Å–æ–±—ã—Ç–∏–µ!"
    public emit(event: string, data?: any): void {
        if (!this.events[event]) return;
        this.events[event].forEach((listener) => listener(data));
    }
}
</file>

<file path="src/FogRenderer.ts">
import { SimplexNoise } from './SimplexNoise';
import { FogStructure } from './FogStructure';
import { CONFIG } from './Config';

/**
 * Fog Renderer - handles animated procedural fog rendering
 */
export class FogRenderer {
    private noise: SimplexNoise;
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;

    // Animation parameters - increased for more visible movement
    private readonly DRIFT_SPEED = 0.0012; // 4x faster (was 0.0003)
    private readonly ROTATION_SPEED = 0.0004; // 4x faster (was 0.0001)
    private readonly NOISE_SCALE = 0.01;
    private readonly MAX_DRIFT = CONFIG.TILE_SIZE * 0.3; // Increased from 0.2
    private readonly MAX_ROTATION = 0.08; // Increased from 0.05 (~4.5¬∞)

    // Visual parameters
    private readonly FOG_COLOR = { r: 200, g: 215, b: 230 };
    private readonly BASE_ALPHA = 0.18;

    constructor(width: number, height: number, seed?: number) {
        this.noise = new SimplexNoise(seed);
        this.canvas = document.createElement('canvas');
        this.canvas.width = width;
        this.canvas.height = height;

        const context = this.canvas.getContext('2d');
        if (!context) throw new Error('Failed to create fog render context');
        this.ctx = context;
    }

    /**
     * Render fog structures
     */
    /**
     * Render fog structures with dual-layer noise and light masking
     */
    public render(structures: FogStructure[], time: number, lights: { x: number, y: number, radius: number }[] = []): void {
        const ctx = this.ctx;
        const width = this.canvas.width;
        const height = this.canvas.height;

        // Clear canvas
        ctx.clearRect(0, 0, width, height);

        // 1. Draw Dual-Layer Fog
        for (const structure of structures) {
            this.renderStructure(structure, time);
        }

        // 2. Apply Light Masks (Cut holes)
        if (lights.length > 0) {
            this.applyLightMasks(lights);
        }
    }

    private renderStructure(structure: FogStructure, time: number): void {
        const TS = CONFIG.TILE_SIZE;
        const ctx = this.ctx;

        for (const tile of structure.tiles) {
            if (tile.density === 0) continue;

            const cx = tile.x * TS + TS / 2;
            const cy = tile.y * TS + TS / 2;
            const baseRadius = TS * 1.5; // Larger radius for volumetric feel

            // Base opacity based on density (0.2 to 1.0)
            const densityAlpha = Math.min(tile.density * 0.2, 1.0);

            ctx.save();
            ctx.translate(cx, cy);

            // --- Layer 1: Base Fog (Slow, Heavy) ---
            // Scale 1.0, Speed 0.5x
            const drift1X = this.noise.noise2D(time * 0.0006 + structure.noiseOffsetX, 0) * (TS * 0.4);
            const drift1Y = this.noise.noise2D(0, time * 0.0006 + structure.noiseOffsetY) * (TS * 0.4);
            const rot1 = this.noise.noise2D(time * 0.0002, tile.x * 0.01) * 0.1;

            ctx.save();
            ctx.translate(drift1X, drift1Y);
            ctx.rotate(rot1);

            const grad1 = ctx.createRadialGradient(0, 0, 0, 0, 0, baseRadius);
            grad1.addColorStop(0, `rgba(${this.FOG_COLOR.r}, ${this.FOG_COLOR.g}, ${this.FOG_COLOR.b}, ${densityAlpha * 0.6})`);
            grad1.addColorStop(1, `rgba(${this.FOG_COLOR.r}, ${this.FOG_COLOR.g}, ${this.FOG_COLOR.b}, 0)`);

            ctx.fillStyle = grad1;
            ctx.beginPath();
            ctx.arc(0, 0, baseRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // --- Layer 2: Mist (Fast, Light) ---
            // Scale 0.5, Speed 1.5x, Opposite direction
            const drift2X = this.noise.noise2D(time * 0.0018 + structure.noiseOffsetX + 100, 100) * (TS * 0.2) * -1;
            const drift2Y = this.noise.noise2D(100, time * 0.0018 + structure.noiseOffsetY + 100) * (TS * 0.2) * -1;
            // Higher frequency rotation
            const rot2 = this.noise.noise2D(time * 0.0008, tile.y * 0.02) * 0.2;

            ctx.save();
            ctx.translate(drift2X, drift2Y);
            ctx.rotate(rot2);

            // Smaller, more transparent mist patches
            const mistRadius = baseRadius * 0.7;
            const mistAlpha = densityAlpha * 0.3;

            const grad2 = ctx.createRadialGradient(0, 0, 0, 0, 0, mistRadius);
            grad2.addColorStop(0, `rgba(${this.FOG_COLOR.r + 20}, ${this.FOG_COLOR.g + 20}, ${this.FOG_COLOR.b + 20}, ${mistAlpha})`);
            grad2.addColorStop(1, `rgba(${this.FOG_COLOR.r}, ${this.FOG_COLOR.g}, ${this.FOG_COLOR.b}, 0)`);

            ctx.fillStyle = grad2;
            ctx.beginPath();
            ctx.arc(0, 0, mistRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.restore();
        }
    }

    private applyLightMasks(lights: { x: number, y: number, radius: number }[]): void {
        const ctx = this.ctx;

        ctx.save();
        // Cut out holes in the fog
        ctx.globalCompositeOperation = 'destination-out';

        for (const light of lights) {
            // Flicker effect: radius +/- 5%
            const flicker = 0.95 + Math.random() * 0.1;
            const r = light.radius * flicker;

            // Soft cutout using gradient
            const grad = ctx.createRadialGradient(light.x, light.y, 0, light.x, light.y, r);
            // Inner: completely transparent (removed fog)
            // Outer: fade to original fog
            grad.addColorStop(0, 'rgba(0, 0, 0, 1)');
            grad.addColorStop(0.5, 'rgba(0, 0, 0, 0.8)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(light.x, light.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }

    /**
     * Get the rendered canvas
     */
    public getCanvas(): HTMLCanvasElement {
        return this.canvas;
    }

    /**
     * Resize the render canvas
     */
    public resize(width: number, height: number): void {
        this.canvas.width = width;
        this.canvas.height = height;
    }
}
</file>

<file path="src/MetricsSystem.ts">
import { SaveManager } from './SaveManager';

/**
 * Metrics Collection System
 * Collects gameplay statistics for balancing
 */

export interface IGameMetrics {
    gamesPlayed: number;
    wavesReached: number[];         // Array of max waves reached per game
    averageWaveReached: number;
    towersBuilt: number;
    cardsUsed: Record<string, number>; // Count per card type
    moneySpent: number;
    moneyEarned: number;
    enemiesKilled: number;
    livesLost: number;
    gamesWon: number;
}

export class MetricsSystem {
    private metrics: IGameMetrics;
    private currentGameMetrics: {
        waveReached: number;
        towersBuilt: number;
        cardsUsed: Record<string, number>;
        moneySpent: number;
        moneyEarned: number;
        enemiesKilled: number;
        livesLost: number;
    };

    constructor() {
        // Try to load from localStorage
        const saved = localStorage.getItem('towerDefenseMetrics');
        if (saved) {
            this.metrics = JSON.parse(saved);
        } else {
            this.metrics = {
                gamesPlayed: 0,
                wavesReached: [],
                averageWaveReached: 0,
                towersBuilt: 0,
                cardsUsed: {},
                moneySpent: 0,
                moneyEarned: 0,
                enemiesKilled: 0,
                livesLost: 0,
                gamesWon: 0,
            };
        }

        this.currentGameMetrics = {
            waveReached: 0,
            towersBuilt: 0,
            cardsUsed: {},
            moneySpent: 0,
            moneyEarned: 0,
            enemiesKilled: 0,
            livesLost: 0,
        };
    }

    // Track actions
    public trackTowerBuilt() {
        this.currentGameMetrics.towersBuilt++;
    }

    public trackCardUsed(cardType: string) {
        if (!this.currentGameMetrics.cardsUsed[cardType]) {
            this.currentGameMetrics.cardsUsed[cardType] = 0;
        }
        this.currentGameMetrics.cardsUsed[cardType]++;
    }

    public trackMoneySpent(amount: number) {
        this.currentGameMetrics.moneySpent += amount;
    }

    public trackMoneyEarned(amount: number) {
        this.currentGameMetrics.moneyEarned += amount;
    }

    public trackEnemyKilled() {
        this.currentGameMetrics.enemiesKilled++;
    }

    public trackLifeLost() {
        this.currentGameMetrics.livesLost++;
    }

    public trackWaveReached(wave: number) {
        this.currentGameMetrics.waveReached = Math.max(this.currentGameMetrics.waveReached, wave);
    }

    // End game and save metrics
    public endGame(won: boolean) {
        this.metrics.gamesPlayed++;
        this.metrics.wavesReached.push(this.currentGameMetrics.waveReached);
        this.metrics.towersBuilt += this.currentGameMetrics.towersBuilt;
        this.metrics.moneySpent += this.currentGameMetrics.moneySpent;
        this.metrics.moneyEarned += this.currentGameMetrics.moneyEarned;
        this.metrics.enemiesKilled += this.currentGameMetrics.enemiesKilled;
        this.metrics.livesLost += this.currentGameMetrics.livesLost;

        // Merge card usage
        for (const [card, count] of Object.entries(this.currentGameMetrics.cardsUsed)) {
            if (!this.metrics.cardsUsed[card]) {
                this.metrics.cardsUsed[card] = 0;
            }
            this.metrics.cardsUsed[card] += count;
        }

        if (won) {
            this.metrics.gamesWon++;
        }

        // Calculate average wave reached
        const total = this.metrics.wavesReached.reduce((a, b) => a + b, 0);
        this.metrics.averageWaveReached = total / this.metrics.wavesReached.length;

        // Save to localStorage
        this.save();

        // Update Campaign Persistence
        SaveManager.updateProgress({
            money: this.currentGameMetrics.moneyEarned,
            kills: this.currentGameMetrics.enemiesKilled,
            waves: this.currentGameMetrics.waveReached,
            maxWave: this.currentGameMetrics.waveReached
        });

        // Log to console for debugging
        console.log('=== GAME METRICS ===');
        console.log(`Games Played: ${this.metrics.gamesPlayed}`);
        console.log(`Average Wave: ${this.metrics.averageWaveReached.toFixed(1)}`);
        console.log(`Win Rate: ${((this.metrics.gamesWon / this.metrics.gamesPlayed) * 100).toFixed(1)}%`);
        console.log('Card Usage:', this.metrics.cardsUsed);
    }

    public save() {
        localStorage.setItem('towerDefenseMetrics', JSON.stringify(this.metrics));
    }

    public getMetrics(): IGameMetrics {
        return { ...this.metrics };
    }

    public getCardUsagePercentages(): Record<string, number> {
        const total = Object.values(this.metrics.cardsUsed).reduce((a, b) => a + b, 0);
        const percentages: Record<string, number> = {};

        for (const [card, count] of Object.entries(this.metrics.cardsUsed)) {
            percentages[card] = (count / total) * 100;
        }

        return percentages;
    }

    public reset() {
        this.metrics = {
            gamesPlayed: 0,
            wavesReached: [],
            averageWaveReached: 0,
            towersBuilt: 0,
            cardsUsed: {},
            moneySpent: 0,
            moneyEarned: 0,
            enemiesKilled: 0,
            livesLost: 0,
            gamesWon: 0,
        };
        this.save();
    }
}
</file>

<file path="src/renderers/SpriteProjectileRenderer.ts">
import { Assets } from '../Assets';
import { Projectile } from '../Projectile';

export class SpriteProjectileRenderer {
    static draw(ctx: CanvasRenderingContext2D, projectile: Projectile) {
        if (!projectile.alive) return;

        // Enhanced visual for critical hits
        if (projectile.isCrit) {
            // Enhanced visual for critical hits (kept dynamic for glow intensity)
            ctx.save();
            // Outer glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff3300'; // Orange-red glow
            ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius + 6, 0, Math.PI * 2);
            ctx.fill();

            // Inner core glow
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffff00';
            ctx.fillStyle = '#ffffaa';
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius + 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Inner bright core
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // --- BAKED PROJECTILES ---
            const type = projectile.projectileType || 'standard';
            const img = Assets.get(`projectile_${type}`);

            if (img) {
                const size = 16;
                ctx.save();
                ctx.translate(projectile.x, projectile.y);

                // Rotate if needed (always rotate towards velocity for correct orientation)
                const angle = Math.atan2(projectile.vy, projectile.vx);
                ctx.rotate(angle);

                ctx.drawImage(img, -size / 2, -size / 2);

                // Level-based trail effects
                if (projectile.towerLevel >= 2) {
                    const angle = Math.atan2(projectile.vy, projectile.vx);

                    // Fade in trail over first 30 frames (0.5 seconds)
                    const trailOpacity = Math.min(1, (120 - projectile.life) / 30);

                    ctx.save();
                    ctx.rotate(angle);

                    if (projectile.towerLevel === 2) {
                        // LVL 2: Light trail
                        ctx.strokeStyle = projectile.color;
                        ctx.globalAlpha = 0.4 * trailOpacity;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-size * 1.2, 0);
                        ctx.stroke();
                    } else if (projectile.towerLevel === 3) {
                        // LVL 3: Bright trail with glow
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = projectile.color;
                        ctx.strokeStyle = projectile.color;
                        ctx.globalAlpha = 0.7 * trailOpacity;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-size * 2, 0);
                        ctx.stroke();

                        // Inner bright core trail
                        ctx.shadowBlur = 5;
                        ctx.strokeStyle = '#fff';
                        ctx.globalAlpha = 0.9 * trailOpacity;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-size * 1.5, 0);
                        ctx.stroke();
                    }

                    ctx.restore();
                }

                // Sniper Trail (original, still works)
                if (type === 'sniper') {
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = projectile.color;
                    // Draw line relative to rotated context (backing up)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-size * 1.5, 0);
                    ctx.stroke();
                }

                ctx.restore();
            } else {
                // Fallback
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
}
</file>

<file path="src/renderers/turrets/FireTurretRenderer.ts">
import { ITurretRenderer } from './TurretRenderer';

/**
 * Fire Card Turret Renderer
 */
export class FireTurretRenderer implements ITurretRenderer {
    readonly cardId = 'fire';

    getTurretAsset(): string {
        return 'turret_fire';
    }

    getModuleAsset(): string {
        return 'mod_fire';
    }

    getMuzzleOffset(): number {
        return 15; // Short barrel for Mortar/Fire
    }
}
</file>

<file path="src/renderers/turrets/IceTurretRenderer.ts">
import { ITurretRenderer } from './TurretRenderer';

/**
 * Ice Card Turret Renderer
 */
export class IceTurretRenderer implements ITurretRenderer {
    readonly cardId = 'ice';

    getTurretAsset(): string {
        return 'turret_ice';
    }

    getModuleAsset(): string {
        return 'mod_ice';
    }

    getMuzzleOffset(): number {
        return 24; // Crystal structure length
    }

    // Future: drawEffects for frost aura
}
</file>

<file path="src/renderers/turrets/MinigunTurretRenderer.ts">
import { ITurretRenderer } from './TurretRenderer';
import type { Tower } from '../../Tower';

/**
 * Minigun Card Turret Renderer
 * Includes heat haze effect
 */
export class MinigunTurretRenderer implements ITurretRenderer {
    readonly cardId = 'minigun';

    getTurretAsset(): string {
        return 'turret_minigun';
    }

    getModuleAsset(): string {
        return 'mod_minigun';
    }

    getMuzzleOffset(): number {
        return 30; // Medium barrel for Minigun
    }

    /**
     * Draw heat haze when spinning up
     * Called INSIDE rotated context ‚Äî effect is attached to barrel
     */
    drawEffects(ctx: CanvasRenderingContext2D, tower: Tower): void {
        if (tower.spinupTime > 0) {
            this.drawHeatHaze(ctx, tower);
        }
    }

    private drawHeatHaze(ctx: CanvasRenderingContext2D, tower: Tower): void {
        // Heat rises from the barrel tip
        // We're in rotated context, so barrel tip is at (barrelLen, 0)
        const barrelLen = 30;

        ctx.save();
        const time = Date.now() * 0.005;

        // Draw multiple rising heat puffs
        for (let i = 0; i < 3; i++) {
            const cycleDur = 50;
            const offset = (time * 20 + i * (cycleDur / 3)) % cycleDur;

            // Fade out as it rises
            const alpha = Math.max(0, (1 - (offset / cycleDur)) * 0.2);

            // Sway perpendicular to barrel (in rotated space, that's Y axis)
            const sway = Math.sin(time + i) * 5;
            const dist = offset;

            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.beginPath();
            const size = 5 + (offset * 0.2);
            // In rotated context: X is along barrel, Y is perpendicular
            ctx.arc(barrelLen + dist * 0.3, sway - dist * 0.5, size, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }
}
</file>

<file path="src/renderers/turrets/SniperTurretRenderer.ts">
import { ITurretRenderer } from './TurretRenderer';
import type { Tower } from '../../Tower';
import { VISUALS } from '../../VisualConfig';

/**
 * Sniper Card Turret Renderer
 * Includes laser sight effect
 */
export class SniperTurretRenderer implements ITurretRenderer {
    readonly cardId = 'sniper';

    getTurretAsset(): string {
        return 'turret_sniper';
    }

    getModuleAsset(): string {
        return 'mod_sniper';
    }

    getMuzzleOffset(): number {
        return 40; // Long barrel for Sniper
    }

    /**
     * Draw laser sight
     * Called INSIDE rotated+recoiled context ‚Äî laser moves with barrel
     */
    drawEffects(ctx: CanvasRenderingContext2D, tower: Tower): void {
        const stats = tower.getStats();
        // Pulse effect
        const opacity = 0.4 + Math.sin(Date.now() * 0.005) * 0.2;

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.strokeStyle = VISUALS.TOWER.LASER;
        ctx.globalAlpha = opacity;
        ctx.lineWidth = 1.5;

        ctx.beginPath();
        ctx.moveTo(10, 0); // Start from end of barrel
        ctx.lineTo(stats.range, 0); // Extend to max range
        ctx.stroke();

        // Dot at the end
        ctx.fillStyle = VISUALS.TOWER.LASER;
        ctx.globalAlpha = opacity * 1.5;
        ctx.beginPath();
        ctx.arc(stats.range, 0, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
}
</file>

<file path="src/renderers/turrets/SplitTurretRenderer.ts">
import { ITurretRenderer } from './TurretRenderer';

/**
 * Split/Multishot Card Turret Renderer
 */
export class SplitTurretRenderer implements ITurretRenderer {
    readonly cardId = 'multi';

    getTurretAsset(): string {
        return 'turret_split';
    }

    getModuleAsset(): string {
        return 'mod_split';
    }

    getMuzzleOffset(): number {
        return 28; // Wide barrel array
    }
}
</file>

<file path="src/renderers/turrets/TurretRenderer.ts">
import type { Tower } from '../../Tower';

/**
 * Interface for turret-specific renderers
 * Similar to UnitRenderer for enemies
 */
export interface ITurretRenderer {
    /** Card ID for mapping */
    readonly cardId: string;

    /** Get turret asset name */
    getTurretAsset(): string;

    /** Get module asset name (for slots 1-2) */
    getModuleAsset(): string;

    /** 
     * Get muzzle offset from tower center (px) 
     * Used for projectile spawn point and muzzle flash
     */
    getMuzzleOffset(): number;

    /** 
     * Additional rendering after turret (laser, heat haze)
     * Called INSIDE rotated+recoiled context ‚Äî effects move with barrel
     */
    drawEffects?(ctx: CanvasRenderingContext2D, tower: Tower): void;

    /**
     * Draw preview of turret for ghost building
     * @param ctx Context to draw to
     * @param x Center X
     * @param y Center Y
     */
    drawPreview?(ctx: CanvasRenderingContext2D, x: number, y: number): void;
}

/**
 * Default renderer for unknown cards or empty towers
 */
export class DefaultTurretRenderer implements ITurretRenderer {
    readonly cardId = 'default';

    getTurretAsset(): string {
        return 'turret_standard';
    }

    getModuleAsset(): string {
        return '';
    }

    getMuzzleOffset(): number {
        return 22; // Default barrel length
    }
}
</file>

<file path="src/renderers/units/HellhoundUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import { CONFIG } from '../../Config';
import type { Enemy } from '../../Enemy';

export class HellhoundUnitRenderer implements UnitRenderer {
    // üî• Demonic Palette
    private static readonly OBSIDIAN = '#150505';     // Black rock skin
    private static readonly OBSIDIAN_LIGHT = '#2d1b1b';
    private static readonly MAGMA_CORE = '#ff3d00';   // Bright lava
    private static readonly MAGMA_CRUST = '#bf360c';  // Cooling lava
    private static readonly EYE_FIRE = '#ffff00';     // Intense yellow
    private static readonly CLAW_BONE = '#b0bec5';    // Ash grey claws
    private static readonly MANE_COLOR = '#ff1744';   // Fire/Energy Mane

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.001;
        const runCycle = time * (enemy.baseSpeed * 0.3);
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        const beastScale = scale * 1.1;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        ctx.save();

        if (enemy.hitFlashTimer > 0) ctx.filter = 'brightness(500%) sepia(100%) hue-rotate(-50deg)';

        if (facing === 'SIDE') {
            // Standard: Draw facing RIGHT.
            // If rotation indicates Left (< -PI/2 or > PI/2), flip.
            if (Math.abs(rotation) > Math.PI / 2) {
                ctx.scale(-1, 1);
            }
            this.drawSide(ctx, beastScale, runCycle, isMoving, time);
        } else if (facing === 'UP') {
            this.drawBack(ctx, beastScale, runCycle, isMoving, time);
        } else {
            this.drawFront(ctx, beastScale, runCycle, isMoving, time);
        }

        ctx.restore();
    }

    // === SIDE VIEW (Facing RIGHT) ===
    private drawSide(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, t: number) {
        // Reduced tilt for smoother run
        const tilt = isMoving ? Math.sin(cycle) * 0.05 : 0; // Was 0.1
        const vertical = isMoving ? Math.abs(Math.sin(cycle)) * 1 * s : 0; // Reduced bounce

        ctx.translate(0, -vertical);
        ctx.rotate(tilt);

        // 1. Far Legs (Left side of dog, technically)
        const legPhase = Math.PI * 0.2;
        // Front Far
        this.drawLegSide(ctx, 4 * s, 3 * s, cycle, 0 + legPhase, s);
        // Back Far
        this.drawLegSide(ctx, -5 * s, 3 * s, cycle, Math.PI + legPhase, s);

        // 2. Body (Chest Right, Butt Left)
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        // Chest at +X, Butt at -X
        ctx.moveTo(6 * s, -3 * s); // Neck base top
        ctx.bezierCurveTo(8 * s, 0, 4 * s, 5 * s, 2 * s, 1 * s); // Chest / Front Leg joint
        ctx.lineTo(-2 * s, 2 * s); // Belly
        ctx.lineTo(-7 * s, 3 * s); // Butt bottom
        ctx.lineTo(-8 * s, -2 * s); // Tail base
        ctx.bezierCurveTo(-5 * s, -5 * s, 0, -5 * s, 6 * s, -3 * s); // Spine
        ctx.fill();

        // Magma Cracks
        this.drawMagmaCracksSide(ctx, s, t);

        // 3. Mane (Flames) -> Towards Head (Right)
        this.drawManeSide(ctx, 5 * s, -4 * s, s, t);

        // 4. Near Legs
        // Front Near
        this.drawLegSide(ctx, 4 * s, 3 * s, cycle, 0, s);
        // Back Near
        this.drawLegSide(ctx, -5 * s, 3 * s, cycle, Math.PI, s);

        // 5. Head (At Right)
        ctx.save();
        ctx.translate(7 * s, -2 * s);
        ctx.rotate(-tilt * 0.8); // Stabilize head
        this.drawHeadSide(ctx, s, isMoving);
        ctx.restore();

        // 6. Tail (At Left)
        this.drawTail(ctx, -8 * s, -1 * s, cycle, s);

        // 7. Particles (Emit backwards - Left)
        if (isMoving) this.drawEmbers(ctx, -4 * s, 2 * s, s, t, true);
    }

    // === FRONT VIEW ===
    private drawFront(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, t: number) {
        const vertical = isMoving ? Math.abs(Math.sin(cycle)) * 1.5 * s : 0;
        ctx.translate(0, -vertical);

        // Back Legs (Wide stance)
        this.drawLegFront(ctx, -5 * s, 3 * s, cycle, Math.PI, s, true);
        this.drawLegFront(ctx, 5 * s, 3 * s, cycle, 0, s, true);

        // Body (Chest) - More defined
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        // Triangular Chest
        ctx.moveTo(-5 * s, -3 * s);
        ctx.lineTo(5 * s, -3 * s);
        ctx.lineTo(3 * s, 4 * s);
        ctx.lineTo(-3 * s, 4 * s);
        ctx.fill();

        // Magma Core (Burning Heart)
        ctx.fillStyle = HellhoundUnitRenderer.MAGMA_CORE;
        ctx.beginPath();
        ctx.moveTo(-1 * s, -1 * s); ctx.lineTo(1 * s, -1 * s); ctx.lineTo(0, 3 * s);
        ctx.fill();

        // Front Legs (Shoulders) - Straighter
        this.drawLegFront(ctx, -3 * s, 5 * s, cycle, 0, s, false);
        this.drawLegFront(ctx, 3 * s, 5 * s, cycle, Math.PI, s, false);

        // Mane
        this.drawManeFront(ctx, 0, -5 * s, s, t);

        // Head
        ctx.translate(0, -3 * s); // Higher head
        this.drawHeadFront(ctx, s);

        if (isMoving) this.drawEmbers(ctx, 0, 0, s, t, false);
    }

    // === BACK VIEW ===
    private drawBack(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, t: number) {
        const vertical = isMoving ? Math.abs(Math.sin(cycle)) * 1.5 * s : 0;
        ctx.translate(0, -vertical);

        // Front Legs (Visible between back legs)
        this.drawLegFront(ctx, -2 * s, 3 * s, cycle, 0, s, true);
        this.drawLegFront(ctx, 2 * s, 3 * s, cycle, Math.PI, s, true);

        // Hips (Rounder)
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.arc(0, 0, 5 * s, 0, Math.PI * 2);
        ctx.fill();

        // Magma Spine
        ctx.fillStyle = HellhoundUnitRenderer.MAGMA_CRUST;
        ctx.beginPath(); ctx.rect(-1 * s, -5 * s, 2 * s, 5 * s); ctx.fill();

        // Back Legs (Hunches)
        this.drawLegFront(ctx, -4 * s, 6 * s, cycle, Math.PI, s, false);
        this.drawLegFront(ctx, 4 * s, 6 * s, cycle, 0, s, false);

        // Tail
        this.drawTail(ctx, 0, -2 * s, cycle, s);

        // Head/Ears (Behind)
        ctx.translate(0, -4 * s);
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN_LIGHT;
        // Ear silhouette
        ctx.beginPath(); ctx.moveTo(-3 * s, -2 * s); ctx.lineTo(-5 * s, -5 * s); ctx.lineTo(-2 * s, -3 * s); ctx.fill();
        ctx.beginPath(); ctx.moveTo(3 * s, -2 * s); ctx.lineTo(5 * s, -5 * s); ctx.lineTo(2 * s, -3 * s); ctx.fill();

        if (isMoving) this.drawEmbers(ctx, 0, 0, s, t, false);
    }

    // --- COMPONENTS ---

    private drawHeadSide(ctx: CanvasRenderingContext2D, s: number, mouthOpen: boolean) {
        // Correction: Facing RIGHT
        // Skull
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.ellipse(0, -1 * s, 3.5 * s, 3 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        const jawOpen = mouthOpen ? 0.5 : 0;

        // Snout (Forward = +X)
        // Upper Jaw
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.moveTo(1 * s, -2 * s); // Brow
        ctx.lineTo(6 * s, -1 * s - jawOpen * s); // Nose Tip
        ctx.lineTo(6 * s, 1 * s - jawOpen * s); // Teeth Line
        ctx.lineTo(2 * s, 2 * s); // Jaw hinge
        ctx.fill();

        // Lower Jaw
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN_LIGHT;
        ctx.beginPath();
        ctx.moveTo(2 * s, 2 * s);
        ctx.lineTo(5 * s, 2 * s + jawOpen * 2 * s); // Jaw Tip
        ctx.lineTo(1 * s, 3 * s); // Throat
        ctx.fill();

        // Eye (Forward)
        ctx.fillStyle = HellhoundUnitRenderer.EYE_FIRE;
        ctx.shadowBlur = 5; ctx.shadowColor = '#ffeb3b';
        ctx.beginPath(); ctx.arc(1.5 * s, -1.5 * s, 0.8 * s, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;

        // Ear (Back = -X)
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.moveTo(-1 * s, -2 * s);
        ctx.lineTo(-4 * s, -5 * s); // Point back
        ctx.lineTo(-3 * s, -1 * s);
        ctx.fill();
    }

    private drawHeadFront(ctx: CanvasRenderingContext2D, s: number) {
        // Hexagonal Skull
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.moveTo(-3 * s, -4 * s);
        ctx.lineTo(3 * s, -4 * s);
        ctx.lineTo(4 * s, 0);
        ctx.lineTo(2 * s, 4 * s); // Chin
        ctx.lineTo(-2 * s, 4 * s);
        ctx.lineTo(-4 * s, 0);
        ctx.fill();

        // Glowing Eyes
        ctx.fillStyle = HellhoundUnitRenderer.EYE_FIRE;
        ctx.shadowBlur = 8; ctx.shadowColor = '#ffeb3b';
        ctx.beginPath();
        ctx.moveTo(-1 * s, -1 * s); ctx.lineTo(-3 * s, -2 * s); ctx.lineTo(-3 * s, -0.5 * s); ctx.fill(); // Angular Left
        ctx.beginPath();
        ctx.moveTo(1 * s, -1 * s); ctx.lineTo(3 * s, -2 * s); ctx.lineTo(3 * s, -0.5 * s); ctx.fill(); // Angular Right
        ctx.shadowBlur = 0;

        // Snout
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.rect(-1.5 * s, 1 * s, 3 * s, 2 * s);
        ctx.fill();

        // Ears
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath(); ctx.moveTo(-3 * s, -4 * s); ctx.lineTo(-5 * s, -7 * s); ctx.lineTo(-2 * s, -5 * s); ctx.fill();
        ctx.beginPath(); ctx.moveTo(3 * s, -4 * s); ctx.lineTo(5 * s, -7 * s); ctx.lineTo(2 * s, -5 * s); ctx.fill();
    }

    private drawLegSide(ctx: CanvasRenderingContext2D, x: number, y: number, cycle: number, phase: number, s: number) {
        const angle = Math.cos(cycle + phase) * 0.6;
        const kneeBend = Math.max(0, Math.sin(cycle + phase)) * 1.5;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        // Thigh
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.5 * s, 4 * s, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Calf
        ctx.translate(0, 3 * s);
        ctx.rotate(kneeBend - 0.3);
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN_LIGHT;
        ctx.beginPath();
        // Tapered Leg
        ctx.moveTo(-1 * s, 0); ctx.lineTo(1 * s, 0); ctx.lineTo(0.5 * s, 5 * s); ctx.lineTo(-0.5 * s, 5 * s);
        ctx.fill();

        // Paw
        ctx.translate(0, 5 * s);
        ctx.rotate(-kneeBend + 0.3);
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath(); ctx.ellipse(1 * s, 0, 1.5 * s, 1 * s, 0, 0, Math.PI * 2); ctx.fill(); // Feet point forward (+X)

        ctx.restore();
    }

    private drawLegFront(ctx: CanvasRenderingContext2D, x: number, y: number, cycle: number, phase: number, s: number, back: boolean) {
        const lift = Math.max(0, Math.sin(cycle + phase)) * 3 * s;
        ctx.save();
        ctx.translate(x, y - lift);

        ctx.fillStyle = back ? HellhoundUnitRenderer.OBSIDIAN_LIGHT : HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.ellipse(0, 0, 1.8 * s, 4 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.translate(0, 4 * s);
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath(); ctx.arc(0, 0, 1.8 * s, 0, Math.PI * 2); ctx.fill();
        // Claws
        ctx.fillStyle = HellhoundUnitRenderer.CLAW_BONE;
        ctx.beginPath(); ctx.rect(-1 * s, 1 * s, 0.5 * s, 1 * s); ctx.rect(0.5 * s, 1 * s, 0.5 * s, 1 * s); ctx.fill();

        ctx.restore();
    }

    private drawTail(ctx: CanvasRenderingContext2D, x: number, y: number, cycle: number, s: number) {
        const whip = Math.sin(cycle * 2) * 0.5;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(whip + 2.5); // Extend Back-Left

        ctx.strokeStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.lineWidth = 1.5 * s;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(3 * s, 0, 6 * s, -2 * s);
        ctx.stroke();

        ctx.fillStyle = HellhoundUnitRenderer.MAGMA_CORE;
        ctx.beginPath(); ctx.arc(6 * s, -2 * s, 1.2 * s, 0, Math.PI * 2); ctx.fill();

        ctx.restore();
    }

    private drawMagmaCracksSide(ctx: CanvasRenderingContext2D, s: number, t: number) {
        const alpha = 0.5 + Math.sin(t * 5) * 0.5;
        ctx.strokeStyle = HellhoundUnitRenderer.MAGMA_CORE;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = 1.2 * s;

        ctx.beginPath();
        // Shoulder
        ctx.moveTo(4 * s, -1 * s); ctx.lineTo(2 * s, 1 * s);
        // Flank
        ctx.moveTo(-2 * s, 0); ctx.lineTo(-4 * s, 2 * s);
        ctx.stroke();

        ctx.globalAlpha = 1.0;
    }

    private drawManeSide(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, t: number) {
        ctx.translate(x, y);
        const flicker = Math.sin(t * 15);
        const grad = ctx.createRadialGradient(0, 0, 1 * s, 0, 0, 5 * s);
        grad.addColorStop(0, HellhoundUnitRenderer.MAGMA_CORE);
        grad.addColorStop(1, 'rgba(255, 87, 34, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
            const angle = 2.5 + i * 0.8 + flicker * 0.1; // Point Backwards
            const len = 5 * s + Math.random() * 2 * s;
            const px = Math.cos(angle) * len;
            const py = Math.sin(angle) * len;
            ctx.lineTo(px, py);
            ctx.lineTo(0, 0);
        }
        ctx.fill();
        ctx.translate(-x, -y);
    }

    private drawManeFront(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, t: number) {
        ctx.fillStyle = HellhoundUnitRenderer.MAGMA_CRUST;
        const flicker = Math.sin(t * 12) * 0.5 * s;
        ctx.beginPath();
        // Spiky collar
        ctx.moveTo(-6 * s, -2 * s);
        ctx.lineTo(0, -6 * s - flicker);
        ctx.lineTo(6 * s, -2 * s);
        ctx.lineTo(0, 1 * s);
        ctx.fill();
    }

    private drawEmbers(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, t: number, side: boolean) {
        if (Math.random() > 0.6) return;
        // Trail backwards
        const px = x + (Math.random() - 0.5) * 6 * s - 4 * s;
        const py = y + (Math.random() - 0.5) * 4 * s;

        ctx.fillStyle = HellhoundUnitRenderer.EYE_FIRE;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(px, py, 0.6 * s, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    drawEmissive(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        // Handled in main draw
    }
}
</file>

<file path="src/renderers/units/RatUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import type { Enemy } from '../../Enemy';

export class RatUnitRenderer implements UnitRenderer {
    // üé® Darker Alchemical Palette
    private static readonly FUR_COLOR = '#3e2723';       // Dark Chocolate
    private static readonly FUR_LIGHT = '#5d4037';       // Muddy Brown
    private static readonly SKIN_COLOR = '#bcaaa4';      // Pale, Sickly Skin
    private static readonly POISON_GLOW = '#64dd17';     // Toxic Neon Green (Darker shade)
    private static readonly POISON_LIQUID = '#76ff03';   // Bright Core
    private static readonly BARREL_WOOD = '#261b18';     // Burnt Wood
    private static readonly BARREL_RIM = '#4e342e';      // Rusted Iron

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.005;
        const walkCycle = time * (enemy.baseSpeed * 2.5);
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        // Rat is low to the ground
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 1 * scale : 0;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        ctx.save();
        ctx.translate(0, -bounce);

        // Shake/Wobble Effect for the unstable payload
        if (isMoving) {
            const wobble = Math.sin(time * 15) * 0.05; // Fast jitter
            ctx.rotate(wobble);
        }

        if (facing === 'SIDE') {
            if (Math.abs(rotation) > Math.PI / 2) {
                ctx.scale(-1, 1);
            }
            this.drawSide(ctx, scale, walkCycle, isMoving, time);
        } else if (facing === 'UP') {
            this.drawBack(ctx, scale, walkCycle, isMoving, time);
        } else {
            this.drawFront(ctx, scale, walkCycle, isMoving, time);
        }

        ctx.restore();
    }

    // === FRONT ===
    private drawFront(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean, time: number) {
        // Feet
        const footOff = Math.sin(walkCycle) * 3 * scale;
        this.drawPaw(ctx, -5 * scale, 6 * scale + footOff, scale);
        this.drawPaw(ctx, 5 * scale, 6 * scale - footOff, scale);

        // Body
        ctx.fillStyle = RatUnitRenderer.FUR_COLOR;
        ctx.beginPath(); ctx.ellipse(0, 0, 7 * scale, 6 * scale, 0, 0, Math.PI * 2); ctx.fill();

        // Barrel (Unstable!)
        ctx.save();
        ctx.translate(0, -7 * scale);
        // Liquid Slosh Animation
        const slosh = Math.sin(time * 8) * 0.2;
        ctx.rotate(slosh);

        this.drawBarrel(ctx, scale, true);
        ctx.restore();

        // Head
        ctx.save();
        ctx.translate(0, 1 * scale); // Lower head (hunchback)
        this.drawHeadFront(ctx, scale);
        ctx.restore();
    }

    // === BACK ===
    private drawBack(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean, time: number) {
        // Feet
        const footOff = Math.sin(walkCycle) * 3 * scale;
        this.drawPaw(ctx, -5 * scale, 6 * scale + footOff, scale);
        this.drawPaw(ctx, 5 * scale, 6 * scale - footOff, scale);

        // Tail (Wagging wildly)
        // More complex wave for "rat-like" feel
        const tailWag = Math.sin(time * 10) * 0.4;
        this.drawTail(ctx, 0, 4 * scale, scale, tailWag, true);

        // Body
        ctx.fillStyle = RatUnitRenderer.FUR_COLOR;
        ctx.beginPath(); ctx.ellipse(0, 0, 8 * scale, 7 * scale, 0, 0, Math.PI * 2); ctx.fill();

        // Barrel (Strapped)
        ctx.save();
        ctx.translate(0, -3 * scale);
        const slosh = Math.sin(time * 8) * 0.1;
        ctx.rotate(slosh);
        this.drawBarrel(ctx, scale, false);
        ctx.restore();

        // Ears
        ctx.fillStyle = RatUnitRenderer.SKIN_COLOR;
        ctx.beginPath(); ctx.arc(-6 * scale, -2 * scale, 2.5 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(6 * scale, -2 * scale, 2.5 * scale, 0, Math.PI * 2); ctx.fill();
    }

    // === SIDE ===
    private drawSide(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean, time: number) {
        const frontLegA = Math.sin(walkCycle) * 4 * scale;
        const backLegA = Math.sin(walkCycle + Math.PI / 2) * 4 * scale;

        // Back Legs
        this.drawPaw(ctx, -7 * scale + backLegA, 6 * scale, scale);

        // Tail (Trailing with wave)
        // Uses sine wave logic inside drawTail for side view
        this.drawTail(ctx, -9 * scale, 1 * scale, scale, 0, false, time);

        // Body (Hunched)
        ctx.fillStyle = RatUnitRenderer.FUR_COLOR;
        ctx.beginPath();
        ctx.ellipse(0, 1 * scale, 10 * scale, 6 * scale, 0, 0, Math.PI * 2); // Fatter
        ctx.fill();

        // Barrel (Heavy Load)
        ctx.save();
        ctx.translate(-1 * scale, -6 * scale);
        ctx.rotate(-0.2 + Math.sin(time * 10) * 0.05); // Heavy wobble
        this.drawBarrel(ctx, scale, false);
        ctx.restore();

        // Front Legs
        this.drawPaw(ctx, 7 * scale + frontLegA, 6 * scale, scale);

        // Head
        ctx.save();
        ctx.translate(10 * scale, 2 * scale); // Low head
        this.drawHeadSide(ctx, scale);
        ctx.restore();
    }

    // --- PARTS ---

    private drawHeadFront(ctx: CanvasRenderingContext2D, scale: number) {
        // Face
        ctx.fillStyle = RatUnitRenderer.FUR_LIGHT;
        ctx.beginPath();
        ctx.moveTo(-4 * scale, -2 * scale);
        ctx.lineTo(4 * scale, -2 * scale);
        ctx.lineTo(0, 6 * scale);
        ctx.fill();

        // Nose
        ctx.fillStyle = RatUnitRenderer.SKIN_COLOR;
        ctx.beginPath(); ctx.arc(0, 6 * scale, 1.5 * scale, 0, Math.PI * 2); ctx.fill();

        // Ears (Ragged)
        ctx.fillStyle = RatUnitRenderer.SKIN_COLOR;
        ctx.beginPath(); ctx.arc(-6 * scale, -3 * scale, 3 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(6 * scale, -3 * scale, 3 * scale, 0, Math.PI * 2); ctx.fill();

        // Glowing Toxic Eyes
        ctx.fillStyle = RatUnitRenderer.POISON_GLOW;
        ctx.shadowBlur = 8;
        ctx.shadowColor = RatUnitRenderer.POISON_GLOW;
        ctx.beginPath(); ctx.arc(-2.5 * scale, -0.5 * scale, 1.2 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(2.5 * scale, -0.5 * scale, 1.2 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
    }

    private drawHeadSide(ctx: CanvasRenderingContext2D, scale: number) {
        ctx.fillStyle = RatUnitRenderer.FUR_LIGHT;
        ctx.beginPath();
        ctx.ellipse(0, 0, 5 * scale, 3.5 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Long Snout
        ctx.fillStyle = RatUnitRenderer.FUR_LIGHT; // Same color to blend
        ctx.beginPath(); ctx.ellipse(3 * scale, 1 * scale, 3 * scale, 2 * scale, 0, 0, Math.PI * 2); ctx.fill();

        ctx.fillStyle = RatUnitRenderer.SKIN_COLOR;
        ctx.beginPath(); ctx.arc(6 * scale, 1.5 * scale, 1.5 * scale, 0, Math.PI * 2); ctx.fill(); // Nose

        ctx.beginPath(); ctx.arc(-2 * scale, -3 * scale, 3 * scale, 0, Math.PI * 2); ctx.fill(); // Ear

        // Eye
        ctx.fillStyle = RatUnitRenderer.POISON_GLOW;
        ctx.shadowBlur = 8;
        ctx.shadowColor = RatUnitRenderer.POISON_GLOW;
        ctx.beginPath(); ctx.arc(2 * scale, -1 * scale, 1.3 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
    }

    private drawPaw(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number) {
        // –ë–æ–ª–µ–µ –∑–∞–º–µ—Ç–Ω—ã–µ –ª–∞–ø–∫–∏
        ctx.fillStyle = '#d7ccc8'; // Lighter than SKIN_COLOR for visibility
        ctx.strokeStyle = RatUnitRenderer.SKIN_COLOR;
        ctx.lineWidth = 1;
        ctx.beginPath();
        // Larger claws with visible toes
        ctx.moveTo(x - 3 * scale, y + 3 * scale);
        ctx.lineTo(x - 1 * scale, y - 1 * scale);
        ctx.lineTo(x, y + 1 * scale);
        ctx.lineTo(x + 1 * scale, y - 1 * scale);
        ctx.lineTo(x + 3 * scale, y + 3 * scale);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    private drawTail(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number, angleObs: number, isBack: boolean, time: number = 0) {
        // –ë–æ–ª–µ–µ —Ç–æ–ª—Å—Ç—ã–π –∏ –∑–∞–º–µ—Ç–Ω—ã–π —Ö–≤–æ—Å—Ç
        ctx.strokeStyle = '#d7ccc8'; // Lighter for visibility
        ctx.lineWidth = 3.5 * scale; // Thicker
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x, y);

        if (isBack) {
            // Wagging tail from back view - more pronounced
            ctx.quadraticCurveTo(
                x + Math.sin(angleObs) * 12 * scale,
                y + 6 * scale,
                x + Math.sin(angleObs) * 18 * scale,
                y - 3 * scale
            );
        } else {
            // Side view trailing Sine Wave - more visible
            const wave = Math.sin(time * 15) * 4 * scale;
            ctx.quadraticCurveTo(
                x - 6 * scale,
                y + wave,
                x - 15 * scale,
                y + 3 * scale
            );
        }
        ctx.stroke();

        // Tip of tail
        ctx.fillStyle = RatUnitRenderer.SKIN_COLOR;
        const tipX = isBack ? (x + Math.sin(angleObs) * 18 * scale) : (x - 15 * scale);
        const tipY = isBack ? (y - 3 * scale) : (y + 3 * scale);
        ctx.beginPath();
        ctx.arc(tipX, tipY, 1.5 * scale, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawBarrel(ctx: CanvasRenderingContext2D, scale: number, glow: boolean) {
        const w = 10 * scale; // Bulky
        const h = 8 * scale;

        // Wood Body
        ctx.fillStyle = RatUnitRenderer.BARREL_WOOD;
        ctx.beginPath();
        ctx.rect(-w / 2, -h / 2, w, h);
        ctx.fill();

        // Metal Bands
        ctx.fillStyle = RatUnitRenderer.BARREL_RIM;
        ctx.fillRect(-w / 2, -h / 2 + 1 * scale, w, 1 * scale);
        ctx.fillRect(-w / 2, h / 2 - 2 * scale, w, 1 * scale);

        // Leak / Liquid
        if (glow) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = RatUnitRenderer.POISON_GLOW;
        }
        ctx.fillStyle = RatUnitRenderer.POISON_LIQUID;
        ctx.beginPath(); ctx.arc(0, 0, 2.5 * scale, 0, Math.PI * 2); ctx.fill(); // Core
        ctx.shadowBlur = 0;

        // Drip
        if (Math.random() < 0.1) {
            // Instant drip visual (simulated)
            ctx.fillStyle = RatUnitRenderer.POISON_LIQUID;
            ctx.beginPath(); ctx.arc(w / 2, h / 2, 1.5 * scale, 0, Math.PI * 2); ctx.fill();
        }

        // Fuse Spark
        const spark = (Date.now() % 100) > 50; // Fast flicker
        if (spark) {
            ctx.fillStyle = '#fff176';
            ctx.beginPath();
            ctx.arc(2 * scale, -h / 2 - 2 * scale, 2 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ff3d00';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(2 * scale, -h / 2); ctx.lineTo(2 * scale, -h / 2 - 2 * scale); ctx.stroke();
        }
    }
}
</file>

<file path="src/renderers/units/UnitRenderer.ts">
import { Assets } from '../../Assets';
import { CONFIG } from '../../Config';
import type { Enemy } from '../../Enemy';

/**
 * Interface for specific unit renderers (Strategy Pattern).
 * Draws ONLY the body/components of the unit. 
 * Coordinate system is already transformed to unit center (0,0) 
 * and rotated by the parent EnemyRenderer.
 */
export interface UnitRenderer {
    /**
     * Draw the unit body.
     * @param ctx Canvas context (pre-translated to 0,0)
     * @param enemy The enemy instance
     * @param scale Visual scale factor
     * @param rotation Rotation in radians (direction of movement)
     */
    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void;

    /**
     * Optional: Draw glowing parts (eyes, runes) that should pierce through fog/darkness.
     * Drawn in a separate pass after lighting.
     */
    drawEmissive?(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void;
}

/**
 * Default renderer for generic enemies (fallback).
 * Implements the classic "Sprite or Circle" logic.
 */
export class DefaultUnitRenderer implements UnitRenderer {

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        // Legacy behavior: rotate sprite to face movement
        ctx.save();
        ctx.rotate(rotation + Math.PI / 2);

        const safeType = enemy.typeId ? enemy.typeId.toLowerCase() : 'grunt';

        // Lookup config using typeId
        const typeConf = Object.values(CONFIG.ENEMY_TYPES).find(t => t.id === safeType);

        const archetype = typeConf?.archetype || 'GRUNT';
        // @ts-ignore - tint is optional in IEnemyTypeConfig but union type might confuse TS
        const tint = typeConf?.tint;

        const bodyImgName = `enemy_${archetype.toLowerCase()}`;
        const bodyImg = Assets.get(bodyImgName);

        if (bodyImg) {
            const size = 48 * scale;
            const half = size / 2;

            ctx.drawImage(bodyImg, -half, -half, size, size);

            if (tint) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = tint;
                ctx.globalAlpha = 0.5;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }

            // Hit Flash
            if (enemy.hitFlashTimer > 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.8;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }

            // Status Tints
            if (enemy.statuses.some(s => s.type === 'slow')) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = CONFIG.AMBIENT.LIGHTING.ICE || '#00e5ff';
                ctx.globalAlpha = 0.4;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }
            if (enemy.statuses.some(s => s.type === 'burn')) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = CONFIG.AMBIENT.LIGHTING.FIRE || '#ff3d00';
                ctx.globalAlpha = 0.4;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }
        } else {
            // Fallback (Circle)
            ctx.fillStyle = tint || '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 16 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }
}
</file>

<file path="src/systems/AtmosphereSystem.ts">
import { DayNightCycle } from '../DayNightCycle';

/**
 * Configurable atmosphere parameters - easily tunable
 */
interface IAtmosphereConfig {
    // Sunlight settings
    sunRayCount: number;
    sunRayOpacity: number;
    sunRayWidth: number;
    sunRayAngle: number; // degrees from horizontal

    // Cloud shadow settings
    cloudShadowCount: number;
    cloudShadowSpeed: number; // pixels per second in world space
    cloudShadowOpacity: number;
    cloudShadowMinSize: number;
    cloudShadowMaxSize: number;
    cloudShadowDirection: number; // angle in degrees (0 = right, 90 = down)

    // Moonlight settings
    moonlightOpacity: number;
    moonlightColor: string;

    // Color grading
    dayFilter: string;
    nightFilter: string;

    // Stars settings
    enableStars: boolean;
    starCount: number;
    starOpacity: number;
}

interface CloudShadow {
    x: number;        // world X coordinate
    y: number;        // world Y coordinate  
    width: number;    // fixed width
    height: number;   // fixed height
    speed: number;    // individual speed multiplier (0.8 - 1.2)
    vx: number;       // velocity X (calculated from direction)
    vy: number;       // velocity Y (calculated from direction)
}

export class AtmosphereSystem {
    private dayNightCycle: DayNightCycle;
    private config: IAtmosphereConfig;
    private clouds: CloudShadow[] = [];
    private starPositions: { x: number; y: number }[] = [];
    private worldWidth: number = 1280; // will be updated via setWorldSize
    private worldHeight: number = 800;

    constructor(dayNightCycle: DayNightCycle, config?: Partial<IAtmosphereConfig>) {
        this.dayNightCycle = dayNightCycle;

        // Default config - easily modifiable
        this.config = {
            // Sunlight
            sunRayCount: 5,
            sunRayOpacity: 0.08,
            sunRayWidth: 120,
            sunRayAngle: 30,

            // Cloud shadows
            cloudShadowCount: 8,
            cloudShadowSpeed: 20, // pixels/second
            cloudShadowOpacity: 0.06, // Reduced from 0.12 for brighter atmosphere
            cloudShadowMinSize: 180,
            cloudShadowMaxSize: 320,
            cloudShadowDirection: 45, // diagonal movement (top-left to bottom-right)

            // Moonlight
            moonlightOpacity: 0.15,
            moonlightColor: '#4fc3f7',

            // Color grading
            dayFilter: 'sepia(0.05) saturate(1.1)',
            nightFilter: 'hue-rotate(10deg) saturate(0.9)',

            // Stars
            enableStars: true,
            starCount: 50,
            starOpacity: 0.8,

            ...config // Override with provided config
        };

        this.initializeCloudShadows();
        if (this.config.enableStars) {
            this.initializeStars();
        }
    }

    /**
     * Set world dimensions for proper cloud positioning
     * Should be called once when map is loaded
     */
    public setWorldSize(width: number, height: number): void {
        this.worldWidth = width;
        this.worldHeight = height;
        // Re-initialize clouds with new world bounds
        this.clouds = [];
        this.initializeCloudShadows();
    }

    private initializeCloudShadows(): void {
        const directionRad = (this.config.cloudShadowDirection * Math.PI) / 180;

        for (let i = 0; i < this.config.cloudShadowCount; i++) {
            // Random position across entire world
            const x = Math.random() * this.worldWidth;
            const y = Math.random() * this.worldHeight;

            // Random size between min and max
            const sizeRange = this.config.cloudShadowMaxSize - this.config.cloudShadowMinSize;
            const width = this.config.cloudShadowMinSize + Math.random() * sizeRange;
            const height = width * (0.5 + Math.random() * 0.3); // height is 50-80% of width

            // Slight speed variation for more organic movement
            const speedMultiplier = 0.8 + Math.random() * 0.4; // 0.8 to 1.2

            // Calculate velocity from direction
            const speed = this.config.cloudShadowSpeed * speedMultiplier;
            const vx = Math.cos(directionRad) * speed;
            const vy = Math.sin(directionRad) * speed;

            this.clouds.push({ x, y, width, height, speed: speedMultiplier, vx, vy });
        }
    }

    private initializeStars(): void {
        // Random star positions (fixed, not moving)
        for (let i = 0; i < this.config.starCount; i++) {
            this.starPositions.push({
                x: Math.random(),
                y: Math.random() * 0.6 // Stars in upper 60% of screen
            });
        }
    }

    public update(deltaTime: number): void {
        // Update cloud positions in world space
        this.clouds.forEach(cloud => {
            cloud.x += cloud.vx * deltaTime;
            cloud.y += cloud.vy * deltaTime;

            // Wrap around when cloud exits world bounds
            // Add padding to prevent pop-in
            const padding = Math.max(cloud.width, cloud.height);

            if (cloud.x > this.worldWidth + padding) {
                cloud.x = -padding;
            } else if (cloud.x < -padding) {
                cloud.x = this.worldWidth + padding;
            }

            if (cloud.y > this.worldHeight + padding) {
                cloud.y = -padding;
            } else if (cloud.y < -padding) {
                cloud.y = this.worldHeight + padding;
            }
        });
    }

    public draw(ctx: CanvasRenderingContext2D): void {
        const time = this.dayNightCycle.getTimeOfDay(); // 0 (dawn) to 1 (night)
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;

        // Save original state
        ctx.save();

        // Smooth transition calculation
        // 0.0-0.3: Dawn (transitioning to day)
        // 0.3-0.5: Full day
        // 0.5-0.7: Dusk (transitioning to night)
        // 0.7-1.0: Full night

        let dayIntensity = 0;
        let nightIntensity = 0;

        if (time < 0.3) {
            // Dawn
            dayIntensity = time / 0.3; // 0 to 1
        } else if (time < 0.5) {
            // Day
            dayIntensity = 1;
        } else if (time < 0.7) {
            // Dusk
            dayIntensity = 1 - ((time - 0.5) / 0.2); // 1 to 0
            nightIntensity = (time - 0.5) / 0.2; // 0 to 1
        } else {
            // Night
            nightIntensity = 1;
        }

        // Draw clouds (always visible, independent of day/night blend)
        // We draw them here to ensure they are consistent across transition
        this.drawCloudShadows(ctx, 1.0); // Always draw clouds

        // Draw both day and night effects with smooth blending
        if (dayIntensity > 0) {
            this.drawDayEffects(ctx, canvasWidth, canvasHeight, dayIntensity);
        }
        if (nightIntensity > 0) {
            this.drawNightEffects(ctx, canvasWidth, canvasHeight, nightIntensity);
        }

        ctx.restore();
    }

    private drawDayEffects(ctx: CanvasRenderingContext2D, width: number, height: number, intensity: number): void {
        // 1. Sunlight rays (diagonal lines)
        ctx.save();
        ctx.globalAlpha = this.config.sunRayOpacity * intensity;
        const rayAngleRad = (this.config.sunRayAngle * Math.PI) / 180;

        for (let i = 0; i < this.config.sunRayCount; i++) {
            const spacing = width / (this.config.sunRayCount + 1);
            const startX = spacing * (i + 1);
            const gradient = ctx.createLinearGradient(
                startX, 0,
                startX + Math.cos(rayAngleRad) * height,
                height
            );
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(startX - this.config.sunRayWidth / 2, 0, this.config.sunRayWidth, height);
        }
        ctx.restore();

        // 3. Subtle warm tint (removed harsh overlay)
        // Ambient lighting already handles color temperature
        ctx.restore();
    }

    private drawCloudShadows(ctx: CanvasRenderingContext2D, intensity: number): void {
        ctx.save();
        // Base opacity for clouds
        // At night, maybe slightly less opaque? Or darker? 
        // For now constant opacity from config
        ctx.globalAlpha = this.config.cloudShadowOpacity * intensity;

        this.clouds.forEach(cloud => {
            // Create gradient for soft edges
            const gradient = ctx.createRadialGradient(
                cloud.x, cloud.y, 0,
                cloud.x, cloud.y, cloud.width * 0.6
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.2)');   // Reduced from 0.4
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.1)'); // Reduced from 0.2
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;

            // Draw organic cloud shape (multiple overlapping ellipses)
            ctx.beginPath();
            ctx.ellipse(
                cloud.x,
                cloud.y,
                cloud.width * 0.5,
                cloud.height * 0.5,
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // Add secondary ellipse for organic shape
            ctx.beginPath();
            ctx.ellipse(
                cloud.x + cloud.width * 0.2,
                cloud.y - cloud.height * 0.15,
                cloud.width * 0.35,
                cloud.height * 0.4,
                Math.PI * 0.3, 0, Math.PI * 2
            );
            ctx.fill();

            // Add third ellipse
            ctx.beginPath();
            ctx.ellipse(
                cloud.x - cloud.width * 0.15,
                cloud.y + cloud.height * 0.1,
                cloud.width * 0.3,
                cloud.height * 0.35,
                -Math.PI * 0.25, 0, Math.PI * 2
            );
            ctx.fill();
        });
        ctx.restore();
    }

    private drawNightEffects(ctx: CanvasRenderingContext2D, width: number, height: number, intensity: number): void {
        // 1. Moonlight (soft blue glow from top)
        ctx.save();
        ctx.globalAlpha = this.config.moonlightOpacity * intensity;
        const moonGradient = ctx.createLinearGradient(0, 0, 0, height / 2);
        moonGradient.addColorStop(0, this.config.moonlightColor);
        moonGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
        ctx.fillStyle = moonGradient;
        ctx.fillRect(0, 0, width, height / 2);
        ctx.restore();

        // 2. Stars
        if (this.config.enableStars) {
            ctx.save();
            ctx.globalAlpha = this.config.starOpacity * intensity;
            ctx.fillStyle = '#ffffff';

            this.starPositions.forEach(star => {
                const x = star.x * width;
                const y = star.y * height;
                const radius = 0.5 + Math.random();

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Twinkle effect (subtle)
                if (Math.random() > 0.95) {
                    ctx.globalAlpha = this.config.starOpacity * intensity * 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.restore();
        }

        // 3. Subtle cool tint (removed harsh overlay)
        // Ambient lighting already handles night coloring
        ctx.restore();
    }

    /**
     * Update configuration at runtime
     */
    public updateConfig(newConfig: Partial<IAtmosphereConfig>): void {
        this.config = { ...this.config, ...newConfig };

        // Re-initialize if needed
        if (newConfig.cloudShadowCount !== undefined ||
            newConfig.cloudShadowDirection !== undefined ||
            newConfig.cloudShadowMinSize !== undefined ||
            newConfig.cloudShadowMaxSize !== undefined) {
            this.clouds = [];
            this.initializeCloudShadows();
        }
        if (newConfig.starCount !== undefined || newConfig.enableStars !== undefined) {
            this.starPositions = [];
            if (this.config.enableStars) {
                this.initializeStars();
            }
        }
    }

    public getConfig(): IAtmosphereConfig {
        return { ...this.config };
    }
}
</file>

<file path="src/systems/ProjectileSystem.ts">
import { Projectile } from '../Projectile';
import { EffectSystem } from '../EffectSystem';

export class ProjectileSystem {
    // Single pool array containing both active and inactive projectiles
    private pool: Projectile[] = [];

    // Getter for other systems (Collision, etc)
    public get projectiles(): Projectile[] {
        return this.pool;
    }

    public spawn(x: number, y: number, target: { x: number, y: number }, stats: any): Projectile {
        // 1. Try to find an inactive projectile
        let p = this.pool.find(p => !p.alive);

        if (!p) {
            // 2. If not found, create new and add to pool
            p = new Projectile();
            this.pool.push(p);
        }

        // 3. Reset/Init (active = true happens here)
        p.init(x, y, target, stats);
        return p;
    }

    public createExplosion(x: number, y: number, radius: number, damage: number, friendlyFire: boolean = false) {
        // Visual Explosion (Reuse existing particle logic or spawn a dummy projectile that explodes immediately)
        // For now, let's spawn a "stationary" projectile that dies immediately but triggers effects
        // OR better: Just handle the logic here if we have access to effects.

        // Since this system doesn't have direct access to 'enemies' list to apply damage,
        // we will create a special projectile that acts as the explosion.

        // Actually, looking at the code, ProjectileSystem.update() doesn't do collision checks.
        // Collision is likely handled in GameScene.
        // So we need to return a projectile that the GameScene will process as "Just Exploded"

        const p = this.spawn(x, y, { x, y }, {
            dmg: damage,
            speed: 0,
            color: '#76ff03',
            effects: [],
            pierce: 999,
            projectileType: 'explosion', // New type
            explosionRadius: radius,
            explosionDamage: damage,
            explodeOnDeath: true // This ensures it triggers explosion logic
        });

        p.life = 0; // Die immediately next frame to trigger explosion

        // Mark it specially for friendly fire if needed
        // We'll add a runtime property or use existing fields
        (p as any).friendlyFire = friendlyFire;

        return p;
    }

    public update(dt: number, effects: EffectSystem) {
        for (const p of this.pool) {
            if (p.alive) {
                p.update(effects, dt);
            }
        }
    }

    public draw(ctx: CanvasRenderingContext2D) {
        for (const p of this.pool) {
            if (p.alive) {
                p.draw(ctx);
            }
        }
    }

    public clear() {
        // Mark all as dead, but keep objects in pool for reuse
        for (const p of this.pool) {
            p.alive = false;
        }
    }
}
</file>

<file path="src/ui/PauseMenu.ts">
import { IGameScene } from '../scenes/IGameScene';
import { UIUtils } from '../UIUtils';
import { SoundManager, SoundPriority } from '../SoundManager';

export class PauseMenu {
    private scene: IGameScene;
    private elUiLayer: HTMLElement;
    private elPauseMenu: HTMLElement | null = null;

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.elUiLayer = document.getElementById('ui-layer')!;
        this.init();
    }

    private init() {
        // ESCAPE TO PAUSE - bind listener
        this.boundKeyHandler = this.handleKeyDown.bind(this);
        window.addEventListener('keydown', this.boundKeyHandler);

        // Create menu overlay
        this.createOverlay();
    }

    private boundKeyHandler: ((e: KeyboardEvent) => void) | null = null;

    private handleKeyDown(e: KeyboardEvent) {
        if (e.code === 'Escape') {
            this.scene.togglePause();
        }
    }

    public destroy() {
        if (this.boundKeyHandler) {
            window.removeEventListener('keydown', this.boundKeyHandler);
            this.boundKeyHandler = null;
        }
        if (this.elPauseMenu) {
            this.elPauseMenu.remove();
            this.elPauseMenu = null;
        }
    }

    private createOverlay() {
        if (!document.getElementById('pause-menu')) {
            const menu = UIUtils.createOverlay('pause-menu');
            this.elPauseMenu = menu;
            this.renderMainMenu(menu);
        } else {
            this.elPauseMenu = document.getElementById('pause-menu');
        }
    }

    private renderMainMenu(menu: HTMLElement) {
        menu.innerHTML = ''; // Clear
        const content = document.createElement('div');
        Object.assign(content.style, {
            background: '#222',
            padding: '40px',
            borderRadius: '8px',
            border: '2px solid #555',
            textAlign: 'center',
            minWidth: '300px'
        });

        content.innerHTML = `
            <h1 style="margin-top: 0; color: #ffd700; text-transform: uppercase; letter-spacing: 2px;">Paused</h1>
            <p style="color: #aaa; font-size: 14px; margin-top: -10px;">Press ESC to resume</p>
        `;

        // Continue
        UIUtils.createButton(content, 'Continue', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.scene.togglePause();
        }, { background: '#4caf50', width: '100%', padding: '12px', fontSize: '16px', border: 'none' });

        content.appendChild(document.createElement('br'));

        // Settings
        UIUtils.createButton(content, 'Settings', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.renderSettings(menu);
        }, { background: '#2196f3', width: '100%', padding: '12px', fontSize: '16px', border: 'none', marginTop: '10px' });

        // Exit
        UIUtils.createButton(content, 'Exit to Menu', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.scene.togglePause();
            this.scene.game.toMenu();
        }, { background: '#f44336', width: '100%', padding: '12px', fontSize: '16px', border: 'none', marginTop: '10px' });

        menu.appendChild(content);
    }

    private renderSettings(menu: HTMLElement) {
        menu.innerHTML = '';
        const content = document.createElement('div');
        Object.assign(content.style, {
            background: '#222',
            padding: '40px',
            borderRadius: '8px',
            border: '2px solid #555',
            textAlign: 'center',
            minWidth: '300px'
        });

        content.innerHTML = `<h2 style="color:#ffd700; margin:0 0 20px 0;">Audio Settings</h2>`;

        const addSlider = (label: string, val: number, onChange: (v: number) => void) => {
            const row = document.createElement('div');
            row.style.marginBottom = '10px';
            row.style.textAlign = 'left';
            row.innerHTML = `<label style="display:inline-block; width:60px;">${label}</label>`;

            const input = document.createElement('input');
            input.type = 'range';
            input.min = '0';
            input.max = '1';
            input.step = '0.1';
            input.value = val.toString();
            input.oninput = (e) => onChange(parseFloat((e.target as HTMLInputElement).value));

            row.appendChild(input);
            content.appendChild(row);
        };

        addSlider('Master', SoundManager.MASTER_VOLUME, (v) => SoundManager.setVolume(v));
        addSlider('SFX', SoundManager.SFX_VOLUME, (v) => SoundManager.SFX_VOLUME = v);
        addSlider('Music', SoundManager.MUSIC_VOLUME, (v) => SoundManager.MUSIC_VOLUME = v);

        // Back button
        UIUtils.createButton(content, 'Back', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.renderMainMenu(menu);
        }, { background: '#555', marginTop: '20px', width: '100%', padding: '10px', border: 'none' });

        menu.appendChild(content);
    }

    public update(paused: boolean) {
        if (this.elPauseMenu) {
            this.elPauseMenu.style.display = paused ? 'flex' : 'none';
        }
    }
}
</file>

<file path="src/cards/MultishotCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Multishot Card Upgrades
 * 
 * Level 1: 2 projectiles at 60% damage each
 * Level 2: 2 projectiles at 70% damage each
 * Level 3: 3 projectiles at 55% damage each
 * 
 * Note: Multishot is handled differently - it modifies projectile count
 * and damage multiplier rather than using effects system
 */
export const MULTISHOT_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {},
        effects: []
        // Projectile count: 2, damage multiplier: 0.60
    },
    2: {
        level: 2,
        modifiers: {},
        effects: []
        // Projectile count: 2, damage multiplier: 0.70
    },
    3: {
        level: 3,
        modifiers: {},
        effects: []
        // Projectile count: 3, damage multiplier: 0.55
    }
};

/**
 * Get multishot configuration for a given level
 */
export function getMultishotConfig(level: number): { projectileCount: number; damageMultiplier: number; spread: number } {
    switch (level) {
        case 1:
            return { projectileCount: 2, damageMultiplier: 0.60, spread: 0.30 };
        case 2:
            return { projectileCount: 2, damageMultiplier: 0.70, spread: 0.20 };
        case 3:
            return { projectileCount: 3, damageMultiplier: 0.55, spread: 0.25 };
        default:
            return { projectileCount: 1, damageMultiplier: 1.0, spread: 0 };
    }
}
</file>

<file path="src/CrashHandler.ts">
import { Logger, LogChannel, LogLevel } from './utils/Logger';
import { SafeJson } from './utils/SafeJson';

export class CrashHandler {
    constructor() {
        this.init();
        Logger.info(LogChannel.SYSTEM, 'CrashHandler initialized');
    }

    private init() {
        window.onerror = (message, source, lineno, colno, error) => {
            this.handleError(message as string, source, lineno, colno, error);
            return true; // Prevent default browser console spam if we handle it
        };

        window.addEventListener('unhandledrejection', (event) => {
            this.handleError(event.reason ? event.reason.toString() : 'Unhandled Rejection', 'Promise', 0, 0, event.reason);
        });
    }

    private handleError(msg: string, source: string | undefined, line: number, col: number | undefined, error: any) {
        // 1. Log to our internal logger immediately (so it's in history)
        Logger.error(LogChannel.SYSTEM, `CRASH: ${msg}`, { source, line, stack: error?.stack });

        // 2. Stop Game Loop (Global hack or try to find game instance)
        // We can't easily stop requestAnimationFrame from here without reference, but we can cover the screen.

        // 3. Show BSOD
        this.showBSOD(msg, source || 'unknown', line, error);
    }

    private showBSOD(msg: string, source: string, line: number, error: any) {
        // Stop interaction
        const ui = document.getElementById('ui-layer');
        if (ui) ui.style.display = 'none';

        // Create BSOD
        const bsod = document.createElement('div');
        Object.assign(bsod.style, {
            position: 'fixed', top: '0', left: '0', width: '100%', height: '100%',
            background: 'rgba(50, 0, 0, 0.96)', color: '#fff', fontFamily: 'Consolas, monospace',
            padding: '40px', zIndex: '999999', overflow: 'auto', display: 'flex', flexDirection: 'column',
            backdropFilter: 'blur(5px)'
        });

        const report = this.createFullReport(msg, source, line, error);

        bsod.innerHTML = `
            <h1 style="color: #ff5555; margin: 0 0 20px 0;">‚ò†Ô∏è CRITICAL FAILURE</h1>
            <p style="font-size: 16px; color: #ffaaaa; margin-bottom: 30px;">
                The game encountered an unrecoverable error.
            </p>
            
            <div style="background: #220000; padding: 20px; border: 1px solid #ff4444; border-radius: 6px; margin-bottom: 20px;">
                <div style="color: #ff5555; font-weight: bold; margin-bottom: 10px;">EPOCH ERROR: ${msg}</div>
                <div style="color: #999; font-size: 12px;">${source}:${line}</div>
                <pre style="color: #ccc; margin-top: 15px; font-size: 12px; overflow-x: auto;">${error?.stack || 'No stack trace available'}</pre>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="btn-copy-report" style="padding: 12px 24px; background: #fff; color: #800; border: none; font-weight: bold; cursor: pointer; border-radius: 4px;">
                    üìã COPY FULL DEBUG REPORT
                </button>
                <button onclick="location.reload()" style="padding: 12px 24px; background: #444; color: #fff; border: none; cursor: pointer; border-radius: 4px;">
                    üîÑ RELOAD GAME
                </button>
            </div>
            
            <p style="margin-top: 20px; color: #666; font-size: 12px;">
                Please send this report to the developer.
            </p>
        `;

        document.body.appendChild(bsod);

        document.getElementById('btn-copy-report')!.onclick = () => {
            navigator.clipboard.writeText(report).then(() => {
                const btn = document.getElementById('btn-copy-report')!;
                btn.innerText = '‚úÖ COPIED!';
                btn.style.background = '#4f4';
                btn.style.color = '#000';
            });
        };
    }

    private createFullReport(msg: string, source: string, line: number, error: any): string {
        const report = {
            timestamp: new Date().toISOString(),
            error: {
                message: msg,
                source: `${source}:${line}`,
                stack: error?.stack,
            },
            system: {
                ua: navigator.userAgent,
                resolution: `${window.innerWidth}x${window.innerHeight}`,
                time: performance.now().toFixed(2) + 'ms'
            },
            logs: Logger.getHistory(), // Last 200 logs
            // Ideally we would dump GameState here, but we lack reference. 
            // The logs should contain enough info if properly instrumented.
        };

        return JSON.stringify(report, null, 2);
    }
}
</file>

<file path="src/editor/EditorToolbar.ts">
import { UIUtils } from '../UIUtils';
import { VISUALS } from '../VisualConfig';

export type EditorMode =
    | 'paint_road'
    | 'paint_grass'
    | 'set_start'
    | 'set_end'
    | 'place_waypoint'
    | 'eraser'
    | 'paint_fog'
    | 'place_stone'
    | 'place_rock'
    | 'place_tree'
    | 'place_wheat'
    | 'place_flowers';

interface ITool {
    id: EditorMode;
    label: string;
    icon: string;
    color: string;
    hotkey?: string;
}

interface IToolCategory {
    id: string;
    name: string;
    icon: string;
    tools: ITool[];
}

export class EditorToolbar {
    private container: HTMLElement;
    private categoriesContainer: HTMLElement;
    private toolsContainer: HTMLElement;

    private categories: IToolCategory[] = [];
    private selectedCategory: number = 0;
    private onModeChange: (mode: EditorMode) => void;

    constructor(onModeChange: (mode: EditorMode) => void) {
        this.onModeChange = onModeChange;

        // Define categories
        this.categories = [
            {
                id: 'environment',
                name: '–û–∫—Ä—É–∂–µ–Ω–∏–µ',
                icon: 'üå≤',
                tools: [
                    { id: 'paint_grass', label: '–¢—Ä–∞–≤–∞', icon: 'üå≤', color: '#388e3c' },
                    { id: 'paint_road', label: '–î–æ—Ä–æ–≥–∞', icon: 'üü´', color: '#795548' },
                    { id: 'paint_fog', label: '–¢—É–º–∞–Ω', icon: 'üå´Ô∏è', color: '#607d8b' },
                ]
            },
            {
                id: 'path',
                name: '–ü—É—Ç—å',
                icon: 'üö©',
                tools: [
                    { id: 'set_start', label: '–°—Ç–∞—Ä—Ç', icon: 'üèÅ', color: '#00bcd4' },
                    { id: 'set_end', label: '–§–∏–Ω–∏—à', icon: 'üõë', color: '#e91e63' },
                    { id: 'place_waypoint', label: '–¢–æ—á–∫–∞', icon: 'üìç', color: '#9c27b0' },
                ]
            },
            {
                id: 'objects',
                name: '–û–±—ä–µ–∫—Ç—ã',
                icon: 'ü™®',
                tools: [
                    { id: 'place_stone', label: '–ö–∞–º–Ω–∏', icon: 'ü™®', color: '#757575' },
                    { id: 'place_rock', label: '–°–∫–∞–ª—ã', icon: '‚õ∞Ô∏è', color: '#616161' },
                    { id: 'place_tree', label: '–õ–µ—Å', icon: 'üå≤', color: '#2e7d32' },
                    { id: 'place_wheat', label: '–ü—à–µ–Ω–∏—Ü–∞', icon: 'üåæ', color: '#f9a825' },
                    { id: 'place_flowers', label: '–¶–≤–µ—Ç—ã', icon: 'üå∏', color: '#c2185b' },
                ]
            },
            {
                id: 'erase',
                name: '–°—Ç–µ—Ä–µ—Ç—å',
                icon: 'üßπ',
                tools: [
                    { id: 'eraser', label: '–õ–∞—Å—Ç–∏–∫', icon: 'üßπ', color: '#ff6600', hotkey: 'E' },
                ]
            }
        ];

        this.container = this.createContainer();
        this.categoriesContainer = this.createCategoriesView();
        this.toolsContainer = this.createToolsView();

        this.container.appendChild(this.categoriesContainer);
        this.container.appendChild(this.toolsContainer);

        document.body.appendChild(this.container);

        this.selectCategory(0);
    }

    private createContainer(): HTMLElement {
        return UIUtils.createContainer({
            position: 'absolute',
            bottom: '20px',
            left: '50%',
            transform: 'translateX(-50%)',
            display: 'flex',
            flexDirection: 'column',
            gap: `${VISUALS.UI.SPACING.sm}px`,
            padding: `${VISUALS.UI.SPACING.md}px`,
            background: VISUALS.UI.COLORS.glass.bgDark,
            borderRadius: VISUALS.UI.BORDERS.radius.lg,
            zIndex: '1000'
        });
    }

    private createCategoriesView(): HTMLElement {
        const container = document.createElement('div');
        Object.assign(container.style, {
            display: 'flex',
            gap: `${VISUALS.UI.SPACING.xs}px`,
            borderBottom: `${VISUALS.UI.BORDERS.width.normal} solid #444`,
            paddingBottom: `${VISUALS.UI.SPACING.sm}px`
        });

        this.categories.forEach((cat, idx) => {
            const btn = document.createElement('button');
            btn.textContent = `${cat.icon} ${cat.name}`;
            btn.dataset.categoryIndex = idx.toString();

            Object.assign(btn.style, {
                background: VISUALS.UI.COLORS.neutral.medium,
                color: VISUALS.UI.COLORS.text.primary,
                border: `${VISUALS.UI.BORDERS.width.normal} solid ${VISUALS.UI.COLORS.neutral.light}`,
                padding: `${VISUALS.UI.SPACING.sm}px ${VISUALS.UI.SPACING.lg}px`,
                borderRadius: VISUALS.UI.BORDERS.radius.md,
                cursor: 'pointer',
                fontSize: VISUALS.UI.FONTS.size.md,
                fontWeight: VISUALS.UI.FONTS.weight.bold,
                transition: VISUALS.UI.TRANSITIONS.presets.fast
            });

            btn.onclick = () => this.selectCategory(idx);
            container.appendChild(btn);
        });

        return container;
    }

    private createToolsView(): HTMLElement {
        const container = document.createElement('div');
        Object.assign(container.style, {
            display: 'flex',
            gap: '8px',
            flexWrap: 'wrap'
        });

        return container;
    }

    public selectCategory(index: number): void {
        if (index < 0 || index >= this.categories.length) return;

        this.selectedCategory = index;

        // Update category button states
        const categoryBtns = this.categoriesContainer.querySelectorAll('button');
        categoryBtns.forEach((btn, idx) => {
            if (idx === index) {
                Object.assign((btn as HTMLElement).style, {
                    background: VISUALS.UI.COLORS.info,
                    borderColor: '#2196f3',
                    transform: 'translateY(-2px)'
                });
            } else {
                Object.assign((btn as HTMLElement).style, {
                    background: VISUALS.UI.COLORS.neutral.medium,
                    borderColor: VISUALS.UI.COLORS.neutral.light,
                    transform: 'translateY(0)'
                });
            }
        });

        // Update tools display
        this.renderTools();
    }

    private renderTools(): void {
        this.toolsContainer.innerHTML = '';

        const category = this.categories[this.selectedCategory];

        category.tools.forEach(tool => {
            const btn = document.createElement('button');
            btn.textContent = `${tool.icon} ${tool.label}`;
            if (tool.hotkey) {
                btn.textContent += ` (${tool.hotkey})`;
            }

            Object.assign(btn.style, {
                background: tool.color,
                color: VISUALS.UI.COLORS.text.primary,
                border: `${VISUALS.UI.BORDERS.width.thin} solid ${VISUALS.UI.COLORS.glass.borderHover}`,
                padding: `${VISUALS.UI.SPACING.sm}px ${VISUALS.UI.SPACING.lg}px`,
                borderRadius: VISUALS.UI.BORDERS.radius.md,
                cursor: 'pointer',
                fontSize: VISUALS.UI.FONTS.size.md,
                fontWeight: VISUALS.UI.FONTS.weight.bold,
                transition: VISUALS.UI.TRANSITIONS.presets.fast
            });

            btn.onmouseenter = () => {
                btn.style.transform = 'scale(1.05)';
                btn.style.boxShadow = VISUALS.UI.SHADOWS.md;
            };

            btn.onmouseleave = () => {
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = 'none';
            };

            btn.onclick = () => {
                console.log('[EditorToolbar] Tool clicked:', tool.id, tool.label);
                this.onModeChange(tool.id);
            };

            this.toolsContainer.appendChild(btn);
        });
    }

    public show(): void {
        this.container.style.display = 'flex';
    }

    public hide(): void {
        this.container.style.display = 'none';
    }

    public destroy(): void {
        if (this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
    }
}
</file>

<file path="src/editor/EnemyRegistry.ts">
import { ENEMY_TYPES, ENEMY_CONFIG } from '../config/Enemies';
import { IEnemyTypeConfig } from '../types';

/**
 * Service to provide access to enemy data for the editor.
 * Wraps the raw configuration to provide helper methods.
 */
export class EnemyRegistry {
    /**
     * Get all available enemy types as an array of entries
     */
    public static getAllEntries(): { key: string; config: IEnemyTypeConfig }[] {
        return Object.entries(ENEMY_TYPES).map(([key, config]) => ({ key, config }));
    }

    /**
     * Get all available enemy types (values only)
     * @deprecated Use getAllEntries for keys
     */
    public static getAllTypes(): IEnemyTypeConfig[] {
        return Object.values(ENEMY_TYPES).filter(e => !e.isHidden);
    }

    /**
     * Get enemy types visible in editor (excludes isHidden)
     */
    public static getVisibleForEditor(): IEnemyTypeConfig[] {
        return Object.values(ENEMY_TYPES).filter(e => !e.isHidden);
    }

    /**
     * Get a specific enemy type by ID (Case insensitive check)
     */
    public static getType(id: string): IEnemyTypeConfig | undefined {
        const key = id.toUpperCase();
        return ENEMY_TYPES[key] || Object.values(ENEMY_TYPES).find(t => t.id === id);
    }

    /**
     * Get enemy types used for dropdowns (keys)
     */
    public static getTypeKeys(): string[] {
        return Object.keys(ENEMY_TYPES);
    }

    /**
     * Calculates an approximate "Power Rating" for a single unit of this type.
     * Used for sorting or rough estimation.
     * Formula: Effective HP * Speed Factor
     */
    public static getPowerRating(typeId: string): number {
        const type = this.getType(typeId);
        if (!type) return 0;

        const hp = ENEMY_CONFIG.BASE_HP * type.hpMod;
        // Normalizing speed: 60 (1 tile/sec) is baseline 1.0
        const speedFactor = type.speed / 60;

        return hp * speedFactor;
    }

    /**
     * Returns types sorted by their Power Rating (weakest to strongest)
     */
    public static getTypesSortedByPower(): IEnemyTypeConfig[] {
        return this.getAllTypes().sort((a, b) => {
            return this.getPowerRating(a.id) - this.getPowerRating(b.id);
        });
    }
}
</file>

<file path="src/EventBus.ts">
/**
 * Event Bus Module
 * Decouples game systems using the Observer pattern.
 */

export type EventCallback<T = any> = (data: T) => void;

interface IEventSubscription {
    id: number;
    event: string;
    callback: EventCallback;
}

export class EventBus {
    private static instance: EventBus;
    private subscribers: Map<string, IEventSubscription[]> = new Map();
    private nextId: number = 0;

    private constructor() { }

    public static getInstance(): EventBus {
        if (!EventBus.instance) {
            EventBus.instance = new EventBus();
        }
        return EventBus.instance;
    }

    /**
     * Subscribe to an event
     * @param event Event name (use constants from Events object)
     * @param callback Function to call when event is emitted
     * @returns Subscription ID (can be used to unsubscribe)
     */
    public on<T = any>(event: string, callback: EventCallback<T>): number {
        const id = this.nextId++;
        if (!this.subscribers.has(event)) {
            this.subscribers.set(event, []);
        }
        this.subscribers.get(event)!.push({ id, event, callback });
        return id;
    }

    /**
     * Unsubscribe using the ID returned by on()
     */
    public off(id: number): void {
        this.subscribers.forEach((subs, event) => {
            const index = subs.findIndex(s => s.id === id);
            if (index !== -1) {
                subs.splice(index, 1);
            }
        });
    }

    /**
     * Emit an event with data
     */
    public emit<T = any>(event: string, data?: T): void {
        if (!this.subscribers.has(event)) return;
        this.subscribers.get(event)!.forEach(sub => sub.callback(data));
    }

    /**
     * Clear all subscribers (useful for scene transitions)
     */
    public clear(): void {
        this.subscribers.clear();
    }
}

// Define Event Constants for type safety type feeling
export const Events = {
    // Economy
    MONEY_CHANGED: 'MONEY_CHANGED', // data: number (new amount)
    LIVES_CHANGED: 'LIVES_CHANGED', // data: number (new amount)

    // Wave
    WAVE_STARTED: 'WAVE_STARTED',   // data: number (wave index)
    WAVE_COMPLETED: 'WAVE_COMPLETED', // data: number (wave index)

    // Game State
    GAME_OVER: 'GAME_OVER',         // data: number (final wave)
    GAME_RESTART: 'GAME_RESTART',   // void

    // UI
    TOGGLE_PAUSE: 'TOGGLE_PAUSE',   // data: boolean (isPaused)
    ENEMY_IMMUNE: 'ENEMY_IMMUNE',   // data: { x: number, y: number }
    ENEMY_DIED: 'ENEMY_DIED',       // data: { enemy: Enemy }
    ENEMY_SPAWNED: 'ENEMY_SPAWNED', // data: string (enemyType)
    SPAWN_PUDDLE: 'SPAWN_PUDDLE',   // data: { x: number, y: number }
};
</file>

<file path="src/Pathfinder.ts">
import { Cell } from './MapData';

export class Pathfinder {
    // –ù–∞—Ö–æ–¥–∏—Ç –ø—É—Ç—å –æ—Ç start –¥–æ end, –∏—Å–ø–æ–ª—å–∑—É—è —Ç–æ–ª—å–∫–æ —Ç–∞–π–ª—ã —Ç–∏–ø–∞ 1 (Path)
    // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç {x, y} –∏–ª–∏ –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤, –µ—Å–ª–∏ –ø—É—Ç–∏ –Ω–µ—Ç
    public static findPath(
        grid: Cell[][],
        start: { x: number; y: number },
        end: { x: number; y: number },
    ): { x: number; y: number }[] {
        const rows = grid.length;
        const cols = grid[0].length;

        // –û—á–µ—Ä–µ–¥—å –¥–ª—è BFS: [ {x, y}, [path_so_far] ]
        const queue: { pos: { x: number; y: number }; path: { x: number; y: number }[] }[] = [];
        queue.push({ pos: start, path: [start] });

        const visited = new Set<string>();
        visited.add(`${start.x},${start.y}`);

        const directions = [
            { dx: 0, dy: -1 }, // Up
            { dx: 1, dy: 0 }, // Right
            { dx: 0, dy: 1 }, // Down
            { dx: -1, dy: 0 }, // Left
        ];

        while (queue.length > 0) {
            const { pos, path } = queue.shift()!;

            if (pos.x === end.x && pos.y === end.y) {
                return path;
            }

            for (const dir of directions) {
                const nx = pos.x + dir.dx;
                const ny = pos.y + dir.dy;
                const key = `${nx},${ny}`;

                if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !visited.has(key)) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –¥–æ—Ä–æ–≥–∞ (type === 1) –ò–õ–ò —ç—Ç–æ –∫–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞ (–¥–∞–∂–µ –µ—Å–ª–∏ –º—ã –µ—ë —Å–ª—É—á–∞–π–Ω–æ –∑–∞–∫—Ä–∞—Å–∏–ª–∏ —Ç—Ä–∞–≤–æ–π, —Ö–æ—Ç—è –ø–æ –ª–æ–≥–∏–∫–µ –æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–∞ –¥–æ—Ä–æ–≥–µ)
                    // –ù–æ –ª—É—á—à–µ —Å—Ç—Ä–æ–≥–æ: —Ö–æ–¥–∏—Ç—å –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –ø–æ –¥–æ—Ä–æ–≥–µ.
                    const cell = grid[ny][nx];
                    if (cell.type === 1) {
                        visited.add(key);
                        queue.push({ pos: { x: nx, y: ny }, path: [...path, { x: nx, y: ny }] });
                    }
                }
            }
        }

        return [];
    }
}
</file>

<file path="src/RendererFactory.ts">
import { Tower } from './Tower';
import { Enemy } from './Enemy';
import { MapManager } from './Map';
import { Projectile } from './Projectile';
import { TowerRenderer } from './renderers/TowerRenderer';
import { EnemyRenderer } from './renderers/EnemyRenderer';
import { SpriteProjectileRenderer } from './renderers/SpriteProjectileRenderer';
import { IEffect } from './EffectSystem';
// SpriteEffectRenderer is currently inline in EffectSystem.ts, we will handle that there.

export class RendererFactory {
    static drawTower(ctx: CanvasRenderingContext2D, tower: Tower) {
        // Draw Both (Legacy/Default)
        TowerRenderer.drawSprite(ctx, tower);
        TowerRenderer.drawUI(ctx, tower);
    }

    static drawTowerSprite(ctx: CanvasRenderingContext2D, tower: Tower) {
        TowerRenderer.drawSprite(ctx, tower);
    }

    static drawTowerUI(ctx: CanvasRenderingContext2D, tower: Tower) {
        TowerRenderer.drawUI(ctx, tower);
    }

    static drawEnemy(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        // Draw Both (Legacy/Default)
        EnemyRenderer.drawSprite(ctx, enemy);
        EnemyRenderer.drawUI(ctx, enemy);
    }

    static drawEnemySprite(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        EnemyRenderer.drawSprite(ctx, enemy);
    }

    static drawEnemyUI(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        EnemyRenderer.drawUI(ctx, enemy);
    }

    static drawMap(ctx: CanvasRenderingContext2D, map: MapManager) {
        map.draw(ctx);
    }

    static drawProjectile(ctx: CanvasRenderingContext2D, projectile: Projectile) {
        SpriteProjectileRenderer.draw(ctx, projectile);
    }

    static drawEffect(ctx: CanvasRenderingContext2D, effect: IEffect) {
        return false; // Return false to fallback to default logic in EffectSystem
    }
}
</file>

<file path="src/renderers/units/SkeletonUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import type { Enemy } from '../../Enemy';

export class SkeletonUnitRenderer implements UnitRenderer {
    // Palette
    private static readonly BONE_LIGHT = '#e0d0b0';
    private static readonly BONE_DARK = '#a89070';
    private static readonly BONE_OUTLINE = '#5d4037';
    private static readonly RED_GLOW = '#d32f2f';
    private static readonly ARMOR_DARK = '#2d2d2d';
    private static readonly ARMOR_LIGHT = '#546e7a';

    // Config
    private static readonly HEAD_RADIUS = 5.5;

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.001; // Use seconds
        // baseSpeed is ~90 px/sec. 90 * 0.15 = 13.5 rad/sec (~2 steps/sec)
        const walkCycle = time * (enemy.baseSpeed * 0.15);
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';

        // Rotation Logic
        const r = rotation;
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        ctx.save();

        // Hit Flash Effect
        if (enemy.hitFlashTimer > 0) {
            ctx.filter = 'brightness(1000%)';
        }

        if (facing === 'SIDE') {
            // Flip for Left Facing
            if (Math.abs(rotation) > Math.PI / 2) {
                ctx.scale(-1, 1);
            }
            this.drawSide(ctx, scale, walkCycle, isMoving);
        } else if (facing === 'UP') {
            this.drawBack(ctx, scale, walkCycle, isMoving);
        } else {
            this.drawFront(ctx, scale, walkCycle, isMoving);
        }

        ctx.restore();
    }

    // === FRONT VIEW (Walking Down) ===
    private drawFront(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;

        // Feet
        const leftFootY = isMoving ? Math.sin(walkCycle) * 4 * scale + (8 * scale) : 8 * scale;
        const rightFootY = isMoving ? Math.sin(walkCycle + Math.PI) * 4 * scale + (8 * scale) : 8 * scale;
        this.drawFoot(ctx, -5 * scale, leftFootY, scale);
        this.drawFoot(ctx, 5 * scale, rightFootY, scale);

        ctx.translate(0, -bounce);

        // Torso/Armor (Layer 1 - Behind items)
        this.drawTorsoFront(ctx, scale);

        // Arms (Swaying)
        const armSway = isMoving ? Math.sin(walkCycle) * 0.2 : 0;

        // Left (Shield)
        ctx.save();
        ctx.translate(-11 * scale, 0 + armSway * 5 * scale);
        // Arm Bone
        this.drawBoneArm(ctx, scale, 0);
        // Shield facing camera
        ctx.translate(0, 6 * scale);
        this.drawShieldFront(ctx, scale);
        ctx.restore();

        // Right (Sword)
        ctx.save();
        ctx.translate(11 * scale, 0 - armSway * 5 * scale);
        this.drawBoneArm(ctx, scale, 0);
        ctx.translate(0, 6 * scale);
        this.drawSwordFront(ctx, scale);
        ctx.restore();

        // Head
        ctx.translate(0, -5 * scale); // Neck height
        this.drawSkullFront(ctx, scale);
    }

    // === BACK VIEW (Walking Up) ===
    private drawBack(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;

        // Feet
        const leftFootY = isMoving ? Math.sin(walkCycle) * 4 * scale : 0;
        const rightFootY = isMoving ? Math.sin(walkCycle + Math.PI) * 4 * scale : 0;
        this.drawFoot(ctx, -5 * scale, leftFootY - 2 * scale, scale);
        this.drawFoot(ctx, 5 * scale, rightFootY - 2 * scale, scale);

        ctx.translate(0, -bounce);

        // Arms (Layer 0 - Before Body)
        const armSway = isMoving ? Math.sin(walkCycle) * 0.2 : 0;

        // Left Item (Shield - Back view)
        ctx.save();
        ctx.translate(-11 * scale, 0 - armSway * 5 * scale);
        this.drawBoneArm(ctx, scale, 0);
        ctx.translate(0, 6 * scale);
        this.drawShieldBack(ctx, scale);
        ctx.restore();

        // Right Item (Sword - Back view)
        ctx.save();
        ctx.translate(11 * scale, 0 + armSway * 5 * scale);
        this.drawBoneArm(ctx, scale, 0);
        ctx.translate(0, 6 * scale);
        this.drawSwordBack(ctx, scale);
        ctx.restore();

        // Torso Back 
        this.drawTorsoBack(ctx, scale);

        // Head
        ctx.translate(0, -5 * scale);
        this.drawSkullBack(ctx, scale);
    }

    // === SIDE VIEW (Walking Right) ===
    private drawSide(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;

        // Feet (Scissor)
        const stride = 5 * scale;
        const leftFootX = isMoving ? Math.sin(walkCycle) * stride : 0;
        const rightFootX = isMoving ? -Math.sin(walkCycle) * stride : 0;
        this.drawFoot(ctx, leftFootX, 8 * scale, scale);
        this.drawFoot(ctx, rightFootX, 8 * scale, scale);

        ctx.translate(0, -bounce);

        // Back Arm (Shield) - Behind Torso
        const armSway = isMoving ? Math.cos(walkCycle) * 0.6 : 0;
        ctx.save();
        ctx.translate(-3 * scale, 0 - armSway * 5 * scale);
        ctx.rotate(-0.2); // Angle back
        this.drawBoneArm(ctx, scale, 0);
        ctx.translate(0, 6 * scale);
        // Shield Profile (Edge)
        this.drawShieldSide(ctx, scale);
        ctx.restore();

        // Torso Side
        this.drawTorsoSide(ctx, scale);

        // Front Arm (Sword) - In Front of Torso
        ctx.save();
        ctx.translate(3 * scale, 1 * scale + armSway * 5 * scale);
        ctx.rotate(0.2); // Angle forward
        this.drawBoneArm(ctx, scale, 0);
        ctx.translate(0, 6 * scale);
        this.drawSwordSide(ctx, scale);
        ctx.restore();

        // Head
        ctx.translate(1 * scale, -5 * scale); // Shift fwd slightly
        this.drawSkullSide(ctx, scale);
    }

    // --- BODY PARTS ---

    private drawTorsoFront(ctx: CanvasRenderingContext2D, scale: number) {
        // Ribcage / Armor Plate
        ctx.fillStyle = SkeletonUnitRenderer.ARMOR_DARK;
        ctx.beginPath();
        // Trapezoid shape
        ctx.moveTo(-7 * scale, -7 * scale); // Shoulders
        ctx.lineTo(7 * scale, -7 * scale);
        ctx.lineTo(5 * scale, 5 * scale); // Waist
        ctx.lineTo(-5 * scale, 5 * scale);
        ctx.fill();

        // Rib details
        ctx.strokeStyle = SkeletonUnitRenderer.BONE_LIGHT;
        ctx.lineWidth = 2 * scale;
        ctx.beginPath();
        ctx.moveTo(-4 * scale, -2 * scale); ctx.lineTo(4 * scale, -2 * scale);
        ctx.moveTo(-3 * scale, 1 * scale); ctx.lineTo(3 * scale, 1 * scale);
        ctx.stroke();
    }

    private drawTorsoBack(ctx: CanvasRenderingContext2D, scale: number) {
        // Spine / Armor Plate
        ctx.fillStyle = SkeletonUnitRenderer.ARMOR_DARK;
        ctx.beginPath();
        ctx.moveTo(-7 * scale, -7 * scale);
        ctx.lineTo(7 * scale, -7 * scale);
        ctx.lineTo(5 * scale, 5 * scale);
        ctx.lineTo(-5 * scale, 5 * scale);
        ctx.fill();

        // Spine details
        ctx.strokeStyle = SkeletonUnitRenderer.BONE_DARK;
        ctx.lineWidth = 3 * scale;
        ctx.beginPath();
        ctx.moveTo(0, -6 * scale);
        ctx.lineTo(0, 4 * scale);
        ctx.stroke();
    }

    private drawTorsoSide(ctx: CanvasRenderingContext2D, scale: number) {
        ctx.fillStyle = SkeletonUnitRenderer.ARMOR_DARK;
        ctx.beginPath();
        ctx.ellipse(0, -1 * scale, 4 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawBoneArm(ctx: CanvasRenderingContext2D, scale: number, angle: number) {
        ctx.strokeStyle = SkeletonUnitRenderer.BONE_LIGHT;
        ctx.lineWidth = 2.5 * scale;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, 6 * scale);
        ctx.stroke();
    }

    private drawFoot(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = SkeletonUnitRenderer.BONE_DARK;
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.5 * scale, 3.5 * scale, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // --- HEADS ---

    private drawSkullFront(ctx: CanvasRenderingContext2D, scale: number) {
        const r = SkeletonUnitRenderer.HEAD_RADIUS * scale;
        // Cranium
        ctx.fillStyle = SkeletonUnitRenderer.BONE_LIGHT;
        ctx.beginPath();
        ctx.arc(0, -2 * scale, r, 0, Math.PI * 2);
        ctx.fill();
        // Jaw
        ctx.beginPath();
        ctx.rect(-2.5 * scale, 2 * scale, 5 * scale, 2.5 * scale);
        ctx.fill();

        // Eyes
        const eyeY = 0 * scale;
        const eyeX = 2 * scale;
        const eyeSize = 1.8 * scale;
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(-eyeX, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeX, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();

        // Glow
        ctx.fillStyle = SkeletonUnitRenderer.RED_GLOW;
        const glowSize = 0.6 * scale;
        ctx.beginPath(); ctx.arc(-eyeX, eyeY, glowSize, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeX, eyeY, glowSize, 0, Math.PI * 2); ctx.fill();
    }

    private drawSkullBack(ctx: CanvasRenderingContext2D, scale: number) {
        const r = SkeletonUnitRenderer.HEAD_RADIUS * scale;
        ctx.fillStyle = SkeletonUnitRenderer.BONE_LIGHT;
        ctx.beginPath();
        ctx.arc(0, -2 * scale, r, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawSkullSide(ctx: CanvasRenderingContext2D, scale: number) {
        const r = SkeletonUnitRenderer.HEAD_RADIUS * scale;
        ctx.fillStyle = SkeletonUnitRenderer.BONE_LIGHT;
        ctx.beginPath();
        ctx.arc(-1 * scale, -2 * scale, r, 0, Math.PI * 2); // Shift back
        ctx.fill();

        // Snout
        ctx.beginPath();
        ctx.fillRect(1 * scale, 0, 3 * scale, 3 * scale);

        // Eye (One)
        const eyeX = 3 * scale;
        const eyeY = -0.5 * scale;
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.ellipse(eyeX, eyeY, 1.5 * scale, 2 * scale, 0, 0, Math.PI * 2); ctx.fill();

        ctx.fillStyle = SkeletonUnitRenderer.RED_GLOW;
        ctx.beginPath(); ctx.arc(eyeX + 0.5 * scale, eyeY, 0.6 * scale, 0, Math.PI * 2); ctx.fill();
    }

    // --- ITEMS ---

    private drawSwordFront(ctx: CanvasRenderingContext2D, scale: number) {
        // Pointing down/forward
        ctx.fillStyle = '#cfd8dc';
        ctx.beginPath();
        ctx.moveTo(-1 * scale, 0); ctx.lineTo(1 * scale, 0);
        ctx.lineTo(0, 14 * scale);
        ctx.fill();
        // Hilt
        ctx.fillStyle = SkeletonUnitRenderer.ARMOR_LIGHT;
        ctx.fillRect(-3 * scale, -1 * scale, 6 * scale, 1 * scale);
    }

    private drawSwordSide(ctx: CanvasRenderingContext2D, scale: number) {
        // Held forward (horizontalish)
        ctx.save();
        ctx.rotate(-Math.PI / 4); // Angle up slightly
        ctx.fillStyle = '#cfd8dc';
        ctx.fillRect(0, -1 * scale, 14 * scale, 2 * scale); // Blade
        ctx.fillStyle = SkeletonUnitRenderer.ARMOR_LIGHT;
        ctx.fillRect(0, -3 * scale, 2 * scale, 6 * scale); // Guard
        ctx.restore();
    }

    private drawSwordBack(ctx: CanvasRenderingContext2D, scale: number) {
        // Same as front but maybe darker?
        this.drawSwordFront(ctx, scale);
    }

    private drawShieldFront(ctx: CanvasRenderingContext2D, scale: number) {
        ctx.fillStyle = '#5d4037';
        ctx.beginPath(); ctx.arc(0, 3 * scale, 6 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = '#8d6e63';
        ctx.lineWidth = 2 * scale;
        ctx.stroke();
    }

    private drawShieldSide(ctx: CanvasRenderingContext2D, scale: number) {
        // Thin profile
        ctx.fillStyle = '#5d4037';
        ctx.beginPath();
        ctx.ellipse(0, 3 * scale, 1.5 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#8d6e63';
        ctx.lineWidth = 1 * scale;
        ctx.stroke();
    }

    private drawShieldBack(ctx: CanvasRenderingContext2D, scale: number) {
        // Back of shield (wood planks, straps)
        ctx.fillStyle = '#3e2723'; // Darker wood
        ctx.beginPath(); ctx.arc(0, 3 * scale, 6 * scale, 0, Math.PI * 2); ctx.fill();
        // Handle strap
        ctx.fillStyle = '#111';
        ctx.fillRect(-2 * scale, 2 * scale, 4 * scale, 2 * scale);
    }
}
</file>

<file path="src/Scene.ts">
export interface Scene {
    // –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏ –Ω–∞ —ç—Ç—É —Å—Ü–µ–Ω—É
    onEnter(): void;

    // –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —É—Ö–æ–¥–µ —Å–æ —Å—Ü–µ–Ω—ã
    onExit(): void;

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–æ–≥–∏–∫–∏ (60 —Ä–∞–∑ –≤ —Å–µ–∫)
    update(dt: number): void;

    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
    draw(ctx: CanvasRenderingContext2D): void;
}
</file>

<file path="src/scenes/GameState.ts">
import { CONFIG } from '../Config';
import { Enemy } from '../Enemy';
import { Tower } from '../Tower';
import { Projectile } from '../Projectile';
import { ObjectPool } from '../Utils';
import { EventBus, Events } from '../EventBus';

/**
 * Manages game state (money, lives, wave, pause) and provides state mutation methods.
 * Emits events when state changes occur.
 */
export class GameState {
    // Core state
    public wave: number = 0;
    public lives: number = CONFIG.PLAYER.START_LIVES;
    public money: number = CONFIG.PLAYER.START_MONEY;
    public paused: boolean = false;
    public isRunning: boolean = true;
    public timeScale: number = 1.0;

    // Entity collections
    public enemies: Enemy[] = [];
    public towers: Tower[] = [];
    // public projectiles: Projectile[] = []; // MOVED to ProjectileSystem

    // Object pools
    // public projectilePool: ObjectPool<Projectile>; // MOVED to ProjectileSystem
    public enemyPool: ObjectPool<Enemy>;

    // Selection state
    public selectedTower: Tower | null = null;

    // Animation state
    public frames: number = 0;
    public shakeTimer: number = 0;
    public shakeIntensity: number = 0;

    private eventBus: EventBus = EventBus.getInstance();

    constructor() {
        // this.projectilePool = new ObjectPool(() => new Projectile());
        this.enemyPool = new ObjectPool(() => new Enemy());
    }



    // === Reset (for restart) ===
    public reset(): void {
        this.wave = 0;
        this.lives = CONFIG.PLAYER.START_LIVES;
        this.money = CONFIG.PLAYER.START_MONEY;
        this.paused = false;
        this.isRunning = true;
        this.timeScale = 1.0;
        this.frames = 0;
        this.shakeTimer = 0;
        this.shakeIntensity = 0;
        this.selectedTower = null;

        // Clear entities
        this.enemies = [];
        this.towers = [];
        // this.projectiles = []; // MOVED
    }

    // === Money Management ===
    public addMoney(amount: number): void {
        this.money += amount;
        this.eventBus.emit(Events.MONEY_CHANGED, this.money);
    }

    public spendMoney(amount: number): boolean {
        if (this.money >= amount) {
            this.money -= amount;
            this.eventBus.emit(Events.MONEY_CHANGED, this.money);
            return true;
        }
        return false;
    }

    // === Lives Management ===
    public loseLife(amount: number = 1, effects?: any): void {
        this.lives -= amount;
        this.eventBus.emit(Events.LIVES_CHANGED, this.lives);

        // Red screen flash on damage
        if (effects) {
            effects.add({
                type: 'screen_flash',
                x: 0,
                y: 0,
                life: 15,
                flashColor: 'rgba(255, 0, 0, ',
            });
        }

        if (this.lives <= 0) {
            this.eventBus.emit(Events.GAME_OVER, this.wave);
            this.isRunning = false;
        }
    }

    // === Wave Management ===
    public incrementWave(): void {
        this.wave++;
    }

    // === Pause Management ===
    public togglePause(): void {
        this.paused = !this.paused;
        this.eventBus.emit(Events.TOGGLE_PAUSE, this.paused);
    }

    // === Screen Shake ===
    public triggerShake(duration: number, intensity: number): void {
        this.shakeTimer = duration;
        this.shakeIntensity = intensity;
    }

    public updateShake(): void {
        if (this.shakeTimer > 0) {
            this.shakeTimer--;
        }
    }

    // === Tower Selection ===
    public selectTower(tower: Tower | null): void {
        this.selectedTower = tower;
    }

    // === Time Scale ===
    public setTimeScale(scale: number): void {
        this.timeScale = Math.max(1.0, Math.min(scale, 2.0)); // Clamp between 1x and 2x
    }

    public toggleTimeScale(): void {
        this.timeScale = (this.timeScale === 1.0) ? 2.0 : 1.0;
    }

    // === Game Over ===
    public endGame(): void {
        this.isRunning = false;
    }
}
</file>

<file path="src/SoundManager.ts">
export enum SoundPriority {
    LOW = 0,
    HIGH = 1
}

export class SoundManager {
    private static ctx: AudioContext;
    private static buffers: Record<string, AudioBuffer> = {};
    private static lastPlayed: Record<string, number> = {};
    private static lastPlayedType: Record<string, number> = {}; // Track last play time by TYPE

    // Config
    private static CULL_MS = 50; // Minimum time between same sounds (Legacy logic)
    private static THROTTLE_MS = 60; // Global throttle for identical sounds
    public static MASTER_VOLUME = 0.3; // Made public for settings
    public static SFX_VOLUME = 1.0;
    public static MUSIC_VOLUME = 0.5;

    public static setVolume(master: number) {
        this.MASTER_VOLUME = Math.max(0, Math.min(1, master));
    }

    public static async init() {
        if (this.ctx) return;

        try {
            // @ts-ignore - Handle webkit prefix for older browsers if needed
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContextClass();
            console.log('SoundManager: AudioContext initialized');

            // Generate basic sounds
            this.generateSounds();
        } catch (e) {
            console.error('SoundManager: Failed to init AudioContext', e);
        }
    }

    public static resume() {
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    public static play(key: string, priority: SoundPriority = SoundPriority.LOW) {
        if (!this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();

        const now = Date.now();
        const last = this.lastPlayed[key] || 0;

        // 1. Culling / Ducking logic
        // If High Priority, we always play (or maybe duck others? For now just play)
        // If Low Priority, check time since last played
        if (priority === SoundPriority.LOW) {
            // Check legacy cull (per specific key/instance if unique keys used)
            if (now - last < this.CULL_MS) {
                return;
            }

            // Global Type Throttling 
            // This prevents "shoot_basic" from playing 10 times in one frame from 10 towers
            const lastType = this.lastPlayedType[key] || 0;
            if (now - lastType < this.THROTTLE_MS) {
                return;
            }
        }

        this.lastPlayed[key] = now;
        this.lastPlayedType[key] = now;

        const buffer = this.buffers[key];
        if (!buffer) {
            // console.warn(`SoundManager: Sound '${key}' not found`);
            return;
        }

        // Create Source
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;

        // 2. Pitch Variance (Tech Trick)
        // +/- 10% (0.9 to 1.1)
        const detune = 0.9 + Math.random() * 0.2;
        source.playbackRate.value = detune;

        // Gain (Volume)
        const gainNode = this.ctx.createGain();
        let vol = this.MASTER_VOLUME * this.SFX_VOLUME;

        // Boost high priority sounds slightly
        if (priority === SoundPriority.HIGH) vol *= 1.5;

        // Randomize volume slightly too for "organic" feel
        vol *= (0.9 + Math.random() * 0.2);

        gainNode.gain.value = vol;

        // Connect
        source.connect(gainNode);
        gainNode.connect(this.ctx.destination);

        source.start();
    }

    private static generateSounds() {
        // We synthesize simple buffers
        // 1. Shoot (Sniper/Gun) - Sharp decay noise/square
        this.buffers['shoot_basic'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 20);
            return (Math.random() * 2 - 1) * decay;
        }, 0.2);

        this.buffers['shoot_sniper'] = this.createBuffer((t) => {
            // Longer, louder crack
            const decay = Math.exp(-t * 10);
            const noise = (Math.random() * 2 - 1);
            return noise * decay * 1.5; // Boost
        }, 0.5);

        // 2. Hit - High pitched tick
        this.buffers['hit'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 50);
            return Math.sin(t * 2000 * Math.PI * 2) * decay;
        }, 0.1);

        // 3. Enemy Death - Soft pop (pleasant, not annoying on repeat)
        this.buffers['death'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 25);
            // Soft bubble pop - high start, quick fade
            const freq = 400 * Math.exp(-t * 8);
            return Math.sin(t * freq * Math.PI * 2) * decay * 0.6;
        }, 0.15);

        // 4. Boss Spawn - Low droning sweep
        this.buffers['boss_spawn'] = this.createBuffer((t) => {
            const freq = 50 + Math.sin(t * 10) * 20;
            return Math.sin(t * freq * Math.PI * 2) * 0.8;
        }, 1.5);

        // 5. UI Click - Clean pip
        this.buffers['click'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 30);
            return Math.sin(t * 800 * Math.PI * 2) * decay;
        }, 0.1);

        // 6. UI Hover - Very short tick
        this.buffers['hover'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 50);
            return Math.sin(t * 1200 * Math.PI * 2) * decay * 0.2;
        }, 0.05);

        // 7. Explosion
        this.buffers['explosion'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 5);
            return (Math.random() * 2 - 1) * decay;
        }, 0.5);
    }

    private static createBuffer(fn: (t: number) => number, duration: number): AudioBuffer {
        const sampleRate = this.ctx.sampleRate;
        const frames = sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, frames, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < frames; i++) {
            data[i] = fn(i / sampleRate);
        }
        return buffer;
    }
}
</file>

<file path="src/systems/NotificationSystem.ts">
import { EffectSystem } from '../EffectSystem';
import { EventBus, Events } from '../EventBus';
import { SoundManager, SoundPriority } from '../SoundManager';

/**
 * NotificationSystem - Visual notifications for game events
 * Wave start, wave clear, boss spawn, etc.
 */
export class NotificationSystem {
    private effects: EffectSystem;
    private canvas: HTMLCanvasElement;

    // Active notifications queue
    private notifications: INotification[] = [];

    constructor(effects: EffectSystem, canvas: HTMLCanvasElement) {
        this.effects = effects;
        this.canvas = canvas;

        this.initSubscriptions();
    }

    private initSubscriptions() {
        const bus = EventBus.getInstance();

        bus.on(Events.WAVE_STARTED, (wave: number) => {
            this.showWaveStart(wave);
        });

        bus.on(Events.WAVE_COMPLETED, (wave: number) => {
            this.showWaveClear(wave);
        });

        bus.on(Events.ENEMY_IMMUNE, (data: { x: number, y: number }) => {
            this.showImmune(data.x, data.y);
        });
    }

    /**
     * Wave Start notification - big zoom-in text
     */
    public showWaveStart(waveNum: number) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;

        // Main wave text with zoom effect
        this.effects.add({
            type: 'text',
            text: `WAVE ${waveNum}`,
            x: cx,
            y: cy,
            life: 1.5, // 90 frames
            color: '#fff',
            fontSize: 48,
            vy: 0
        });

        // Subtitle
        this.effects.add({
            type: 'text',
            text: 'INCOMING',
            x: cx,
            y: cy + 50,
            life: 1.1, // 70 frames
            color: '#ff5722',
            fontSize: 24,
            vy: 0
        });

        // Screen flash (red tint)
        this.effects.add({
            type: 'screen_flash',
            x: 0,
            y: 0,
            life: 25,
            flashColor: 'rgba(255, 50, 50, '
        });

        // Sound
        SoundManager.play('boss_spawn', SoundPriority.HIGH);
    }

    /**
     * Wave Clear notification - gold flash + confetti
     */
    public showWaveClear(waveNum: number) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;

        // Victory text
        this.effects.add({
            type: 'text',
            text: 'WAVE CLEARED!',
            x: cx,
            y: cy - 30,
            life: 1.3, // 80 frames
            color: '#ffd700',
            fontSize: 36,
            vy: -30 // -0.5 * 60
        });

        // Gold screen flash
        this.effects.add({
            type: 'screen_flash',
            x: 0,
            y: 0,
            life: 20,
            flashColor: 'rgba(255, 215, 0, '
        });

        // Confetti particles
        this.spawnConfetti(cx, cy);

        // Sound
        SoundManager.play('click', SoundPriority.HIGH);
    }

    /**
     * Boss Spawn notification - dramatic darkening + spotlight
     */
    public showBossSpawn(bossName: string, x: number, y: number) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;

        // Warning text
        this.effects.add({
            type: 'text',
            text: '‚ö†Ô∏è BOSS ‚ö†Ô∏è',
            x: cx,
            y: cy - 100,
            life: 2.0, // 120
            color: '#ff0000',
            fontSize: 42,
            vy: 0
        });

        // Boss name
        this.effects.add({
            type: 'text',
            text: bossName.toUpperCase(),
            x: cx,
            y: cy - 50,
            life: 1.6, // 100
            color: '#fff',
            fontSize: 28,
            vy: 0
        });

        // Dark flash
        this.effects.add({
            type: 'screen_flash',
            x: 0,
            y: 0,
            life: 40,
            flashColor: 'rgba(0, 0, 0, '
        });

        // Sound
        SoundManager.play('boss_spawn', SoundPriority.HIGH);
    }

    /**
     * Spawn confetti particles
     */
    private spawnConfetti(cx: number, cy: number) {
        const colors = ['#ffd700', '#ff5722', '#4caf50', '#2196f3', '#e91e63'];

        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = (2 + Math.random() * 4) * 60; // Convert to px/sec
            const color = colors[Math.floor(Math.random() * colors.length)];

            this.effects.add({
                type: 'particle',
                x: cx + (Math.random() - 0.5) * 100,
                y: cy,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 120, // Bias upward (2 * 60)
                life: 0.6 + Math.random() * 0.5, // 40-70 frames
                color: color,
                radius: 3 + Math.random() * 3
            });
        }
    }

    /**
     * Custom notification (for special events)
     */
    public showCustom(text: string, color: string = '#fff', duration: number = 60) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;

        this.effects.add({
            type: 'text',
            text: text,
            x: cx,
            y: cy,
            life: duration,
            color: color,
            fontSize: 32,
            vy: -0.5
        });
    }

    public showImmune(x: number, y: number) {
        this.effects.add({
            type: 'text',
            text: 'IMMUNE',
            x: x,
            y: y - 20, // Slight offset up
            life: 0.6,
            color: '#ffd700', // Gold
            fontSize: 16, // Smaller than boss text
            vy: -50 // Float up fast
        });
    }
}

interface INotification {
    type: 'wave_start' | 'wave_clear' | 'boss_spawn' | 'custom';
    text: string;
    life: number;
    maxLife: number;
}
</file>

<file path="src/UIUtils.ts">
import { VISUALS } from './VisualConfig';

export interface IButtonOptions {
    background?: string;
    color?: string;
    fontSize?: string;
    padding?: string;
    border?: string;
    borderRadius?: string;
    width?: string;
    zIndex?: string;
    fontFamily?: string;
    cursor?: string;
    position?: string;
    top?: string;
    right?: string;
    bottom?: string;
    left?: string;
    title?: string;
    pointerEvents?: string;
    fontWeight?: string;
    marginTop?: string;
    id?: string;
    height?: string;
    boxShadow?: string;
    display?: string;
    alignItems?: string;
    justifyContent?: string;
    marginLeft?: string;
    flex?: string;
    flexShrink?: string;
    flexGrow?: string;
}

export interface IContainerOptions {
    position?: string;
    top?: string;
    left?: string;
    bottom?: string;
    right?: string;
    width?: string;
    height?: string;
    display?: string;
    flexDirection?: string;
    alignItems?: string;
    justifyContent?: string;
    gap?: string;
    background?: string;
    color?: string;
    padding?: string;
    border?: string;
    borderRadius?: string;
    zIndex?: string;
    pointerEvents?: string;
    maxWidth?: string;
    maxHeight?: string;
    overflowY?: string;
    overflowX?: string;
    transform?: string;
    flexGrow?: string;
    flexShrink?: string;
    marginBottom?: string;
}

export class UIUtils {
    /**
     * Creates a styled button and appends it to the parent.
     */
    public static createButton(
        parent: HTMLElement,
        text: string,
        onClick: (e: MouseEvent) => void,
        options: IButtonOptions = {}
    ): HTMLButtonElement {
        const btn = document.createElement('button');
        btn.innerHTML = text;

        // UPDATED: Use design tokens from VISUALS.UI
        const defaults: Partial<CSSStyleDeclaration> = {
            padding: `${VISUALS.UI.SPACING.sm}px ${VISUALS.UI.SPACING.lg}px`,
            fontSize: VISUALS.UI.FONTS.size.lg,
            cursor: 'pointer',
            background: VISUALS.UI.COLORS.neutral.medium,
            color: VISUALS.UI.COLORS.text.primary,
            border: `${VISUALS.UI.BORDERS.width.normal} solid ${VISUALS.UI.COLORS.neutral.light}`,
            borderRadius: VISUALS.UI.BORDERS.radius.md,
            fontFamily: VISUALS.UI.FONTS.family.primary,
            pointerEvents: 'auto',
            transition: VISUALS.UI.TRANSITIONS.presets.fast
        };

        // Merge options
        Object.assign(btn.style, defaults);

        // Apply overrides
        if (options.background) btn.style.background = options.background;
        if (options.color) btn.style.color = options.color;
        if (options.fontSize) btn.style.fontSize = options.fontSize;
        if (options.padding) btn.style.padding = options.padding;
        if (options.border) btn.style.border = options.border;
        if (options.borderRadius) btn.style.borderRadius = options.borderRadius;
        if (options.width) btn.style.width = options.width;
        if (options.zIndex) btn.style.zIndex = options.zIndex;
        if (options.fontFamily) btn.style.fontFamily = options.fontFamily;
        if (options.cursor) btn.style.cursor = options.cursor;
        if (options.position) btn.style.position = options.position;
        if (options.top) btn.style.top = options.top;
        if (options.right) btn.style.right = options.right;
        if (options.bottom) btn.style.bottom = options.bottom;
        if (options.left) btn.style.left = options.left;
        if (options.title) btn.title = options.title;
        if (options.pointerEvents) btn.style.pointerEvents = options.pointerEvents;
        if (options.fontWeight) btn.style.fontWeight = options.fontWeight;
        if (options.marginTop) btn.style.marginTop = options.marginTop;
        if (options.id) btn.id = options.id;
        if (options.height) btn.style.height = options.height;
        if (options.boxShadow) btn.style.boxShadow = options.boxShadow;
        if (options.display) btn.style.display = options.display;
        if (options.alignItems) btn.style.alignItems = options.alignItems;
        if (options.justifyContent) btn.style.justifyContent = options.justifyContent;
        if (options.marginLeft) btn.style.marginLeft = options.marginLeft;
        if (options.flex) btn.style.flex = options.flex;
        if (options.flexShrink) btn.style.flexShrink = options.flexShrink;
        if (options.flexGrow) btn.style.flexGrow = options.flexGrow;

        btn.onclick = onClick;

        // Simple hover effect
        const originalBg = btn.style.background;
        btn.onmouseover = () => {
            btn.style.filter = 'brightness(1.2)';
        };
        btn.onmouseout = () => {
            btn.style.filter = 'none';
        };

        parent.appendChild(btn);
        return btn;
    }

    /**
     * Creates a container (div) with standard styling options.
     */
    public static createContainer(options: IContainerOptions = {}): HTMLElement {
        const div = document.createElement('div');

        // Apply options
        if (options.position) div.style.position = options.position;
        if (options.top) div.style.top = options.top;
        if (options.left) div.style.left = options.left;
        if (options.bottom) div.style.bottom = options.bottom;
        if (options.right) div.style.right = options.right;
        if (options.width) div.style.width = options.width;
        if (options.height) div.style.height = options.height;
        if (options.display) div.style.display = options.display;
        if (options.flexDirection) div.style.flexDirection = options.flexDirection;
        if (options.alignItems) div.style.alignItems = options.alignItems;
        if (options.justifyContent) div.style.justifyContent = options.justifyContent;
        if (options.gap) div.style.gap = options.gap;
        if (options.background) div.style.background = options.background;
        if (options.color) div.style.color = options.color;
        if (options.padding) div.style.padding = options.padding;
        if (options.border) div.style.border = options.border;
        if (options.borderRadius) div.style.borderRadius = options.borderRadius;
        if (options.zIndex) div.style.zIndex = options.zIndex;
        if (options.pointerEvents) div.style.pointerEvents = options.pointerEvents;
        if (options.maxWidth) div.style.maxWidth = options.maxWidth;
        if (options.maxHeight) div.style.maxHeight = options.maxHeight;
        if (options.overflowY) div.style.overflowY = options.overflowY;
        if (options.overflowX) div.style.overflowX = options.overflowX;
        if (options.transform) div.style.transform = options.transform;
        if (options.flexGrow) div.style.flexGrow = options.flexGrow;
        if (options.flexShrink) div.style.flexShrink = options.flexShrink;
        if (options.marginBottom) div.style.marginBottom = options.marginBottom;

        return div;
    }

    /**
     * Creates a full-screen overlay for menus/modals.
     */
    public static createOverlay(id?: string): HTMLElement {
        const overlay = document.createElement('div');
        if (id) overlay.id = id;
        Object.assign(overlay.style, {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: VISUALS.UI.COLORS.overlay,
            zIndex: '2000',
            display: 'none',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            color: VISUALS.UI.COLORS.text.primary,
            fontFamily: VISUALS.UI.FONTS.family.primary
        });
        document.body.appendChild(overlay);
        return overlay;
    }

    /**
     * Animates an element with a flash effect.
     */
    public static flashElement(el: HTMLElement, color: string, durationMs: number = 200) {
        const originalColor = el.style.color;
        const originalTransform = el.style.transform;

        // UPDATED: Use design token easing curve
        const easing = VISUALS.UI.TRANSITIONS.easing.standard;
        el.style.transition = `color ${durationMs / 2}ms ${easing}, transform ${durationMs / 2}ms ${easing}`;
        el.style.color = color;
        el.style.transform = 'scale(1.3)';

        setTimeout(() => {
            el.style.color = originalColor;
            el.style.transform = originalTransform || 'scale(1)';
        }, durationMs);
    }
}
</file>

<file path="src/cards/FireCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Fire Card Upgrades
 * 
 * Level 1: Area damage, +15 damage, -15% attack speed
 * Level 2: Larger area, +30 damage, -10% attack speed
 * Level 3: Same as level 2 + enemies explode on death (50% tower damage)
 */
export const FIRE_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damage: 15,
            attackSpeedMultiplier: 0.85, // -15% attack speed
        },
        effects: [
            {
                type: 'splash',
                splashRadius: 50,
            }
        ],
        visualOverrides: {
            projectileType: 'fire',
            projectileColor: '#f44336',
            projectileSpeed: 360, // 6 * 60
        }
    },
    2: {
        level: 2,
        modifiers: {
            damage: 30,
            attackSpeedMultiplier: 0.90, // -10% attack speed
        },
        effects: [
            {
                type: 'splash',
                splashRadius: 85,
            }
        ]
    },
    3: {
        level: 3,
        modifiers: {
            damage: 30,
            attackSpeedMultiplier: 0.90, // -10% attack speed
        },
        effects: [
            {
                type: 'splash',
                splashRadius: 90,
            },
            {
                type: 'explodeOnDeath',
                explosionDamagePercent: 0.5, // 50% of tower damage
                explosionRadius: 40,
            }
        ]
    }
};
</file>

<file path="src/ObjectRenderer.ts">
import { CONFIG } from './Config';
import { VISUALS } from './VisualConfig';
import { ProceduralGrass } from './renderers/ProceduralGrass';

/**
 * ObjectRenderer - programmatic rendering for map objects
 * Supports 5 object types: stone, rock, tree, wheat, flowers
 * Designed to be easily replaced with asset-based rendering later
 */

export type ObjectType = 'stone' | 'rock' | 'tree' | 'wheat' | 'flowers';

export class ObjectRenderer {
    /**
     * Draw an object at specified pixel coordinates
     * @param ctx Canvas rendering context
     * @param type Object type
     * @param x Pixel x coordinate
     * @param y Pixel y coordinate
     * @param size Tile size (1 for most objects, 2-3 for rocks)
     */
    static draw(ctx: CanvasRenderingContext2D, type: ObjectType, x: number, y: number, size: number = 1): void {
        const TS = CONFIG.TILE_SIZE;

        switch (type) {
            case 'stone':
                this.drawStone(ctx, x, y, TS);
                break;
            case 'rock':
                this.drawRock(ctx, x, y, TS, size);
                break;
            case 'tree':
                this.drawTree(ctx, x, y, TS);
                break;
            case 'wheat':
                this.drawWheat(ctx, x, y, TS);
                break;
            case 'flowers':
                this.drawFlowers(ctx, x, y, TS);
                break;
        }
    }

    /**
     * Draw small stones (1 tile)
     * Phase 5: Uses global light direction from VISUALS.LIGHTING
     */
    private static drawStone(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        const centerX = x + TS / 2;
        const centerY = y + TS / 2;

        // Draw 2-3 small gray stones
        const stoneCount = 2 + Math.floor((x + y) % 2);

        for (let i = 0; i < stoneCount; i++) {
            const offsetX = ((x + i * 17) % 30) - 15;
            const offsetY = ((y + i * 23) % 30) - 15;
            const radius = 6 + ((x + y + i) % 4);

            // Stone shadow (uses global light direction)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Slightly darker
            ctx.beginPath();
            ctx.ellipse(
                centerX + offsetX + VISUALS.LIGHTING.SHADOW_OFFSET_X,
                centerY + offsetY + VISUALS.LIGHTING.SHADOW_OFFSET_Y,
                radius, radius * 0.8, 0, 0, Math.PI * 2
            );
            ctx.fill();

            // Stone body
            ctx.fillStyle = '#757575';
            ctx.beginPath();
            ctx.ellipse(centerX + offsetX, centerY + offsetY, radius, radius * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Highlight (opposite direction from shadow)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; // Brighter
            ctx.beginPath();
            ctx.ellipse(
                centerX + offsetX + VISUALS.LIGHTING.HIGHLIGHT_OFFSET_X,
                centerY + offsetY + VISUALS.LIGHTING.HIGHLIGHT_OFFSET_Y,
                radius * 0.4, radius * 0.3, 0, 0, Math.PI * 2
            );
            ctx.fill();
        }
    }

    /**
     * Draw large rocks (2-3 tiles) with varied shapes
     * Phase 5: Uses global light direction
     */
    private static drawRock(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number, size: number): void {
        const width = size * TS;
        const height = size * TS;
        const centerX = x + width / 2;
        const centerY = y + height / 2;

        // More varied vertices based on size and position
        const vertices = 5 + (size - 1) + ((x + y) % 3);

        // Create pseudo-random but deterministic variations
        const seed = x * 73 + y * 137;

        // Shadow with varied shape
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        for (let i = 0; i < vertices; i++) {
            const angle = (i / vertices) * Math.PI * 2;
            const variance = ((seed + i * 43) % 20) - 10; // -10 to +10
            const radius = width * 0.35 + variance;
            const angleOffset = ((seed + i * 23) % 30 - 15) * 0.01; // Small angle variation
            const px = centerX + Math.cos(angle + angleOffset) * radius + 4;
            const py = centerY + Math.sin(angle + angleOffset) * radius + 4;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        // Rock body with varied color
        const grayVariance = ((seed % 30) - 15);
        const grayValue = 97 + grayVariance; // Around #616161
        ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
        ctx.beginPath();
        for (let i = 0; i < vertices; i++) {
            const angle = (i / vertices) * Math.PI * 2;
            const variance = ((seed + i * 43) % 20) - 10;
            const radius = width * 0.35 + variance;
            const angleOffset = ((seed + i * 23) % 30 - 15) * 0.01;
            const px = centerX + Math.cos(angle + angleOffset) * radius;
            const py = centerY + Math.sin(angle + angleOffset) * radius;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        // Add varied texture lines
        ctx.strokeStyle = '#424242';
        ctx.lineWidth = 1 + (size - 1) * 0.5;
        const lineCount = 2 + ((seed % 4));
        for (let i = 0; i < lineCount; i++) {
            const startAngle = ((seed + i * 67) % 360) * Math.PI / 180;
            const endAngle = startAngle + (Math.PI / 4) + ((seed + i) % 20) * 0.05;
            const r1 = width * (0.1 + ((seed + i * 13) % 10) * 0.01);
            const r2 = width * (0.25 + ((seed + i * 17) % 15) * 0.01);
            ctx.beginPath();
            ctx.moveTo(centerX + Math.cos(startAngle) * r1, centerY + Math.sin(startAngle) * r1);
            ctx.lineTo(centerX + Math.cos(endAngle) * r2, centerY + Math.sin(endAngle) * r2);
            ctx.stroke();
        }

        // Varied highlight position
        const highlightX = centerX - width * 0.15 + ((seed % 20) - 10);
        const highlightY = centerY - height * 0.15 + ((seed % 15) - 7);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        ctx.arc(highlightX, highlightY, width * 0.08, 0, Math.PI * 2);
        ctx.fill();
    }

    /**
     * Draw tree (1 tile)
     * Phase 5: Uses global light direction, gradient trunk, layered foliage
     */
    private static drawTree(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        const centerX = x + TS / 2;
        const bottomY = y + TS - 5;

        // Trunk shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(centerX - 6, bottomY - 25, 14, 28);

        // Trunk
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(centerX - 5, bottomY - 25, 10, 25);

        // Foliage shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.arc(centerX + 3, bottomY - 20, 18, 0, Math.PI * 2);
        ctx.fill();

        // Foliage (3 circles for depth)
        const foliageColors = ['#1b5e20', '#2e7d32', '#388e3c'];
        const foliageOffsets = [
            { x: -5, y: -5, r: 14 },
            { x: 5, y: -3, r: 16 },
            { x: 0, y: -10, r: 15 }
        ];

        foliageOffsets.forEach((offset, i) => {
            ctx.fillStyle = foliageColors[i];
            ctx.beginPath();
            ctx.arc(centerX + offset.x, bottomY - 20 + offset.y, offset.r, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    /**
     * Draw wheat field (1 tile)
     */
    private static drawWheat(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        // Background (darker gold)
        ctx.fillStyle = '#f9a825';
        ctx.fillRect(x, y, TS, TS);

        // Wheat stalks pattern
        ctx.strokeStyle = '#fbc02d';
        ctx.lineWidth = 2;

        for (let row = 0; row < 4; row++) {
            for (let col = 0; col < 4; col++) {
                const stalkX = x + col * (TS / 4) + (TS / 8);
                const stalkY = y + row * (TS / 4) + (TS / 8);
                const offset = ((row + col) % 2) * 3;

                // Stalk
                ctx.beginPath();
                ctx.moveTo(stalkX, stalkY + 10);
                ctx.lineTo(stalkX + offset, stalkY - 2);
                ctx.stroke();

                // Wheat head
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.ellipse(stalkX + offset, stalkY - 4, 3, 5, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Border removed - was causing bright white artifacts on tiles
        // ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
        // ctx.lineWidth = 1;
        // ctx.strokeRect(x, y, TS, TS);
    }

    /**
     * Draw flowering grass (1 tile) - grass colored with varied flowers
     * –§–ê–ó–ê 3: –û–±–Ω–æ–≤–ª–µ–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ProceduralGrass –¥–ª—è —Ñ–æ–Ω–∞
     */
    private static drawFlowers(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        // –®–ê–ì 1: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å ProceduralGrass –¥–ª—è —Ñ–æ–Ω–∞
        // –í–ê–ñ–ù–û: –≠—Ç–æ —Å–æ–∑–¥–∞—ë—Ç –∏–¥–µ–Ω—Ç–∏—á–Ω—ã–π —Ñ–æ–Ω —Å –æ–±—ã—á–Ω–æ–π —Ç—Ä–∞–≤–æ–π

        // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∞–π–ª–∞
        const seed = x * 73 + y * 137;

        // –†–µ–Ω–¥–µ—Ä–∏–º –∂–∏–≤—É—é —Ç—Ä–∞–≤—É –∫–∞–∫ —Ñ–æ–Ω
        try {
            ProceduralGrass.draw(ctx, x, y, TS, seed);
        } catch (error) {
            console.error('[ObjectRenderer] ProceduralGrass.draw failed:', error);
            // Fallback - –ø—Ä–æ—Å—Ç–æ–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
            const gradient = ctx.createLinearGradient(x, y, x, y + TS);
            gradient.addColorStop(0, VISUALS.ENVIRONMENT.GRASS.LIGHT);
            gradient.addColorStop(1, VISUALS.ENVIRONMENT.GRASS.BASE);
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, TS, TS);
        }

        // –®–ê–ì 2: –ú–ù–û–ì–û –º–µ–ª–∫–∏—Ö —Ü–≤–µ—Ç–æ–≤ –ø–æ–≤–µ—Ä—Ö —Ç—Ä–∞–≤—ã
        const flowerCount = 20 + (seed % 11); // 20-30 (–±—ã–ª–æ 10-17)

        // –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –ø–∞–ª–∏—Ç—Ä–∞ (7 —Ü–≤–µ—Ç–æ–≤, –¥–æ–±–∞–≤–ª–µ–Ω –∂—ë–ª—Ç—ã–π)
        const flowerColors = [
            '#e91e63', // –†–æ–∑–æ–≤—ã–π
            '#9c27b0', // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
            '#2196f3', // –°–∏–Ω–∏–π
            '#ff9800', // –û—Ä–∞–Ω–∂–µ–≤—ã–π
            '#ffeb3b', // –ñ—ë–ª—Ç—ã–π (–ù–û–í–´–ô)
            '#f44336', // –ö—Ä–∞—Å–Ω—ã–π
            '#fff'     // –ë–µ–ª—ã–π
        ];

        for (let i = 0; i < flowerCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const fx = x + ((seed * 7 + i * 13) % TS);
            const fy = y + ((seed * 11 + i * 19) % TS);

            // –†–∞–∑–º–µ—Ä: 1.0-1.8px (–º–µ–Ω—å—à–µ —á–µ–º –±—ã–ª–æ 1.5-3px)
            const flowerSize = 1.0 + ((seed + i * 7) % 8) * 0.1; // 1.0-1.8px

            // –¶–≤–µ—Ç –∏–∑ –ø–∞–ª–∏—Ç—Ä—ã
            const colorIdx = (seed + i * 3) % flowerColors.length;

            // –£–ü–†–û–©–Å–ù–ù–ê–Ø –ì–ï–û–ú–ï–¢–†–ò–Ø: –ü—Ä–æ—Å—Ç–æ–π –∫—Ä—É–∂–æ–∫ (–≤–º–µ—Å—Ç–æ –ª–µ–ø–µ—Å—Ç–∫–æ–≤)
            // –í–Ω–µ—à–Ω–∏–π –∫—Ä—É–≥ (—Ü–≤–µ—Ç)
            ctx.fillStyle = flowerColors[colorIdx];
            ctx.beginPath();
            ctx.arc(fx, fy, flowerSize, 0, Math.PI * 2);
            ctx.fill();

            // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –±–ª–∏–∫ (–±–µ–ª—ã–π —Ü–µ–Ω—Ç—Ä)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(fx, fy, flowerSize * 0.5, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}
</file>

<file path="src/scenes/GameController.ts">
import { ICard } from '../CardSystem';
import { CONFIG } from '../Config';
import { Tower } from '../Tower';
import { GameState } from './GameState';
import { EntityManager } from './EntityManager';
import { EffectSystem } from '../EffectSystem';
import { InspectorSystem } from '../InspectorSystem';
import { UIManager } from '../UIManager';
import { MetricsSystem } from '../MetricsSystem';
import { IMapData } from '../MapData';
import { EventEmitter } from '../Events';

/**
 * Handles user actions and game controller logic:
 * - Tower building/selection
 * - Card drop handling
 * - Grid click handling
 * - Keyboard hotkeys
 */
export class GameController {
    constructor(
        private state: GameState,
        private entityManager: EntityManager,
        private effects: EffectSystem,
        private inspector: InspectorSystem,
        private ui: UIManager,
        private metrics: MetricsSystem,
        private mapData: IMapData,
        private isBuildable: (col: number, row: number) => boolean,
        private cardSys: any, // CardSystem reference
        private events: EventEmitter,
    ) {
        this.events.on('CARD_DROPPED', (data: any) => {
            this.handleCardDrop(data.card, data.x, data.y);
        });
    }

    private lastErrorTime: number = 0;

    // === Tower Building ===

    public startBuildingTower(col: number, row: number): void {
        const screenX = col * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const screenY = row * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        const validation = this.entityManager.canBuildTower(col, row, this.mapData, this.isBuildable);

        if (!validation.valid) {
            // Debounce error text to prevent infinite spam
            const now = Date.now();
            if (now - this.lastErrorTime > 500) {
                this.showFloatingText(validation.reason!, screenX, screenY, 'red');
                this.lastErrorTime = now;
            }
            return;
        }

        const tower = this.entityManager.buildTower(col, row);
        this.ui.update();
    }

    // === Grid Click Handling ===

    public handleGridClick(col: number, row: number): void {
        const tower = this.entityManager.getTowerAt(col, row);
        if (tower) {
            this.state.selectTower(tower);
            this.inspector.selectTower(tower);
        } else {
            this.state.selectTower(null);
            this.inspector.hide();
        }
    }

    // === Card Drop Handling ===

    public handleCardDrop(card: ICard, x: number, y: number): boolean {
        const col = Math.floor(x / CONFIG.TILE_SIZE);
        const row = Math.floor(y / CONFIG.TILE_SIZE);

        // Check if this is a tower card
        if (
            card.type.id === 'fire' ||
            card.type.id === 'ice' ||
            card.type.id === 'sniper' ||
            card.type.id === 'multi' ||
            card.type.id === 'minigun'  // FIXED: Added minigun support
        ) {
            const success = this.entityManager.addCardToTower(card, col, row, this.isBuildable);

            if (success) {
                this.cardSys.removeCardFromHand(card);
                this.showFloatingText('Card installed!', x, y, 'lime');
                this.ui.update();

                // Refresh inspector if this tower is selected
                const tower = this.entityManager.getTowerAt(col, row);
                if (tower && this.state.selectedTower === tower) {
                    this.inspector.selectTower(tower);
                }
                return true;
            } else {
                const tower = this.entityManager.getTowerAt(col, row);
                if (tower && tower.cards.length >= 3) {
                    this.showFloatingText('Tower full!', x, y, 'orange');
                } else if (this.state.money < CONFIG.ECONOMY.TOWER_COST) {
                    this.showFloatingText('Not enough money!', x, y, 'red');
                } else {
                    this.showFloatingText("Can't build here", x, y, 'red');
                }
                return false;
            }
        }

        return false;
    }

    // === Tower Selling ===

    public sellTower(tower: Tower): void {
        const refund = this.entityManager.sellTower(tower);
        if (refund > 0) {
            this.inspector.hide();
            this.ui.update();
        }
    }

    public sellCardFromTower(tower: Tower, cardIndex: number): void {
        const result = this.entityManager.sellCardFromTower(tower, cardIndex);
        if (result.card) {
            this.ui.update();
            // Refresh inspector to show updated card slots
            this.inspector.selectTower(tower);
        }
    }

    // === Card Management ===

    public giveRandomCard(): void {
        const keys = Object.keys(CONFIG.CARD_TYPES);
        const key = keys[Math.floor(Math.random() * keys.length)];
        this.cardSys.addCard(key, 1);
        this.ui.update();
    }

    // === Keyboard Hotkeys ===

    public handleKeyDown(e: KeyboardEvent): void {
        if (this.state.paused) return;

        switch (e.code) {
            case 'Space':
                this.handleSpaceKey();
                break;
                if (this.state.selectedTower) {
                    this.sellTower(this.state.selectedTower);
                }
                break;
            case 'KeyM':
                console.log('CHEAT: Give Minigun');
                this.cardSys.addCard('MINIGUN', 1);
                this.ui.update();
                this.showFloatingText('+ MINIGUN', window.innerWidth / 2, window.innerHeight / 2, '#d0f');
                break;
            case 'Digit1':
            case 'Digit2':
            case 'Digit3':
            case 'Digit4':
            case 'Digit5':
                // Card selection hotkeys (if implemented in future)
                break;
        }
    }

    private handleSpaceKey(): void {
        // Space key logic will be handled by WaveManager
        // Just toggle time scale if wave is active
        const waveActive = false; // This should come from WaveManager

        if (waveActive) {
            this.state.toggleTimeScale();
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const text = this.state.timeScale === 2.0 ? '>> 2x Speed' : '> 1x Speed';
            this.showFloatingText(text, centerX, centerY, '#fff');
        }
    }

    // === Helper Methods ===

    public showFloatingText(text: string, x: number, y: number, color: string = '#fff'): void {
        this.effects.add({ type: 'text', text, x, y, life: 1.0, color, vy: -60 });
    }
}
</file>

<file path="src/systems/LightingSystem.ts">
import { CONFIG } from '../Config';

export interface ILight {
    x: number;
    y: number;
    radius: number;
    color: string; // Hex or rgba
    intensity: number; // 0 to 1
}

export class LightingSystem {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private width: number;
    private height: number;
    private scale: number; // Phase 6: Performance optimization

    private lights: ILight[] = [];
    public ambientLight: number = 0.9; // 0 = Pitch Black, 1 = Full Brightness

    constructor(width: number, height: number, optimization: boolean = false) {
        this.width = width;
        this.height = height;

        // Phase 6: 2x scale optimization for performance
        this.scale = optimization ? 2 : 1;

        // Create offscreen canvas for light map (at reduced resolution if optimized)
        this.canvas = document.createElement('canvas');
        this.canvas.width = Math.floor(width / this.scale);
        this.canvas.height = Math.floor(height / this.scale);
        this.ctx = this.canvas.getContext('2d', { alpha: true })!;
    }

    public resize(width: number, height: number) {
        this.width = width;
        this.height = height;
        this.canvas.width = Math.floor(width / this.scale);
        this.canvas.height = Math.floor(height / this.scale);
    }

    public clear() {
        this.lights = [];
    }

    public addLight(x: number, y: number, radius: number, color: string, intensity: number = 1.0) {
        // Standard system
        this.lights.push({
            x: x / this.scale,
            y: y / this.scale,
            radius: radius / this.scale,
            color,
            intensity
        });
    }

    /**
     * Phase 6: Enable global darkness (nighttime mode)
     */
    public enableGlobalDarkness(darknessLevel: number = 0.7) {
        this.ambientLight = 1 - darknessLevel; // e.g., 0.7 darkness = 0.3 ambient
    }

    /**
     * Phase 6: Add light from a tower
     */
    public addTowerLight(x: number, y: number, tileSize: number) {
        this.addLight(x + tileSize / 2, y + tileSize / 2, tileSize * 2.5, '#ffaa00', 0.8);
    }

    public render(targetCtx: CanvasRenderingContext2D) {
        // Logic for SPRITE style (Original)
        const w = this.canvas.width;
        const h = this.canvas.height;

        // 0. Clear previous frame
        this.ctx.clearRect(0, 0, w, h);

        // 1. Fill light map with "Darkness"
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.fillStyle = `rgba(0, 0, 0, ${1 - this.ambientLight})`;
        this.ctx.fillRect(0, 0, w, h);

        // 2. Punch holes / Add lights (Visibility)
        this.ctx.globalCompositeOperation = 'destination-out';

        this.lights.forEach(light => {
            const g = this.ctx.createRadialGradient(light.x, light.y, 0, light.x, light.y, light.radius);
            g.addColorStop(0, `rgba(0, 0, 0, ${light.intensity})`); // Full erase
            g.addColorStop(1, 'rgba(0, 0, 0, 0)'); // No erase

            this.ctx.fillStyle = g;
            this.ctx.beginPath();
            this.ctx.arc(light.x, light.y, light.radius, 0, Math.PI * 2);
            this.ctx.fill();
        });

        // 3. Draw colored glows (Additive Pass)
        // We render this DIRECTLY to the target context to add glow on top of game + darkness
        // OR we render to a separate canvas. 
        // Rendering to targetCtx directly is better for performance and visual control.

        // Draw the darkness overlay first (scaled up if using optimization)
        targetCtx.save();
        targetCtx.drawImage(this.canvas, 0, 0, this.width, this.height);

        // Now draw colored lights on TOP using 'lighter' (or 'screen')
        targetCtx.globalCompositeOperation = 'lighter'; // Additive blending

        this.lights.forEach(light => {
            if (light.color === '#000000') return; // Skip black lights

            // Scale back to target resolution
            const x = light.x * this.scale;
            const y = light.y * this.scale;
            const r = light.radius * this.scale;

            const g = targetCtx.createRadialGradient(x, y, 0, x, y, r);
            // Convert hex to rgb for gradient? Or just use hex if browser supports (it does usually)
            // But we need alpha falloff.

            // Helper to get RGBA from potentially hex string would be nice, but simple fix:
            // Let's assume color is a valid CSS color string. 
            // We'll use a simple approximation or just draw with lower opacity at center.

            g.addColorStop(0, light.color); // Color at center
            g.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade to transparent

            targetCtx.fillStyle = g;
            targetCtx.globalAlpha = light.intensity * 0.6; // Scale down glow intensity
            targetCtx.beginPath();
            targetCtx.arc(light.x, light.y, light.radius, 0, Math.PI * 2);
            targetCtx.fill();
        });

        targetCtx.restore();
    }
}
</file>

<file path="src/VisualConfig.ts">
/**
 * Centralized Visual Configuration
 * Stores colors, sizes, and other visual constants for procedural generation and rendering.
 */

import { UI } from './design';

export const VISUALS = {
    ENVIRONMENT: {
        GRASS: {
            // –ñ–∏–≤–∞—è —Ç—Ä–∞–≤–∞ (—Å—Ä–µ–¥–Ω—è—è –∑–µ–ª–µ–Ω—å) - –§–ê–ó–ê 2: –û–±–Ω–æ–≤–ª–µ–Ω–æ
            BASE: '#6b9e4a',         // –°—Ä–µ–¥–Ω–µ-–∑–µ–ª—ë–Ω—ã–π (–æ—Å–Ω–æ–≤–∞)
            LIGHT: '#7ab55a',        // –°–≤–µ—Ç–ª–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è
            DARK: '#5a8839',         // –¢—ë–º–Ω–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è (—Ç–µ–Ω–∏)
            BLADE: '#8bc34a',        // –¢—Ä–∞–≤–∏–Ω–∫–∏ (—è—Ä–∫–∏–µ)
            DETAIL: '#757575',       // –ö–∞–º–µ—à–∫–∏
            FLOWER: '#ffeb3b',       // –ú–µ–ª–∫–∏–µ —Ü–≤–µ—Ç–æ—á–∫–∏

            // –ë–∏–æ–ª—é–º–∏–Ω–µ—Å—Ü–µ–Ω—Ü–∏—è (–ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô - –¥–ª—è –§–∞–∑—ã 4)
            BIOLUM: '#4dd0e1',       // Cyan bioluminescence

            // LEGACY - –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º
            MAIN: '#6b9e4a',         // = BASE (fallback)
            VAR_1: '#7ab55a',        // = LIGHT (fallback)
            VAR_2: '#5a8839',        // = DARK (fallback)
        },
        PATH: {
            // –ö–∞–º–µ–Ω–Ω–∞—è –¥–æ—Ä–æ–≥–∞ (–§–ê–ó–ê 1: –û–±–Ω–æ–≤–ª–µ–Ω–æ)
            STONE_BASE: '#c5b8a1',       // –°–≤–µ—Ç–ª—ã–π –±–µ–∂–µ–≤—ã–π –∫–∞–º–µ–Ω—å
            STONE_LIGHT: '#d4c5a9',      // –°–≤–µ—Ç–ª–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è
            STONE_DARK: '#b6a890',       // –¢—ë–º–Ω–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è
            CRACK: '#8b7e6a',            // –¢—Ä–µ—â–∏–Ω—ã (—Ç—ë–º–Ω–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ã–π)
            EDGE: '#9a8d7a',             // –ö—Ä–∞—è –º–µ–∂–¥—É –ø–ª–∏—Ç–∞–º–∏
            MOSS: '#7a8f63',             // –ú–æ—Ö (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

            // LEGACY - –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º
            MAIN: '#c5b8a1',             // = STONE_BASE (fallback)
            DETAIL: '#8b7e6a',           // = CRACK (fallback)
            GRID: '#9a8d7a',             // = EDGE (fallback)
            BORDER: '#9a8d7a',           // = EDGE (fallback)
        },
        DECOR: {
            TREE: {
                BASE: '#3a4a2f', // Match –Ω–æ–≤—É—é grass
                FOLIAGE_LIGHT: '#2e4d32',
                FOLIAGE_DARK: '#1b3e20',
            },
            ROCK: {
                BASE: '#3a4a2f',
                STONE: '#5a606c', // –¢–µ–º–Ω–µ–µ –¥–ª—è Dark —Å—Ç–∏–ª—è
            }
        },
        FOG: {
            BASE: '#263238',
        }
    },
    // –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–µ—Ç–∞ (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –§–∞–∑—ã 5!)
    LIGHTING: {
        GLOBAL_LIGHT_ANGLE: Math.PI * 0.75,  // 135¬∞ (—Å–µ–≤–µ—Ä–æ-–∑–∞–ø–∞–¥ ‚Üí —é–≥–æ-–≤–æ—Å—Ç–æ–∫)
        SHADOW_OFFSET_X: 3,   // px —Å–º–µ—â–µ–Ω–∏—è —Ç–µ–Ω–∏
        SHADOW_OFFSET_Y: 3,
        HIGHLIGHT_OFFSET_X: -2,  // px –±–ª–∏–∫–∞ (–ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ —Ç–µ–Ω–∏)
        HIGHLIGHT_OFFSET_Y: -2,
    },
    TOWER: {
        BASE: {
            PLATFORM: '#9e9e9e', // Grey 500
            RIM: '#616161',      // Grey 700
            RIVETS: '#424242',
        },
        TURRET: {
            STANDARD: {
                MAIN: '#616161',
                STROKE: '#212121',
                BARREL: '#616161',
            },
            ICE: {
                MAIN: '#00acc1', // Cyan 600
                STROKE: '#e0f7fa',
                SPIKE: '#4dd0e1', // Cyan 300
            },
            FIRE: {
                MAIN: '#f4511e', // Deep Orange 600
                STROKE: '#ffccbc',
                BARREL: '#ff7043',
                TIP: '#bf360c',
            },
            SNIPER: {
                MAIN: '#2e7d32', // Green 800
                BARREL: '#1b5e20', // Green 900
                MUZZLE: '#4caf50',
            },
            SPLIT: {
                MAIN: '#f57f17', // Yellow 900
                BARREL: '#fbc02d', // Yellow 700
            }
        },
        MODULES: {
            ICE: {
                BODY: '#0277bd',
                LIQUID: '#4fc3f7',
                CAP: '#eceff1',
            },
            FIRE: {
                BODY: '#c62828',
                SYMBOL: '#ffeb3b',
            },
            SNIPER: {
                BODY: '#212121',
                LENS: '#00e5ff',
            },
            SPLIT: {
                BODY: '#ff6f00',
                ACCENT: '#ffd54f',
            }
        },
        BUILDING: {
            BASE: 'rgba(158, 158, 158, 0.5)',
            BAR_BG: 'rgba(0,0,0,0.5)',
            BAR_FILL: 'gold',
        },
        LASER: 'rgba(255, 0, 0, 0.6)',  // Sniper laser sight
        HEIGHT: 0.6,
        BASE_COLOR: '#9e9e9e', // Fallback color for tower base (migrated from CONFIG.COLORS.TOWER_BASE)
        RANGE_CIRCLE: {
            FILL: 'rgba(0, 255, 255, 0.1)',
            STROKE: 'rgba(0, 255, 255, 0.4)',
        }
    },
    ENEMY: {
        SKELETON: {
            BONE: '#e0e0e0',
            EYES: '#212121',
        },
        WOLF: {
            BODY: '#5d4037',
            EYES: '#ff1744',
        },
        TROLL: {
            SKIN: '#558b2f',
            FEATURE: '#33691e',
        },
        SPIDER: {
            BODY: '#311b92',
            HEAD: '#4527a0',
            EYES: '#d50000',
        },
        PROPS: {
            SHIELD: { WOOD: '#8d6e63', METAL: '#bdbdbd' },
            HELMET: { GOLD: '#ffd700', HORN: '#e0e0e0' },
            BARRIER: { FILL: 'rgba(100, 255, 218, 0.4)', STROKE: 'rgba(255, 255, 255, 0.8)' },
            WEAPON: { HANDLE: '#5d4037', GUARD: '#ffd700', BLADE: '#cfd8dc' },
        }
    },
    PROJECTILES: {
        STANDARD: '#fff',
        ICE: '#00bcd4',
        FIRE: '#f44336',
        SNIPER: '#4caf50',
        SPLIT: '#ff9800',
    },

    // UI Design System (imported from modular design tokens)
    UI: UI
};

// Re-export helper functions from design system
export { getSpacing, getTransition } from './design';
</file>

<file path="src/cards/CardType.ts">
/**
 * Base interfaces and types for the upgrade card system
 */

export interface ICardModifiers {
    damage?: number;              // Flat damage bonus
    damageMultiplier?: number;    // Multiplier for base damage (e.g., 0.30 = 30% of base)
    attackSpeedMultiplier?: number; // Multiplier for attack speed (0.85 = -15% speed, 1.0 = no change)
    range?: number;               // Flat range bonus
    rangeMultiplier?: number;     // Multiplier for range
    critChance?: number;          // Critical hit chance (0-1)
}

export interface ICardEffect {
    type: 'splash' | 'slow' | 'pierce' | 'explodeOnDeath' | 'chainSlowOnDeath' | 'spinup';

    // Splash effect properties
    splashRadius?: number;

    // Slow effect properties
    slowPower?: number;           // 0-1, where 0.2 = 20% slow
    slowDuration?: number;        // Frames
    damageToSlowed?: number;      // Damage multiplier for slowed enemies (1.2 = +20% damage)

    // Pierce properties
    pierceCount?: number;         // Number of enemies to pierce through
    pierceDamageLoss?: number;    // Damage loss per pierce (0.15 = 15% loss)

    // Explosion on death properties
    explosionDamagePercent?: number; // Percent of tower damage (0.5 = 50%)
    explosionRadius?: number;

    // Chain slow properties
    chainRadius?: number;

    // Spinup properties (Minigun mechanic)
    spinupDamagePerSecond?: number;   // Flat damage bonus per second of continuous fire
    spinupCritPerSecond?: number;     // Crit chance bonus per second (0.02 = 2%)
    spinupSteps?: Array<{ threshold: number; damage: number }>; // For stepped damage (level 3)
    maxSpinupSeconds?: number;        // Maximum spinup time (7 seconds)
    overheatDuration?: number;        // Overheat lockout duration in frames (90 or 180)
    overheatExtensionWithIce?: number; // Bonus time before overheat when combined with Ice card (180 frames = 3 sec)

    // Legacy/Generic properties (fixing TS errors)
    radius?: number;
    dur?: number;
    power?: number;
}

export interface ICardVisualOverrides {
    projectileType?: string;    // Visual type: 'standard', 'fire', 'ice', 'sniper', 'minigun', 'split'
    projectileColor?: string;   // Hex color for projectile
    projectileSpeed?: number;   // Projectile travel speed
}

export interface IUpgradeCard {
    level: number;
    modifiers: ICardModifiers;
    effects: ICardEffect[];
    visualOverrides?: ICardVisualOverrides; // NEW: Data-driven visuals
}

/**
 * Merge multiple card modifiers into one
 */
export function mergeModifiers(modifiers: ICardModifiers[]): ICardModifiers {
    const result: ICardModifiers = {
        damage: 0,
        attackSpeedMultiplier: 1.0,
        range: 0,
        rangeMultiplier: 1.0,
        critChance: 0,
    };

    modifiers.forEach(mod => {
        result.damage! += mod.damage || 0;
        result.attackSpeedMultiplier! *= mod.attackSpeedMultiplier || 1.0;
        result.range! += mod.range || 0;
        result.rangeMultiplier! *= mod.rangeMultiplier || 1.0;
        result.critChance! = Math.max(result.critChance!, mod.critChance || 0);
    });

    return result;
}

/**
 * Merge multiple card effects into one array
 */
export function mergeEffects(effectArrays: ICardEffect[][]): ICardEffect[] {
    const result: ICardEffect[] = [];
    effectArrays.forEach(effects => {
        result.push(...effects);
    });
    return result;
}
</file>

<file path="src/cards/MinigunCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Minigun Card Upgrades
 * 
 * Level 1: Percentage damage modifier (-70%), +3 dmg/sec, overheat after 5s (1.5s lockout)
 * Level 2: Same as level 1 (-60%) + 2% crit chance per second
 * Level 3: Stepped damage ramp (-45%), + crit, overheat 3s lockout
 */
export const MINIGUN_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damageMultiplier: 0.50, // 50% of base damage (50% reduction)
            attackSpeedMultiplier: 2.65, // 45 / 17 = 2.65x faster attacks
        },
        effects: [
            {
                type: 'spinup',
                spinupDamagePerSecond: 3, // +3 damage per second
                maxSpinupSeconds: 5, // 5 seconds
                overheatDuration: 1.5, // 90 / 60
                overheatExtensionWithIce: 2, // 120 / 60
            }
        ],
        visualOverrides: {
            projectileType: 'minigun',
            projectileColor: '#fff',
            projectileSpeed: 720, // 12 * 60
        }
    },
    2: {
        level: 2,
        modifiers: {
            damageMultiplier: 0.60, // 60% of base damage (40% reduction)
            attackSpeedMultiplier: 2.75,
        },
        effects: [
            {
                type: 'spinup',
                spinupDamagePerSecond: 3,
                spinupCritPerSecond: 0.02, // +2% crit chance per second
                maxSpinupSeconds: 5,
                overheatDuration: 1.5,
                overheatExtensionWithIce: 2,
            }
        ]
    },
    3: {
        level: 3,
        modifiers: {
            damageMultiplier: 0.75, // 75% of base damage (25% reduction)
            attackSpeedMultiplier: 2.65,
        },
        effects: [
            {
                type: 'spinup',
                // Stepped damage: 5 steps over 5 seconds
                spinupSteps: [
                    { threshold: 1, damage: 5 },   // 0-1 sec: +5 dmg
                    { threshold: 2, damage: 10 },  // 1-2 sec: +10 dmg
                    { threshold: 3, damage: 15 },  // 2-3 sec: +15 dmg
                    { threshold: 4, damage: 20 },  // 3-4 sec: +20 dmg
                    { threshold: 5, damage: 30 },  // 4-5 sec: +30 dmg (max)
                ],
                spinupCritPerSecond: 0.02, // +2% crit chance per second
                maxSpinupSeconds: 5,
                overheatDuration: 1.5,
                overheatExtensionWithIce: 2,
            }
        ]
    }
};
</file>

<file path="src/cards/SniperCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Sniper Card Upgrades
 * 
 * Level 1: +80 range, +14 damage, -50% attack speed, 10% crit chance
 * Level 2: +160 range, +24 damage, -35% attack speed, 15% crit chance
 * Level 3: +240 range, +46 damage, -15% attack speed, 20% crit chance, pierce 2 enemies (15% damage loss each)
 */
export const SNIPER_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damage: 14,
            range: 80,
            attackSpeedMultiplier: 0.30, // -70% attack speed (slower)
            critChance: 0.15, // 15% crit chance
        },
        effects: [],
        visualOverrides: {
            projectileType: 'sniper',
            projectileColor: '#4caf50',
            projectileSpeed: 900, // 15 * 60
        }
    },
    2: {
        level: 2,
        modifiers: {
            damage: 24,
            range: 160,
            attackSpeedMultiplier: 0.45, // -55% attack speed
            critChance: 0.15,
        },
        effects: []
    },
    3: {
        level: 3,
        modifiers: {
            damage: 46,
            range: 240,
            attackSpeedMultiplier: 0.60, // -40% attack speed (improved from level 2)
            critChance: 0.20,
        },
        effects: [
            {
                type: 'pierce',
                pierceCount: 2, // Pierce through 2 enemies
                pierceDamageLoss: 0.15, // Lose 15% damage per pierce
            }
        ]
    }
};
</file>

<file path="src/config/Enemies.ts">
import { IEnemyTypeConfig } from '../types';

export const ENEMY_CONFIG = {
    BASE_HP: 25,
    HP_GROWTH: 1.2
};

export const ENEMY_TYPES: Record<string, IEnemyTypeConfig> = {
    GRUNT: {
        id: 'grunt',
        name: '–°–∫–µ–ª–µ—Ç',
        symbol: 'üíÄ',
        hpMod: 1.2,
        speed: 90, // 1.5 * 60 = 90
        reward: 4,
        color: '#e0e0e0',
        desc: '–û–±—ã—á–Ω—ã–π —Å–∫–µ–ª–µ—Ç',
        archetype: 'SKELETON',
        scale: 1.0,
    },
    SCOUT: {
        id: 'scout',
        name: '–ê–¥—Å–∫–∞—è –ì–æ–Ω—á–∞—è',
        symbol: 'üêï',
        hpMod: 0.85,
        speed: 168, // 2.8 * 60 = 168
        reward: 2,
        color: '#212121', // Dark fur color
        desc: '–ë—ã—Å—Ç—Ä—ã–π —Ö–∏—â–Ω–∏–∫ –∏–∑ –ø—Ä–µ–∏—Å–ø–æ–¥–Ω–µ–π',
        archetype: 'HELLHOUND',
        scale: 0.9,
    },
    TANK: {
        id: 'tank',
        name: '–í–æ–µ–≤–æ–¥–∞ –û—Ä–∫–æ–≤',
        symbol: 'üëπ', // Or maybe üõ°Ô∏è? Sticking with ogre/oni usually works for Orcs, or use custom unicode if preferred.
        hpMod: 3.65,
        speed: 68, // Decreased by ~20% from 48
        reward: 10,
        color: '#558b2f',
        desc: '–ñ–∏–≤–æ–π —Ç–∞—Ä–∞–Ω –≤ —Ç—è–∂–µ–ª–æ–π –±—Ä–æ–Ω–µ',
        archetype: 'ORC',
        scale: 1.3,
    },
    BOSS: {
        id: 'boss',
        name: '–ü—Ä–∏–∑—Ä–∞–∫ –ü—É—Å—Ç–æ—Ç—ã',
        symbol: 'üëª',
        hpMod: 30.0,
        speed: 40,
        reward: 300,
        color: '#1a0b2e',
        desc: '–ù–µ—É—è–∑–≤–∏–º–∞—è —Å—É—â–Ω–æ—Å—Ç—å',
        archetype: 'WRAITH',
        scale: 1.2,
    },
    // --- NEW VARIANTS ---
    SKELETON_COMMANDER: {
        id: 'skeleton_commander',
        name: '–ö–æ–º–∞–Ω–¥–∏—Ä –°–∫–µ–ª–µ—Ç–æ–≤',
        symbol: 'üëë',
        hpMod: 3.0,
        speed: 72, // Heavy (1.2 * 60)
        reward: 12,
        color: '#ffd700',
        desc: '–°—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Å–∏–ª—å–Ω–µ–µ –æ—Ç —Å–º–µ—Ä—Ç–µ–π —Å–æ—é–∑–Ω–∏–∫–æ–≤',
        archetype: 'SKELETON_COMMANDER',
        scale: 1.3,
        tint: '#ffd700'
    },
    SPIDER_POISON: {
        id: 'spider_poison',
        name: '–Ø–¥–æ–≤–∏—Ç—ã–π',
        symbol: 'üß™',
        hpMod: 1.4,
        speed: 132, // 2.2 * 60 = 132
        reward: 6,
        color: '#76ff03',
        desc: '–û—Å—Ç–∞–≤–ª—è–µ—Ç –ª–µ—á–∞—â—É—é –ª—É–∂—É –ø–æ—Å–ª–µ —Å–º–µ—Ä—Ç–∏',
        archetype: 'SPIDER',
        scale: 1.15,
        tint: '#76ff03'
    },
    TROLL_ARMORED: {
        id: 'troll_armored',
        name: '–õ–∞—Ç–Ω–∏–∫',
        symbol: 'üõ°Ô∏è',
        hpMod: 7.0,
        speed: 42, // 0.7 * 60 = 42
        reward: 15,
        color: '#eceff1', // Snow White
        desc: '–°–Ω–µ–∂–Ω—ã–π —Ç—Ä–æ–ª–ª—å —Å —Ç—è–∂–µ–ª–æ–π –¥—É–±–∏–Ω–æ–π',
        archetype: 'TROLL',
        scale: 1.3,
        tint: '#cfd8dc'
    },
    GOBLIN: {
        id: 'goblin',
        name: '–ì–æ–±–ª–∏–Ω',
        symbol: 'üë∫',
        hpMod: 0.8,
        speed: 76,
        reward: 3,
        color: '#689f38',
        desc: '–ñ–∞–¥–Ω—ã–π –º–∞—Ä–æ–¥–µ—Ä —Å –º–µ—à–∫–æ–º',
        archetype: 'GOBLIN',
        scale: 1.35,
    },
    SAPPER_RAT: {
        id: 'sapper_rat',
        name: '–ê–ª—Ö–∏–º–∏—á–µ—Å–∫–∞—è –ö—Ä—ã—Å–∞',
        symbol: 'üêÄ',
        hpMod: 1.8, // Durable carrier
        speed: 130, // Slightly slower to compensate for HP
        reward: 12,
        color: '#3e2723', // Darker brown
        desc: '–í–∑—Ä—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —Å–º–µ—Ä—Ç–∏, –Ω–∞–Ω–æ—Å—è —É—Ä–æ–Ω –í–°–ï–ú',
        archetype: 'RAT',
        scale: 1.15,
    },
    MAGMA_KING: {
        id: 'magma_king',
        name: '–ö–æ—Ä–æ–ª—å –ú–∞–≥–º—ã',
        symbol: 'üåã',
        hpMod: 15.0,
        speed: 55,
        reward: 100,
        color: '#ff3d00', // Magma Orange
        desc: '–î—Ä–µ–≤–Ω–∏–π –∞—Ä—Ö–∏–¥–µ–º–æ–Ω –∏–∑ —Ä–∞—Å–ø–ª–∞–≤–ª–µ–Ω–Ω–æ–π –º–∞–≥–º—ã. –°–±—Ä–∞—Å—ã–≤–∞–µ—Ç –æ—Å—Ç—ã–≤—à—É—é –æ–±–æ–ª–æ—á–∫—É –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —É—Ä–æ–Ω–∞.',
        archetype: 'MAGMA',
        scale: 1.4,
    },
    MAGMA_STATUE: {
        id: 'magma_statue',
        name: '–û–±—Å–∏–¥–∏–∞–Ω–æ–≤–∞—è –°—Ç–∞—Ç—É—è',
        symbol: 'üóø',
        hpMod: 8.0,
        speed: 1,
        reward: 0,
        color: '#212121', // Obsidian
        desc: '–û—Å—Ç—ã–≤—à–∞—è –ª–∞–≤–æ–≤–∞—è –æ–±–æ–ª–æ—á–∫–∞ –±–æ—Å—Å–∞. –¢–≤–µ—Ä–¥–∞—è –∫–∞–∫ –∫–∞–º–µ–Ω—å.',
        archetype: 'MAGMA',
        scale: 1.0,
        armor: 15,
        isHidden: true,
    }
};
</file>

<file path="src/ForgeSystem.ts">
import { IGameScene } from './scenes/IGameScene';
import { CardSystem, ICard } from './CardSystem';
import { CONFIG } from './Config';

export class ForgeSystem {
    private scene: IGameScene;
    private slotEls: HTMLElement[];

    public forgeSlots: (ICard | null)[] = [null, null];
    public isForging: boolean = false;

    constructor(scene: IGameScene) {
        this.scene = scene;
        // –ö—ç—à–∏—Ä—É–µ–º DOM —ç–ª–µ–º–µ–Ω—Ç—ã —Å–ª–æ—Ç–æ–≤. 
        // –í –∏–¥–µ–∞–ª–µ —ç—Ç–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤ UIManager, –Ω–æ –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–∏–º –∑–¥–µ—Å—å –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏.
        this.slotEls = [document.getElementById('forge-slot-0')!, document.getElementById('forge-slot-1')!];
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –æ—Ç–ø—É—Å—Ç–∏–ª–∏ –ª–∏ –º—ã—à—å –Ω–∞–¥ —Å–ª–æ—Ç–æ–º –∫—É–∑–Ω–∏—Ü—ã.
     * –ï—Å–ª–∏ –¥–∞ - –∫–ª–∞–¥–µ—Ç –∫–∞—Ä—Ç—É –≤ —Å–ª–æ—Ç.
     */
    public tryDropCard(mouseX: number, mouseY: number, card: ICard): boolean {
        // –ù–µ–ª—å–∑—è –∫–ª–∞—Å—Ç—å –∫–∞—Ä—Ç—ã, –ø–æ–∫–∞ –∏–¥–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –∫–æ–≤–∫–∏
        if (this.isForging) return false;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π —Å–ª–æ—Ç
        for (let i = 0; i < this.slotEls.length; i++) {
            const rect = this.slotEls[i].getBoundingClientRect();

            // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –∫—É—Ä—Å–æ—Ä –≤–Ω—É—Ç—Ä–∏ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ —Å–ª–æ—Ç–∞?
            if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) {
                // –ï—Å–ª–∏ —Å–ª–æ—Ç –∑–∞–Ω—è—Ç - –Ω–µ –∫–ª–∞–¥–µ–º
                if (this.forgeSlots[i] !== null) {
                    return false;
                }

                // –£—Å–ø–µ—Ö: –∫–ª–∞–¥–µ–º –∫–∞—Ä—Ç—É
                this.putInForgeSlot(i, card);
                return true;
            }
        }
        return false;
    }

    public canForge(): boolean {
        const c1 = this.forgeSlots[0];
        const c2 = this.forgeSlots[1];
        return !!(c1 && c2 && c1.type.id === c2.type.id && c1.level === c2.level && c1.level < 3);
    }

    public putInForgeSlot(slotIdx: number, card: ICard) {
        this.scene.cardSys.removeCardFromHand(card);
        this.forgeSlots[slotIdx] = card;
        this.render();
        // UI update via generic update or event would be better
        this.scene.ui.update();
    }

    public returnFromForge(slotIdx: number) {
        const card = this.forgeSlots[slotIdx];
        if (card) {
            this.forgeSlots[slotIdx] = null;
            this.scene.cardSys.hand.push(card); // Push back to hand
            this.scene.cardSys.render(); // Re-render hand
            this.render();
            this.scene.ui.update();
        }
    }

    public tryForge() {
        if (!this.canForge()) return;

        // Progressive Forge Cost
        const card = this.forgeSlots[0]!;
        const cost = card.level === 1
            ? CONFIG.ECONOMY.FORGE_COST_LVL1   // 50
            : CONFIG.ECONOMY.FORGE_COST_LVL2;  // 65

        // Logic decoupled from UI floating text hopefully? 
        // No, we still need feedback.
        if (this.scene.money < cost) {
            this.scene.showFloatingText('Need Money!', 500, 500, 'red');
            return;
        }

        if (!this.scene.spendMoney(cost)) {
            return;
        }
        this.isForging = true;

        // Get forge slot position for particle effects
        const forgeSlot0 = this.slotEls[0];
        const forgeSlot1 = this.slotEls[1];
        const canvas = this.scene.game.canvas;
        const canvasRect = canvas.getBoundingClientRect();

        // Add visual feedback to forge slots (CSS classes)
        if (forgeSlot0) forgeSlot0.classList.add('forging');
        if (forgeSlot1) forgeSlot1.classList.add('forging');

        // Calculate center position between slots for effects
        let effectX = 200;
        let effectY = canvas.height - 300;

        if (forgeSlot0 && forgeSlot1) {
            const rect0 = forgeSlot0.getBoundingClientRect();
            const rect1 = forgeSlot1.getBoundingClientRect();
            const centerX = (rect0.left + rect1.right) / 2;
            const centerY = (rect0.top + rect0.bottom) / 2;

            // Convert screen coords to canvas coords
            effectX = (centerX - canvasRect.left) * (canvas.width / canvasRect.width);
            effectY = (centerY - canvasRect.top) * (canvas.height / canvasRect.height);
        }

        // Spawn particles during forge animation
        let forgeFrame = 0;
        const particleInterval = setInterval(() => {
            forgeFrame++;
            // const intensity = 1 + (forgeFrame / 16); 

            for (let i = 0; i < 5; i++) {
                this.scene.effects.add({
                    type: 'particle',
                    x: effectX + (Math.random() - 0.5) * 80,
                    y: effectY + (Math.random() - 0.5) * 50,
                    vx: (Math.random() - 0.5) * 360, // 6 * 60
                    vy: -(Math.random() * 240 + 60), // 4+1 * 60
                    life: 0.5 + Math.random() * 0.3, // 30-50 frames
                    radius: Math.random() * 4 + 2,
                    color: Math.random() > 0.5 ? '#ff9800' : '#ffeb3b', // Orange/Yellow sparks
                });
            }
        }, 50);

        // Forging complete
        setTimeout(() => {
            clearInterval(particleInterval);

            // Remove forging animation from slots
            if (forgeSlot0) forgeSlot0.classList.remove('forging');
            if (forgeSlot1) forgeSlot1.classList.remove('forging');

            const c1 = this.forgeSlots[0]!;
            const newLevel = c1.level + 1;

            // Find card type key
            let typeKey = 'FIRE';
            for (const k in CONFIG.CARD_TYPES) {
                if (CONFIG.CARD_TYPES[k].id === c1.type.id) {
                    typeKey = k;
                    break;
                }
            }

            this.forgeSlots = [null, null];
            this.isForging = false;

            // Add upgraded card back to hand
            this.scene.cardSys.addCard(typeKey, newLevel);

            // Enhanced completion effects
            this.scene.effects.add({
                type: 'explosion',
                x: effectX,
                y: effectY,
                radius: 60,
                life: 0.6,
                color: '#ffd700', // Gold
            });

            // Burst of particles
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                this.scene.effects.add({
                    type: 'particle',
                    x: effectX,
                    y: effectY,
                    vx: Math.cos(angle) * 300, // 5 * 60
                    vy: Math.sin(angle) * 300,
                    life: 0.65,
                    radius: 4,
                    color: '#ffd700',
                });
            }

            this.scene.showFloatingText('‚öíÔ∏è FORGED!', effectX, effectY - 30, 'gold');

            // Re-render
            this.render();
            this.scene.ui.update();

        }, 800);
    }

    public render() {
        this.slotEls.forEach((el, idx) => {
            el.innerHTML = '';
            const slotCard = this.forgeSlots[idx];
            if (slotCard) {
                const cardEl = CardSystem.createCardElement(slotCard);
                cardEl.onclick = () => this.returnFromForge(idx);
                el.appendChild(cardEl);
            } else {
                el.innerText = (idx + 1).toString();
            }
        });
    }

    public update() {
        // No per-frame update needed for now
    }
}
</file>

<file path="src/InspectorSystem.ts">
import { GameScene } from './scenes/GameScene';
import { Tower } from './Tower';
import { CONFIG } from './Config';

export class InspectorSystem {
    private scene: GameScene;
    private elInspector: HTMLElement;
    private elName: HTMLElement;
    private elStats: HTMLElement;
    private elCardsContainer: HTMLElement;
    private elSellBtn: HTMLButtonElement;

    private currentTower: Tower | null = null;

    constructor(scene: GameScene) {
        this.scene = scene;
        this.elInspector = document.createElement('div');

        // Create inspector panel
        this.elInspector.id = 'inspector-panel';
        this.elInspector.className = 'ui-panel'; // Use existing panel style
        Object.assign(this.elInspector.style, {
            background: 'rgba(20, 20, 30, 0.95)',
            border: '2px solid #555',
            borderRadius: '8px',
            padding: '15px',
            color: '#fff',
            display: 'none',
            pointerEvents: 'auto',
            marginBottom: '15px', // Space above shop panel
        });

        this.elName = document.createElement('h3');
        this.elName.style.margin = '0 0 10px 0';
        this.elName.style.textAlign = 'center';

        this.elStats = document.createElement('div');
        this.elStats.style.fontSize = '13px';
        this.elStats.style.marginBottom = '10px';

        this.elCardsContainer = document.createElement('div');
        Object.assign(this.elCardsContainer.style, {
            borderTop: '1px solid #555',
            paddingTop: '10px',
            marginTop: '10px',
        });

        this.elSellBtn = document.createElement('button');
        this.elSellBtn.innerText = 'üóëÔ∏è –ü–†–û–î–ê–¢–¨ –ë–ê–®–ù–Æ';
        Object.assign(this.elSellBtn.style, {
            marginTop: '10px',
            padding: '12px',
            background: '#d32f2f',
            color: '#fff',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            fontWeight: 'bold',
            width: '100%',
            fontSize: '14px',
        });

        // CRITICAL: Use addEventListener for better event handling
        this.elSellBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event from bubbling to canvas
            e.preventDefault();
            console.log('Sell button clicked! Tower:', this.currentTower);
            if (this.currentTower) {
                this.scene.sellTower(this.currentTower);
            }
        });

        this.elInspector.appendChild(this.elName);
        this.elInspector.appendChild(this.elStats);
        this.elInspector.appendChild(this.elCardsContainer);
        this.elInspector.appendChild(this.elSellBtn);

        // CRITICAL: Attach to #ui-right container, NOT document.body
        // This ensures proper event handling within the UI layer
        const uiRight = document.getElementById('ui-right');
        if (uiRight) {
            // Insert at the beginning so it appears above shop
            uiRight.insertBefore(this.elInspector, uiRight.firstChild);
        } else {
            // Fallback to body if ui-right not found
            document.body.appendChild(this.elInspector);
        }
    }

    public selectTower(tower: Tower) {
        this.currentTower = tower;
        this.elInspector.style.display = 'block';
        this.updateInfo();
    }

    public hide() {
        this.currentTower = null;
        this.elInspector.style.display = 'none';
    }

    private updateInfo() {
        if (!this.currentTower) return;

        this.elName.innerText = 'üè∞ –ë–∞—à–Ω—è';

        // Get tower stats
        const stats = this.currentTower.getStats();

        // Build stats display
        let statsHTML = '';
        statsHTML += `<div>‚öîÔ∏è –£—Ä–æ–Ω: ${stats.dmg.toFixed(1)}</div>`;
        statsHTML += `<div>üìè –†–∞–¥–∏—É—Å: ${stats.range.toFixed(0)}</div>`;
        statsHTML += `<div>‚è±Ô∏è –°–∫–æ—Ä–æ—Å—Ç—å: ${(1 / stats.cd).toFixed(1)}/—Å</div>`;
        if (stats.pierce > 0) {
            statsHTML += `<div>üéØ –ü—Ä–æ–±–∏–≤–∞–Ω–∏–µ: ${stats.pierce}</div>`;
        }
        this.elStats.innerHTML = statsHTML;

        // Clear and rebuild cards container
        this.elCardsContainer.innerHTML = '';

        // === TARGETING MODE SELECTOR ===
        const targetingSection = document.createElement('div');
        Object.assign(targetingSection.style, {
            borderBottom: '1px solid #555',
            paddingBottom: '10px',
            marginBottom: '10px',
        });

        const targetingLabel = document.createElement('div');
        targetingLabel.innerText = '–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Ü–µ–ª–∏:';
        Object.assign(targetingLabel.style, {
            fontSize: '12px',
            color: '#aaa',
            marginBottom: '5px',
            textAlign: 'center',
        });
        targetingSection.appendChild(targetingLabel);

        const targetingRow = document.createElement('div');
        Object.assign(targetingRow.style, {
            display: 'flex',
            gap: '5px',
            justifyContent: 'center',
        });

        // Create buttons for each targeting mode
        Object.values(CONFIG.TARGETING_MODES).forEach((mode: any) => {
            const btn = document.createElement('button');
            btn.innerText = mode.icon;
            btn.title = `${mode.name}: ${mode.desc}`;

            const isActive = this.currentTower!.targetingMode === mode.id;
            Object.assign(btn.style, {
                width: '36px',
                height: '36px',
                fontSize: '18px',
                background: isActive ? '#4caf50' : '#444',
                border: `2px solid ${isActive ? '#fff' : '#666'}`,
                borderRadius: '6px',
                cursor: 'pointer',
                transition: 'all 0.15s',
            });

            btn.addEventListener('mouseenter', () => {
                if (!isActive) btn.style.background = '#555';
            });
            btn.addEventListener('mouseleave', () => {
                if (!isActive) btn.style.background = '#444';
            });

            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                if (this.currentTower) {
                    this.currentTower.targetingMode = mode.id;
                    console.log('Targeting mode changed to:', mode.id);
                    this.updateInfo(); // Refresh to show new selection
                }
            });

            targetingRow.appendChild(btn);
        });

        targetingSection.appendChild(targetingRow);
        this.elCardsContainer.appendChild(targetingSection);
        // === END TARGETING MODE SELECTOR ===

        const label = document.createElement('div');
        label.style.fontSize = '12px';
        label.style.color = '#aaa';
        label.style.marginBottom = '5px';
        label.style.textAlign = 'center';
        label.innerText = '–ö–∞—Ä—Ç—ã (–∫–ª–∏–∫ = –ø—Ä–æ–¥–∞—Ç—å):';
        this.elCardsContainer.appendChild(label);

        const cardsRow = document.createElement('div');
        Object.assign(cardsRow.style, {
            display: 'flex',
            gap: '5px',
            justifyContent: 'center',
        });

        for (let i = 0; i < 3; i++) {
            const slotEl = document.createElement('div');

            if (this.currentTower.cards[i]) {
                const card = this.currentTower.cards[i];
                const stars = '‚òÖ'.repeat(card.level);
                const sellPrice = CONFIG.ECONOMY.CARD_SELL_PRICES[card.level] || 5;

                Object.assign(slotEl.style, {
                    width: '50px',
                    height: '70px',
                    background: card.type.color,
                    borderRadius: '4px',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    border: '2px solid rgba(255,255,255,0.3)',
                    position: 'relative',
                    cursor: 'pointer',
                    transition: 'transform 0.1s, box-shadow 0.1s',
                });

                slotEl.innerHTML = `
                    <div style="position: absolute; top: 2px; left: 2px; font-size: 8px; color: #fff;">${stars}</div>
                    <div style="font-size: 24px;">${card.type.icon}</div>
                    <div style="font-size: 10px; color: #fff; margin-top: 2px;">${sellPrice}üí∞</div>
                `;

                // Hover effect
                slotEl.onmouseenter = () => {
                    slotEl.style.transform = 'scale(1.1)';
                    slotEl.style.boxShadow = '0 0 10px gold';
                };
                slotEl.onmouseleave = () => {
                    slotEl.style.transform = 'scale(1)';
                    slotEl.style.boxShadow = 'none';
                };

                // Click to sell card
                const cardIndex = i;
                slotEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    console.log('Card sell clicked! Index:', cardIndex, 'Tower:', this.currentTower);
                    if (this.currentTower) {
                        this.scene.sellCardFromTower(this.currentTower, cardIndex);
                    }
                });
            } else {
                // Empty slot
                Object.assign(slotEl.style, {
                    width: '50px',
                    height: '70px',
                    background: '#333',
                    borderRadius: '4px',
                    border: '1px dashed #555',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: '#555',
                    fontSize: '18px',
                });
                slotEl.innerText = '?';
            }

            cardsRow.appendChild(slotEl);
        }

        this.elCardsContainer.appendChild(cardsRow);

        // Update sell button with refund amount
        const refund = Math.floor(CONFIG.ECONOMY.TOWER_COST * CONFIG.ECONOMY.SELL_REFUND);
        this.elSellBtn.innerText = `üóëÔ∏è –ü–†–û–î–ê–¢–¨ (+${refund}üí∞)`;
    }
}
</file>

<file path="src/scenes/IGameScene.ts">
import { Game } from '../Game';
import { IMapData } from '../MapData';
import { WaveManager } from '../WaveManager';
import { CardSystem, ICard } from '../CardSystem';
import { UIManager } from '../UIManager';
import { ForgeSystem } from '../ForgeSystem';
import { InspectorSystem } from '../InspectorSystem';
import { MetricsSystem } from '../MetricsSystem';
import { Enemy } from '../Enemy';
import { Tower } from '../Tower';
import { Projectile } from '../Projectile';
import { EffectSystem } from '../EffectSystem';
import { EventEmitter } from '../Events';

// Define the interface for the GameScene
export interface IGameScene {
    // Core references
    game: Game;
    mapData: IMapData;

    // Systems
    waveManager: WaveManager;
    cardSys: CardSystem;
    ui: UIManager;
    forge: ForgeSystem;
    inspector: InspectorSystem;
    metrics: MetricsSystem;
    effects: EffectSystem;
    events: EventEmitter;

    // State
    wave: number;
    readonly money: number;
    readonly lives: number;
    readonly startingLives: number; // For perfect wave bonus detection
    enemies: Enemy[];
    towers: Tower[];
    projectiles: Projectile[];

    // Methods
    spawnEnemy(type: string): void;
    showFloatingText(text: string, x: number, y: number, color?: string): void;
    handleCardDrop(card: ICard, x: number, y: number): boolean;
    giveRandomCard(): void;
    sellTower(tower: Tower): void;
    sellCardFromTower(tower: Tower, cardIndex: number): void;
    restart(): void;
    togglePause(): void;

    // Helper Methods
    addMoney(amount: number): void;
    spendMoney(amount: number): boolean;
    loseLife(amount?: number): void;

    // Need these for some systems (e.g. UIManager accessing shop)
    // shop is in UIManager, but UIManager might access scene's other props
}
</file>

<file path="src/types.ts">
/**
 * Central type definitions for the Tower Defense game
 */

// ============================================
// Card System Types
// ============================================

export interface ICardTypeConfig {
    id: string;
    name: string;
    icon: string;
    color: string;
    desc: string;
    // Turret rendering (optional for backward compatibility)
    turretAsset?: string;  // e.g. 'turret_fire'
    moduleAsset?: string;  // e.g. 'mod_fire'
}

// ============================================
// Enemy System Types
// ============================================

export interface IEnemyTypeConfig {
    id: string;
    name: string;
    symbol: string;
    hpMod: number;
    speed: number;
    reward: number;
    armor?: number; // Optional armor value
    color: string;
    desc: string;
    // Modular Visuals
    archetype?: 'SKELETON' | 'WOLF' | 'TROLL' | 'SPIDER' | 'HELLHOUND' | 'ORC' | 'WRAITH' | 'GOBLIN' | 'SKELETON_COMMANDER' | 'RAT' | 'MAGMA';
    scale?: number;
    props?: string[]; // IDs of props
    tint?: string;    // Hex color override
    isHidden?: boolean; // If true, hidden from Editor/Bestiary lists
}

// ============================================
// Configuration Types
// ============================================

export type CardTypeKey = 'FIRE' | 'ICE' | 'SNIPER' | 'MULTISHOT';
export type EnemyTypeKey = 'GRUNT' | 'SCOUT' | 'TANK' | 'BOSS';

// ============================================
// Utility Types
// ============================================

/**
 * Type-safe accessor for card types
 */
export function getCardTypeConfig(key: string): ICardTypeConfig | undefined {
    return undefined; // Implementation will be in Config.ts
}

/**
 * Type-safe accessor for enemy types
 */
export function getEnemyTypeConfig(key: string): IEnemyTypeConfig | undefined {
    return undefined; // Implementation will be in Config.ts
}
</file>

<file path="src/BestiarySystem.ts">
import { GameScene } from './scenes/GameScene';
import { BestiaryUI } from './ui/bestiary/BestiaryUI';
import { UIUtils } from './UIUtils';
import { EventBus, Events } from './EventBus';

export class BestiarySystem {
    private scene: GameScene;
    private unlockedEnemies: Set<string> = new Set();
    private ui: BestiaryUI | null = null;
    private btn!: HTMLElement;

    private eventSubId: number = -1;

    constructor(scene: GameScene) {
        this.scene = scene;
        this.loadProgress(); // Load saved unlocks
        this.createButton();

        // Start with basic enemy unlocked (if not already loaded)
        this.unlock('grunt');

        // Listen for enemy spawns to unlock them
        this.eventSubId = EventBus.getInstance().on(Events.ENEMY_SPAWNED, (enemyType: string) => {
            this.unlock(enemyType);
        });
    }

    public destroy() {
        if (this.eventSubId !== -1) {
            EventBus.getInstance().off(this.eventSubId);
            this.eventSubId = -1;
        }
        if (this.btn && this.btn.parentNode) {
            this.btn.parentNode.removeChild(this.btn);
        }
        if (this.ui) {
            this.ui.hide();
            // BestiaryUI doesn't strictly need destroy if it just removes DOM, 
            // but we could add it if needed. For now, removing the button is key.
        }
    }

    private loadProgress() {
        try {
            const saved = localStorage.getItem('nt_bestiary_unlocks');
            if (saved) {
                const ids = JSON.parse(saved);
                if (Array.isArray(ids)) {
                    ids.forEach(id => this.unlockedEnemies.add(id));
                }
            }
        } catch (e) {
            console.error('Failed to load bestiary progress', e);
        }
    }

    private saveProgress() {
        try {
            const data = JSON.stringify(Array.from(this.unlockedEnemies));
            localStorage.setItem('nt_bestiary_unlocks', data);
        } catch (e) {
            console.error('Failed to save bestiary progress', e);
        }
    }

    public unlock(typeId: string) {
        const id = typeId.toLowerCase();
        if (!this.unlockedEnemies.has(id)) {
            this.unlockedEnemies.add(id);
            this.saveProgress();
            if (this.ui) this.ui.unlockEnemy(id);
        }
    }

    private getUI(): BestiaryUI {
        if (!this.ui) {
            this.ui = new BestiaryUI(this.scene, this.unlockedEnemies);
        }
        return this.ui;
    }

    private toggle() {
        this.getUI().toggle();
    }

    private createButton() {
        this.btn = UIUtils.createButton(document.body, 'üìñ', () => this.toggle(), {
            position: 'absolute',
            top: '20px',
            left: '20px',
            width: '40px',
            height: '40px',
            borderRadius: '50%',
            fontSize: '24px',
            padding: '0',
            background: 'rgba(0,0,0,0.6)',
            color: '#fff',
            border: '2px solid #aaa',
            zIndex: '100',
            title: 'Bestiary'
        });

        // Hover effect for button
        this.btn.onmousedown = () => (this.btn.style.transform = 'scale(0.9)');
        this.btn.onmouseup = () => (this.btn.style.transform = 'scale(1)');
    }
}
</file>

<file path="src/cards/IceCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Ice Card Upgrades
 * 
 * Level 1: 30% slow, -10% range, +1 damage
 * Level 2: 45% slow, -20% range, +3 damage, +20% damage to slowed enemies
 * Level 3: 75% slow, -25% range, +6 damage, +40% damage to slowed, chain slow on death
 */
export const ICE_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damage: 1,
            rangeMultiplier: 0.90, // -10% range
        },
        effects: [
            {
                type: 'slow',
                slowPower: 0.30, // 30% slow
                slowDuration: 3, // 180 / 60
            }
        ],
        visualOverrides: {
            projectileType: 'ice',
            projectileColor: '#00bcd4',
            projectileSpeed: 600, // 10 * 60
        }
    },
    2: {
        level: 2,
        modifiers: {
            damage: 3,
            rangeMultiplier: 0.80, // -20% range
        },
        effects: [
            {
                type: 'slow',
                slowPower: 0.45, // 45% slow
                slowDuration: 4.5, // 270 / 60
                damageToSlowed: 1.20, // +20% damage to slowed enemies
            }
        ]
    },
    3: {
        level: 3,
        modifiers: {
            damage: 6,
            rangeMultiplier: 0.75, // -25% range
        },
        effects: [
            {
                type: 'slow',
                slowPower: 0.75, // 75% slow
                slowDuration: 6, // 360 / 60
                damageToSlowed: 1.40, // +40% damage to slowed enemies
            },
            {
                type: 'chainSlowOnDeath',
                chainRadius: 80,
            }
        ]
    }
};
</file>

<file path="src/FogSystem.ts">
import { IMapData } from './MapData';
import { FogRenderer } from './FogRenderer';
import { FogStructure, buildFogStructures } from './FogStructure';
import { CONFIG } from './Config';

/**
 * Fog System - manages layered fog with density and structure-based animation
 * @description
 * Supports 6 density levels:
 * - 0: No fog (visible)
 * - 1: 20% density
 * - 2: 40% density
 * - 3: 60% density
 * - 4: 80% density
 * - 5: 100% density
 */
export class FogSystem {
    private mapData: IMapData;
    private renderer: FogRenderer;
    private structures: FogStructure[] = [];
    private time: number = 0;
    private dirty: boolean = true;

    constructor(mapData: IMapData) {
        this.mapData = mapData;

        // Initialize fog data if missing
        if (!this.mapData.fogData) {
            this.mapData.fogData = Array(mapData.width * mapData.height).fill(0);
        } else if (this.mapData.fogData.length !== mapData.width * mapData.height) {
            const newData = Array(mapData.width * mapData.height).fill(0);
            this.mapData.fogData = newData;
        }

        // Create standard renderer
        this.renderer = new FogRenderer(
            mapData.width * 64, // Assuming TILE_SIZE = 64
            mapData.height * 64
        );

        this.buildStructures();
    }

    /**
     * Build fog structures from current fog data
     */
    private buildStructures(): void {
        this.structures = buildFogStructures(
            this.mapData.fogData!,
            this.mapData.width,
            this.mapData.height
        );
        this.dirty = false;

        console.log(`FogSystem: Found ${this.structures.length} fog structures`);
    }

    /**
     * Update fog animation
     */
    /**
     * Update fog animation
     */
    public update(dt: number = 0.016, lights: { x: number, y: number, radius: number }[] = []): void {
        // Rebuild structures if data changed
        if (this.dirty) {
            this.buildStructures();
        }

        const t = (dt > 0) ? (this.time += dt * 60) : 0;

        // Render Sprite logic
        if (dt > 0 || this.time === 0) {
            this.renderer.render(this.structures, this.time, lights);
        }
    }

    /**
     * Draw fog to main canvas
     */
    public draw(ctx: CanvasRenderingContext2D): void {
        ctx.save();
        ctx.drawImage(this.renderer.getCanvas(), 0, 0);
        ctx.restore();
    }

    /**
     * Set fog density at specific tile
     * @param x Column
     * @param y Row
     * @param density 0-5 (0 = no fog, 5 = max density)
     */
    public setFog(x: number, y: number, density: number): void {
        if (x < 0 || x >= this.mapData.width || y < 0 || y >= this.mapData.height) return;
        if (density < 0 || density > 5) return;

        const index = y * this.mapData.width + x;
        if (this.mapData.fogData![index] !== density) {
            this.mapData.fogData![index] = density;
            this.dirty = true;
        }
    }

    /**
     * Get fog density at specific tile
     */
    public getFog(x: number, y: number): number {
        if (x < 0 || x >= this.mapData.width || y < 0 || y >= this.mapData.height) return 0;
        const index = y * this.mapData.width + x;
        return this.mapData.fogData![index] || 0;
    }

    /**
     * Cycle fog density (1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 1)
     * For editor use - each click increases density
     */
    public cycleFogDensity(x: number, y: number): void {
        const current = this.getFog(x, y);
        let next: number;

        if (current === 0) {
            // First click on empty tile -> density 1
            next = 1;
        } else if (current >= 5) {
            // Max density -> back to 1
            next = 1;
        } else {
            // Increment density
            next = current + 1;
        }

        this.setFog(x, y, next);
    }

    /**
     * Get fog data array
     */
    public getFogData(): number[] {
        return this.mapData.fogData || [];
    }

    /**
     * Legacy method for compatibility
     * @deprecated Use setFog or cycleFogDensity instead
     */
    public toggleFog(col: number, row: number): void {
        this.cycleFogDensity(col, row);
    }
}
</file>

<file path="src/ui/GameHUD.ts">
import { IGameScene } from '../scenes/IGameScene';
import { CONFIG } from '../Config';
import { UIUtils } from '../UIUtils';
import { EventBus, Events } from '../EventBus';
import { VISUALS } from '../VisualConfig';

export class GameHUD {
    private scene: IGameScene;

    private elMoney: HTMLElement;
    private elWave: HTMLElement;
    private elLives: HTMLElement;
    private elEnemyCounter: HTMLElement;
    private elForgeBtn: HTMLButtonElement;
    private elStartBtn: HTMLButtonElement;
    // private elPauseBtn: HTMLButtonElement; // REMOVED

    constructor(scene: IGameScene) {
        this.scene = scene;

        this.elMoney = document.getElementById('money')!;
        this.elWave = document.getElementById('wave')!;
        this.elLives = document.getElementById('lives')!;
        this.elEnemyCounter = document.getElementById('enemy-counter')!;
        this.elForgeBtn = document.getElementById('forge-btn') as HTMLButtonElement;
        this.elStartBtn = document.getElementById('start-wave-btn') as HTMLButtonElement;
        // Pause button removed

        this.initListeners();
        this.initSubscriptions();

        // Initial values
        this.updateMoney(this.scene.money);
        this.updateLives(this.scene.lives);
        this.updateWaveText(this.scene.wave);
    }

    private initListeners() {
        this.elStartBtn.addEventListener('click', () => this.scene.waveManager.startWave());

        // Pause button listener removed

        this.elForgeBtn.addEventListener('click', () => {
            // FIX: Use forge system
            if (!this.scene.forge || !this.scene.forge.canForge()) return;

            // Determine cost based on card level
            const card = this.scene.forge.forgeSlots[0];
            const forgeCost = card && card.level >= 2
                ? CONFIG.ECONOMY.FORGE_COST_LVL2
                : CONFIG.ECONOMY.FORGE_COST_LVL1;

            if (this.scene.money >= forgeCost) {
                this.scene.forge.tryForge();
                // Button state will update on next tick or via event if we add more events
            }
        });
    }

    private initSubscriptions() {
        const bus = EventBus.getInstance();
        bus.on(Events.MONEY_CHANGED, (money: number) => this.updateMoney(money));
        bus.on(Events.LIVES_CHANGED, (lives: number) => this.updateLives(lives));
        bus.on(Events.WAVE_STARTED, (wave: number) => {
            this.updateWaveText(wave);
            this.updateStartBtn(true);
        });
        bus.on(Events.WAVE_COMPLETED, () => this.updateStartBtn(false));
        // Pause toggle event listener removed for button update (button doesn't exist)
    }

    private updateMoney(newMoney: number) {
        // Flash animation
        const current = parseInt(this.elMoney.innerText) || 0;
        if (newMoney > current) {
            UIUtils.flashElement(this.elMoney.parentElement || this.elMoney, VISUALS.UI.COLORS.success);
        } else if (newMoney < current) {
            UIUtils.flashElement(this.elMoney.parentElement || this.elMoney, VISUALS.UI.COLORS.danger);
        }
        this.elMoney.innerText = newMoney.toString();
        this.updateForgeBtn(newMoney);
    }

    private updateLives(newLives: number) {
        const current = parseInt(this.elLives.innerText) || 0;
        if (newLives < current) {
            UIUtils.flashElement(this.elLives.parentElement || this.elLives, VISUALS.UI.COLORS.danger);
        }
        this.elLives.innerText = newLives.toString();
    }

    private updateWaveText(wave: number) {
        this.elWave.innerText = wave.toString();
    }

    public updateEnemyCounter(currentCount: number) {
        this.elEnemyCounter.innerText = currentCount.toString();
    }

    private updateStartBtn(isWaveActive: boolean) {
        if (isWaveActive) {
            this.elStartBtn.innerText = '>>'; // Fast forward / Next wave
            this.elStartBtn.disabled = false;
            this.elStartBtn.style.opacity = '1';
            this.elStartBtn.title = 'Start next wave early for bonus!';
        } else {
            this.elStartBtn.innerText = '‚öîÔ∏è';
            this.elStartBtn.disabled = false;
            this.elStartBtn.style.opacity = '1';
            this.elStartBtn.title = 'Start Wave';
        }
    }

    private updateForgeBtn(money: number) {
        const forgeSys = this.scene.forge;

        // Determine cost based on slot
        let forgeCost: number = CONFIG.ECONOMY.FORGE_COST_LVL1;
        if (forgeSys && forgeSys.forgeSlots[0] && forgeSys.forgeSlots[0].level >= 2) {
            forgeCost = CONFIG.ECONOMY.FORGE_COST_LVL2;
        }

        const canForge = forgeSys && forgeSys.canForge();
        const hasMoney = money >= forgeCost;

        if (canForge && hasMoney) {
            this.elForgeBtn.disabled = false;
            this.elForgeBtn.innerHTML = `<span>‚öíÔ∏è</span> ${forgeCost}üí∞`;
            this.elForgeBtn.style.opacity = '1';
        } else {
            this.elForgeBtn.disabled = true;
            if (!canForge) this.elForgeBtn.innerHTML = `<span>‚öíÔ∏è</span> –ù–ï–¢ –ö–ê–†–¢`;
            else if (!hasMoney) this.elForgeBtn.innerHTML = `<span>‚öíÔ∏è</span> ${forgeCost}üí∞`;
        }
    }

    // updatePauseBtn removed

    public update() {
        // Polling kept only for complex checks if needed, but currently mostly event driven.
        // Forge button might need polling if HAND changes without event.
        // Let's keep a light update for safety or refactor fully later.
        // For now, let's update ForgeBtn here to be safe as CardSystem doesn't emit events yet.
        if (!this.scene) return;
        this.updateForgeBtn(this.scene.money);

        // Also update start btn state just in case? Or rely on events.
        // Events should be enough for Start Btn.
        this.updateStartBtn(this.scene.waveManager.isWaveActive);
    }
}
</file>

<file path="src/ui/ShopUI.ts">
import { IGameScene } from '../scenes/IGameScene';
import { CONFIG } from '../Config';
import { EventBus, Events } from '../EventBus';
import { VISUALS } from '../VisualConfig';

export class ShopUI {
    private scene: IGameScene;

    private elShopBtn: HTMLButtonElement;
    private elRefreshBtn: HTMLButtonElement; // [NEW]
    private elSlotsContainer: HTMLElement;

    private shopCards: string[] = [];
    private selectedSlot: number = -1;

    public readonly cost: number = 100;
    public readonly refreshCost: number = CONFIG.ECONOMY.SHOP_REROLL_COST; // [NEW]

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.elShopBtn = document.getElementById('shop-btn') as HTMLButtonElement;
        this.elRefreshBtn = document.getElementById('shop-refresh-btn') as HTMLButtonElement; // [NEW]
        this.elSlotsContainer = document.getElementById('shop-slots')!;

        this.initListeners();
        this.rerollShop();
    }

    private initListeners() {
        this.elShopBtn.addEventListener('click', () => this.buySelectedCard());
        this.elRefreshBtn.addEventListener('click', () => this.rerollWithCost()); // [NEW]

        EventBus.getInstance().on(Events.MONEY_CHANGED, () => {
            this.update();
        });
    }

    public rerollWithCost() {
        if (this.scene.money < this.refreshCost) {
            this.scene.showFloatingText('Not enough gold!', 800, 800, 'red');
            return;
        }

        if (this.scene.spendMoney(this.refreshCost)) {
            this.scene.metrics.trackMoneySpent(this.refreshCost);
            this.scene.showFloatingText(`- ${this.refreshCost}üí∞`, 800, 800, 'gold');
            this.rerollShop();

            // Anim refresh
            this.elRefreshBtn.classList.add('shaking');
            setTimeout(() => this.elRefreshBtn.classList.remove('shaking'), 500);
        }
    }

    public rerollShop() {
        this.shopCards = [];
        const allKeys = Object.keys(CONFIG.CARD_TYPES);

        // IMPROVED: Ensure diversity - no duplicates if possible
        const shuffled = [...allKeys].sort(() => Math.random() - 0.5);
        for (let i = 0; i < 3; i++) {
            this.shopCards.push(shuffled[i % shuffled.length]);
        }

        this.selectedSlot = -1;
        this.render();
    }

    private getRandomCardKey(): string {
        const keys = Object.keys(CONFIG.CARD_TYPES);
        return keys[Math.floor(Math.random() * keys.length)];
    }

    public selectSlot(index: number) {
        if (index < 0 || index >= this.shopCards.length) return;

        if (this.selectedSlot === index) {
            this.selectedSlot = -1;
        } else {
            this.selectedSlot = index;
        }
        this.render();
        this.update();
    }

    public buySelectedCard() {
        if (this.selectedSlot === -1) return;

        if (this.scene.money < this.cost) {
            this.scene.showFloatingText('–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –∑–æ–ª–æ—Ç–∞!', 800, 800, 'red');
            return;
        }

        if (this.scene.cardSys.hand.length >= CONFIG.PLAYER.HAND_LIMIT) {
            this.scene.showFloatingText('–†—É–∫–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∞!', 800, 800, 'orange');
            return;
        }

        if (!this.scene.spendMoney(this.cost)) {
            this.scene.showFloatingText('Error: Transaction Failed', 800, 800, 'red');
            return;
        }
        this.scene.metrics.trackMoneySpent(this.cost);

        const cardKey = this.shopCards[this.selectedSlot];
        this.scene.cardSys.addCard(cardKey, 1);

        this.scene.effects.add({
            type: 'text',
            text: `- ${this.cost}üí∞`,
            x: this.scene.game.canvas.width - 200,
            y: this.scene.game.canvas.height - 100,
            life: 60,
            color: 'gold',
            vy: -1,
        });

        this.shopCards[this.selectedSlot] = this.getRandomCardKey();
        this.selectedSlot = -1;

        this.render();
        this.update();
    }

    public update() {
        this.elShopBtn.innerHTML = `<span>üõí</span> ${this.cost}üí∞`;

        const canAfford = this.scene.money >= this.cost;
        const hasSelection = this.selectedSlot !== -1;

        if (canAfford && hasSelection) {
            this.elShopBtn.disabled = false;
            this.elShopBtn.style.opacity = '1';
            this.elShopBtn.style.cursor = 'pointer';
        } else {
            this.elShopBtn.disabled = true;
            this.elShopBtn.style.opacity = '0.5';
            this.elShopBtn.style.cursor = 'not-allowed';
        }

        // Refresh Btn State
        this.elRefreshBtn.innerHTML = `‚Üª ${this.refreshCost}üí∞`; // NEW: Update text dynamically
        if (this.scene.money >= this.refreshCost) {
            this.elRefreshBtn.disabled = false;
            this.elRefreshBtn.style.opacity = '1';
            this.elRefreshBtn.style.cursor = 'pointer';
        } else {
            this.elRefreshBtn.disabled = true;
            this.elRefreshBtn.style.opacity = '0.5';
            this.elRefreshBtn.style.cursor = 'not-allowed';
        }
    }

    private render() {
        this.elSlotsContainer.innerHTML = '';

        this.shopCards.forEach((key, idx) => {
            const typeConfig = CONFIG.CARD_TYPES[key];

            // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å–ª–æ—Ç–∞
            const slot = document.createElement('div');
            slot.className = 'slot shop-slot';

            // --- –í–ò–ó–£–ê–õ–¨–ù–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï ---
            // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É –≤–Ω—É—Ç—Ä–∏, —Ç–æ—á–Ω–æ —Ç–∞–∫—É—é –∂–µ, –∫–∞–∫ –≤ —Ä—É–∫–µ
            const cardVisual = document.createElement('div');
            cardVisual.className = `card type-${typeConfig.id} level-1`;
            // –£–±–∏—Ä–∞–µ–º pointer-events, —á—Ç–æ–±—ã –∫–ª–∏–∫ –ø—Ä–æ—Ö–æ–¥–∏–ª —Å–∫–≤–æ–∑—å –∫–∞—Ä—Ç—É –Ω–∞ —Å–ª–æ—Ç
            cardVisual.style.pointerEvents = 'none';

            // Get stats HTML for level 1
            const statsHTML = this.getCardStatsHTML(typeConfig.id);

            // –í –º–∞–≥–∞–∑–∏–Ω–µ –º—ã –ø—Ä–æ–¥–∞–µ–º –∫–∞—Ä—Ç—ã 1 —É—Ä–æ–≤–Ω—è
            cardVisual.innerHTML = `
                <div class="card-level">‚òÖ</div>
                <div class="card-icon">${typeConfig.icon}</div>
                <div class="card-stats">${statsHTML}</div>
            `;

            slot.appendChild(cardVisual);
            // -----------------------------

            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞
            if (this.selectedSlot === idx) {
                slot.classList.add('selected');
            } else {
                slot.classList.remove('selected');
            }

            // Clean inline styles that might persist if we swapped logic
            slot.style.border = '';
            slot.style.boxShadow = '';
            slot.style.background = '';

            slot.style.cursor = 'pointer';
            slot.onclick = () => this.selectSlot(idx);

            this.elSlotsContainer.appendChild(slot);
        });
    }

    private getCardStatsHTML(typeId: string): string {
        // Same logic as CardSystem, but always level 1
        switch (typeId) {
            case 'fire':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +15</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 50</div>`;
            case 'ice':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +3</div><div class="card-stat-line">‚ùÑÔ∏è 30%</div>`;
            case 'sniper':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +14</div><div class="card-stat-line">üéØ +80</div>`;
            case 'multi':
                return `<div class="card-stat-primary">2 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.8x —É—Ä–æ–Ω</div>`;
            case 'minigun':
                return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+3 —É—Ä–æ–Ω/—Å</div>`;
            default:
                return `<div class="card-stat-line">–ö–∞—Ä—Ç–∞</div>`;
        }
    }
}
</file>

<file path="src/WaveEditor.ts">
import { IWaveConfig } from './MapData';
import { WaveModel } from './editor/WaveModel';
import { WaveList } from './editor/components/WaveList';
import './editor/editor.css';

export class WaveEditor {
    private container!: HTMLElement;
    private model: WaveModel;
    private waveList!: WaveList;
    private onSave: (waves: IWaveConfig[]) => void;
    private onClose: () => void;

    /**
     * @param initialWaves - The initial configuration of waves (will be copied)
     * @param onSave - Callback when user clicks Save
     * @param onClose - Callback when user clicks Cancel
     */
    constructor(initialWaves: IWaveConfig[], onSave: (waves: IWaveConfig[]) => void, onClose: () => void) {
        this.onSave = onSave;
        this.onClose = onClose;

        // Initialize Model with draft data
        // WaveModel handles deep copying
        this.model = new WaveModel(initialWaves);

        this.createUI();

        // Subscribe to model changes to re-render the list
        // In the future, we could have granular updates, but full re-render is safe for now
        this.model.subscribe(() => {
            if (this.waveList) {
                this.waveList.render();
            }
        });
    }

    private createUI() {
        // 1. Overlay
        const overlay = document.createElement('div');
        overlay.className = 'wave-editor-overlay';

        // 2. Main Container
        this.container = document.createElement('div');
        this.container.className = 'wave-editor-container';

        // 3. Header
        const header = document.createElement('div');
        header.className = 'we-header';
        header.innerHTML = `
            <h2>Wave Configuration</h2>
            <div style="font-size: 12px; color: #888;">Draft Mode</div>
        `;
        this.container.appendChild(header);

        // 4. Content (The Wave List)
        const content = document.createElement('div');
        content.className = 'we-content';

        this.waveList = new WaveList(this.model);
        this.waveList.mount(content);

        this.container.appendChild(content);

        // 5. Footer (Buttons)
        const footer = document.createElement('div');
        footer.className = 'we-footer';

        const saveBtn = document.createElement('button');
        saveBtn.className = 'we-btn we-btn-primary';
        saveBtn.style.flex = '1';
        saveBtn.textContent = 'Save & Close';
        saveBtn.onclick = () => this.save();

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'we-btn we-btn-danger';
        cancelBtn.style.flex = '1';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.onclick = () => this.close();

        footer.appendChild(saveBtn);
        footer.appendChild(cancelBtn);
        this.container.appendChild(footer);

        // Mount Overlay to Body
        overlay.appendChild(this.container);
        document.body.appendChild(overlay);

        // Update reference to point to overlay for destruction
        this.container = overlay;
    }

    private save() {
        if (!this.model.validate()) {
            alert('Invalid configuration! Check for empty waves or groups.');
            return;
        }
        this.onSave(this.model.getWaves());
        this.destroy();
    }

    private close() {
        this.onClose();
        this.destroy();
    }

    public destroy() {
        // Component Cleanup
        if (this.waveList) {
            this.waveList.destroy();
        }

        // Model Cleanup
        if (this.model) {
            this.model.destroy();
        }

        // DOM Cleanup
        if (this.container && this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
    }
}
</file>

<file path="src/CollisionSystem.ts">
import { Enemy } from './Enemy';
import { Projectile } from './Projectile';
import { EffectSystem } from './EffectSystem';
import { SoundManager, SoundPriority } from './SoundManager';
import { SpatialGrid } from './SpatialGrid';

export class CollisionSystem {
    private effects: EffectSystem;
    private enemyGrid: SpatialGrid<Enemy>;

    constructor(effects: EffectSystem) {
        this.effects = effects;
        // Initialize grid with screen dimensions, 128px cells
        this.enemyGrid = new SpatialGrid<Enemy>(window.innerWidth, window.innerHeight, 128);
    }


    public update(projectiles: Projectile[], enemies: Enemy[]) {
        // Rebuild spatial grid each frame
        this.enemyGrid.clear();
        for (const enemy of enemies) {
            if (enemy.isAlive()) {
                this.enemyGrid.register(enemy);
            }
        }

        // Check projectile collisions using spatial grid
        for (const p of projectiles) {
            if (!p.alive) continue;

            // Out of bounds check
            if (p.x < -50 || p.x > window.innerWidth + 50 || p.y < -50 || p.y > window.innerHeight + 50) {
                p.alive = false;
                continue;
            }

            // Get only nearby enemies instead of checking all enemies
            const searchRadius = 100; // Reasonable search radius for collision
            const nearbyEnemies = this.enemyGrid.getNearby(p.x, p.y, searchRadius);

            for (const e of nearbyEnemies) {
                if (!e.isAlive()) continue;
                if (p.hitList.includes(e.id)) continue;

                const dist = Math.hypot(e.x - p.x, e.y - p.y);
                const hitDist = 20 + p.radius;

                if (dist < hitDist) {
                    this.handleHit(p, e, enemies);

                    if (p.pierce > 0) {
                        p.pierce--;
                        p.hitList.push(e.id);
                    } else {
                        p.alive = false;
                        break;
                    }
                }
            }
        }
    }

    private handleHit(p: Projectile, target: Enemy, allEnemies: Enemy[]) {
        // Apply damage with projectile reference (for tracking kills)
        const wasSlowed = target.statuses.some(s => s.type === 'slow');

        target.takeDamage(p.damage, p);

        // Sound Hit
        SoundManager.play('hit', SoundPriority.LOW);

        // --- –í–ò–ó–£–ê–õ: –ò—Å–∫—Ä—ã –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏ (critical hit = more particles) ---
        const particleCount = p.isCrit ? 10 : 5;
        for (let i = 0; i < particleCount; i++) {
            this.effects.add({
                type: 'particle',
                x: target.x,
                y: target.y,
                vx: (Math.random() - 0.5) * (p.isCrit ? 480 : 240), // 8/4 * 60
                vy: (Math.random() - 0.5) * (p.isCrit ? 480 : 240),
                life: p.isCrit ? 0.5 : 0.35, // 30/20 frames
                color: p.color, // Use projectile color (tower type)
                radius: p.isCrit ? 4 : 2,
            });
        }

        // === CRIT FLASH + BIG TEXT ===
        if (p.isCrit) {
            // Screen flash (white)
            this.effects.add({
                type: 'screen_flash',
                x: 0,
                y: 0,
                life: 0.15,
                flashColor: 'rgba(255, 255, 255, ',
            });

            // Big "CRIT!" text
            this.effects.add({
                type: 'text',
                text: 'CRIT!',
                x: target.x,
                y: target.y - 30,
                life: 0.6,
                color: '#ff0',
                fontSize: 28,
                vy: -120,
            });

            // Enlarged damage number
            this.effects.add({
                type: 'text',
                text: Math.floor(p.damage).toString(),
                x: target.x + 15,
                y: target.y - 10,
                life: 0.5,
                color: '#ffd700',
                fontSize: 22,
                vy: -90,
            });
        }
        // === END CRIT EFFECTS ===
        // -----------------------------------

        // Handle enemy death effects
        const enemyDied = !target.isAlive();
        if (enemyDied) {
            this.handleEnemyDeath(target, p, allEnemies, wasSlowed);
        }

        // Splash damage effect
        const splash = p.effects.find((ef) => ef.type === 'splash');
        if (splash) {
            this.effects.add({
                type: 'explosion',
                x: target.x,
                y: target.y,
                radius: splash.splashRadius || splash.radius,
                life: 0.25,
                color: 'rgba(255, 100, 0, 0.5)',
            });

            for (const neighbor of allEnemies) {
                if (neighbor === target || !neighbor.isAlive()) continue;
                const dist = Math.hypot(neighbor.x - target.x, neighbor.y - target.y);
                if (dist <= (splash.splashRadius || splash.radius)) {
                    neighbor.takeDamage(p.damage * 0.7);
                }
            }
        }

        // Slow effect (with damage modifier)
        const slow = p.effects.find((ef) => ef.type === 'slow');
        if (slow) {
            const damageBonus = slow.damageToSlowed || 1.0;
            // Default 60 frames -> 1.0 second. Assuming slow.dur/slowDuration are already converted in Card files, 
            // but fallback must be 1.0, not 60.
            target.applyStatus('slow', slow.slowDuration || slow.dur || 1.0, slow.slowPower || slow.power || 0.4, damageBonus);
        }
    }

    private handleEnemyDeath(enemy: Enemy, killingProjectile: Projectile, allEnemies: Enemy[], wasSlowed: boolean) {
        const deathX = enemy.x;
        const deathY = enemy.y;

        // Sound Death
        // Boss death sound? (Checking enemy type or size)
        SoundManager.play('death', SoundPriority.LOW);

        // Fire Level 3: Explosion on death
        if (killingProjectile.explodeOnDeath) {
            this.effects.add({
                type: 'explosion',
                x: deathX,
                y: deathY,
                radius: killingProjectile.explosionRadius,
                life: 0.35,
                color: 'rgba(255, 69, 0, 0.8)',
            });

            // Damage nearby enemies
            for (const neighbor of allEnemies) {
                if (!neighbor.isAlive()) continue;
                const dist = Math.hypot(neighbor.x - deathX, neighbor.y - deathY);
                if (dist <= killingProjectile.explosionRadius) {
                    neighbor.takeDamage(killingProjectile.explosionDamage);
                }
            }
        }

        // Ice Level 3: Chain slow on death (if enemy was slowed when it died)
        if (wasSlowed) {
            const chainSlowEffect = killingProjectile.effects.find((ef: any) => ef.type === 'chainSlowOnDeath');
            if (chainSlowEffect) {
                const chainRadius = chainSlowEffect.chainRadius || 60;

                // Visual effect for chain slow
                this.effects.add({
                    type: 'explosion',
                    x: deathX,
                    y: deathY,
                    radius: chainRadius,
                    life: 20,
                    color: 'rgba(0, 188, 212, 0.5)',
                });

                // Apply slow to nearby enemies
                for (const neighbor of allEnemies) {
                    if (!neighbor.isAlive()) continue;
                    const dist = Math.hypot(neighbor.x - deathX, neighbor.y - deathY);
                    if (dist <= chainRadius) {
                        // Apply the same slow effect from the projectile
                        const slowEffect = killingProjectile.effects.find((ef: any) => ef.type === 'slow');
                        if (slowEffect) {
                            const damageBonus = slowEffect.damageToSlowed || 1.0;
                            neighbor.applyStatus('slow', slowEffect.slowDuration || slowEffect.dur || 1.0, slowEffect.slowPower || slowEffect.power || 0.4, damageBonus);
                        }
                    }
                }
            }
        }
    }
}
</file>

<file path="src/EntityFactory.ts">
import { Enemy } from './Enemy';
import { Tower } from './Tower';
import { CONFIG, getEnemyType } from './Config';
import { generateUUID } from './Utils';

export class EntityFactory {
    // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–±—Ä–∞–ª–∏ –ª–∏—à–Ω–∏–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã, —Ç–µ–ø–µ—Ä—å —Ä–æ–≤–Ω–æ 3
    public static createEnemy(typeKey: string, wave: number, path: { x: number; y: number }[]): Enemy {
        const enemy = new Enemy();
        this.setupEnemy(enemy, typeKey, wave, path);
        return enemy;
    }

    public static setupEnemy(enemy: Enemy, typeKey: string, wave: number, path: { x: number; y: number }[]) {
        const safeKey = typeKey || 'GRUNT';

        const typeConf = getEnemyType(safeKey) || getEnemyType('GRUNT')!;
        if (!getEnemyType(safeKey)) {
            console.warn(`Unknown enemy type: ${typeKey}, falling back to GRUNT`);
        }

        const hp = CONFIG.ENEMY.BASE_HP * typeConf.hpMod * Math.pow(CONFIG.ENEMY.HP_GROWTH, wave - 1);

        // Spawn enemy at the first waypoint
        const startX = path.length > 0 ? path[0].x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 : 0;
        const startY = path.length > 0 ? path[0].y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 : 0;

        enemy.init({
            id: `e_${generateUUID()}`,
            health: hp,
            speed: typeConf.speed,
            path: path,
            x: startX,
            y: startY,
        });

        enemy.setType(typeConf.id || safeKey.toLowerCase());
        enemy.reward = typeConf.reward || 5;
    }

    public static createTower(col: number, row: number): Tower {
        return new Tower(col, row);
    }
}
</file>

<file path="src/MapData.ts">
// –†–µ–∂–∏–º—ã –ø–æ—è–≤–ª–µ–Ω–∏—è –≤—Ä–∞–≥–æ–≤ –∏–∑ –ø–æ—Ä—Ç–∞–ª–∞
export type SpawnPattern = 'normal' | 'random' | 'swarm';

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ–¥–Ω–æ–π –≤–æ–ª–Ω—ã
export interface IWaveConfig {
    enemies: {
        type: string;
        count: number;
        // @deprecated –°—Ç–∞—Ä—ã–µ –ø–æ–ª—è - –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è, —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        speed?: number; // 0.5, 1.0, 1.5, 2.0 etc (multiplier)
        spawnRate?: 'fast' | 'medium' | 'slow'; // spawn delay
        // –ù–æ–≤–æ–µ –ø–æ–ª–µ - —Ä–µ–∂–∏–º –ø–æ—è–≤–ª–µ–Ω–∏—è –≥—Ä—É–ø–ø—ã –≤—Ä–∞–≥–æ–≤
        spawnPattern?: SpawnPattern;
    }[]; // –ö—Ç–æ –∏ —Å–∫–æ–ª—å–∫–æ
}

// –ü–æ–ª–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
export interface IMapObject {
    type: string; // 'stone' | 'rock' | 'tree' | 'wheat' | 'flowers'
    x: number;
    y: number;
    properties?: Record<string, any>;
    size?: number; // –†–∞–∑–º–µ—Ä –æ–±—ä–µ–∫—Ç–∞ –≤ —Ç–∞–π–ª–∞—Ö (–¥–ª—è —Å–∫–∞–ª: 2 –∏–ª–∏ 3)
}

export interface Cell {
    type: number; // 0=Grass, 1=Path, 2=Decor
    x: number;
    y: number;
    decor?: string | null;
}

// –ü–æ–ª–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
export interface IMapData {
    width: number;
    height: number;
    tiles: number[][]; // 0=Grass, 1=Path, 2=Decor
    waypoints: { x: number; y: number }[];
    objects: IMapObject[];

    // –ù–æ–≤—ã–µ –ø–æ–ª—è (—Å—Ü–µ–Ω–∞—Ä–∏–π)
    waves?: IWaveConfig[];
    startingMoney?: number;
    startingLives?: number;
    manualPath?: boolean; // true if waypoints were manually placed
    fogData?: number[]; // ARRAY: fog density per tile (0=Visible, 1-5=Fog density 20%-100%)
}

export interface Cell {
    type: number; // 0=Grass, 1=Path, 2=Decor
    x: number;
    y: number;
    decor?: string | null;
}

// –ó–∞–≥–ª—É—à–∫–∞ (—á—Ç–æ–±—ã —Å—Ç–∞—Ä—ã–π –∫–æ–¥ –Ω–µ –ª–æ–º–∞–ª—Å—è, –µ—Å–ª–∏ –≥–¥–µ-—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)
export const DEMO_MAP: IMapData = {
    width: 10,
    height: 10,
    tiles: Array(10)
        .fill(0)
        .map(() => Array(10).fill(0)), // 10x10 Grass
    waypoints: [],
    objects: [],
    waves: [],
    startingMoney: 100,
    startingLives: 20,
    fogData: [],
};
</file>

<file path="src/renderers/TowerRenderer.ts">
import { Assets } from '../Assets';
import { CONFIG } from '../Config';
import { VISUALS } from '../VisualConfig';
import type { Tower } from '../Tower';
import { getTurretRenderer } from './turrets';

export class TowerRenderer {
    static drawSprite(ctx: CanvasRenderingContext2D, tower: Tower) {
        const size = CONFIG.TILE_SIZE;
        const drawX = tower.col * size;
        const drawY = tower.row * size;

        if (tower.isBuilding) {
            TowerRenderer.drawBuildingSprite(ctx, tower, drawX, drawY, size);
        } else {
            TowerRenderer.drawActiveSprite(ctx, tower, size);
        }
    }

    static drawUI(ctx: CanvasRenderingContext2D, tower: Tower) {
        const size = CONFIG.TILE_SIZE;
        const drawX = tower.col * size;
        const drawY = tower.row * size;

        if (tower.isBuilding) {
            TowerRenderer.drawBuildingUI(ctx, tower, drawX, drawY, size);
        } else {
            // Overheat bar for Minigun
            let turretName = 'turret_standard';
            const mainCard = tower.cards[0];
            if (mainCard && mainCard.type.id === 'minigun') turretName = 'turret_minigun';

            if (turretName === 'turret_minigun' && tower.spinupTime > 0) {
                TowerRenderer.drawOverheatBar(ctx, tower);
            }
        }
    }

    static drawPreview(ctx: CanvasRenderingContext2D, x: number, y: number, cardId?: string) {
        ctx.globalAlpha = 0.5;
        // Draw Base
        const baseImg = Assets.get('base_default');
        if (baseImg) {
            ctx.drawImage(baseImg, x - 32, y - 32);
        } else {
            ctx.fillStyle = VISUALS.TOWER.BASE_COLOR;
            ctx.beginPath();
            ctx.arc(x, y, 22, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw Turret (if card selected)
        if (cardId) {
            const renderer = getTurretRenderer(cardId);
            const turretImg = Assets.get(renderer.getTurretAsset());

            // Should also draw preview modules? Maybe too much detail.
            // Just draw the main turret for now.
            if (turretImg) {
                // Determine scale based on... level 1 for preview
                ctx.drawImage(turretImg, x - 32, y - 32);
            }

            // Draw range circle in preview?
            // Already handled by UI usually, but good to ensure visual clarity
        }
        ctx.globalAlpha = 1.0;
    }


    private static drawBuildingSprite(ctx: CanvasRenderingContext2D, tower: Tower, drawX: number, drawY: number, size: number) {
        // ... existing building sprite logic ...
        // Enhanced building animation - base emerges from below with opacity
        const pct = tower.buildProgress / tower.maxBuildProgress;
        const emergeOffset = (1 - pct) * 15; // Starts 15px below, rises to 0
        const halfSize = size / 2;

        ctx.save();

        // Clip to only show portion based on progress (reveal from bottom)
        ctx.beginPath();
        const clipHeight = size * pct;
        ctx.rect(drawX, drawY + size - clipHeight - emergeOffset, size, clipHeight + 5);
        ctx.clip();

        // Draw actual base with reduced opacity
        ctx.globalAlpha = 0.5 + pct * 0.5; // 50% -> 100% opacity
        const baseImg = Assets.get('base_default');
        if (baseImg) {
            ctx.drawImage(baseImg, drawX, drawY - emergeOffset);
        } else {
            // Fallback circle
            ctx.fillStyle = VISUALS.TOWER.BASE_COLOR;
            ctx.beginPath();
            ctx.arc(tower.x, tower.y - emergeOffset, size * 0.35, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();

        // Holographic construction lines overlay
        ctx.save();
        ctx.globalAlpha = 0.3 * (1 - pct); // Fade out as progress increases
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(tower.x, tower.y, size * 0.35, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }

    private static drawBuildingUI(ctx: CanvasRenderingContext2D, tower: Tower, drawX: number, drawY: number, size: number) {
        // ... existing building UI logic ...
        // Progress bar
        const pct = tower.buildProgress / tower.maxBuildProgress;
        const barWidth = size - 10;
        ctx.fillStyle = VISUALS.TOWER.BUILDING.BAR_BG;
        ctx.fillRect(drawX + 5, drawY + size - 10, barWidth, 5);
        ctx.fillStyle = '#4caf50'; // Green progress
        ctx.fillRect(drawX + 5, drawY + size - 10, barWidth * pct, 5);
    }

    private static drawActiveSprite(ctx: CanvasRenderingContext2D, tower: Tower, size: number) {
        // 1. Draw Base (Static - NO Rotation, NO Recoil)
        const halfSize = size / 2;
        const baseImg = Assets.get('base_default');
        if (baseImg) {
            ctx.drawImage(baseImg, tower.x - halfSize, tower.y - halfSize);
        }

        // 2. Get turret renderer via Strategy Pattern
        const mainCard = tower.cards[0];
        const renderer = getTurretRenderer(mainCard?.type.id || 'default');
        const turretName = renderer.getTurretAsset();

        // 3. Draw Turret (Rotated + Recoiled)
        const turretImg = Assets.get(turretName);
        if (turretImg) {
            ctx.save();
            ctx.translate(tower.x, tower.y);

            // Apply rotation
            // For Minigun, we might have additional barrel rotation? 
            // Usually minigun barrels spin AROUND the aim axis.
            // But this is top-down 2D. 
            // So 'barrelRotation' might effectively just be 'angle' if we want the whole gun to spin?
            // No, minigun barrels spin around the central axis.
            // Visually in 2D top down, this might look like the sprite switching frames OR
            // just blurring.
            // For now, standard rotation towards target:
            ctx.rotate(tower.angle);

            // Progressive scaling based on HIGHEST card level
            const cardLevel = tower.cards.length > 0
                ? Math.max(...tower.cards.map(c => c.level))
                : 1;
            const scaleMultiplier = 1.0 + ((cardLevel - 1) * 0.15);
            ctx.scale(scaleMultiplier, scaleMultiplier);

            // Apply Barrel Recoil (Kickback)
            // Move along the negative X axis (since we are rotated, X is "forward")
            // Wait, standard canvas rotation: 0 is right (East).
            // So translates X moves forward/back.
            if (tower.barrelRecoil) {
                ctx.translate(tower.barrelRecoil, 0);
            }

            // Draw turret body
            ctx.drawImage(turretImg, -halfSize, -halfSize);

            // 4. Draw Modules (Attachments) - Attached to turret body?
            // If modules are attached to the rotating turret (like side-mounted guns), draw here.
            // If they are on the base, draw before.
            // Current design: Modules are ON the turret.
            TowerRenderer.drawModules(ctx, tower);

            // 5. Draw turret-specific effects (laser, heat haze)
            // Called INSIDE rotated+recoiled context so effects move with barrel
            if (renderer.drawEffects) {
                renderer.drawEffects(ctx, tower);
            }

            ctx.restore();

            // Level-based visual effects (outside rotation context, e.g. auras)
            TowerRenderer.drawLevelVisuals(ctx, tower, cardLevel, mainCard);
        }
    }

    private static drawModules(ctx: CanvasRenderingContext2D, tower: Tower) {
        tower.cards.forEach((card, index) => {
            // Slot 0 Defines Turret Body. Modules are for Index > 0
            if (index > 0) {
                const renderer = getTurretRenderer(card.type.id);
                // OLD: Sprite based
                // const modName = renderer.getModuleAsset();

                // NEW: Shape based modules (Phase 1)
                // For now, let's keep using the old sprite logic BUT
                // Phase 1 calls for Shapes.
                // Let's implement Shapes here as part of "Critical Fixes" 
                // because old icons were "pixel mush".

                // Determine position
                let offX = 0;
                let offY = 0;
                if (index === 1) { offX = -5; offY = 12; }
                else if (index === 2) { offX = -5; offY = -12; }
                else { offX = -12; offY = 0; }

                TowerRenderer.drawModuleShape(ctx, card.type.id, offX, offY, card.type.color);
            }
        });
    }

    private static drawModuleShape(ctx: CanvasRenderingContext2D, type: string, x: number, y: number, color: string) {
        ctx.fillStyle = color;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;

        // Simple shapes for readability
        ctx.beginPath();
        switch (type) {
            case 'fire': // Circle
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                break;
            case 'ice': // Diamond
                ctx.moveTo(x, y - 5);
                ctx.lineTo(x + 5, y);
                ctx.lineTo(x, y + 5);
                ctx.lineTo(x - 5, y);
                ctx.closePath();
                break;
            case 'sniper': // Triangle
                ctx.moveTo(x + 5, y);
                ctx.lineTo(x - 4, y - 4);
                ctx.lineTo(x - 4, y + 4);
                ctx.closePath();
                break;
            case 'multi': // Hexagon (Split)
                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3;
                    const vx = x + Math.cos(angle) * 4;
                    const vy = y + Math.sin(angle) * 4;
                    if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                }
                ctx.closePath();
                break;
            case 'minigun': // Square
                ctx.rect(x - 4, y - 4, 8, 8);
                break;
            default: // Small circle default
                ctx.arc(x, y, 3, 0, Math.PI * 2);
        }
        ctx.fill();
        ctx.stroke();
    }

    private static drawLevelVisuals(ctx: CanvasRenderingContext2D, tower: Tower, visualLevel: number, mainCard: any) {
        if (visualLevel > 1) {
            ctx.save();
            ctx.translate(tower.x, tower.y);

            if (visualLevel === 2) {
                // LVL 2: Pulse Glow
                const pulse = 0.3 + Math.sin(Date.now() * 0.003) * 0.1;
                const cardColor = mainCard?.type.color || '#fff';
                const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, 25);
                gradient.addColorStop(0, `${cardColor}00`);
                gradient.addColorStop(1, `${cardColor}${Math.floor(pulse * 255).toString(16).padStart(2, '0')}`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, 25, 0, Math.PI * 2);
                ctx.fill();
            } else if (visualLevel === 3) {
                // LVL 3: Rotating Aura Ring
                const rotation = (Date.now() * 0.002) % (Math.PI * 2);
                const cardColor = mainCard?.type.color || '#fff';
                ctx.strokeStyle = cardColor;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;

                // Draw rotating arc segments
                for (let i = 0; i < 3; i++) {
                    const angle = rotation + (i * Math.PI * 2 / 3);
                    ctx.beginPath();
                    ctx.arc(0, 0, 28, angle, angle + Math.PI / 3);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1.0;
            }

            // Level counter badge
            ctx.fillStyle = '#ffd700'; // Gold
            ctx.font = 'bold 14px Arial';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText(visualLevel.toString(), 20, -20);
            ctx.fillText(visualLevel.toString(), 20, -20);

            ctx.restore();
        }
    }

    private static drawOverheatBar(ctx: CanvasRenderingContext2D, tower: Tower) {
        // Calculate percentage
        let pct = 0;

        if (tower.isOverheated) {
            // During overheat, show REVERSE progress (draining)
            // If totalOverheatDuration is 0 (shouldn't happen), avoid divide by zero
            const totalDur = tower.totalOverheatDuration || 1.5;
            pct = tower.overheatCooldown / totalDur;
        } else {
            // Normal heating up
            const maxTime = tower.maxHeat || 5;
            pct = tower.spinupTime / maxTime;
        }

        if (pct > 1) pct = 1;
        if (pct < 0) pct = 0;

        const barW = 6; // Slightly wider (was 4)
        const barH = 24; // Taller (was 20)
        const barX = tower.x + 22; // Right of tower
        const barY = tower.y - 12;

        // Bg
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(barX, barY, barW, barH);

        // Border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barW, barH);

        // Fill Logic
        if (tower.isOverheated) {
            // Flashing Red/Orange indicating danger/lockout
            const flash = Math.floor(Date.now() / 100) % 2 === 0;
            ctx.fillStyle = flash ? '#ff4400' : '#ff8800';
        } else {
            // Check if Cooling (No target, spinupTime > 0)
            // Ideally we'd pass a "isCooling" flag, but we can infer it if heat is decreasing.
            // However, TowerRenderer is static. 
            // Let's use blue tint if heat is not full and likely cooling? 
            // Actually, we don't know if it's cooling just by state here.
            // But we can check if it has a target in Tower? No.
            // Let's just keep the Red/Green gradient but maybe add a blue border if cooling?
            // Actually, user complained about "no animation of cooling".
            // The bar shrinking IS the animation.
            // Maybe they want the BAR COLOR to trigger "Cooling".
            // In WeaponSystem, when cooling, we reduce spinupTime.

            // Gradient Green -> Yellow -> Red
            if (pct < 0.5) {
                const r = Math.floor(255 * (pct * 2));
                ctx.fillStyle = `rgb(${r},255,0)`;
            } else {
                const g = Math.floor(255 * (2 - pct * 2));
                ctx.fillStyle = `rgb(255,${g},0)`;
            }
        }

        // Draw from bottom up
        const fillH = barH * pct;
        ctx.fillRect(barX + 1, barY + (barH - fillH) - 1, barW - 2, fillH);
    }
}
</file>

<file path="src/Assets.ts">
import { CONFIG } from './Config';
import { VISUALS } from './VisualConfig';
import { ProceduralPatterns } from './ProceduralPatterns';
import { ProceduralRoad } from './renderers/ProceduralRoad';
import { ProceduralGrass } from './renderers/ProceduralGrass';

export class Assets {
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    private static images: Record<string, HTMLCanvasElement | HTMLImageElement> = {};

    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è —Ä–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, grass –º–æ–∂–µ—Ç –∏–º–µ—Ç—å grass_1, grass_2, grass_3)
    private static variants: Record<string, (HTMLCanvasElement | HTMLImageElement)[]> = {};

    // –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã: true = –ø—ã—Ç–∞—Ç—å—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å PNG, false = —Ç–æ–ª—å–∫–æ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è
    private static USE_EXTERNAL_ASSETS = true;

    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏
    private static loadStats = {
        attempted: 0,
        loaded: 0,
        failed: 0,
        procedural: 0
    };

    // –ì–õ–ê–í–ù–´–ô –ú–ï–¢–û–î –ó–ê–ì–†–£–ó–ö–ò
    public static async loadAll(): Promise<void> {
        console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
        console.log('‚ïë   ASSETS: –ù–∞—á–∞–ª–æ –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤    ‚ïë');
        console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

        this.loadStats = { attempted: 0, loaded: 0, failed: 0, procedural: 0 };

        if (this.USE_EXTERNAL_ASSETS) {
            console.log('[1/2] –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –≤–Ω–µ—à–Ω–∏–µ PNG –∞—Å—Å–µ—Ç—ã...');
            try {
                await this.loadExternalAssets();
                console.log(`‚úì –í–Ω–µ—à–Ω–∏–µ PNG: –∑–∞–≥—Ä—É–∂–µ–Ω–æ ${this.loadStats.loaded}, –Ω–µ –Ω–∞–π–¥–µ–Ω–æ ${this.loadStats.failed}\n`);
            } catch (error) {
                console.warn('‚ö† –û—à–∏–±–∫–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ PNG, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ', error);
            }
        }

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –∞—Å—Å–µ—Ç–æ–≤
        console.log('[2/2] –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã—Ö —Ç–µ–∫—Å—Ç—É—Ä –¥–ª—è –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –∞—Å—Å–µ—Ç–æ–≤...');
        this.generateFallbackTextures();

        console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
        console.log(`‚ïë   –ò–¢–û–ì–û: ${Object.keys(this.images).length} –∞—Å—Å–µ—Ç–æ–≤ –∑–∞–≥—Ä—É–∂–µ–Ω–æ           ‚ïë`);
        console.log(`‚ïë   PNG: ${this.loadStats.loaded} | –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã—Ö: ${this.loadStats.procedural}          ‚ïë`);
        console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

        return Promise.resolve();
    }

    /**
     * –ü–æ–ª—É—á–∏—Ç—å –∞—Å—Å–µ—Ç –ø–æ –∏–º–µ–Ω–∏. –ï—Å–ª–∏ –µ—Å—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã - –≤–µ—Ä–Ω–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π.
     */
    public static get(name: string): HTMLCanvasElement | HTMLImageElement | undefined {
        // –ï—Å–ª–∏ –µ—Å—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã - –≤—ã–±—Ä–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–π
        if (this.variants[name] && this.variants[name].length > 0) {
            const variantList = this.variants[name];
            return variantList[Math.floor(Math.random() * variantList.length)];
        }

        // –ò–Ω–∞—á–µ –≤–µ—Ä–Ω—É—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π –∞—Å—Å–µ—Ç
        return this.images[name];
    }

    /**
     * –ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –∞—Å—Å–µ—Ç–∞ (–¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞)
     */
    public static getVariant(name: string, variantIndex: number): HTMLCanvasElement | HTMLImageElement | undefined {
        if (this.variants[name] && this.variants[name][variantIndex]) {
            return this.variants[name][variantIndex];
        }
        return this.images[name];
    }

    /**
     * –ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è –∞—Å—Å–µ—Ç–∞
     */
    public static getVariantCount(name: string): number {
        return this.variants[name]?.length || 0;
    }

    /**
     * –ó–∞–≥—Ä—É–∑–∫–∞ –æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
     * –ü—ã—Ç–∞–µ—Ç—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å: name.png, name_1.png, name_2.png, etc.
     */
    private static async loadImage(name: string, path: string, maxVariants: number = 5): Promise<void> {
        this.loadStats.attempted++;

        // –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª
        const mainLoaded = await this.tryLoadSingleImage(name, path);

        if (mainLoaded) {
            this.loadStats.loaded++;

            // –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã (name_1.png, name_2.png, etc.)
            const variantList: (HTMLCanvasElement | HTMLImageElement)[] = [];

            // –î–æ–±–∞–≤–∏—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–∫ –ø–µ—Ä–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç
            if (this.images[name]) {
                variantList.push(this.images[name]);
            }

            // –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
            for (let i = 1; i <= maxVariants; i++) {
                const variantPath = path.replace(/\.png$/, `_${i}.png`);
                const variantName = `${name}_${i}`;
                const loaded = await this.tryLoadSingleImage(variantName, variantPath, true); // silent = true

                if (loaded && this.images[variantName]) {
                    variantList.push(this.images[variantName]);
                }
            }

            // –ï—Å–ª–∏ –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ - —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏—Ö
            if (variantList.length > 1) {
                this.variants[name] = variantList;
                console.log(`Assets: Found ${variantList.length} variants for "${name}"`);
            }
        } else {
            this.loadStats.failed++;
        }
    }

    /**
     * –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
     */
    private static tryLoadSingleImage(name: string, path: string, silent: boolean = false): Promise<boolean> {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                this.images[name] = img;
                if (!silent) {
                    console.log(`‚úÖ Assets: "${path}" loaded successfully`);
                }
                resolve(true);
            };
            img.onerror = () => {
                if (!silent) {
                    console.log(`‚ùå Assets: "${path}" not found, will use procedural fallback`);
                }
                resolve(false);
            };
            // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑ –∫–æ—Ä–Ω—è (–µ—Å–ª–∏ –ø—É—Ç—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å '../')
            img.src = path.startsWith('../') ? path : `/assets/images/${path}`;
        });
    }

    /**
     * –ó–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö –≤–Ω–µ—à–Ω–∏—Ö –∞—Å—Å–µ—Ç–æ–≤
     */
    private static async loadExternalAssets(): Promise<void> {
        const loadTasks: Promise<void>[] = [];

        // === –ö–†–ò–¢–ò–ß–ù–´–ï –ê–°–°–ï–¢–´ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è PNG) ===

        // Tiles - –æ–∫—Ä—É–∂–µ–Ω–∏–µ (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è)
        // –§–ê–ó–ê 2: –û—Ç–∫–ª—é—á–µ–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é grass_0...grass_3
        // loadTasks.push(this.loadImage('grass', 'tiles/grass.png', 5));  // –¥–æ 5 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
        loadTasks.push(this.loadImage('path', 'tiles/path.png', 3));

        // Fog tiles (0-15) - –±–µ–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, —Ç.–∫. –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è –±–∏—Ç–º–∞—Å–∫–∏–Ω–≥–∞
        for (let i = 0; i < 16; i++) {
            loadTasks.push(this.loadImage(`fog_${i}`, `tiles/fog_${i}.png`, 0));
        }

        // –î–µ–∫–æ—Ä–∞—Ü–∏–∏ - –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã
        loadTasks.push(this.loadImage('decor_tree', 'tiles/tree.png', 3));
        loadTasks.push(this.loadImage('decor_rock', 'tiles/rock.png', 5));
        loadTasks.push(this.loadImage('stone', 'tiles/stone.png', 3));
        loadTasks.push(this.loadImage('wheat', 'tiles/wheat.png', 2));
        loadTasks.push(this.loadImage('flowers', 'tiles/flowers.png', 3));

        // –ë–∞—à–Ω–∏ - –±–∞–∑–æ–≤—ã–µ (–±–µ–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, —Ç.–∫. –≤–∏–∑—É–∞–ª—å–Ω–æ –≤–∞–∂–Ω–∞ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å)
        loadTasks.push(this.loadImage('tower_base', 'towers/base.png'));
        loadTasks.push(this.loadImage('base_default', 'towers/base_default.png'));
        loadTasks.push(this.loadImage('tower_gun', 'towers/gun.png'));

        // –¢—É—Ä–µ–ª–∏
        loadTasks.push(this.loadImage('turret_standard', 'towers/turret_standard.png'));
        loadTasks.push(this.loadImage('turret_ice', 'towers/turret_ice.png'));
        loadTasks.push(this.loadImage('turret_fire', 'towers/turret_fire.png'));
        loadTasks.push(this.loadImage('turret_sniper', 'towers/turret_sniper.png'));
        loadTasks.push(this.loadImage('turret_split', 'towers/turret_split.png'));
        loadTasks.push(this.loadImage('turret_minigun', 'towers/turret_minigun.png'));

        // –ú–æ–¥—É–ª–∏
        loadTasks.push(this.loadImage('mod_ice', 'modules/ice.png'));
        loadTasks.push(this.loadImage('mod_fire', 'modules/fire.png'));
        loadTasks.push(this.loadImage('mod_sniper', 'modules/sniper.png'));
        loadTasks.push(this.loadImage('mod_split', 'modules/split.png'));
        loadTasks.push(this.loadImage('mod_minigun', 'modules/minigun.png'));

        // –í—Ä–∞–≥–∏ - –±–∞–∑–æ–≤—ã–µ –∞—Ä—Ö–µ—Ç–∏–ø—ã (–º–æ–≥—É—Ç –∏–º–µ—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è)
        loadTasks.push(this.loadImage('enemy_skeleton', 'enemies/skeleton.png', 3));
        loadTasks.push(this.loadImage('enemy_wolf', 'enemies/wolf.png', 2));
        loadTasks.push(this.loadImage('enemy_troll', 'enemies/troll.png', 2));
        loadTasks.push(this.loadImage('enemy_spider', 'enemies/spider.png', 2));

        // Props –≤—Ä–∞–≥–æ–≤
        loadTasks.push(this.loadImage('prop_shield', 'props/shield.png'));
        loadTasks.push(this.loadImage('prop_helmet', 'props/helmet.png'));
        loadTasks.push(this.loadImage('prop_weapon', 'props/weapon.png'));
        loadTasks.push(this.loadImage('prop_barrier', 'props/barrier.png'));

        // –°–Ω–∞—Ä—è–¥—ã - –∫—Ä–∏—Ç–∏—á–Ω—ã–µ –¥–ª—è –≥–µ–π–º–ø–ª–µ—è
        loadTasks.push(this.loadImage('projectile_standard', 'projectiles/standard.png'));
        loadTasks.push(this.loadImage('projectile_ice', 'projectiles/ice.png'));
        loadTasks.push(this.loadImage('projectile_fire', 'projectiles/fire.png'));
        loadTasks.push(this.loadImage('projectile_sniper', 'projectiles/sniper.png'));
        loadTasks.push(this.loadImage('projectile_split', 'projectiles/split.png'));
        loadTasks.push(this.loadImage('projectile_minigun', 'projectiles/minigun.png'));

        // –§–æ–Ω—ã –º–µ–Ω—é (–∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ –∫–æ—Ä–Ω—è)
        loadTasks.push(this.tryLoadSingleImage('menu_start', '../start.jpg').then(() => { }));
        loadTasks.push(this.tryLoadSingleImage('menu_map', '../map.jpg').then(() => { }));


        // –≠–§–§–ï–ö–¢–´ - –æ—Å—Ç–∞–≤–ª—è–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–º–∏ (–Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ–º PNG)

        // effect_muzzle_flash, shadow_small - –±—É–¥—É—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
        await Promise.all(loadTasks);
    }


    /**
     * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è –≤—Å–µ—Ö –∞—Å—Å–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –±—ã–ª–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
     */
    private static generateFallbackTextures(): void {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∫–∏–µ –∞—Å—Å–µ—Ç—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–ª—è –Ω–∏—Ö –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã
        const requiredAssets = [
            'grass_0', 'grass_1', 'grass_2', 'grass_3', // 4 variants for grass
            'path', 'decor_tree', 'decor_rock', 'stone', 'wheat', 'flowers',
            'tower_base', 'base_default', 'tower_gun',
            'turret_standard', 'turret_ice', 'turret_fire', 'turret_sniper', 'turret_split', 'turret_minigun',
            'mod_ice', 'mod_fire', 'mod_sniper', 'mod_split', 'mod_minigun',
            'projectile_standard', 'projectile_ice', 'projectile_fire', 'projectile_sniper', 'projectile_split', 'projectile_minigun',
            'effect_muzzle_flash', 'shadow_small'
        ];

        // –î–æ–±–∞–≤–ª—è–µ–º fog tiles
        for (let i = 0; i < 16; i++) {
            requiredAssets.push(`fog_${i}`);
        }

        // –î–æ–±–∞–≤–ª—è–µ–º path tiles (Phase 2 - bitmasking)
        for (let i = 0; i < 16; i++) {
            requiredAssets.push(`path_${i}`);
        }

        // –î–æ–±–∞–≤–ª—è–µ–º enemies
        const enemies = Object.values(CONFIG.ENEMY_TYPES);
        enemies.forEach((e) => {
            requiredAssets.push(`enemy_${e.id}`);
        });

        // –î–æ–±–∞–≤–ª—è–µ–º props
        requiredAssets.push('prop_shield', 'prop_helmet', 'prop_weapon', 'prop_barrier');

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ
        requiredAssets.forEach(assetName => {
            if (!this.images[assetName]) {
                this.generateProceduralAsset(assetName);
            }
        });
    }

    /**
     * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—É—é —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∞—Å—Å–µ—Ç–∞
     */
    private static generateProceduralAsset(name: string): void {
        // –í—ã–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ä—É—é —Å–∏—Å—Ç–µ–º—É –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
        if (name.startsWith('grass_')) {
            // –§–ê–ó–ê 2: –û–±–Ω–æ–≤–ª–µ–Ω–æ - –ø—Ä–æ—Å—Ç–∞—è –∑–µ–ª–µ–Ω–∞—è —Ç—Ä–∞–≤–∞ (–ø–æ –∑–∞–ø—Ä–æ—Å—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
            const variantIdx = parseInt(name.split('_')[1]);

            this.generateTexture(name, CONFIG.TILE_SIZE, (ctx, w, h) => {
                // –ü—Ä–æ—Å—Ç–æ –∑–µ–ª—ë–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç –ë–ï–ó –¥–µ—Ç–∞–ª–µ–π
                ctx.fillStyle = '#6b9e4a'; // –°—Ä–µ–¥–Ω–∏–π –∑–µ–ª—ë–Ω—ã–π
                ctx.fillRect(0, 0, w, h);
            });

            // IMPORTANT: Register as variant for 'grass'
            if (!this.variants['grass']) {
                this.variants['grass'] = [];
            }
            if (this.images[name] instanceof HTMLCanvasElement) {
                this.variants['grass'].push(this.images[name] as HTMLCanvasElement);
            }

            this.loadStats.procedural++;

            // –ï—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –µ–≥–æ –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–π –∞—Å—Å–µ—Ç 'grass'
            if (name === 'grass_0') {
                this.images['grass'] = this.images[name];
            }


        } else if (name === 'path') {
            this.generateTexture('path', CONFIG.TILE_SIZE, (ctx, w, h) => {
                ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.MAIN;
                ctx.fillRect(0, 0, w, h);
                for (let i = 0; i < 15; i++) {
                    ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.DETAIL;
                    ctx.beginPath();
                    ctx.arc(Math.random() * w, Math.random() * h, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            this.loadStats.procedural++;
        } else if (name.startsWith('fog_')) {
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º fog tiles –ø–æ —Å—Ç–∞—Ä–æ–º—É
            const index = parseInt(name.replace('fog_', ''));
            if (!isNaN(index)) {
                this.generateFogTile(index);
                this.loadStats.procedural++;
            }
        } else if (name.startsWith('path_')) {
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º path tiles (Phase 2 - bitmasking)
            this.generatePathTiles(); // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Å–µ 16 –∑–∞ —Ä–∞–∑
            this.loadStats.procedural++;
        } else if (name.startsWith('enemy_')) {
            // Enemies
            const enemyId = name.replace('enemy_', '');
            const enemy = Object.values(CONFIG.ENEMY_TYPES).find(e => e.id === enemyId);
            if (enemy) {
                this.generateEnemyTexture(enemy.id, enemy.color);
                this.loadStats.procedural++;
            }
        } else {
            // –î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∞—Å—Å–µ—Ç–æ–≤ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —á–µ—Ä–µ–∑ —Å—Ç–∞—Ä—É—é —Å–∏—Å—Ç–µ–º—É
            // –ù–û –¢–û–õ–¨–ö–û –ï–°–õ–ò –æ–Ω–∏ –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!
            console.log(`[Assets] No specific fallback for "${name}", checking if already loaded...`);
            if (!this.images[name]) {
                console.log(`[Assets] "${name}" not loaded, generating procedurally...`);
                this.generateAllTextures();  // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –í–°–ï –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ
            } else {
                console.log(`[Assets] "${name}" already loaded (PNG), skipping generation`);
            }
        }
    }

    // --- –°–¢–ê–†–ê–Ø –°–ò–°–¢–ï–ú–ê –ü–†–û–¶–ï–î–£–†–ù–û–ô –ì–ï–ù–ï–†–ê–¶–ò–ò (–æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è fallback) ---
    private static generateAllTextures() {
        // –§–ê–ó–ê 2: –°—Ç–∞—Ä–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è 'grass' –£–î–ê–õ–ï–ù–ê
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—É—é —Å–∏—Å—Ç–µ–º—É grass_0...grass_3 (—Å–º. generateProceduralAsset)


        this.generateTexture('path', CONFIG.TILE_SIZE, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.MAIN;
            ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 15; i++) {
                ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.DETAIL;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        this.generateTexture('decor_tree', CONFIG.TILE_SIZE, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.TREE.BASE;
            ctx.fillRect(0, 0, w, h); // –§–æ–Ω —Ç—Ä–∞–≤—ã
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.TREE.FOLIAGE_LIGHT;
            ctx.beginPath();
            ctx.arc(w / 2, h / 2, 16, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.TREE.FOLIAGE_DARK;
            ctx.beginPath();
            ctx.arc(w / 2 - 5, h / 2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
        });

        this.generateTexture('decor_rock', CONFIG.TILE_SIZE, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.ROCK.BASE;
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.ROCK.STONE;
            ctx.beginPath();
            ctx.moveTo(10, h - 10);
            ctx.lineTo(w / 2, 10);
            ctx.lineTo(w - 10, h - 10);
            ctx.fill();
        });

        // –ë–∞—à–Ω–∏
        this.generateTexture('tower_base', CONFIG.TILE_SIZE, (ctx, w, h) => {
            const center = w / 2;
            ctx.fillStyle = VISUALS.TOWER.BASE.PLATFORM;
            ctx.beginPath();
            ctx.arc(center, center, w * 0.375, 0, Math.PI * 2); // 24/64 = 0.375
            ctx.fill();
            ctx.strokeStyle = VISUALS.TOWER.BASE.RIM;
            ctx.lineWidth = 4;
            ctx.stroke();
        });

        this.generateTexture('tower_gun', CONFIG.TILE_SIZE, (ctx, w, h) => {
            const center = w / 2;
            const barrelWidth = w * 0.125;  // 8/64 = 0.125
            const barrelLength = w * 0.53;  // 34/64 ~= 0.53
            const barrelStart = w * 0.31;   // 20/64 ~= 0.31

            ctx.fillStyle = VISUALS.TOWER.BASE.RIVETS; // Using rivets color for gun? Original was #424242 which matches rivets
            // Draw barrel horizontally pointing RIGHT (East)
            ctx.fillRect(barrelStart, center - barrelWidth / 2, barrelLength, barrelWidth);
            ctx.beginPath();
            ctx.arc(center, center, w * 0.22, 0, Math.PI * 2); // 14/64 ~= 0.22
            ctx.fill(); // Turret body
            ctx.fillStyle = '#eceff1';
            ctx.beginPath();
            ctx.arc(center, center, w * 0.094, 0, Math.PI * 2); // 6/64 ~= 0.094
            ctx.fill();
        });

        // –í—Ä–∞–≥–∏
        const enemies = Object.values(CONFIG.ENEMY_TYPES);
        enemies.forEach((e) => {
            this.generateEnemyTexture(e.id, e.color);
        });

        // Fog
        this.generateFogTiles();

        // Path tiles (Phase 2 - bitmasking)
        this.generatePathTiles();

        // --- NEW MODULAR TOWER ASSETS ---
        this.generateTowerParts();

        // --- PROJECTILES & EFFECTS ---
        this.generateProjectiles();
        this.generateMisc();
    }

    private static generateTexture(
        name: string,
        size: number,
        drawFn: (ctx: CanvasRenderingContext2D, w: number, h: number) => void,
    ) {
        // –ö–†–ò–¢–ò–ß–ù–û: –ù–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞—Ç—å —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ PNG!
        if (this.images[name]) {
            console.log(`[generateTexture] Skipping "${name}" - already loaded as PNG`);
            return;
        }

        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d')!;
        drawFn(ctx, size, size);
        this.images[name] = canvas;
        console.log(`[generateTexture] Generated procedural "${name}"`);
    }

    /**
     * Layered Texture Generation (Phase 1)
     * Generates textures using multiple layers for richer visuals
     * @param name Asset name
     * @param size Texture size
     * @param layers Layer functions: base, pattern, highlight, dirt
     */
    private static generateLayeredTexture(
        name: string,
        size: number,
        layers: {
            base: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
            pattern?: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
            highlight?: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
            dirt?: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
        }
    ): void {
        // –ö–†–ò–¢–ò–ß–ù–û (–∏–∑ –∞—É–¥–∏—Ç–∞): –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏!
        if (this.images[name]) {
            console.warn(`[Assets] Texture "${name}" already generated, skipping`);
            return;
        }

        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d')!;

        // Layer 1: Base (–ø–æ–¥–ª–æ–∂–∫–∞)
        layers.base(ctx, size, size);

        // Layer 2: Pattern (—É–∑–æ—Ä)
        if (layers.pattern) {
            layers.pattern(ctx, size, size);
        }

        // Layer 3: Highlight (–±–ª–∏–∫–∏/–∞–∫—Ü–µ–Ω—Ç—ã)
        if (layers.highlight) {
            layers.highlight(ctx, size, size);
        }

        // Layer 4: Dirt (–≥—Ä—è–∑—å/—à—É–º)
        if (layers.dirt) {
            layers.dirt(ctx, size, size);
        }

        this.images[name] = canvas;
        console.log(`[generateLayeredTexture] Generated "${name}" with ${Object.keys(layers).length} layers`);
    }


    private static generateEnemyTexture(name: string, color: string) {
        this.generateTexture(`enemy_${name}`, 48, (ctx, w, h) => {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(w / 2, h / 2, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            // –ì–ª–∞–∑–∞
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(w / 2 - 6, h / 2 - 5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(w / 2 + 6, h / 2 - 5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(w / 2 - 6, h / 2 - 5, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(w / 2 + 6, h / 2 - 5, 1.5, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    private static generateFogTiles() {
        const TS = CONFIG.TILE_SIZE;
        // Generate 16 bitmask variations (0-15)
        for (let i = 0; i < 16; i++) {
            this.generateTexture(`fog_${i}`, TS, (ctx, w, h) => {
                const NORTH = (i & 1) !== 0;
                const WEST = (i & 2) !== 0;
                const EAST = (i & 4) !== 0;
                const SOUTH = (i & 8) !== 0;

                // Base fog color (Dark)
                ctx.fillStyle = VISUALS.ENVIRONMENT.FOG.BASE; // Dark Blue Grey

                // Draw main body based on connections
                // We draw a center rect and extend to connected sides
                const cx = w / 2;
                const cy = h / 2;
                const halfW = w / 2;
                const halfH = h / 2;

                // Always draw center
                ctx.fillRect(cx - halfW, cy - halfH, w, h);

                // This simple logic fills the whole tile if it's fog
                // But for bitmasking we want to show "edges" where there is NO fog neighbor

                // Actually, for "Fog of War" where 1=Fog (Hidden), we draw the fog.
                // If I am a Fog tile, I am fully obscured. 
                // But to make it look nice (soft edges), we can use gradients or rounded corners 
                // on sides that are NOT connected to other fog.

                // Let's retry the visual approach:
                // We fill the whole tile with black/dark.
                // Then, for sides that are NOT connected (value 0 in bitmask), we fade out or draw a border?
                // Wait, standard bitmasking works by selecting a sprite that "connects" to neighbors.
                // So '15' (connected all sides) is a solid dark block.
                // '0' (connected to none, i.e., isolated fog) is a dark circle or blob.

                ctx.clearRect(0, 0, w, h); // Start fresh
                ctx.fillStyle = VISUALS.ENVIRONMENT.FOG.BASE;

                // Dynamic dimensions based on tile size (25% margins, 50% center)
                const cX = Math.floor(w / 4);      // Left margin
                const cY = Math.floor(h / 4);      // Top margin
                const cW = Math.floor(w / 2);      // Center width
                const cH = Math.floor(h / 2);      // Center height
                const arcRadius = Math.floor(cW / 2);

                // Draw Center
                ctx.fillRect(cX, cY, cW, cH);

                // NORTH
                if (NORTH) {
                    ctx.fillRect(cX, 0, cW, cY);
                } else {
                    ctx.beginPath();
                    ctx.arc(w / 2, cY, arcRadius, Math.PI, 0);
                    ctx.fill();
                }

                // SOUTH
                if (SOUTH) {
                    ctx.fillRect(cX, cY + cH, cW, h - (cY + cH));
                } else {
                    ctx.beginPath();
                    ctx.arc(w / 2, cY + cH, arcRadius, 0, Math.PI);
                    ctx.fill();
                }

                // WEST
                if (WEST) {
                    ctx.fillRect(0, cY, cX, cH);
                } else {
                    ctx.beginPath();
                    ctx.arc(cX, h / 2, arcRadius, Math.PI * 0.5, Math.PI * 1.5);
                    ctx.fill();
                }

                // EAST
                if (EAST) {
                    ctx.fillRect(cX + cW, cY, w - (cX + cW), cH);
                } else {
                    ctx.beginPath();
                    ctx.arc(cX + cW, h / 2, arcRadius, Math.PI * 1.5, Math.PI * 0.5);
                    ctx.fill();
                }

                // Fill corners if both adjacent sides are connected
                // NW
                if (NORTH && WEST) ctx.fillRect(0, 0, cX, cY);
                // NE
                if (NORTH && EAST) ctx.fillRect(cX + cW, 0, w - (cX + cW), cY);
                // SW
                if (SOUTH && WEST) ctx.fillRect(0, cY + cH, cX, h - (cY + cH));
                // SE
                if (SOUTH && EAST) ctx.fillRect(cX + cW, cY + cH, w - (cX + cW), h - (cY + cH));
            });
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ç–∏—Ä—É–µ—Ç –æ–¥–∏–Ω fog tile –ø–æ –∏–Ω–¥–µ–∫—Å—É (–¥–ª—è fallback)
     */
    private static generateFogTile(index: number) {
        const TS = CONFIG.TILE_SIZE;
        this.generateTexture(`fog_${index}`, TS, (ctx, w, h) => {
            const NORTH = (index & 1) !== 0;
            const WEST = (index & 2) !== 0;
            const EAST = (index & 4) !== 0;
            const SOUTH = (index & 8) !== 0;

            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = VISUALS.ENVIRONMENT.FOG.BASE;

            const cX = Math.floor(w / 4);
            const cY = Math.floor(h / 4);
            const cW = Math.floor(w / 2);
            const cH = Math.floor(h / 2);
            const arcRadius = Math.floor(cW / 2);

            // Draw Center
            ctx.fillRect(cX, cY, cW, cH);

            // NORTH
            if (NORTH) {
                ctx.fillRect(cX, 0, cW, cY);
            } else {
                ctx.beginPath();
                ctx.arc(w / 2, cY, arcRadius, Math.PI, 0);
                ctx.fill();
            }

            // SOUTH
            if (SOUTH) {
                ctx.fillRect(cX, cY + cH, cW, h - (cY + cH));
            } else {
                ctx.beginPath();
                ctx.arc(w / 2, cY + cH, arcRadius, 0, Math.PI); ctx.fill();
            }

            // WEST
            if (WEST) {
                ctx.fillRect(0, cY, cX, cH);
            } else {
                ctx.beginPath();
                ctx.arc(cX, h / 2, arcRadius, Math.PI * 0.5, Math.PI * 1.5);
                ctx.fill();
            }

            // EAST
            if (EAST) {
                ctx.fillRect(cX + cW, cY, w - (cX + cW), cH);
            } else {
                ctx.beginPath();
                ctx.arc(cX + cW, h / 2, arcRadius, Math.PI * 1.5, Math.PI * 0.5);
                ctx.fill();
            }

            // Fill corners if both adjacent sides are connected
            if (NORTH && WEST) ctx.fillRect(0, 0, cX, cY);
            if (NORTH && EAST) ctx.fillRect(cX + cW, 0, w - (cX + cW), cY);
            if (SOUTH && WEST) ctx.fillRect(0, cY + cH, cX, h - (cY + cH));
            if (SOUTH && EAST) ctx.fillRect(cX + cW, cY + cH, w - (cX + cW), h - (cY + cH));
        });
    }

    /**
     * Generate Path Tiles with Bitmasking
     * Creates 16 variants (0-15) for smooth path connections
     * –§–ê–ó–ê 1: –û–±–Ω–æ–≤–ª–µ–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ProceduralRoad –¥–ª—è –∫–∞–º–µ–Ω–Ω–æ–π —Ç–µ–∫—Å—Ç—É—Ä—ã
     */
    private static generatePathTiles() {
        const TS = CONFIG.TILE_SIZE;



        // Generate 16 bitmask variations (0-15)
        for (let i = 0; i < 16; i++) {
            this.generateTexture(`path_${i}`, TS, (ctx, w, h) => {
                // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å ProceduralRoad –¥–ª—è –∫–∞–º–µ–Ω–Ω–æ–π —Ç–µ–∫—Å—Ç—É—Ä—ã
                try {
                    ProceduralRoad.draw(ctx, 0, 0, i);
                } catch (error) {
                    console.error(`[Assets] ProceduralRoad.draw failed for path_${i}:`, error);
                    // Fallback - –ø—Ä–æ—Å—Ç–æ–π –∫–∞–º–µ–Ω—å
                    ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.STONE_BASE || '#c5b8a1';
                    ctx.fillRect(0, 0, w, h);
                }
            });
        }
    }


    private static generateTowerParts() {
        const size = CONFIG.TILE_SIZE;

        // -- 1. Bases --
        this.generateTexture('base_default', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            const r = w * 0.35;
            // Main platform
            ctx.fillStyle = '#9e9e9e'; // Grey 500
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            // Rim
            ctx.strokeStyle = '#616161'; // Grey 700
            ctx.lineWidth = 3;
            ctx.stroke();
            // Rivets
            ctx.fillStyle = '#424242';
            for (let i = 0; i < 4; i++) {
                const a = i * (Math.PI / 2);
                ctx.beginPath();
                ctx.arc(cx + Math.cos(a) * (r - 4), cy + Math.sin(a) * (r - 4), 2, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        // -- 2. Turrets --

        // Standard / Default
        this.generateTexture('turret_standard', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);
            // Simple gun
            ctx.fillStyle = VISUALS.TOWER.TURRET.STANDARD.BARREL;
            ctx.fillRect(0, -6, 20, 12); // Barrel
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2); // Body
            ctx.fill();
            ctx.strokeStyle = VISUALS.TOWER.TURRET.STANDARD.STROKE;
            ctx.lineWidth = 2;
            ctx.stroke();
        });

        // Ice Turret (Crystal/Prism, Blue)
        this.generateTexture('turret_ice', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);

            // Barrel - Crystal spike
            ctx.fillStyle = VISUALS.TOWER.TURRET.ICE.SPIKE; // Cyan 300
            ctx.beginPath();
            ctx.moveTo(0, -4);
            ctx.lineTo(24, 0);
            ctx.lineTo(0, 4);
            ctx.fill();

            // Body - Hexagon
            ctx.fillStyle = VISUALS.TOWER.TURRET.ICE.MAIN; // Cyan 600
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const a = i * (Math.PI / 3);
                const r = 14;
                ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = VISUALS.TOWER.TURRET.ICE.STROKE;
            ctx.lineWidth = 2;
            ctx.stroke();
        });

        // Fire Turret (Mortar/Flamethrower, Orange/Red)
        this.generateTexture('turret_fire', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);

            // Barrel - Wide, short
            ctx.fillStyle = VISUALS.TOWER.TURRET.FIRE.BARREL; // Deep Orange 400
            ctx.fillRect(0, -10, 18, 20);
            // Barrel Tip (charred)
            ctx.fillStyle = VISUALS.TOWER.TURRET.FIRE.TIP;
            ctx.fillRect(14, -10, 4, 20);

            // Body - Round, massive
            ctx.fillStyle = VISUALS.TOWER.TURRET.FIRE.MAIN; // Deep Orange 600
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = VISUALS.TOWER.TURRET.FIRE.STROKE;
            ctx.lineWidth = 2;
            ctx.stroke();
        });

        // Sniper Turret (Long Rifle, Green/Camo)
        this.generateTexture('turret_sniper', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);

            // Barrel - Long, thin
            ctx.fillStyle = VISUALS.TOWER.TURRET.SNIPER.BARREL; // Green 900
            ctx.fillRect(0, -3, 30, 6);
            // Muzzle brake
            ctx.fillStyle = VISUALS.TOWER.TURRET.SNIPER.MUZZLE;
            ctx.fillRect(28, -5, 4, 10);

            // Body - Sleek, angular
            ctx.fillStyle = VISUALS.TOWER.TURRET.SNIPER.MAIN; // Green 800
            ctx.beginPath();
            ctx.moveTo(-10, -8);
            ctx.lineTo(10, -5);
            ctx.lineTo(10, 5);
            ctx.lineTo(-10, 8);
            ctx.closePath();
            ctx.fill();
        });

        // Split Turret (Gatling/Tri-barrel, Yellow)
        this.generateTexture('turret_split', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);

            // Barrels - Three spread out
            ctx.fillStyle = VISUALS.TOWER.TURRET.SPLIT.BARREL; // Yellow 700
            const spread = 0.3;
            // 1
            ctx.save(); ctx.rotate(-spread); ctx.fillRect(0, -3, 20, 6); ctx.restore();
            // 2
            ctx.fillRect(0, -3, 22, 6);
            // 3
            ctx.save(); ctx.rotate(spread); ctx.fillRect(0, -3, 20, 6); ctx.restore();

            // Body - Wide
            ctx.fillStyle = VISUALS.TOWER.TURRET.SPLIT.MAIN; // Yellow 900
            ctx.beginPath();
            ctx.arc(0, 0, 14, 0, Math.PI * 2);
            ctx.fill();
        });

        // Minigun Turret (Gatling gun, Purple/Electric)
        this.generateTexture('turret_minigun', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);

            // Rotating barrel assembly - Multiple thin barrels
            ctx.fillStyle = '#7b1fa2'; // Purple 700
            const barrelCount = 6;
            for (let i = 0; i < barrelCount; i++) {
                const angle = (i / barrelCount) * Math.PI * 2;
                const r = 6; // Radius of barrel circle
                ctx.save();
                ctx.translate(Math.cos(angle) * r, Math.sin(angle) * r);
                ctx.fillRect(0, -1.5, 18, 3); // Thin barrel
                ctx.restore();
            }

            // Central motor housing
            ctx.fillStyle = '#9c27b0'; // Purple 500
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();

            // Electric coil detail
            ctx.strokeStyle = '#e1bee7'; // Purple 100  (light accent)
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.stroke();
        });


        // -- 3. Modules (Overlay attachments) --

        // Mod Ice (Cooling tank - Blue canister)
        this.generateTexture('mod_ice', 24, (ctx, w, h) => {
            // Anchor point is roughly center relative to mounting point
            ctx.fillStyle = VISUALS.TOWER.MODULES.ICE.BODY; // Light Blue 800
            ctx.fillRect(4, 4, 16, 10);
            ctx.fillStyle = VISUALS.TOWER.MODULES.ICE.LIQUID; // Light Blue 300 (liquid level)
            ctx.fillRect(6, 6, 12, 6);
            // Cap
            ctx.fillStyle = VISUALS.TOWER.MODULES.ICE.CAP;
            ctx.fillRect(18, 6, 4, 6);
        });

        // Mod Fire (Fuel tank - Red canister)
        this.generateTexture('mod_fire', 24, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.MODULES.FIRE.BODY; // Red 800
            ctx.beginPath();
            ctx.rect(6, 4, 12, 16);
            ctx.fill();
            // Symbol
            ctx.fillStyle = VISUALS.TOWER.MODULES.FIRE.SYMBOL;
            ctx.font = '10px Arial';
            ctx.fillText('‚ö°', 8, 16);
        });

        // Mod Sniper (Scope - Lens)
        this.generateTexture('mod_sniper', 24, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.MODULES.SNIPER.BODY; // Black body
            ctx.fillRect(2, 8, 20, 8);
            // Lens
            ctx.fillStyle = VISUALS.TOWER.MODULES.SNIPER.LENS; // Cyan accent
            ctx.beginPath();
            ctx.arc(22, 12, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        // Mod Split (Ammo box / Extra barrel)
        this.generateTexture('mod_split', 24, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.MODULES.SPLIT.BODY; // Amber 900
            ctx.fillRect(4, 4, 16, 16);
            // Bullets hint
            ctx.fillStyle = VISUALS.TOWER.MODULES.SPLIT.ACCENT;
            ctx.fillRect(6, 6, 4, 12);
            ctx.fillRect(14, 6, 4, 12);
        });

        // Mod Minigun (Ammo belt / Power cell)
        this.generateTexture('mod_minigun', 24, (ctx, w, h) => {
            // Purple ammunition belt with electric coils
            ctx.fillStyle = '#6a1b9a'; // Purple 800
            ctx.fillRect(4, 6, 16, 12);

            // Belt links
            ctx.fillStyle = '#ce93d8'; // Purple 200 (light)
            for (let i = 0; i < 4; i++) {
                ctx.fillRect(6 + i * 4, 8, 2, 8);
            }

            // Energy cell accent
            ctx.fillStyle = '#ba68c8'; // Purple 300
            ctx.beginPath();
            ctx.arc(12, 12, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        this.generateEnemyArchetypes();
        this.generateEnemyProps();
    }

    private static generateEnemyArchetypes() {
        const size = 48; // Base enemy size

        // 1. Skeleton (Standard)
        this.generateTexture('enemy_skeleton', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Bones (White/Grey)
            ctx.fillStyle = VISUALS.ENEMY.SKELETON.BONE;

            // Skull
            ctx.beginPath();
            ctx.arc(cx, cy - 5, 10, 0, Math.PI * 2);
            ctx.fill();

            // Ribcage/Shoulders
            ctx.fillRect(cx - 8, cy + 2, 16, 6);

            // Spine
            ctx.fillRect(cx - 2, cy + 8, 4, 8);

            // Pelvis
            ctx.fillRect(cx - 6, cy + 16, 12, 4);

            // Eyes (Hollow)
            ctx.fillStyle = VISUALS.ENEMY.SKELETON.EYES;
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 5, 2, 0, Math.PI * 2);
            ctx.arc(cx + 3, cy - 5, 2, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. Wolf (Fast)
        this.generateTexture('enemy_wolf', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Body (Elongated) - Grey/Brown
            ctx.fillStyle = VISUALS.ENEMY.WOLF.BODY; // Brownish grey

            ctx.beginPath();
            ctx.ellipse(cx, cy + 2, 8, 14, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.arc(cx, cy - 10, 8, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.beginPath();
            ctx.moveTo(cx - 5, cy - 14);
            ctx.lineTo(cx - 8, cy - 20);
            ctx.lineTo(cx - 2, cy - 16);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(cx + 5, cy - 14);
            ctx.lineTo(cx + 8, cy - 20);
            ctx.lineTo(cx + 2, cy - 16);
            ctx.fill();

            // Tail
            ctx.strokeStyle = VISUALS.ENEMY.WOLF.BODY;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(cx, cy + 14);
            ctx.lineTo(cx, cy + 22);
            ctx.stroke();

            // Eyes (Red glow)
            ctx.fillStyle = VISUALS.ENEMY.WOLF.EYES;
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.arc(cx + 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.fill();
        });

        // 3. Troll (Heavy)
        this.generateTexture('enemy_troll', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Body (Massive) - Green skin
            ctx.fillStyle = VISUALS.ENEMY.TROLL.SKIN;

            ctx.beginPath();
            ctx.arc(cx, cy, 18, 0, Math.PI * 2);
            ctx.fill();

            // Arms (Big shoulders)
            ctx.beginPath();
            ctx.arc(cx - 16, cy - 5, 8, 0, Math.PI * 2);
            ctx.arc(cx + 16, cy - 5, 8, 0, Math.PI * 2);
            ctx.fill();

            // Head (Small relative to body)
            ctx.beginPath();
            ctx.arc(cx, cy - 10, 10, 0, Math.PI * 2);
            ctx.fill();

            // Angry brow
            ctx.fillStyle = VISUALS.ENEMY.TROLL.FEATURE;
            ctx.beginPath();
            ctx.arc(cx, cy - 12, 10, 0.2, Math.PI - 0.2, true);
            ctx.fill();
        });

        // 4. Spider (Boss)
        this.generateTexture('enemy_spider', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Abdomen (Large rear) - Black/Dark Purple
            ctx.fillStyle = VISUALS.ENEMY.SPIDER.BODY;
            ctx.beginPath();
            ctx.ellipse(cx, cy + 8, 12, 16, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cephalothorax (Head/Chest)
            ctx.fillStyle = VISUALS.ENEMY.SPIDER.HEAD;
            ctx.beginPath();
            ctx.arc(cx, cy - 8, 10, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.strokeStyle = VISUALS.ENEMY.SPIDER.BODY;
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                // Right legs
                ctx.beginPath();
                ctx.moveTo(cx + 5, cy - 5 + i * 4);
                ctx.lineTo(cx + 20, cy - 10 + i * 6);
                ctx.stroke();

                // Left legs
                ctx.beginPath();
                ctx.moveTo(cx - 5, cy - 5 + i * 4);
                ctx.lineTo(cx - 20, cy - 10 + i * 6);
                ctx.stroke();
            }

            // Many eyes
            ctx.fillStyle = VISUALS.ENEMY.SPIDER.EYES;
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.arc(cx + 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.arc(cx, cy - 12, 2, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    private static generateEnemyProps() {
        const size = 32;

        // 1. Shield (Armor)
        this.generateTexture('prop_shield', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Wood texture
            ctx.fillStyle = VISUALS.ENEMY.PROPS.SHIELD.WOOD;
            ctx.beginPath();
            ctx.arc(cx, cy, 12, 0, Math.PI * 2);
            ctx.fill();
            // Metal rim
            ctx.strokeStyle = VISUALS.ENEMY.PROPS.SHIELD.METAL;
            ctx.lineWidth = 3;
            ctx.stroke();
            // Center boss
            ctx.fillStyle = VISUALS.ENEMY.PROPS.SHIELD.METAL;
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. Helmet (Leader)
        this.generateTexture('prop_helmet', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Gold
            ctx.fillStyle = VISUALS.ENEMY.PROPS.HELMET.GOLD;
            ctx.beginPath();
            ctx.moveTo(cx - 10, cy + 5);
            ctx.lineTo(cx + 10, cy + 5);
            ctx.lineTo(cx + 10, cy - 5);
            ctx.lineTo(cx, cy - 12); // Spike
            ctx.lineTo(cx - 10, cy - 5);
            ctx.closePath();
            ctx.fill();

            // Horns
            ctx.strokeStyle = VISUALS.ENEMY.PROPS.HELMET.HORN;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - 10, cy - 2);
            ctx.quadraticCurveTo(cx - 16, cy - 8, cx - 14, cy - 14);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cx + 10, cy - 2);
            ctx.quadraticCurveTo(cx + 16, cy - 8, cx + 14, cy - 14);
            ctx.stroke();
        });

        // 3. Barrier (Energy Shield)
        this.generateTexture('prop_barrier', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Semi-transparent sphere
            ctx.fillStyle = VISUALS.ENEMY.PROPS.BARRIER.FILL;
            ctx.beginPath();
            ctx.arc(cx, cy, 14, 0, Math.PI * 2);
            ctx.fill();

            // Runes
            ctx.strokeStyle = VISUALS.ENEMY.PROPS.BARRIER.STROKE;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx, cy, 12, 0, Math.PI * 2);
            ctx.stroke();
        });

        // 4. Weapon (Sword)
        this.generateTexture('prop_weapon', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            ctx.translate(cx, cy);
            ctx.rotate(Math.PI / 4); // Diagonal

            // Handle
            ctx.fillStyle = VISUALS.ENEMY.PROPS.WEAPON.HANDLE;
            ctx.fillRect(-2, 4, 4, 10);

            // Guard
            ctx.fillStyle = VISUALS.ENEMY.PROPS.WEAPON.GUARD;
            ctx.fillRect(-6, 2, 12, 2);

            // Blade
            ctx.fillStyle = VISUALS.ENEMY.PROPS.WEAPON.BLADE;
            ctx.fillRect(-3, -14, 6, 16);
            // Tip
            ctx.beginPath();
            ctx.moveTo(-3, -14);
            ctx.lineTo(3, -14);
            ctx.lineTo(0, -18);
            ctx.fill();
        });
    }
    private static generateProjectiles() {
        const size = 16;
        const cx = size / 2;
        const cy = size / 2;

        // 1. Standard (White Ball)
        this.generateTexture('projectile_standard', size, (ctx, w, h) => {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. Ice (Spike)
        this.generateTexture('projectile_ice', size, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.TURRET.ICE.SPIKE;
            ctx.beginPath();
            ctx.moveTo(cx + 6, cy);
            ctx.lineTo(cx - 2, cy + 4);
            ctx.lineTo(cx - 4, cy);
            ctx.lineTo(cx - 2, cy - 4);
            ctx.fill();
        });

        // 3. Fire (Fireball)
        this.generateTexture('projectile_fire', size, (ctx, w, h) => {
            // Core
            ctx.fillStyle = VISUALS.TOWER.TURRET.FIRE.MAIN;
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, Math.PI * 2);
            ctx.fill();
            // Outer glow (simulated)
            ctx.fillStyle = 'rgba(255, 87, 34, 0.5)';
            ctx.beginPath();
            ctx.arc(cx, cy, 7, 0, Math.PI * 2);
            ctx.fill();
        });

        // 4. Sniper (Bullet Head) - Trail is drawn dynamically
        this.generateTexture('projectile_sniper', size, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.TURRET.SNIPER.BARREL;
            ctx.fillRect(cx - 4, cy - 1.5, 8, 3);
        });

        // 5. Split (Small Pellet)
        this.generateTexture('projectile_split', size, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.TURRET.SPLIT.BARREL;
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        // 6. Minigun (Tracer round)
        this.generateTexture('projectile_minigun', size, (ctx, w, h) => {
            // Small fast tracer with purple/electric glow
            ctx.fillStyle = '#ba68c8'; // Purple 300
            ctx.fillRect(cx - 2, cy - 1, 5, 2);

            // Core
            ctx.fillStyle = '#e1bee7'; // Purple 100 (bright center)
            ctx.fillRect(cx, cy - 0.5, 3, 1);
        });
    }

    private static generateMisc() {
        // Shadow (Generic)
        this.generateTexture('shadow_small', 32, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(cx, cy, 12, 6, 0, 0, Math.PI * 2);
            ctx.fill();
        });

        // Muzzle Flash
        this.generateTexture('effect_muzzle_flash', 32, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 12);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(cx, cy, 12, 0, Math.PI * 2);
            ctx.fill();
        });
    }
}
</file>

<file path="src/index.ts">
import { Game } from './Game';
import { getSavedMaps, deleteMapFromStorage } from './Utils';
import { CONFIG } from './Config';
import { CrashHandler } from './CrashHandler';

// Expose utils to window for EditorScene
(window as any).getSavedMaps = getSavedMaps;
(window as any).deleteMapFromStorage = deleteMapFromStorage;

window.addEventListener('DOMContentLoaded', () => {
    new CrashHandler();

    const canvas = document.getElementById('game-canvas');
    if (!canvas) {
        console.error('‚ùå –û–®–ò–ë–ö–ê: Canvas –Ω–µ –Ω–∞–π–¥–µ–Ω!');
        return;
    }

    try {
        const game = new Game('game-canvas');
        game.start();

        // Theme Switcher Logic Removed (Ink Mode deprecated)
        const themeBtn = document.getElementById('theme-btn');
        if (themeBtn) {
            themeBtn.style.display = 'none'; // Hide the button
        }

        console.log('‚úÖ –ò–≥—Ä–∞ –≥–æ—Ç–æ–≤–∞. –ù–∞–∂–º–∏—Ç–µ ‚öîÔ∏è, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –≤–æ–ª–Ω—É.');
    } catch (e) {
        console.error('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞:', e);
    }
});
</file>

<file path="src/UIManager.ts">
import { IGameScene } from './scenes/IGameScene';
import { GameHUD } from './ui/GameHUD';
import { PauseMenu } from './ui/PauseMenu';
import { GameOverUI } from './ui/GameOverUI';
import { ShopUI } from './ui/ShopUI';

export class UIManager {
    private scene: IGameScene;

    // Components
    public shop: ShopUI;
    public hud: GameHUD;
    public pauseMenu: PauseMenu;
    public gameOver: GameOverUI;

    // –°—Å—ã–ª–∫–∏ –Ω–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã –¥–ª—è —Å–∫—Ä—ã—Ç–∏—è/–ø–æ–∫–∞–∑–∞
    private elHandContainer: HTMLElement;
    private elUiLayer: HTMLElement;

    constructor(scene: IGameScene) {
        this.scene = scene;

        // Init Components
        this.shop = new ShopUI(scene);
        this.hud = new GameHUD(scene);
        console.log('‚ú® UIManager: Initializing PauseMenu...');
        this.pauseMenu = new PauseMenu(scene);
        this.gameOver = new GameOverUI(scene);

        // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã
        this.elHandContainer = document.getElementById('hand-container')!;
        this.elUiLayer = document.getElementById('ui-layer')!;
    }

    public updatePauseMenu(paused: boolean) {
        this.pauseMenu.update(paused);
    }

    // --- –ù–û–í–´–ï –ú–ï–¢–û–î–´ –£–ü–†–ê–í–õ–ï–ù–ò–Ø –í–ò–î–ò–ú–û–°–¢–¨–Æ ---
    public show() {
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–≥—Ä–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
        this.elUiLayer.style.display = 'block';
        this.elHandContainer.style.display = 'block';
        // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ Game Over —Å–∫—Ä—ã—Ç –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
        this.gameOver.hide();
        this.update();
    }

    public hide() {
        // –ü—Ä—è—á–µ–º –≤—Å—ë –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –≤ –º–µ–Ω—é –∏–ª–∏ —Ä–µ–¥–∞–∫—Ç–æ—Ä
        this.elUiLayer.style.display = 'none';
        this.elHandContainer.style.display = 'none';
        this.gameOver.hide();
    }
    // ------------------------------------------

    public showGameOver(wave: number) {
        this.gameOver.show(wave);
    }

    public hideGameOver() {
        this.gameOver.hide();
    }

    public update() {
        if (!this.scene) return;

        this.hud.update();
        this.shop.update();
    }
}
</file>

<file path="src/Utils.ts">
import { MapManager } from './Map';
import { IMapData, IWaveConfig } from './MapData';
import { CONFIG } from './Config';

export function generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0,
            v = c == 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}

export class ObjectPool<T> {
    private createFn: () => T;
    private pool: T[] = [];
    constructor(createFn: () => T) {
        this.createFn = createFn;
    }
    public obtain(): T {
        return this.pool.length > 0 ? this.pool.pop()! : this.createFn();
    }
    public free(obj: T): void {
        // Type-safe check for reset method
        if (obj && typeof obj === 'object' && 'reset' in obj && typeof (obj as any).reset === 'function') {
            (obj as any).reset();
        }
        this.pool.push(obj);
    }
}

export function generateDefaultWaves(count: number = 10): IWaveConfig[] {
    const waves: IWaveConfig[] = [];
    for (let i = 1; i <= count; i++) {
        const waveEnemies: { type: string; count: number }[] = [];
        if (i <= 3) {
            waveEnemies.push({ type: 'grunt', count: 3 + i * 2 });
        } else {
            waveEnemies.push({ type: 'grunt', count: 5 + i });
            waveEnemies.push({ type: 'scout', count: Math.floor(i / 2) });
        }
        waves.push({ enemies: waveEnemies });
    }
    return waves;
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∏ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –≤–æ–ª–Ω—ã –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
 * –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –æ–±—Ä–∞—Ç–Ω—É—é —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è–º–∏
 */
export function normalizeWaveConfig(wave: any): IWaveConfig {
    if (!wave || !wave.enemies || !Array.isArray(wave.enemies)) {
        return { enemies: [] };
    }

    return {
        enemies: wave.enemies.map((group: any) => ({
            type: group.type || 'GRUNT',
            count: Math.max(1, parseInt(group.count) || 1),
            spawnPattern: (['normal', 'random', 'swarm'].includes(group.spawnPattern))
                ? group.spawnPattern
                : 'normal',
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—ã–µ –ø–æ–ª—è –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
            speed: group.speed,
            spawnRate: group.spawnRate
        }))
    };
}


export function serializeMap(map: MapManager): IMapData {
    const simpleTiles: number[][] = [];
    for (let y = 0; y < map.rows; y++) {
        const row: number[] = [];
        for (let x = 0; x < map.cols; x++) {
            row.push(map.grid[y][x].type);
        }
        simpleTiles.push(row);
    }
    return {
        width: map.cols,
        height: map.rows,
        tiles: simpleTiles,
        waypoints: map.waypoints.map((wp) => ({ x: wp.x, y: wp.y })),
        objects: map.objects || [], // Include objects from map
        waves: map.waves && map.waves.length > 0 ? map.waves : generateDefaultWaves(15),
        startingMoney: CONFIG.PLAYER.START_MONEY,
        startingLives: CONFIG.PLAYER.START_LIVES,
    };
}

export function validateMap(data: any): boolean {
    if (!data) return false;
    if (!data.tiles || !Array.isArray(data.tiles) || data.tiles.length === 0) {
        console.error('Map Validation Failed: No tiles data');
        return false;
    }
    if (!data.waypoints || !Array.isArray(data.waypoints)) {
        console.error('Map Validation Failed: No waypoints array');
        return false;
    }
    if (data.waypoints.length < 2) {
        console.error('Map Validation Failed: Path too short (<2 waypoints)');
        return false;
    }
    return true;
}

// --- STORAGE UTILS ---

export function getSavedMaps(): Record<string, IMapData> {
    try {
        const raw = localStorage.getItem('NEWTOWER_MAPS');
        if (!raw) return {};

        const maps = JSON.parse(raw);

        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –≤–æ–ª–Ω –≤–æ –≤—Å–µ—Ö –∫–∞—Ä—Ç–∞—Ö –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        Object.keys(maps).forEach(mapName => {
            const mapData = maps[mapName];
            if (mapData.waves && Array.isArray(mapData.waves)) {
                mapData.waves = mapData.waves.map(normalizeWaveConfig);
            }
        });

        return maps;
    } catch (e) {
        console.error('Failed to load maps', e);
        return {};
    }
}

export function saveMapToStorage(name: string, data: IMapData): boolean {
    try {
        const maps = getSavedMaps();
        maps[name] = data;
        localStorage.setItem('NEWTOWER_MAPS', JSON.stringify(maps));
        return true;
    } catch (e) {
        console.error('Failed to save map', e);
        return false;
    }
}

export function deleteMapFromStorage(name: string): void {
    const maps = getSavedMaps();
    delete maps[name];
    localStorage.setItem('NEWTOWER_MAPS', JSON.stringify(maps));
}
</file>

<file path="src/renderers/EnemyRenderer.ts">
import { Assets } from '../Assets';
import { CONFIG, getEnemyType } from '../Config';
import type { Enemy } from '../Enemy';
import { UnitRenderer, DefaultUnitRenderer } from './units/UnitRenderer';
import { SkeletonUnitRenderer } from './units/SkeletonUnitRenderer';
import { HellhoundUnitRenderer } from './units/HellhoundUnitRenderer';
import { OrcUnitRenderer } from './units/OrcUnitRenderer';
import { WraithUnitRenderer } from './units/WraithUnitRenderer';
import { GoblinUnitRenderer } from './units/GoblinUnitRenderer';

import { SpiderUnitRenderer } from './units/SpiderUnitRenderer';
import { SkeletonCommanderUnitRenderer } from './units/SkeletonCommanderUnitRenderer';

import { TrollUnitRenderer } from './units/TrollUnitRenderer';
import { RatUnitRenderer } from './units/RatUnitRenderer';
import { MagmaUnitRenderer } from './units/MagmaUnitRenderer';

export class EnemyRenderer {
    // Registry of specific renderers (Singleton/Stateless instances)
    private static defaultRenderer: UnitRenderer = new DefaultUnitRenderer();
    private static renderers: Record<string, UnitRenderer> = {
        'SKELETON': new SkeletonUnitRenderer(),
        'WOLF': new DefaultUnitRenderer(),
        'TROLL': new TrollUnitRenderer(),
        'SPIDER': new SpiderUnitRenderer(),
        'HELLHOUND': new HellhoundUnitRenderer(),
        'ORC': new OrcUnitRenderer(),
        'WRAITH': new WraithUnitRenderer(),
        'GOBLIN': new GoblinUnitRenderer(),
        'SKELETON_COMMANDER': new SkeletonCommanderUnitRenderer(),
        'RAT': new RatUnitRenderer(),
        'MAGMA': new MagmaUnitRenderer(),
    };

    static drawSprite(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        const safeType = enemy.typeId ? enemy.typeId.toLowerCase() : 'grunt';
        const typeConf = getEnemyType(safeType.toUpperCase()) || getEnemyType('GRUNT');

        // Defaults
        const scale = typeConf?.scale || 1.0;
        const archetype = typeConf?.archetype || 'SKELETON';
        const props = typeConf?.props || [];
        const baseColor = typeConf?.color || '#fff';
        const tint = typeConf?.tint;

        ctx.save();
        ctx.translate(enemy.x, enemy.y);

        // === ANIMATIONS ===

        // 1. Rotation towards movement
        const path = enemy.path;
        const pathIndex = enemy.pathIndex;
        let moveAngle = 0;

        if (path && pathIndex < path.length - 1) {
            const next = path[pathIndex];
            const dx = next.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 - enemy.x;
            const dy = next.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 - enemy.y;
            moveAngle = Math.atan2(dy, dx);
        }

        // 2. Breathing (pulsation)
        const breathePhase = (Date.now() * 0.001) + (parseInt(enemy.id.slice(-3), 36) * 0.5);
        const breatheScale = 1.0 + Math.sin(breathePhase) * 0.03;
        ctx.scale(breatheScale, breatheScale);

        // -- VISUAL STACK --

        // 1. Shadow Layer
        EnemyRenderer.drawShadow(ctx, scale);

        // 2. Body Layer (STRATEGY PATTERN DELEGATION)
        const renderer = EnemyRenderer.renderers[archetype] || EnemyRenderer.defaultRenderer;
        try {
            renderer.drawBody(ctx, enemy, scale, moveAngle);
        } catch (e) {
            console.error(`Renderer failed for ${archetype}`, e);
            EnemyRenderer.defaultRenderer.drawBody(ctx, enemy, scale, moveAngle);
        }

        // 3. Props Layer
        if (props.length > 0) {
            props.forEach(propId => {
                const propImg = Assets.get(propId);
                if (propImg) {
                    const pSize = 32 * scale;
                    const pHalf = pSize / 2;
                    ctx.drawImage(propImg, -pHalf, -pHalf, pSize, pSize);
                }
            });
        }

        // 3.5. Status Particles Layer
        EnemyRenderer.drawStatusEffects(ctx, enemy);

        ctx.restore();
    }

    static drawUI(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        const safeType = enemy.typeId ? enemy.typeId.toLowerCase() : 'grunt';
        const typeConf = getEnemyType(safeType.toUpperCase()) || getEnemyType('GRUNT');
        const scale = typeConf?.scale || 1.0;

        ctx.save();
        ctx.translate(enemy.x, enemy.y);
        // Breathing effect also affects UI position slightly if we scaled context, 
        // but typically UI should maybe NOT oscillate?
        // Original code DID oscillate UI because it was inside the breatheScale.
        // Let's keep it simple and stable for UI, or replicate if strictly needed.
        // User asked for "HP Bars bright and clear". Stability is better.
        // I will NOT apply breatheScale to UI for better readability.

        EnemyRenderer.drawHealthBar(ctx, enemy, scale);
        ctx.restore();
    }

    private static drawRimLight(ctx: CanvasRenderingContext2D, color: string, scale: number) {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.3;

        const rimSize = (48 * scale) * 1.2;
        ctx.beginPath();
        ctx.arc(0, 0, rimSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    private static drawShadow(ctx: CanvasRenderingContext2D, scale: number) {
        const shadowImg = Assets.get('shadow_small');
        if (shadowImg) {
            const shadowW = 32 * scale;
            const shadowH = 16 * scale;
            ctx.drawImage(shadowImg, -shadowW / 2, -shadowH / 2 + 10 * scale, shadowW, shadowH);
        } else {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            const shadowW = 16 * scale;
            const shadowH = 8 * scale;
            ctx.ellipse(0, 10 * scale, shadowW, shadowH, 0, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    private static drawStatusEffects(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        if (enemy.statuses.some(s => s.type === 'slow')) {
            for (let i = 0; i < 3; i++) {
                const angle = (Date.now() * 0.003) + (i * Math.PI * 2 / 3);
                const orbX = Math.cos(angle) * 20;
                const orbY = Math.sin(angle) * 20;
                ctx.fillStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.arc(orbX, orbY, 3, 0, Math.PI * 2);
                ctx.fill();
                // Inner glow
                ctx.fillStyle = '#e1f5fe';
                ctx.beginPath();
                ctx.arc(orbX, orbY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    private static drawHealthBar(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number) {
        if (enemy.currentHealth < enemy.maxHealth) {
            const barWidth = CONFIG.UI.HP_BAR_WIDTH;
            const barHeight = CONFIG.UI.HP_BAR_HEIGHT;
            const barY = -30 * scale;

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(-barWidth / 2, barY, barWidth, barHeight);

            // Health bar
            const hpPercent = enemy.currentHealth / enemy.maxHealth;
            let hpColor = '#4caf50'; // green

            if (enemy.isInvulnerable) {
                hpColor = '#ffd700'; // Gold if immune
            } else if (hpPercent < 0.3) {
                hpColor = '#f44336'; // red
            } else if (hpPercent < 0.6) {
                hpColor = '#ff9800'; // orange
            }

            ctx.fillStyle = hpColor;
            ctx.fillRect(-barWidth / 2, barY, barWidth * hpPercent, barHeight);
        }
    }
    static drawEmissive(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        const safeType = enemy.typeId ? enemy.typeId.toLowerCase() : 'grunt';
        const typeConf = getEnemyType(safeType.toUpperCase()) || getEnemyType('GRUNT');
        const scale = typeConf?.scale || 1.0;
        const archetype = typeConf?.archetype || 'SKELETON';

        const renderer = EnemyRenderer.renderers[archetype] || EnemyRenderer.defaultRenderer;
        if (renderer.drawEmissive) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);

            // Re-calculate moveAngle (Duplicate logic, but necessary for correct pose)
            const path = enemy.path;
            const pathIndex = enemy.pathIndex;
            let moveAngle = 0;
            if (path && pathIndex < path.length - 1) {
                const next = path[pathIndex];
                const dx = next.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 - enemy.x;
                const dy = next.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 - enemy.y;
                moveAngle = Math.atan2(dy, dx);
            }

            renderer.drawEmissive(ctx, enemy, scale, moveAngle);
            ctx.restore();
        }
    }
}
</file>

<file path="src/scenes/EntityManager.ts">
import { Enemy } from '../Enemy';
import { Tower } from '../Tower';
import { ICard } from '../CardSystem';
import { CONFIG, getEnemyType } from '../Config';
import { EntityFactory } from '../EntityFactory';
import { GameState } from './GameState';
import { EffectSystem } from '../EffectSystem';
import { MetricsSystem } from '../MetricsSystem';
import { SoundManager } from '../SoundManager';
import { EventBus, Events } from '../EventBus';
import { playDeathAnimation } from '../effects';

/**
 * Manages entity lifecycle:
 * - Tower building/selling
 * - Enemy spawning/death
 * - Projectile cleanup
 * - Visual effects coordination
 */
export class EntityManager {
    constructor(
        private state: GameState,
        private effects: EffectSystem,
        private metrics: MetricsSystem,
    ) { }

    // === Tower Management ===

    /**
     * Validate if a tower can be built at the given position
     */
    public canBuildTower(col: number, row: number, mapData: any, isBuildable: (c: number, r: number) => boolean): { valid: boolean; reason?: string } {
        if (!isBuildable(col, row)) {
            return { valid: false, reason: "Can't build here!" };
        }

        // Check existing tower
        const existingTower = this.state.towers.find((t) => t.col === col && t.row === row);
        if (existingTower) {
            return { valid: false, reason: 'Tower already here!' };
        }

        // Check money
        if (this.state.money < CONFIG.ECONOMY.TOWER_COST) {
            return { valid: false, reason: 'Not enough money!' };
        }

        return { valid: true };
    }

    /**
     * Build a tower at the specified position
     */
    public buildTower(col: number, row: number): Tower {
        this.state.spendMoney(CONFIG.ECONOMY.TOWER_COST);
        this.metrics.trackMoneySpent(CONFIG.ECONOMY.TOWER_COST);

        const tower = EntityFactory.createTower(col, row);
        tower.isBuilding = true;
        tower.buildProgress = 0;
        this.state.towers.push(tower);

        this.metrics.trackTowerBuilt();
        return tower;
    }

    /**
     * Sell an existing tower
     */
    public sellTower(tower: Tower): number {
        const idx = this.state.towers.indexOf(tower);
        if (idx === -1) return 0;

        this.state.towers.splice(idx, 1);
        const refund = Math.floor(CONFIG.ECONOMY.TOWER_COST * CONFIG.ECONOMY.SELL_REFUND);
        this.state.addMoney(refund);

        // Visual feedback
        this.showFloatingText(`+${refund}üí∞`, tower.x, tower.y, 'gold');

        if (this.state.selectedTower === tower) {
            this.state.selectTower(null);
        }

        return refund;
    }

    /**
     * Add a card to a tower or create new tower if none exists
     */
    public addCardToTower(card: ICard, col: number, row: number, isBuildable: (c: number, r: number) => boolean): boolean {
        let tower = this.state.towers.find((t) => t.col === col && t.row === row);

        // If no tower exists, we do NOT build one automatically on drop
        // User requested: "if card is carried not to tower base but to empty cell... it should return to hand"
        if (!tower) {
            return false;
        }

        // Add card to tower
        if (tower.cards.length < 3) {
            tower.cards.push(card);
            this.metrics.trackCardUsed(card.type.id);
            return true;
        }

        return false;
    }

    /**
     * Sell a card from a tower
     */
    public sellCardFromTower(tower: Tower, cardIndex: number): { card: ICard | null; refund: number } {
        const card = tower.removeCard(cardIndex);
        if (!card) return { card: null, refund: 0 };

        const prices = CONFIG.ECONOMY.CARD_SELL_PRICES;
        const refund = prices[card.level] || 5;
        this.state.addMoney(refund);

        this.showFloatingText(`+${refund}üí∞`, tower.x, tower.y - 30, 'gold');
        this.metrics.trackMoneyEarned(refund);

        return { card, refund };
    }

    // === Enemy Management ===

    /**
     * Spawn an enemy of the given type
     */
    public spawnEnemy(type: string, waypoints: { x: number; y: number }[]): Enemy | null {
        if (!waypoints || waypoints.length === 0) return null;

        const enemy = this.state.enemyPool.obtain();
        EntityFactory.setupEnemy(enemy, type, this.state.wave, waypoints);
        this.state.enemies.push(enemy);

        // Notify systems
        EventBus.getInstance().emit(Events.ENEMY_SPAWNED, type);

        return enemy;
    }

    /**
     * Update enemy counter in HUD
     */
    private updateEnemyCounterUI(): void {
        // This will be called from updateEnemies
    }

    /**
     * Process enemy death - rewards, effects, cleanup
     */
    public handleEnemyDeath(enemy: Enemy): void {
        const reward = enemy.reward || 5;
        this.state.addMoney(reward);
        this.metrics.trackEnemyKilled();
        this.metrics.trackMoneyEarned(reward);

        const enemyTypeConf = getEnemyType(enemy.typeId.toUpperCase());

        // === –ê—Ä—Ö–µ—Ç–∏–ø-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è —Å–º–µ—Ä—Ç–∏ ===
        playDeathAnimation(this.effects, enemy, enemyTypeConf);

        // Soft death sound (throttled by SoundManager)
        SoundManager.play('death');

        // Floating text with emoji
        this.effects.add({
            type: 'text',
            text: `+${reward}üí∞`,
            x: enemy.x,
            y: enemy.y,
            life: 0.6,
            color: 'gold',
            vy: -90,
        });

        // Coin particle burst
        const particleCount = Math.min(3 + Math.floor(reward / 5), 8);
        for (let p = 0; p < particleCount; p++) {
            this.effects.add({
                type: 'particle',
                x: enemy.x + (Math.random() - 0.5) * 20,
                y: enemy.y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 360,
                vy: -(Math.random() * 240 + 120),
                life: 0.4 + Math.random() * 0.25,
                radius: 3 + Math.random() * 2,
                color: Math.random() > 0.3 ? '#ffd700' : '#ffeb3b',
            });
        }
    }

    /**
 * Process enemy reaching the end - lose life, cleanup
     */
    public handleEnemyFinished(enemy: Enemy): void {
        const damage = enemy.typeId === 'sapper_rat' ? 5 : 1;
        this.state.loseLife(damage, this.effects); // Pass effects for screen flash

        if (damage > 1) {
            this.showFloatingText(`CRYITICAL BREACH! -${damage}‚ù§Ô∏è`, enemy.x, enemy.y - 20, '#d32f2f');
            SoundManager.play('explosion'); // Louder/Standard
        }

        this.metrics.trackLifeLost();
        // Removed triggerShake - flash effect is enough
        if (damage === 1) SoundManager.play('explosion', 1);
    }

    /**
     * Update all enemies and handle death/finish
     */
    public updateEnemies(dt: number): void {
        for (let i = this.state.enemies.length - 1; i >= 0; i--) {
            const e = this.state.enemies[i];
            e.move(dt);
            e.update(dt);

            if (!e.isAlive()) {
                this.handleEnemyDeath(e);
                this.state.enemyPool.free(e);
                this.state.enemies.splice(i, 1);
            } else if (e.finished) {
                this.handleEnemyFinished(e);
                this.state.enemies.splice(i, 1);
                this.state.enemyPool.free(e);
            }
        }
    }

    // === Projectile Management ===

    // Projectiles are now managed by ProjectileSystem

    // === Helper Methods ===

    private showFloatingText(text: string, x: number, y: number, color: string = '#fff'): void {
        this.effects.add({ type: 'text', text, x, y, life: 1.0, color, vy: -60 });
    }

    /**
     * Get tower at specific grid position
     */
    public getTowerAt(col: number, row: number): Tower | null {
        return this.state.towers.find((t) => t.col === col && t.row === row) || null;
    }
}
</file>

<file path="src/scenes/MenuScene.ts">
import { BaseScene } from '../BaseScene';
import { Game } from '../Game';
import { DEMO_MAP, IMapData } from '../MapData';
import { validateMap, getSavedMaps } from '../Utils';
import { MapManager } from '../Map';
import { CONFIG } from '../Config';
import { UIUtils } from '../UIUtils';
import { Assets } from '../Assets';
import { VISUALS } from '../VisualConfig';

export class MenuScene extends BaseScene {
    private game: Game;
    private container!: HTMLElement;
    private mapSelectionContainer!: HTMLElement;

    constructor(game: Game) {
        super();
        this.game = game;
        this.createUI();
        this.createMapSelectionUI();
    }

    public onEnter() {
        this.container.style.display = 'flex';
        this.mapSelectionContainer.style.display = 'none';

        const uiLayer = document.getElementById('ui-layer');
        if (uiLayer) uiLayer.style.display = 'none';
        const hand = document.getElementById('hand-container');
        if (hand) hand.style.display = 'none';
    }

    public onExit() {
        this.container.style.display = 'none';
        this.mapSelectionContainer.style.display = 'none';

        // Cleanup canvas elements to prevent memory leaks
        this.clearMapPreviews();
    }

    public update(dt: number) { }

    public draw(ctx: CanvasRenderingContext2D) {
        // === –§–æ–Ω–æ–≤–æ–µ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ ===
        const bgImage = Assets.get('menu_start');
        if (bgImage) {
            // Cover-fit —Å —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º (–º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ—Ç —á—Ç–æ–±—ã –ø–æ–∫—Ä—ã—Ç—å –≤–µ—Å—å canvas)
            const scale = Math.max(
                this.game.canvas.width / bgImage.width,
                this.game.canvas.height / bgImage.height
            );
            const x = (this.game.canvas.width - bgImage.width * scale) / 2;
            const y = (this.game.canvas.height - bgImage.height * scale) / 2;

            ctx.drawImage(bgImage, x, y, bgImage.width * scale, bgImage.height * scale);

            // –ó–∞—Ç–µ–º–Ω–µ–Ω–∏–µ –¥–ª—è —á–∏—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç–∏
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        } else {
            // === Fallback - —Å—Ç–∞—Ä—ã–π —Ñ–æ–Ω (—Å–µ—Ç–∫–∞) ===
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);

            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            const s = 64;
            for (let x = 0; x < this.game.canvas.width; x += s) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, this.game.canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < this.game.canvas.height; y += s) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(this.game.canvas.width, y);
                ctx.stroke();
            }
        }

        // === –ó–∞–≥–æ–ª–æ–≤–æ–∫ ===
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 60px Segoe UI';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // –î–≤–æ–π–Ω–∞—è —Ç–µ–Ω—å –¥–ª—è –≥–ª—É–±–∏–Ω—ã
        ctx.shadowColor = 'rgba(0,0,0,0.9)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetY = 4;
        ctx.fillText('NEW TOWER', this.game.canvas.width / 2, 150);

        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–æ–¥—Å–≤–µ—Ç–∫–∞
        ctx.shadowColor = 'rgba(255,255,255,0.3)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetY = -2;
        ctx.fillText('NEW TOWER', this.game.canvas.width / 2, 150);

        ctx.restore();
    }


    private createUI() {
        this.container = UIUtils.createContainer({
            position: 'absolute',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            display: 'none',
            flexDirection: 'column',
            alignItems: 'flex-start', // –°–¥–≤–∏–≥ –≤–ª–µ–≤–æ
            justifyContent: 'center',
            gap: '20px',
            pointerEvents: 'none'
        });
        // –î–æ–±–∞–≤–ª—è–µ–º paddingLeft –≤—Ä—É—á–Ω—É—é
        this.container.style.paddingLeft = '15%';

        UIUtils.createButton(this.container, '‚ñ∂ START GAME', () => {
            this.showMapSelection();
        }, { width: '300px', fontSize: '24px', padding: '15px 40px' });

        UIUtils.createButton(this.container, 'üõ† EDITOR', () => {
            this.game.toEditor();
        }, { width: '300px', fontSize: '24px', padding: '15px 40px' });

        document.body.appendChild(this.container);
    }

    private createMapSelectionUI() {
        this.mapSelectionContainer = UIUtils.createContainer({
            position: 'absolute',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            display: 'none',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: '2000',
            color: '#fff'
        });
        // –§–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤—Ä—É—á–Ω—É—é (–∏–∑ –∫–æ—Ä–Ω—è)
        this.mapSelectionContainer.style.backgroundImage = 'url("../map.jpg")';
        this.mapSelectionContainer.style.backgroundSize = 'cover';
        this.mapSelectionContainer.style.backgroundPosition = 'center';
        this.mapSelectionContainer.style.backgroundRepeat = 'no-repeat';

        // –ó–∞—Ç–µ–º–Ω—è—é—â–∏–π overlay —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º –¥–ª—è –ª—É—á—à–µ–≥–æ —Ñ–æ–∫—É—Å–∞
        const overlay = document.createElement('div');
        Object.assign(overlay.style, {
            position: 'absolute',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            background: 'radial-gradient(circle at center, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.7) 100%)',
            zIndex: '-1',
            pointerEvents: 'none'
        });
        this.mapSelectionContainer.appendChild(overlay);

        const title = document.createElement('h2');
        title.innerText = 'SELECT MAP';
        Object.assign(title.style, {
            marginBottom: `${VISUALS.UI.SPACING.xl}px`,
            fontSize: VISUALS.UI.FONTS.size.huge,
            fontWeight: VISUALS.UI.FONTS.weight.bold,
            textShadow: VISUALS.UI.SHADOWS.lg,
            letterSpacing: '2px'
        });
        this.mapSelectionContainer.appendChild(title);

        const listContainer = document.createElement('div');
        Object.assign(listContainer.style, {
            display: 'flex',
            gap: `${VISUALS.UI.SPACING.lg}px`,
            overflowX: 'auto',
            overflowY: 'hidden',
            maxWidth: '90%',
            maxHeight: '70vh',
            padding: `${VISUALS.UI.SPACING.xl}px`,
            border: `${VISUALS.UI.BORDERS.width.normal} solid ${VISUALS.UI.COLORS.glass.border}`,
            borderRadius: VISUALS.UI.BORDERS.radius.xl,
            background: VISUALS.UI.COLORS.glass.bgLight,
            backdropFilter: 'blur(10px)',
            boxShadow: VISUALS.UI.SHADOWS.xl,
            scrollbarWidth: 'thin',
            scrollbarColor: `${VISUALS.UI.COLORS.glass.borderHover} ${VISUALS.UI.COLORS.glass.bgDark}`
        });
        this.mapSelectionContainer.appendChild(listContainer);

        // Function to refresh list
        (this.mapSelectionContainer as any).refreshList = () => {
            listContainer.innerHTML = '';

            // DEMO MAP
            this.createMapCard(listContainer, 'Demo Map', DEMO_MAP);

            // SAVED MAPS
            const saved = getSavedMaps();
            for (const key in saved) {
                this.createMapCard(listContainer, key, saved[key]);
            }
        };

        UIUtils.createButton(this.mapSelectionContainer, 'BACK', () => {
            this.mapSelectionContainer.style.display = 'none';
            this.container.style.display = 'flex';
        }, {
            background: `linear-gradient(135deg, ${VISUALS.UI.COLORS.danger}, #b71c1c)`,
            fontSize: VISUALS.UI.FONTS.size.xl,
            padding: `${VISUALS.UI.SPACING.md}px ${VISUALS.UI.SPACING.xxl}px`,
            border: `${VISUALS.UI.BORDERS.width.normal} solid ${VISUALS.UI.COLORS.glass.border}`,
            borderRadius: VISUALS.UI.BORDERS.radius.lg,
            boxShadow: VISUALS.UI.SHADOWS.glow.danger,
            width: 'auto'
        });

        document.body.appendChild(this.mapSelectionContainer);
    }

    private createMapCard(parent: HTMLElement, name: string, data: IMapData) {
        try {
            const card = document.createElement('div');
            Object.assign(card.style, {
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                gap: `${VISUALS.UI.SPACING.sm}px`,
                background: VISUALS.UI.COLORS.glass.bg,
                padding: `${VISUALS.UI.SPACING.md}px`,
                borderRadius: VISUALS.UI.BORDERS.radius.lg,
                minWidth: '220px',
                cursor: 'pointer',
                border: `${VISUALS.UI.BORDERS.width.thick} solid ${VISUALS.UI.COLORS.glass.border}`,
                backdropFilter: 'blur(5px)',
                transition: VISUALS.UI.TRANSITIONS.presets.normal,
                boxShadow: VISUALS.UI.SHADOWS.md,
                transform: 'translateZ(0)' // GPU acceleration
            });

            // Preview Canvas
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 150;
            const ctx = canvas.getContext('2d')!;

            // Render preview
            // We need a temporary MapManager to draw
            const tempMap = new MapManager(data);
            // Scale context to fit
            ctx.save();
            const scale = Math.min(200 / (tempMap.cols * CONFIG.TILE_SIZE), 150 / (tempMap.rows * CONFIG.TILE_SIZE));
            ctx.scale(scale, scale);
            tempMap.draw(ctx);
            ctx.restore();

            card.appendChild(canvas);

            const label = document.createElement('div');
            label.innerText = name;
            label.style.fontWeight = VISUALS.UI.FONTS.weight.bold;
            label.style.fontSize = VISUALS.UI.FONTS.size.lg;
            label.style.textShadow = VISUALS.UI.SHADOWS.md;
            card.appendChild(label);

            card.onmouseover = () => {
                card.style.borderColor = VISUALS.UI.COLORS.primary;
                card.style.transform = 'scale(1.05) translateY(-5px)';
                card.style.boxShadow = VISUALS.UI.SHADOWS.glow.primary;
            };
            card.onmouseout = () => {
                card.style.borderColor = VISUALS.UI.COLORS.glass.border;
                card.style.transform = 'scale(1)';
                card.style.boxShadow = VISUALS.UI.SHADOWS.md;
            };
            card.onclick = () => {
                console.log('Map card clicked:', name);
                console.log('Map data:', data);
                const isValid = validateMap(data);
                console.log('Map validation result:', isValid);
                if (isValid) {
                    console.log('Calling toGame...');
                    this.game.toGame(data);
                } else {
                    console.error('Map is invalid!');
                    alert('Map is invalid!');
                }
            };

            parent.appendChild(card);
        } catch (e) {
            console.error(`Failed to render map card for ${name}`, e);
            const errCard = document.createElement('div');
            errCard.innerText = `‚ùå ${name} (Corrupted)`;
            Object.assign(errCard.style, {
                background: '#300',
                color: '#f88',
                padding: '10px',
                borderRadius: '8px',
                minWidth: '200px',
                textAlign: 'center',
            });
            parent.appendChild(errCard);
        }
    }

    /**
     * Clears canvas previews to prevent memory leaks
     */
    private clearMapPreviews(): void {
        // Find the list container with map cards
        const listContainer = this.mapSelectionContainer.querySelector('div[style*="overflowX"]') as HTMLElement;
        if (!listContainer) return;

        // Clear all canvas contexts before removing from DOM
        const canvases = listContainer.querySelectorAll('canvas');
        canvases.forEach(canvas => {
            const ctx = canvas.getContext('2d');
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        });

        // Remove all map cards to free memory
        listContainer.innerHTML = '';
    }

    private showMapSelection() {
        this.container.style.display = 'none';
        this.mapSelectionContainer.style.display = 'flex';
        if ((this.mapSelectionContainer as any).refreshList) {
            (this.mapSelectionContainer as any).refreshList();
        }
    }

    // createBtn removed - replaced by UIUtils.createButton
}
</file>

<file path="src/EffectSystem.ts">
import { Assets } from './Assets';
import { RendererFactory } from './RendererFactory';
import { CONFIG } from './Config';

export interface IEffect {
    type: 'explosion' | 'text' | 'particle' | 'scan' | 'debris' | 'screen_flash' | 'muzzle_flash' | 'scale_pop';
    x: number;
    y: number;
    life: number;
    maxLife?: number;

    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
    radius?: number;
    size?: number; // –î–ª—è —á–∞—Å—Ç–∏—Ü
    color?: string;
    text?: string;
    vx?: number;
    vy?: number;
    rotation?: number; // –í—Ä–∞—â–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü—ã
    vRot?: number; // –°–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞—â–µ–Ω–∏—è
    fontSize?: number; // For custom text size
    gravity?: number; // For debris with gravity
    flashColor?: string; // For screen flash
    enemySprite?: string; // For scale_pop death animation
    enemyColor?: string; // For enemy tint in scale_pop
}

export class EffectSystem {
    private effects: IEffect[] = [];
    private ctx: CanvasRenderingContext2D;
    private canvasWidth: number;
    private canvasHeight: number;

    constructor(ctx: CanvasRenderingContext2D) {
        this.ctx = ctx;
        this.canvasWidth = ctx.canvas.width;
        this.canvasHeight = ctx.canvas.height;
    }

    public add(effect: IEffect) {
        if (!effect.maxLife) effect.maxLife = effect.life;
        this.effects.push(effect);
    }

    public get activeEffects(): IEffect[] {
        return this.effects;
    }

    public update(dt: number) {
        this.effects.forEach((e) => {
            e.life -= dt;

            if (e.type === 'particle' || e.type === 'text' || e.type === 'debris') {
                if (e.vx) e.x += e.vx * dt;
                if (e.vy) e.y += e.vy * dt;

                // Gravity for debris
                // Gravity for debris
                if (e.type === 'debris') {
                    if (e.gravity) e.vy = (e.vy || 0) + e.gravity * dt;
                    if (e.vx) {
                        // Drag: 0.98 per frame approx means ~30% remaining after 1 sec
                        // pow(0.3, dt) is a good approximation for framerate independent damping
                        e.vx *= Math.pow(0.3, dt);
                    }
                    // Rotation
                    if (e.rotation !== undefined && e.vRot) {
                        // Assuming vRot is now passed in radians/sec
                        e.rotation += e.vRot * dt;
                    }
                }
            }
        });

        this.effects = this.effects.filter((e) => e.life > 0);
    }

    public draw() {
        this.effects.forEach((e) => {
            // Try Factory first
            if (RendererFactory.drawEffect(this.ctx, e)) {
                return;
            }

            const progress = e.life / (e.maxLife || 1);

            this.ctx.save();
            this.ctx.globalAlpha = progress;

            if (e.type === 'explosion') {
                const radius = e.radius || 30;
                const time = 1 - progress; // 0 -> 1 over lifetime

                // Layer 1: Expanding shockwave ring
                const ringRadius = radius * (0.3 + time * 0.7);
                const ringWidth = 3 + (1 - time) * 4;
                this.ctx.strokeStyle = e.color || 'rgba(255, 150, 50, 0.8)';
                this.ctx.lineWidth = ringWidth;
                this.ctx.beginPath();
                this.ctx.arc(e.x, e.y, ringRadius, 0, Math.PI * 2);
                this.ctx.stroke();

                // Layer 2: Inner glow core (shrinking)
                const coreRadius = radius * 0.4 * progress;
                if (coreRadius > 1) {
                    const gradient = this.ctx.createRadialGradient(
                        e.x, e.y, 0,
                        e.x, e.y, coreRadius
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                    gradient.addColorStop(0.5, e.color || 'rgba(255, 150, 50, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(e.x, e.y, coreRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Layer 3: Radial rays (spikes)
                if (progress > 0.3) {
                    const rayCount = 8;
                    const rayLength = radius * 0.6 * progress;
                    this.ctx.strokeStyle = e.color || 'rgba(255, 200, 100, 0.7)';
                    this.ctx.lineWidth = 2;
                    for (let i = 0; i < rayCount; i++) {
                        const angle = (i / rayCount) * Math.PI * 2;
                        const startR = radius * 0.15;
                        this.ctx.beginPath();
                        this.ctx.moveTo(
                            e.x + Math.cos(angle) * startR,
                            e.y + Math.sin(angle) * startR
                        );
                        this.ctx.lineTo(
                            e.x + Math.cos(angle) * rayLength,
                            e.y + Math.sin(angle) * rayLength
                        );
                        this.ctx.stroke();
                    }
                }
            } else if (e.type === 'text') {
                const fontSize = e.fontSize || 16;
                this.ctx.fillStyle = e.color || '#fff';
                this.ctx.font = `bold ${fontSize}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(e.text || '', e.x, e.y);
                this.ctx.strokeStyle = 'black';
                this.ctx.lineWidth = fontSize > 20 ? 3 : 2;
                this.ctx.strokeText(e.text || '', e.x, e.y);
            } else if (e.type === 'particle') {
                // Standard Spark
                this.ctx.fillStyle = e.color || '#fff';
                this.ctx.beginPath();
                this.ctx.arc(e.x, e.y, e.radius || 2, 0, Math.PI * 2);
                this.ctx.fill();
            } else if (e.type === 'debris') {
                // –û—Å–∫–æ–ª–æ–∫ (–∫–≤–∞–¥—Ä–∞—Ç), –∫–æ—Ç–æ—Ä—ã–π –∫—Ä—É—Ç–∏—Ç—Å—è –∏ –ø–∞–¥–∞–µ—Ç
                this.ctx.translate(e.x, e.y);
                if (e.rotation) this.ctx.rotate(e.rotation);
                this.ctx.fillStyle = e.color || '#fff';
                const s = e.size || 4;
                this.ctx.fillRect(-s / 2, -s / 2, s, s);
            } else if (e.type === 'muzzle_flash') {
                // –í—Å–ø—ã—à–∫–∞ –Ω–∞ –¥—É–ª–µ –±–∞—à–Ω–∏ - BAKED
                const img = Assets.get('effect_muzzle_flash');
                if (img) {
                    const r = e.radius || 12;
                    this.ctx.drawImage(img, e.x - r, e.y - r, r * 2, r * 2);
                } else {
                    const gradient = this.ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.radius || 12);
                    gradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                    gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(e.x, e.y, e.radius || 12, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            } else if (e.type === 'screen_flash') {
                // Flash –ø–æ –∫—Ä–∞—è–º —ç–∫—Ä–∞–Ω–∞
                const flashAlpha = progress * 0.4;
                const color = e.flashColor || 'rgba(255, 0, 0, ';
                const gradient = this.ctx.createRadialGradient(
                    this.canvasWidth / 2, this.canvasHeight / 2, 0,
                    this.canvasWidth / 2, this.canvasHeight / 2, Math.max(this.canvasWidth, this.canvasHeight) * 0.7
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(1, color + flashAlpha + ')');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
            } else if (e.type === 'scale_pop') {
                // Enemy death scale pop
                const scaleProgress = 1 - progress; // Reverse: 0 -> 1
                const scale = 1 + scaleProgress * 0.5; // Scale from 1.0 to 1.5

                if (e.enemySprite) {
                    const img = Assets.get(e.enemySprite);
                    if (img) {
                        this.ctx.save();
                        this.ctx.translate(e.x, e.y);
                        this.ctx.scale(scale, scale);

                        const size = 64;
                        const half = size / 2;
                        this.ctx.drawImage(img, -half, -half, size, size);

                        // Apply tint if available
                        if (e.enemyColor) {
                            this.ctx.globalCompositeOperation = 'source-atop';
                            this.ctx.fillStyle = e.enemyColor;
                            this.ctx.globalAlpha = 0.3 * progress;
                            this.ctx.fillRect(-half, -half, size, size);
                        }

                        this.ctx.restore();
                    }
                }
            }

            this.ctx.restore();
        });
    }
}
</file>

<file path="src/InputSystem.ts">
import { Game } from './Game';
import { GameScene } from './scenes/GameScene';
import { CONFIG } from './Config';
import { SoundManager } from './SoundManager';

export class InputSystem {
    private game: Game;
    private canvas: HTMLCanvasElement;

    public mouseX: number = 0;
    public mouseY: number = 0;
    public hoverCol: number = -1;
    public hoverRow: number = -1;

    public isMouseDown: boolean = false;
    private holdTimer: number = 0;
    private holdStartCol: number = -1;
    private holdStartRow: number = -1;
    private readonly HOLD_THRESHOLD: number = 0.2; // 0.2 seconds (was 12 frames)

    constructor(game: Game) {
        this.game = game;
        this.canvas = game.canvas;

        // Bind methods to context
        this.onPointerMove = this.onPointerMove.bind(this);
        this.onPointerDown = this.onPointerDown.bind(this);
        this.onPointerUp = this.onPointerUp.bind(this);

        this.initListeners();
    }

    private initListeners() {
        // Prevent default touch actions (scrolling) on canvas
        this.canvas.style.touchAction = 'none';

        this.canvas.addEventListener('pointermove', this.onPointerMove);
        this.canvas.addEventListener('pointerdown', this.onPointerDown);
        this.canvas.addEventListener('pointerleave', this.onPointerLeave.bind(this));
        window.addEventListener('pointerup', this.onPointerUp);
    }

    public destroy() {
        this.canvas.removeEventListener('pointermove', this.onPointerMove);
        this.canvas.removeEventListener('pointerdown', this.onPointerDown);
        this.canvas.removeEventListener('pointerleave', this.onPointerLeave.bind(this));
        window.removeEventListener('pointerup', this.onPointerUp);
    }

    private onPointerMove(e: PointerEvent) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;

        this.mouseX = (e.clientX - rect.left) * scaleX;
        this.mouseY = (e.clientY - rect.top) * scaleY;

        this.hoverCol = Math.floor(this.mouseX / CONFIG.TILE_SIZE);
        this.hoverRow = Math.floor(this.mouseY / CONFIG.TILE_SIZE);

        const scene = this.game.currentScene;
        if (scene instanceof GameScene) {
            if (scene.cardSys && scene.cardSys.dragCard) {
                scene.cardSys.updateDrag(e.clientX, e.clientY);
            }
        }
    }

    private onPointerLeave(_e: PointerEvent) {
        // Reset hover position when mouse leaves canvas to prevent stuck highlights
        this.hoverCol = -1;
        this.hoverRow = -1;
    }

    private onPointerDown(e: PointerEvent) {
        SoundManager.resume();
        if (e.isPrimary && e.button === 0) {
            this.isMouseDown = true;
            this.holdStartCol = this.hoverCol;
            this.holdStartRow = this.hoverRow;
            this.holdTimer = 0;

            // Allow dragging outside canvas to be tracked if needed, 
            // but for now relying on window.pointerup is fine.
            // this.canvas.setPointerCapture(e.pointerId);
        }
    }

    private onPointerUp(e: PointerEvent) {
        if (this.isMouseDown) {
            this.isMouseDown = false;
            // this.canvas.releasePointerCapture(e.pointerId);
        }

        const scene = this.game.currentScene;
        if (scene instanceof GameScene) {
            // –ï—Å–ª–∏ —Ç–∞—â–∏–ª–∏ –∫–∞—Ä—Ç—É
            if (scene.cardSys.dragCard) {
                scene.cardSys.endDrag(e);
                return;
            }

            // CRITICAL FIX: Only process grid clicks if click was on the canvas
            // Otherwise UI clicks (sell button, cards) will trigger grid click and deselect tower
            const clickTarget = e.target as HTMLElement;
            const clickedOnCanvas = clickTarget === this.canvas;

            if (!clickedOnCanvas) {
                // Click was on a UI element, don't process as grid click
                this.holdTimer = 0;
                return;
            }

            // –ï—Å–ª–∏ —ç—Ç–æ –±—ã–ª –∫–ª–∏–∫ (–Ω–µ —É–¥–µ—Ä–∂–∞–Ω–∏–µ)
            if (this.holdTimer < this.HOLD_THRESHOLD) {
                // –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–∞ GameScene
                scene.handleGridClick(this.hoverCol, this.hoverRow);
            }
        }

        this.holdTimer = 0;
    }

    public update(dt: number) {
        const scene = this.game.currentScene;

        if (this.isMouseDown && scene instanceof GameScene) {
            if (!scene.cardSys.dragCard) {
                if (
                    this.hoverCol === this.holdStartCol &&
                    this.hoverRow === this.holdStartRow &&
                    this.hoverCol !== -1
                ) {
                    this.holdTimer += dt;
                    if (this.holdTimer >= this.HOLD_THRESHOLD) {
                        // –í—ã–∑–æ–≤ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
                        scene.startBuildingTower(this.hoverCol, this.hoverRow);
                    }
                } else {
                    this.holdTimer = 0;
                }
            }
        }
    }
}
</file>

<file path="src/Projectile.ts">
import { ICardEffect } from './cards';
import { Assets } from './Assets';
import { RendererFactory } from './RendererFactory';

export interface IProjectileStats {
    dmg: number;
    speed: number;
    color: string;
    effects: ICardEffect[];
    pierce: number;
    critChance?: number;           // Critical hit chance (0-1)
    isCrit?: boolean;               // Is this projectile a crit
    explodeOnDeath?: boolean;       // Fire level 3 effect
    explosionDamage?: number;       // Damage from explosion
    explosionRadius?: number;       // Radius of explosion
    projectileType?: string;        // Visual type: standard, ice, fire, sniper, split
    towerLevel?: number;            // Tower's max card level (for trail effects)
}

export class Projectile {
    public x: number = 0;
    public y: number = 0;
    public vx: number = 0;
    public vy: number = 0;
    public radius: number = 4;
    public alive: boolean = false;

    public damage: number = 0;
    public life: number = 0;
    public color: string = '#fff';
    public effects: ICardEffect[] = [];
    public pierce: number = 0;
    public hitList: string[] = [];
    public isCrit: boolean = false;           // Is this a critical hit
    public explodeOnDeath: boolean = false;   // Should explode on enemy death
    public explosionDamage: number = 0;       // Damage from explosion
    public explosionRadius: number = 0;       // Radius of explosion
    public projectileType: string = 'standard'; // Visual type
    public towerLevel: number = 1;            // Tower's max card level (for trails)

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –ø—É—Å—Ç–æ–π!
    constructor() { }

    // –ú–µ—Ç–æ–¥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ –ø—É–ª–∞)
    public init(x: number, y: number, target: { x: number; y: number }, stats: IProjectileStats) {
        this.x = x;
        this.y = y;
        this.alive = true;
        this.damage = stats.dmg;
        this.color = stats.color;
        this.effects = stats.effects;
        this.pierce = stats.pierce || 0;
        this.hitList = [];
        this.projectileType = stats.projectileType || 'standard';
        this.towerLevel = stats.towerLevel || 1;

        // Handle critical hits
        const critChance = stats.critChance || 0;
        this.isCrit = Math.random() < critChance;
        if (this.isCrit) {
            this.damage *= 2; // Critical hits deal 2x damage
        }

        // Handle explosion on death effect (Fire level 3)
        const explodeEffect = stats.effects.find((e: any) => e.type === 'explodeOnDeath');
        if (explodeEffect) {
            this.explodeOnDeath = true;
            this.explosionDamage = stats.dmg * (explodeEffect.explosionDamagePercent || 0.5);
            this.explosionRadius = explodeEffect.explosionRadius || 40;
        } else {
            this.explodeOnDeath = false;
            this.explosionDamage = 0;
            this.explosionRadius = 0;
        }

        const angle = Math.atan2(target.y - y, target.x - x);
        this.vx = Math.cos(angle) * stats.speed;
        this.vy = Math.sin(angle) * stats.speed;

        this.life = 2.0; // 2 —Å–µ–∫—É–Ω–¥—ã –∂–∏–∑–Ω–∏
        // Adjust life for sniper (faster = less time needed)
        if (this.projectileType === 'sniper') this.life = 1.0;
    }

    public update(effects?: any, dt: number = 1) { // Type 'any' to avoid strict circular import issues if EffectSystem isn't imported, but normally it should be fine. Using any for safety here or import it.
        if (!this.alive) return;

        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;

        // --- TRAIL EFFECTS ---
        // Spawn trail particles approx every ~0.03s (30 fps)
        // Spawn trail particles approx every ~0.03s (30 fps)
        if (effects && Math.random() < dt * 30) {
            const type = this.projectileType || 'standard';

            // Fire Trail (Smoke/Embers)
            if (type === 'fire') {
                effects.add({
                    type: 'particle',
                    x: this.x + (Math.random() - 0.5) * 4,
                    y: this.y + (Math.random() - 0.5) * 4,
                    vx: -this.vx * 0.2 + (Math.random() - 0.5) * 60,
                    vy: -this.vy * 0.2 + (Math.random() - 0.5) * 60,
                    life: 0.25 + Math.random() * 0.15, // ~15-25 frames
                    radius: 2 + Math.random() * 2,
                    color: Math.random() > 0.5 ? 'rgba(255, 100, 0, 0.5)' : 'rgba(100, 100, 100, 0.3)'
                });
            }
            // Ice Trail (Snow/Sparkle)
            else if (type === 'ice') {
                effects.add({
                    type: 'particle',
                    x: this.x,
                    y: this.y,
                    vx: (Math.random() - 0.5) * 30, // 0.5 * 60
                    vy: (Math.random() - 0.5) * 30,
                    life: 0.35, // 20 frames
                    radius: 1.5,
                    color: '#e1f5fe'
                });
            }
            // Sniper Trail (handled by draw mostly, but particles are nice)
            else if (type === 'sniper') {
                // Sniper is fast, maybe no particles needed, leaving trail line in draw()
            }
            // Level 3 Trail (Glow)
            if (this.towerLevel >= 3) {
                effects.add({
                    type: 'particle',
                    x: this.x,
                    y: this.y,
                    vx: 0,
                    vy: 0,
                    life: 0.16, // 10 frames
                    radius: 2,
                    color: this.color
                });
            }
        }

        if (this.life <= 0 || this.x < -100 || this.x > 2000 || this.y < -100 || this.y > 2000) {
            this.alive = false;
        }
    }

    public draw(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawProjectile(ctx, this);
    }

    public reset() {
        this.alive = false;
        this.hitList = [];
    }
}
</file>

<file path="src/scenes/EditorScene.ts">
import { BaseScene } from '../BaseScene';
import { Game } from '../Game';
import { MapManager } from '../Map';
import { CONFIG } from '../Config';
import { IMapData, IMapObject } from '../MapData';
import { serializeMap, saveMapToStorage, getSavedMaps, deleteMapFromStorage } from '../Utils';
import { UIUtils } from '../UIUtils';
import { Pathfinder } from '../Pathfinder';
import { WaveEditor } from '../WaveEditor';
import { FogSystem } from '../FogSystem';
import { EditorToolbar, EditorMode } from '../editor/EditorToolbar';
import { WaypointManager } from '../editor/WaypointManager';
import { EditorHistory, EditorActions } from '../editor/EditorHistory';

export class EditorScene extends BaseScene {
    private game: Game;
    private map: MapManager;
    private fog: FogSystem;
    private toolbar!: EditorToolbar;
    private controlsContainer!: HTMLElement;
    private waypointMgr!: WaypointManager;
    private history!: EditorHistory;

    private mode: EditorMode = 'paint_road';

    // FEATURE: Saved maps panel
    private mapsPanel!: HTMLElement;
    private mapsPanelExpanded: boolean = false;
    private currentMapName: string = '';

    // Track previous mouse state for click detection (not hold)
    private prevMouseDown: boolean = false;
    private lastClickedTile: { col: number; row: number } | null = null;

    constructor(game: Game) {
        super();
        this.game = game;

        // –°–æ–∑–¥–∞–µ–º –ø—É—Å—Ç—É—é —Å–µ—Ç–∫—É
        const cols = Math.ceil(game.canvas.width / CONFIG.TILE_SIZE);
        const rows = Math.ceil(game.canvas.height / CONFIG.TILE_SIZE);
        const emptyTiles = Array(rows)
            .fill(0)
            .map(() => Array(cols).fill(0));

        const emptyData: IMapData = {
            width: cols,
            height: rows,
            tiles: emptyTiles,
            waypoints: [],
            objects: [],
        };

        this.map = new MapManager(emptyData);
        this.fog = new FogSystem(emptyData);
        this.waypointMgr = new WaypointManager();
        this.history = new EditorHistory();
        this.createUI();
        this.createMapsPanel();
        this.setupHotkeys();
    }

    public onEnter() {
        this.toolbar.show();
        this.controlsContainer.style.display = 'flex';
        this.mapsPanel.style.display = 'block';
        const uiLayer = document.getElementById('ui-layer');
        if (uiLayer) uiLayer.style.display = 'none';

        // Initial fog render
        this.fog.update(0);
    }

    public onExit() {
        this.toolbar.hide();
        this.controlsContainer.style.display = 'none';
        this.mapsPanel.style.display = 'none';
        if (this.toolbar) this.toolbar.destroy();
        if (this.controlsContainer.parentNode) this.controlsContainer.parentNode.removeChild(this.controlsContainer);
        if (this.mapsPanel.parentNode) this.mapsPanel.parentNode.removeChild(this.mapsPanel);
    }

    public update(dt: number) {
        // Don't update fog animation in editor - only static rendering
        const input = this.game.input;

        // Handle mouse input - works on hold
        if (input.isMouseDown && input.hoverCol >= 0 && input.hoverRow >= 0) {
            // Check if clicked on a different tile
            const isDifferentTile =
                !this.lastClickedTile ||
                this.lastClickedTile.col !== input.hoverCol ||
                this.lastClickedTile.row !== input.hoverRow;

            if (isDifferentTile) {
                this.handleInput(input.hoverCol, input.hoverRow);
                this.lastClickedTile = { col: input.hoverCol, row: input.hoverRow };

                // Trigger fog re-render after data change (static, no animation)
                this.fog.update(0);
            }
        }

        // Update previous state
        this.prevMouseDown = input.isMouseDown;

        // Reset last clicked tile when mouse is released
        if (!input.isMouseDown) {
            this.lastClickedTile = null;
        }
    }

    private handleInput(col: number, row: number) {
        if (col >= this.map.cols || row >= this.map.rows) return;

        const oldTileType = this.map.grid[row][col].type;
        const oldFogDensity = this.fog.getFog(col, row);

        if (this.mode === 'paint_road') {
            console.log('[EditorScene] paint_road mode active, tile type:', oldTileType, '‚Üí 1');
            if (oldTileType !== 1) {
                this.history.push(EditorActions.createTileAction(this.map.grid, col, row, oldTileType, 1));
                this.map.grid[row][col].type = 1;
                this.map.grid[row][col].decor = null;
                console.log('[EditorScene] Road painted at', col, row);
            } else {
                console.log('[EditorScene] Tile already road, skipping');
            }
        } else if (this.mode === 'paint_grass') {
            if (oldTileType !== 0) {
                this.history.push(EditorActions.createTileAction(this.map.grid, col, row, oldTileType, 0));
                this.map.grid[row][col].type = 0;
            }
        } else if (this.mode === 'eraser') {
            // FEATURE: Eraser - reset to grass, remove fog, and remove objects
            const hasObject = this.map.objects.find(obj => {
                const size = obj.size || 1;
                return col >= obj.x && col < obj.x + size &&
                    row >= obj.y && row < obj.y + size;
            });

            if (oldTileType !== 0 || oldFogDensity !== 0 || hasObject) {
                // –°–±—Ä–æ—Å —Ç–∞–π–ª–∞ –≤ —Ç—Ä–∞–≤—É
                if (oldTileType !== 0) {
                    this.history.push(EditorActions.createTileAction(this.map.grid, col, row, oldTileType, 0));
                    this.map.grid[row][col].type = 0;
                    this.map.grid[row][col].decor = null;
                }
                // –£–¥–∞–ª–µ–Ω–∏–µ —Ç—É–º–∞–Ω–∞
                if (oldFogDensity !== 0) {
                    this.history.push(EditorActions.createFogAction(this.fog, col, row, oldFogDensity, 0));
                    this.fog.setFog(col, row, 0);
                }
                // –£–¥–∞–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ (–≤—Å–µ –æ–±—ä–µ–∫—Ç—ã, –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—é—â–∏–µ —ç—Ç–æ—Ç —Ç–∞–π–ª)
                if (hasObject) {
                    this.map.objects = this.map.objects.filter(obj => {
                        const size = obj.size || 1;
                        const overlaps = col >= obj.x && col < obj.x + size &&
                            row >= obj.y && row < obj.y + size;
                        return !overlaps;
                    });
                }
            }
        } else if (this.mode === 'set_start') {
            const oldState = {
                start: this.waypointMgr.getStart(),
                end: this.waypointMgr.getEnd(),
                waypoints: this.waypointMgr.getWaypoints()
            };
            this.history.push(EditorActions.createWaypointAction(this.waypointMgr, 'setStart', { x: col, y: row }, oldState));
            this.waypointMgr.setStart({ x: col, y: row });
            this.map.grid[row][col].type = 1;
        } else if (this.mode === 'set_end') {
            const oldState = {
                start: this.waypointMgr.getStart(),
                end: this.waypointMgr.getEnd(),
                waypoints: this.waypointMgr.getWaypoints()
            };
            this.history.push(EditorActions.createWaypointAction(this.waypointMgr, 'setEnd', { x: col, y: row }, oldState));
            this.waypointMgr.setEnd({ x: col, y: row });
            this.map.grid[row][col].type = 1;
        } else if (this.mode === 'place_waypoint') {
            if (this.waypointMgr.canAddWaypoint()) {
                const oldState = {
                    start: this.waypointMgr.getStart(),
                    end: this.waypointMgr.getEnd(),
                    waypoints: this.waypointMgr.getWaypoints()
                };
                this.history.push(EditorActions.createWaypointAction(this.waypointMgr, 'addWaypoint', { x: col, y: row }, oldState));
                this.waypointMgr.addWaypoint({ x: col, y: row });
            }
        } else if (this.mode === 'paint_fog') {
            // Cycle fog density: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 0
            this.fog.cycleFogDensity(col, row);
            const newFogDensity = this.fog.getFog(col, row);
            if (oldFogDensity !== newFogDensity) {
                this.history.push(EditorActions.createFogAction(this.fog, col, row, oldFogDensity, newFogDensity));
            }
        } else if (this.mode === 'place_stone') {
            this.placeObject(col, row, 'stone', 1);
        } else if (this.mode === 'place_rock') {
            // –°–∫–∞–ª—ã - —Ä–∞–Ω–¥–æ–º–Ω—ã–π —Ä–∞–∑–º–µ—Ä 2-3 —Ç–∞–π–ª–∞
            const size = Math.random() > 0.5 ? 3 : 2;
            this.placeObject(col, row, 'rock', size);
        } else if (this.mode === 'place_tree') {
            this.placeObject(col, row, 'tree', 1);
        } else if (this.mode === 'place_wheat') {
            this.placeObject(col, row, 'wheat', 1);
        } else if (this.mode === 'place_flowers') {
            this.placeObject(col, row, 'flowers', 1);
        }
    }

    /**
     * Place an object on the map
     */
    private placeObject(col: number, row: number, type: string, size: number): void {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
        if (col + size > this.map.cols || row + size > this.map.rows) {
            return; // –í—ã—Ö–æ–¥–∏—Ç –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã
        }

        // –£–¥–∞–ª–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –æ–±—ä–µ–∫—Ç—ã –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏
        this.map.objects = this.map.objects.filter(obj => {
            const objSize = obj.size || 1;
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
            const overlaps = !(col + size <= obj.x || col >= obj.x + objSize ||
                row + size <= obj.y || row >= obj.y + objSize);
            return !overlaps;
        });

        // –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç
        const newObj = {
            type,
            x: col,
            y: row,
            properties: {},
            size: size > 1 ? size : undefined
        };
        this.map.objects.push(newObj);
    }

    public draw(ctx: CanvasRenderingContext2D) {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);

        for (let y = 0; y < this.map.rows; y++) {
            for (let x = 0; x < this.map.cols; x++) {
                this.map.tiles[y][x] = this.map.grid[y][x].type;
            }
        }

        // CRITICAL FIX: Regenerate prerendered cache after tile changes
        // The Map.draw() uses a cached canvas that must be updated when tiles change
        this.map.prerender();

        // We do NOT overwrite map.waypoints here every frame anymore.
        // It prevents saving them correctly.
        this.map.draw(ctx);
        this.fog.draw(ctx);

        // Draw waypoints with WaypointManager
        this.waypointMgr.draw(ctx);


        const input = this.game.input;
        if (input.hoverCol >= 0) {
            const x = input.hoverCol * CONFIG.TILE_SIZE;
            const y = input.hoverRow * CONFIG.TILE_SIZE;

            ctx.strokeStyle = 'yellow';
            if (this.mode === 'paint_grass') ctx.strokeStyle = 'red';
            if (this.mode === 'eraser') ctx.strokeStyle = '#ff6600';
            if (this.mode === 'set_start') ctx.strokeStyle = 'cyan';
            if (this.mode === 'set_end') ctx.strokeStyle = 'magenta';
            if (this.mode === 'place_waypoint') ctx.strokeStyle = '#00ff00';

            if (this.mode === 'paint_fog') {
                // Show current fog density with color intensity
                const density = this.fog.getFog(input.hoverCol, input.hoverRow);
                const intensity = density * 40 + 80; // 80-280 range
                ctx.strokeStyle = `rgb(${intensity}, ${intensity + 30}, ${intensity + 50})`;

                // Draw density indicator
                ctx.fillStyle = `rgba(200, 215, 230, ${density * 0.15})`;
                ctx.fillRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);

                // Draw density number
                if (density > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(density.toString(), x + CONFIG.TILE_SIZE / 2, y + CONFIG.TILE_SIZE / 2);
                }
            }

            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
        }
    }

    private openWaveConfig() {
        // Use WaypointManager's full path
        if (this.waypointMgr.isValid()) {
            this.map.waypoints = this.waypointMgr.getFullPath();
        } else {
            alert('Set Start and End points first!');
            return;
        }

        const currentWaves = (this.map as any).waves || [];

        new WaveEditor(
            currentWaves,
            (waves) => {
                this.saveMap(waves);
            },
            () => {
                // Cancelled
            },
        );
    }

    private saveMap(waves: any[]) {
        // [FIX] Ensure map waves are updated before serialization
        (this.map as any).waves = waves;

        const data = serializeMap(this.map);
        data.fogData = this.fog.getFogData();
        data.manualPath = this.waypointMgr.isValid(); // Using waypoint manager

        const name = prompt('Enter map name:', this.currentMapName || 'MyMap');
        if (!name) return;

        if (saveMapToStorage(name, data)) {
            this.currentMapName = name; // Update current name
            alert(`Map "${name}" saved successfully!`);
            this.refreshMapsPanel(); // Refresh UI
        } else {
            alert('Failed to save map (Storage full?)');
        }
    }

    private createUI() {
        // Create new modular toolbar
        this.toolbar = new EditorToolbar((mode) => {
            console.log('[EditorScene] Mode changed to:', mode);
            this.mode = mode;
        });

        // Create controls container for additional buttons (WAVES, MENU, Clear Path)
        this.controlsContainer = UIUtils.createContainer({
            position: 'absolute',
            top: '20px',
            right: '20px',
            display: 'flex',
            flexDirection: 'column',
            gap: '8px',
            padding: '10px',
            background: 'rgba(0,0,0,0.85)',
            borderRadius: '8px',
            zIndex: '1000'
        });

        const addBtn = (text: string, onClick: () => void, color: string = '#444') => {
            UIUtils.createButton(this.controlsContainer, text, onClick, {
                background: color,
                border: '1px solid #666',
                padding: '10px 16px',
                borderRadius: '6px',
                fontSize: '14px',
                fontWeight: 'bold',
                width: '100%'
            });
        };

        addBtn('üóëÔ∏è Clear Path', () => {
            this.waypointMgr.clearAll();
        }, '#e91e63');

        addBtn('‚öôÔ∏è WAVES & SAVE', () => this.openWaveConfig(), '#ff9800');
        addBtn('üö™ MENU', () => this.game.toMenu(), '#d32f2f');

        document.body.appendChild(this.controlsContainer);
    }

    // FEATURE: Create saved maps panel
    private createMapsPanel() {
        this.mapsPanel = UIUtils.createContainer({
            position: 'absolute',
            top: '20px',
            left: '20px',
            background: 'rgba(0, 0, 0, 0.9)',
            borderRadius: '8px',
            padding: '10px',
            maxWidth: '300px',
            maxHeight: '80vh',
            overflowY: 'auto',
            display: 'none',
            zIndex: '2000'
        });

        const header = document.createElement('div');
        Object.assign(header.style, {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: '10px',
            cursor: 'pointer',
            color: '#fff',
            fontWeight: 'bold',
        });

        header.innerHTML = `
            <span>üìÅ SAVED MAPS</span>
            <span style="font-size: 20px;">${this.mapsPanelExpanded ? '‚ñº' : '‚ñ∂'}</span>
        `;

        header.onclick = () => {
            this.mapsPanelExpanded = !this.mapsPanelExpanded;
            this.refreshMapsPanel();
        };

        this.mapsPanel.appendChild(header);
        document.body.appendChild(this.mapsPanel);
        this.refreshMapsPanel();
    }

    private refreshMapsPanel() {
        console.log('Refreshing Maps Panel. Raw Storage:', localStorage.getItem('NEWTOWER_MAPS'));
        const maps = getSavedMaps();
        console.log('Parsed Maps:', maps);
        // Clear current content except header
        while (this.mapsPanel.children.length > 1) {
            this.mapsPanel.removeChild(this.mapsPanel.lastChild!);
        }

        // Update toggle icon
        const header = this.mapsPanel.children[0] as HTMLElement;
        header.innerHTML = `
            <span>üìÅ SAVED MAPS</span>
            <span style="font-size: 20px;">${this.mapsPanelExpanded ? '‚ñº' : '‚ñ∂'}</span>
        `;

        if (!this.mapsPanelExpanded) return;


        const mapNames = Object.keys(maps);

        if (mapNames.length === 0) {
            const empty = document.createElement('div');
            empty.style.color = '#888';
            empty.style.padding = '10px';
            empty.innerText = 'No saved maps';
            this.mapsPanel.appendChild(empty);
            return;
        }

        mapNames.forEach((name) => {
            const item = document.createElement('div');
            Object.assign(item.style, {
                background: '#222',
                padding: '10px',
                marginBottom: '5px',
                borderRadius: '4px',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
            });

            const nameSpan = document.createElement('span');
            nameSpan.style.color = '#fff';
            nameSpan.style.flex = '1';
            nameSpan.innerText = name;

            const btnContainer = document.createElement('div');
            btnContainer.style.display = 'flex';
            btnContainer.style.gap = '5px';

            const loadBtn = document.createElement('button');
            loadBtn.innerText = 'üìÇ Load';
            Object.assign(loadBtn.style, {
                background: '#4caf50',
                color: '#fff',
                border: 'none',
                padding: '5px 10px',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '12px',
            });
            loadBtn.onclick = () => this.loadMap(name, maps[name]);

            const delBtn = document.createElement('button');
            delBtn.innerText = 'üóëÔ∏è';
            Object.assign(delBtn.style, {
                background: '#f44336',
                color: '#fff',
                border: 'none',
                padding: '5px 10px',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '12px',
            });
            delBtn.onclick = () => this.deleteMap(name);

            btnContainer.appendChild(loadBtn);
            btnContainer.appendChild(delBtn);

            item.appendChild(nameSpan);
            item.appendChild(btnContainer);
            this.mapsPanel.appendChild(item);
        });
    }

    private loadMap(name: string, data: any) {
        if (!confirm(`Load map "${name}"? Current work will be lost.`)) return;

        // Load map data into editor
        this.currentMapName = name; // [FIX] Track loaded map name
        this.map = new MapManager(data);
        this.fog = new FogSystem(data);

        // Load waypoints into WaypointManager
        this.waypointMgr.clearAll();
        if (data.waypoints && data.waypoints.length > 0) {
            // First point is always Start
            this.waypointMgr.setStart(data.waypoints[0]);

            // Last point is always End (if more than 1)
            if (data.waypoints.length > 1) {
                this.waypointMgr.setEnd(data.waypoints[data.waypoints.length - 1]);
            }

            // Middle points are waypoints
            for (let i = 1; i < data.waypoints.length - 1; i++) {
                this.waypointMgr.addWaypoint(data.waypoints[i]);
            }
        }

        // Render loaded fog
        this.fog.update(0);
    }

    private deleteMap(name: string) {
        if (!confirm(`Delete map "${name}"? This cannot be undone.`)) return;

        deleteMapFromStorage(name);
        this.refreshMapsPanel();
    }

    private setupHotkeys() {
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input fields
            if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
                return;
            }

            // Ctrl+Z - Undo
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                if (this.history.undo()) {
                    this.fog.update(0); // Re-render fog after undo
                }
                return;
            }

            // Ctrl+Shift+Z - Redo
            if (e.ctrlKey && e.shiftKey && e.key === 'Z') {
                e.preventDefault();
                if (this.history.redo()) {
                    this.fog.update(0); // Re-render fog after redo
                }
                return;
            }

            // Ctrl+S - Save
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                this.openWaveConfig();
                return;
            }

            // E - Eraser mode
            if (e.key === 'e' || e.key === 'E') {
                this.mode = 'eraser';
                return;
            }

            // 1-3 - Category selection
            if (e.key >= '1' && e.key <= '3') {
                const categoryIndex = parseInt(e.key) - 1;
                this.toolbar.selectCategory(categoryIndex);
                return;
            }
        });
    }

}
</file>

<file path="src/WeaponSystem.ts">
import { Tower } from './Tower';
import { Enemy } from './Enemy';
import { Projectile } from './Projectile';
import { CONFIG } from './Config';
import { EffectSystem } from './EffectSystem';
import { SoundManager, SoundPriority } from './SoundManager';
import { ProjectileSystem } from './systems/ProjectileSystem';
import { getTurretRenderer } from './renderers/turrets';

export class WeaponSystem {

    public update(towers: Tower[], enemies: Enemy[], projectileSystem: ProjectileSystem, dt: number, effects?: EffectSystem) {
        towers.forEach(tower => {
            this.processTower(tower, enemies, projectileSystem, dt, effects);
        });
    }

    private processTower(tower: Tower, enemies: Enemy[], projectileSystem: ProjectileSystem, dt: number, effects?: EffectSystem) {
        if (tower.isBuilding) return;
        if (tower.cards.length === 0) return;

        // Handle overheat cooldown
        if (tower.isOverheated) {
            if (tower.overheatCooldown > 0) {
                tower.overheatCooldown -= dt;
            } else {
                tower.isOverheated = false;
                tower.spinupTime = 0; // Reset spinup after overheat
            }
            return; // Can't shoot while overheated
        }

        if (tower.cooldown > 0) {
            tower.cooldown -= dt;
        }

        // Decrement recoil (seconds)
        if (tower.recoilTimer > 0) {
            tower.recoilTimer -= dt;
            if (tower.recoilTimer < 0) tower.recoilTimer = 0;
        }

        // Decay barrel recoil (spring physics)
        if (tower.barrelRecoil < 0) {
            tower.barrelRecoil += dt * 20; // Recovery speed
            if (tower.barrelRecoil > 0) tower.barrelRecoil = 0;
        }

        const stats = tower.getStats();

        // 1. Find Target
        const target = this.findTarget(tower, enemies, stats.range);

        if (target) {
            // === SPINUP MECHANIC ===
            // Increment spinup progress whenever we have a target (and not overheated yet)
            const spinupEffect = stats.effects.find(e => e.type === 'spinup');
            if (spinupEffect && !tower.isOverheated) {
                // PHYSICS-BASED HEAT GENERATION
                // Heat generation depends on how fast the gun is firing.
                // Standard Minigun (LVL1) has ~2.65x multiplier.
                // If we add Sniper (0.5x), heat should generate slower.
                // If we add Rapid Fire (2.0x), heat should generate faster.
                // We normalize against the base Minigun speed (~2.65) to keep the 5s duration standard.
                const MINIGUN_BASE_SPEED_MULT = 2.65;
                const speedFactor = (stats.attackSpeedMultiplier || 1.0) / MINIGUN_BASE_SPEED_MULT;

                // If using Sniper card, speedFactor will be < 1, so heat builds slower (takes longer to overheat)
                // If using Rapid card, speedFactor will be > 1, so heat builds faster
                tower.spinupTime += dt * speedFactor;

                const maxSpinupSeconds = spinupEffect.maxSpinupSeconds || 5;
                tower.maxHeat = maxSpinupSeconds; // Sync for visual bar

                // Check if tower has Ice card (for overheat extension)
                const hasIceCard = tower.cards.some(c => c.type.id === 'ice');
                const overheatExtension = hasIceCard ? (spinupEffect.overheatExtensionWithIce || 0) : 0;
                const overheatThreshold = maxSpinupSeconds + overheatExtension;

                if (tower.spinupTime >= overheatThreshold) {
                    tower.isOverheated = true;
                    tower.overheatCooldown = spinupEffect.overheatDuration || 1.5;
                    tower.totalOverheatDuration = tower.overheatCooldown; // Store for UI
                    tower.spinupTime = 0;
                }
            }

            // 2. Rotate Tower Smoothly
            const dx = target.x - tower.x;
            const dy = target.y - tower.y;
            const desiredAngle = Math.atan2(dy, dx);

            // Apply semi-smooth rotation
            tower.angle = this.rotateTowards(tower.angle, desiredAngle, CONFIG.TOWER.TURN_SPEED * dt);

            // 3. Fire only if aimed close enough
            const angleDiff = Math.abs(this.getShortestAngleDifference(tower.angle, desiredAngle));

            if (tower.cooldown <= 0 && angleDiff < CONFIG.TOWER.AIM_TOLERANCE) {
                this.fire(tower, target, stats, projectileSystem, effects);
                tower.cooldown = stats.cd;
            }
        } else {
            // === SPINUP RESET / COOLING ===
            // No target - Start cooling down
            if (tower.spinupTime > 0) {
                // Cool down rate: 
                // User wants 1.5 seconds to cool down from max heat
                // Rate = MaxHeat / 1.5
                const coolRate = (tower.maxHeat / 1.5) * dt;
                tower.spinupTime = Math.max(0, tower.spinupTime - coolRate);
            }
            if (tower.isOverheated) {
                // If we lost target but are overheated, we still cool down the overheat timer?
                // The overheat timer is handled at the top of processTower logic.
                // We don't need to force clear it here, let it run its course.
            }
        }
    }

    private findTarget(tower: Tower, enemies: Enemy[], range: number): Enemy | null {
        // Filter enemies within range
        const inRange = enemies.filter(e => {
            if (!e.isAlive()) return false;
            const dist = Math.hypot(e.x - tower.x, e.y - tower.y);
            return dist <= range;
        });

        if (inRange.length === 0) return null;

        // PRIORITY CHECK: Filter for highest priority enemies (like Magma Statues)
        // If there are enemies with priority > 0, we IGNORE all others and only target them.
        let maxPriority = 0;
        for (const e of inRange) {
            if (e.threatPriority > maxPriority) maxPriority = e.threatPriority;
        }

        // If high priority enemies exist, reduce the pool to ONLY them
        // This ensures the tower is "taunted" by the decoy
        const targetPool = maxPriority > 0
            ? inRange.filter(e => e.threatPriority === maxPriority)
            : inRange;

        // Apply targeting strategy based on tower's mode
        switch (tower.targetingMode) {
            case 'first':
                // Enemy closest to end of path (highest pathIndex)
                return targetPool.reduce((a, b) => a.pathIndex > b.pathIndex ? a : b);

            case 'closest':
                // Enemy nearest to tower
                return targetPool.reduce((a, b) => {
                    const distA = Math.hypot(a.x - tower.x, a.y - tower.y);
                    const distB = Math.hypot(b.x - tower.x, b.y - tower.y);
                    return distA < distB ? a : b;
                });

            case 'strongest':
                // Enemy with highest max health
                return targetPool.reduce((a, b) => a.maxHealth > b.maxHealth ? a : b);

            case 'weakest':
                // Enemy with lowest current health
                return targetPool.reduce((a, b) => a.currentHealth < b.currentHealth ? a : b);

            case 'last':
                // Enemy furthest from end (lowest pathIndex)
                return targetPool.reduce((a, b) => a.pathIndex < b.pathIndex ? a : b);

            default:
                // Default to first available
                return targetPool[0];
        }
    }

    private rotateTowards(current: number, target: number, maxStep: number): number {
        const diff = this.getShortestAngleDifference(current, target);

        if (Math.abs(diff) <= maxStep) {
            return target;
        }

        return current + Math.sign(diff) * maxStep;
    }

    /**
     * Returns the shortest difference between two angles in radians (-PI to PI)
     */
    private getShortestAngleDifference(current: number, target: number): number {
        let diff = target - current;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        return diff;
    }

    private fire(tower: Tower, target: { x: number, y: number }, stats: any, projectileSystem: ProjectileSystem, effects?: EffectSystem) {
        // Muzzle Math
        // NEW: Get dynamic muzzle length from renderer
        const renderer = getTurretRenderer(tower.cards[0]?.type.id || 'default');
        const barrelLen = renderer.getMuzzleOffset ? renderer.getMuzzleOffset() : CONFIG.TOWER.BARREL_LENGTH;

        const muzzleX = tower.x + Math.cos(tower.angle) * barrelLen;
        const muzzleY = tower.y + Math.sin(tower.angle) * barrelLen;

        // === MUZZLE FLASH EFFECT ===
        if (effects) {
            effects.add({
                type: 'muzzle_flash',
                x: muzzleX,
                y: muzzleY,
                radius: 15,
                life: 0.08,
            });

            // === SHELL CASING EFFECT ===
            // Eject shell perpendicular to fire angle
            const ejectAngle = tower.angle + Math.PI / 2 + (Math.random() - 0.5) * 0.5;
            const ejectSpeed = (2 + Math.random() * 2) * 60; // Convert to px/sec
            effects.add({
                type: 'debris',
                x: tower.x, // Eject from tower center/breech
                y: tower.y,
                vx: Math.cos(ejectAngle) * ejectSpeed,
                vy: Math.sin(ejectAngle) * ejectSpeed,
                gravity: 720, // 12 * 60 (Acceleration: px/sec^2)
                rotation: Math.random() * Math.PI,
                vRot: (Math.random() - 0.5) * 30, // 0.5 * 60 (rad/sec)
                life: 1.0, // 60 frames -> 1.0 second
                color: '#ffd700', // Gold shell
                size: 3,
            });
        }

        // Multishot logic
        if (stats.projCount > 1) {
            const startAngle = tower.angle - (stats.spread * (stats.projCount - 1)) / 2;

            for (let i = 0; i < stats.projCount; i++) {
                const currentAngle = startAngle + i * stats.spread;

                // For 'shotgun' spread, we might want the projectile to originate from the same muzzle point
                // but travel in different directions.
                // Or we can slightly offset the origin if it's a wide bank of guns.
                // Let's keep origin same, vary velocity vector implies target varies OR we just calculate velocity manually in Projectile.
                // Currently Projectile.init calculates angle to target. 
                // We need to override this or create a virtual target for the spread shots.

                // Calculate a virtual target point in the direction of fire
                const range = 500; // Arbitrary far distance
                const vx = Math.cos(currentAngle) * range;
                const vy = Math.sin(currentAngle) * range;
                const virtualTarget = { x: muzzleX + vx, y: muzzleY + vy };

                const finalDamage = Math.max(1, stats.damage * (stats.damageMultiplier || 1));
                projectileSystem.spawn(muzzleX, muzzleY, virtualTarget, { ...stats, damage: finalDamage });
            }
        } else {
            // Single shot
            const finalDamage = Math.max(1, stats.damage * (stats.damageMultiplier || 1));
            const p = projectileSystem.spawn(muzzleX, muzzleY, target, { ...stats, damage: finalDamage });

            // Trigger recoil for critical hits
            if (p.isCrit) {
                // Apply barrel recoil (visual only)
                tower.barrelRecoil = -6;

                // Keep body recoil for critical hits (screen shake effect optional)
                tower.recoilTimer = 0.2;
                tower.recoilIntensity = 3;
            } else {
                // Standard recoil
                tower.barrelRecoil = -4;
            }
        }

        // Minigun vibration (constant while firing)
        if (stats.projectileType === 'minigun') {
            tower.recoilTimer = 0.1; // 0.1s duration (was 5 frames)
            // tower.recoilIntensity = 0.5; // OLD: Caused constant shaking
            // Only purely visual recoil for the tower itself, do not trigger screen shake here if possible
            // But if recoilFrames is used for screen shake, we need to be careful.
            // GameScene uses gameState.shakeTimer for screen shake. 
            // Tower.recoilFrames usually just shakes the tower sprite.
            // Let's verify Tower.ts usage of recoil.
        }

        // Play Sound
        const isSniper = stats.projectileType === 'sniper';
        const soundKey = isSniper ? 'shoot_sniper' : 'shoot_basic';
        const priority = isSniper ? SoundPriority.HIGH : SoundPriority.LOW;

        SoundManager.play(soundKey, priority);
    }
}
</file>

<file path="src/CardSystem.ts">
import { IGameScene } from './scenes/IGameScene';
import { CONFIG } from './Config';
import { generateUUID } from './Utils';

export interface ICard {
    id: string;
    type: any;
    level: number;
    isDragging: boolean;
}

export class CardSystem {
    private scene: IGameScene;
    public hand: ICard[] = [];

    // Dragging state
    public dragCard: ICard | null = null;
    private ghostEl: HTMLElement;

    private handContainer: HTMLElement;

    constructor(scene: IGameScene, startingCards: string[] = ['FIRE', 'ICE', 'SNIPER']) {
        this.scene = scene;
        this.handContainer = document.getElementById('hand')!;

        this.ghostEl = document.getElementById('drag-ghost')!;
        this.ghostEl.style.pointerEvents = 'none';

        // Add starting cards
        startingCards.forEach(cardKey => this.addCard(cardKey, 1));
    }

    public startDrag(card: ICard, e: PointerEvent) {
        if (this.scene.forge.isForging) return;
        this.dragCard = card;
        card.isDragging = true;

        this.ghostEl.style.display = 'block';
        this.ghostEl.innerHTML = `<div style="font-size:32px;">${card.type.icon}</div>`;
        this.updateDrag(e.clientX, e.clientY);

        this.render();
    }

    public updateDrag(x: number, y: number) {
        if (!this.dragCard) return;
        this.ghostEl.style.left = `${x}px`;
        this.ghostEl.style.top = `${y}px`;
    }

    public endDrag(e: PointerEvent) {
        if (!this.dragCard) return;

        // Check forge slots FIRST via ForgeSystem
        const droppedInForge = this.scene.forge.tryDropCard(e.clientX, e.clientY, this.dragCard);

        if (!droppedInForge) {
            // Drop on Canvas
            const rect = this.scene.game.canvas.getBoundingClientRect();
            const inCanvas =
                e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;

            if (inCanvas) {
                const x = (e.clientX - rect.left) * (this.scene.game.canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (this.scene.game.canvas.height / rect.height);
                this.scene.events.emit('CARD_DROPPED', { card: this.dragCard, x, y });
            }
        }

        this.dragCard.isDragging = false;
        this.dragCard = null;
        this.ghostEl.style.display = 'none';
        this.render();
    }

    public addCard(typeKey: string, level: number = 1) {
        if (this.hand.length >= CONFIG.PLAYER.HAND_LIMIT) {
            this.scene.showFloatingText('Hand Full!', window.innerWidth / 2, window.innerHeight - 100, 'red');
            return;
        }

        const type = CONFIG.CARD_TYPES[typeKey];
        if (!type) {
            console.warn(`Unknown card type: ${typeKey}`);
            return;
        }

        const card: ICard = {
            id: generateUUID(),
            type: type,
            level: level,
            isDragging: false,
        };
        this.hand.push(card);
        this.render();
        this.scene.ui.update();
    }

    public addRandomCardToHand() {
        const keys = Object.keys(CONFIG.CARD_TYPES);
        const randomKey = keys[Math.floor(Math.random() * keys.length)];
        this.addCard(randomKey, 1);
    }

    public removeCardFromHand(card: ICard) {
        const index = this.hand.indexOf(card);
        if (index !== -1) {
            this.hand.splice(index, 1);
            this.render();
            this.scene.ui.update();
        }
    }

    public render() {
        this.handContainer.innerHTML = '';
        this.hand.forEach((card) => {
            const el = CardSystem.createCardElement(card);
            el.onpointerdown = (e: any) => this.startDrag(card, e);
            if (card.isDragging) el.classList.add('dragging-placeholder');
            this.handContainer.appendChild(el);
        });
    }

    public static createCardElement(card: ICard): HTMLElement {
        const el = document.createElement('div');
        el.className = `card type-${card.type.id} level-${card.level}`;

        // Star rating
        let stars = '‚òÖ'.repeat(card.level);

        // Stats HTML
        let statsHTML = this.getCardStatsHTML(card);

        el.innerHTML = `
            <div class="card-level">${stars}</div>
            <div class="card-icon">${card.type.icon}</div>
            <div class="card-stats">${statsHTML}</div>
        `;
        return el;
    }

    public static getCardStatsHTML(card: ICard): string {
        const type = card.type.id;
        const level = card.level;

        switch (type) {
            case 'fire':
                if (level === 1) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +15</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 50</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +30</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 85</div>`;
                } else {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +30</div><div class="card-stat-line">–í–∑—Ä—ã–≤ + üíÄ</div>`;
                }

            case 'ice':
                if (level === 1) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +3</div><div class="card-stat-line">‚ùÑÔ∏è 30%</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +6</div><div class="card-stat-line">‚ùÑÔ∏è 45%</div>`;
                } else {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +9</div><div class="card-stat-line">‚ùÑÔ∏è 75% + ‚õìÔ∏è</div>`;
                }

            case 'sniper':
                if (level === 1) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +14</div><div class="card-stat-line">üéØ +80</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +24</div><div class="card-stat-line">üéØ +160</div>`;
                } else {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +46</div><div class="card-stat-line">üéØ +240 üí´</div>`;
                }

            case 'multi':
                if (level === 1) {
                    return `<div class="card-stat-primary">2 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.8x —É—Ä–æ–Ω</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">3 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.6x —É—Ä–æ–Ω</div>`;
                } else {
                    return `<div class="card-stat-primary">4 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.45x —É—Ä–æ–Ω</div>`;
                }

            case 'minigun':
                if (level === 1) {
                    return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+3 —É—Ä–æ–Ω/—Å</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+—É—Ä–æ–Ω +–∫—Ä–∏—Ç</div>`;
                } else {
                    return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">–¥–æ +30 —É—Ä–æ–Ω</div>`;
                }

            default:
                return `<div class="card-stat-line">${card.type.desc}</div>`;
        }
    }
}
</file>

<file path="src/Map.ts">
import { CONFIG } from './Config';
import { IMapData, Cell, IMapObject } from './MapData';
import { Assets } from './Assets';
import { Pathfinder } from './Pathfinder';
import { LightingSystem } from './systems/LightingSystem';
import { ObjectRenderer, ObjectType } from './ObjectRenderer';

export class MapManager {
    public cols!: number;
    public rows!: number;

    public grid: Cell[][] = [];

    public tiles: number[][] = [];
    public waypoints: { x: number; y: number }[] = [];
    public waves: any[] = [];
    public lighting?: LightingSystem;
    public objects: IMapObject[] = []; // Objects for decoration and blocking

    private cacheCanvas: HTMLCanvasElement;

    constructor(data: IMapData) {
        this.loadMap(data);
    }

    public loadMap(data: IMapData) {
        this.cols = data.width;
        this.rows = data.height;
        this.tiles = data.tiles;
        this.waypoints = data.waypoints;
        this.waves = data.waves || [];
        this.objects = data.objects || []; // Load objects

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–±—ä–µ–∫—Ç–∞ grid –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Ä–µ–¥–∞–∫—Ç–æ—Ä–æ–º
        this.grid = [];
        for (let y = 0; y < this.rows; y++) {
            const row: Cell[] = [];
            for (let x = 0; x < this.cols; x++) {
                const type = this.tiles[y][x];
                let decor = null;
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–µ–∫–æ—Ä –≤–∏–∑—É–∞–ª—å–Ω–æ
                if (type === 2) decor = Math.random() > 0.5 ? 'tree' : 'rock';
                row.push({ type, x, y, decor });
            }
            this.grid.push(row);
        }

        // If waypoints only contain start and end, expand to full path
        if (this.waypoints.length === 2) {
            const fullPath = Pathfinder.findPath(this.grid, this.waypoints[0], this.waypoints[1]);
            if (fullPath.length > 0) {
                this.waypoints = fullPath;
            }
        }

        // Prerender the static map logic
        this.prerender();
        // Cache torches logic
        this.cacheTorches();
    }

    public prerender() {
        // Create offscreen canvas
        this.cacheCanvas = document.createElement('canvas');
        this.cacheCanvas.width = this.cols * CONFIG.TILE_SIZE;
        this.cacheCanvas.height = this.rows * CONFIG.TILE_SIZE;
        const ctx = this.cacheCanvas.getContext('2d');

        if (!ctx) return;

        const TS = CONFIG.TILE_SIZE;

        for (let y = 0; y < this.rows; y++) {
            for (let x = 0; x < this.cols; x++) {
                const type = this.tiles[y][x];
                const px = x * TS;
                const py = y * TS;

                // –†–∏—Å—É–µ–º —Ç–∞–π–ª –Ω–∞ –∫—ç—à-–∫–∞–Ω–≤–∞—Å
                if (type === 1) {
                    // PATH
                    this.drawTile(ctx, 'path', px, py);
                } else {
                    // GRASS (0)
                    this.drawTile(ctx, 'grass', px, py);
                }
            }
        }
    }

    public isBuildable(col: number, row: number): boolean {
        if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) return false;
        if (this.tiles[row][col] !== 0) return false; // Only grass is buildable

        // Check if any object occupies this tile
        const hasObject = this.objects.some(obj => {
            const size = obj.size || 1;
            return col >= obj.x && col < obj.x + size &&
                row >= obj.y && row < obj.y + size;
        });

        return !hasObject;
    }

    public draw(ctx: CanvasRenderingContext2D) {
        // 1. Draw cached static background
        if (this.cacheCanvas) {
            ctx.drawImage(this.cacheCanvas, 0, 0);
        }

        const TS = CONFIG.TILE_SIZE;

        // 2. Draw dynamic objects (trees, rocks, etc that are "objects" not tiles)
        for (const obj of this.objects) {
            const px = obj.x * TS;
            const py = obj.y * TS;
            ObjectRenderer.draw(ctx, obj.type as ObjectType, px, py, obj.size || 1);
        }

        if (this.waypoints.length > 0) {
            const start = this.waypoints[0];
            const end = this.waypoints[this.waypoints.length - 1];
            this.drawIcon(ctx, '‚ò†Ô∏è', start.x, start.y);
            this.drawIcon(ctx, 'üè∞', end.x, end.y);
        }
    }

    // [NEW] Cache torch positions to avoid grid scanning every frame
    private torchPositions: { x: number, y: number, colorHash: number }[] = [];

    // ... (prerender is fine)

    private cacheTorches() {
        this.torchPositions = [];
        const TS = CONFIG.TILE_SIZE;
        const checkGrass = (cx: number, cy: number) => {
            if (cx < 0 || cx >= this.cols || cy < 0 || cy >= this.rows) return true;
            return this.tiles[cy][cx] !== 1;
        };

        const spacing = 4; // Every 4th valid spot roughly

        for (let y = 0; y < this.rows; y++) {
            for (let x = 0; x < this.cols; x++) {
                if (this.tiles[y][x] === 1) { // Path
                    // Identify borders with grass
                    const top = checkGrass(x, y - 1);
                    const bottom = checkGrass(x, y + 1);
                    const left = checkGrass(x - 1, y);
                    const right = checkGrass(x + 1, y);

                    // Add to cache if valid
                    if (top && (x + y * 7) % spacing === 0) {
                        this.torchPositions.push({ x: x * TS + TS / 2, y: y * TS + 4, colorHash: 0 });
                    }
                    if (bottom && (x + y * 13) % spacing === 0) {
                        this.torchPositions.push({ x: x * TS + TS / 2, y: y * TS + TS - 4, colorHash: 1 });
                    }
                    if (left && (y + x * 11) % spacing === 0) {
                        this.torchPositions.push({ x: x * TS + 4, y: y * TS + TS / 2, colorHash: 2 });
                    }
                    if (right && (y + x * 17) % spacing === 0) {
                        this.torchPositions.push({ x: x * TS + TS - 4, y: y * TS + TS / 2, colorHash: 3 });
                    }
                }
            }
        }
    }

    // [NEW] Draw Torches overlay (called from GameScene after main draw)
    public drawTorches(ctx: CanvasRenderingContext2D, time: number = 0) {
        if (!this.lighting) return;
        if (this.torchPositions.length === 0) return;

        const TS = CONFIG.TILE_SIZE;
        // Light radius: 1.5 tiles
        const radiusVal = TS * 1.5;

        // Optimized: Iterate cached positions
        for (const torch of this.torchPositions) {
            // Smooth flicker using Sine waves
            const flickerBase = Math.sin(time * 0.1 + torch.colorHash) * 0.05 + Math.sin(time * 0.03 + torch.colorHash * 2) * 0.05;
            const pop = (Math.random() > 0.98) ? (Math.random() * 0.1) : 0;
            const flickerLocal = 1.0 + flickerBase + pop;

            // Torch Stick
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(torch.x - 2, torch.y, 4, 6);

            // Flame
            const size = (8 + flickerBase * 4);
            ctx.fillStyle = `rgba(255, 87, 34, ${0.8 + flickerBase})`;
            ctx.beginPath();
            ctx.arc(torch.x, torch.y + 2, size / 2, 0, Math.PI * 2);
            ctx.fill();

            // Inner Flame
            ctx.fillStyle = `rgba(255, 235, 59, ${0.8 + flickerBase})`;
            ctx.beginPath();
            ctx.arc(torch.x, torch.y + 2, size / 4, 0, Math.PI * 2);
            ctx.fill();

            // Light
            const lightRadius = radiusVal + flickerBase * 5;
            this.lighting!.addLight(torch.x, torch.y, lightRadius, '#ff9100', 0.8 * flickerLocal);
        }
    }

    private drawTile(ctx: CanvasRenderingContext2D, key: string, x: number, y: number) {
        // Phase 2: Bitmasking –¥–ª—è path
        if (key === 'path') {
            // –í—ã—á–∏—Å–ª–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–∞–π–ª–∞
            const col = Math.floor(x / CONFIG.TILE_SIZE);
            const row = Math.floor(y / CONFIG.TILE_SIZE);

            // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–æ—Å–µ–¥–µ–π (–¥–ª—è –±–∏—Ç–º–∞—Å–∫–∞)
            const NORTH = (row > 0 && this.tiles[row - 1][col] === 1) ? 1 : 0;
            const WEST = (col > 0 && this.tiles[row][col - 1] === 1) ? 1 : 0;
            const EAST = (col < this.cols - 1 && this.tiles[row][col + 1] === 1) ? 1 : 0;
            const SOUTH = (row < this.rows - 1 && this.tiles[row + 1][col] === 1) ? 1 : 0;

            // –í—ã—á–∏—Å–ª–∏—Ç—å –∏–Ω–¥–µ–∫—Å –±–∏—Ç–º–∞—Å–∫–∞ (0-15)
            const bitmask = NORTH | (WEST << 1) | (EAST << 2) | (SOUTH << 3);

            // –ü–æ–ª—É—á–∏—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π path tile
            const pathTile = Assets.get(`path_${bitmask}`);

            if (pathTile) {
                ctx.drawImage(pathTile, x, y);
            } else {
                // Fallback - –ø—Ä–æ—Å—Ç–æ–π path
                const fallback = Assets.get('path');
                if (fallback) {
                    ctx.drawImage(fallback, x, y);
                } else {
                    ctx.fillStyle = '#c5b8a1'; // –§–ê–ó–ê 1: –ö–∞–º–µ–Ω–Ω—ã–π fallback

                    ctx.fillRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                }
            }
            return;
        }

        // Grass (—Å –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å—é)
        // FIX: Use deterministic variant to prevent flickering (Assets.get is random)
        let img: HTMLCanvasElement | HTMLImageElement | undefined;

        if (key === 'grass') {
            const variantCount = Assets.getVariantCount('grass');
            if (variantCount > 0) {
                // Deterministic index based on position
                const index = Math.abs((x * 73 + y * 37)) % variantCount;
                img = Assets.getVariant('grass', index);
            } else {
                img = Assets.get('grass');
            }
        } else {
            img = Assets.get(key);
        }

        if (img) {
            // –î–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è —Ç—Ä–∞–≤—ã - —Å–ª—É—á–∞–π–Ω–æ–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ
            if (key === 'grass') {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–π "—Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏"
                const seed = x * 73 + y * 37;
                const flipH = (seed % 2) === 0;
                const flipV = (Math.floor(seed / 2) % 2) === 0;

                ctx.save();
                ctx.translate(x + CONFIG.TILE_SIZE / 2, y + CONFIG.TILE_SIZE / 2);
                ctx.scale(flipH ? -1 : 1, flipV ? -1 : 1);
                ctx.drawImage(img, -CONFIG.TILE_SIZE / 2, -CONFIG.TILE_SIZE / 2);
                ctx.restore();
            } else {
                ctx.drawImage(img, x, y);
            }
        } else {
            ctx.fillStyle = key === 'path' ? '#ded29e' : '#8bc34a';
            ctx.fillRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
        }
    }

    private drawIcon(ctx: CanvasRenderingContext2D, icon: string, col: number, row: number) {
        const halfTile = CONFIG.TILE_SIZE / 2;
        const x = col * CONFIG.TILE_SIZE + halfTile;
        const y = row * CONFIG.TILE_SIZE + halfTile;
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(icon, x, y);
    }

    public validatePath(_start: { x: number; y: number }, _end: { x: number; y: number }): { x: number; y: number }[] {
        return [];
    }
}
</file>

<file path="src/WaveManager.ts">
import { IGameScene } from './scenes/IGameScene';
import { CONFIG } from './Config';
import { IWaveConfig, SpawnPattern } from './MapData';
import { SoundManager, SoundPriority } from './SoundManager';
import { EventBus, Events } from './EventBus';

/**
 * –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –æ –≤—Ä–∞–≥–µ –≤ –æ—á–µ—Ä–µ–¥–∏ —Å–ø–∞–≤–Ω–∞
 */
interface SpawnQueueEntry {
    type: string;
    pattern: SpawnPattern;
    baseInterval: number;
}

/**
 * Manages wave logic, spawning enemies, and tracking wave progress.
 */
export class WaveManager {
    private scene: IGameScene;
    public isWaveActive: boolean = false;

    // –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ –≤–º–µ—Å—Ç–æ –ø—Ä–æ—Å—Ç–æ–≥–æ –º–∞—Å—Å–∏–≤–∞ —Å—Ç—Ä–æ–∫
    private spawnQueue: SpawnQueueEntry[] = [];
    private spawnTimer: number = 0;
    private currentPattern: SpawnPattern = 'normal';
    private currentBaseInterval: number = 40;
    private currentIndex: number = 0; // –ò–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–≥–æ –≤—Ä–∞–≥–∞ –≤ –æ—á–µ—Ä–µ–¥–∏

    // Card reward tracking - track last wave number that received a card
    private lastCardGivenForWave: number = 0;

    constructor(scene: IGameScene) {
        this.scene = scene;
    }

    /**
     * Starts the next wave. If already active, adds bonus.
     */
    public startWave() {
        // ALLOW EARLY WAVE START
        // If wave is active, we just increment and add more enemies to the queue

        this.scene.wave++;
        EventBus.getInstance().emit(Events.WAVE_STARTED, this.scene.wave);

        // If not active, activate. If active, we just continue.
        if (!this.isWaveActive) {
            this.isWaveActive = true;
        } else {
            // Early wave bonus!
            // Early wave bonus!
            this.scene.addMoney(CONFIG.ECONOMY.EARLY_WAVE_BONUS);
            this.scene.metrics.trackMoneyEarned(CONFIG.ECONOMY.EARLY_WAVE_BONUS);
            this.scene.showFloatingText(`EARLY! +${CONFIG.ECONOMY.EARLY_WAVE_BONUS}üí∞`, this.scene.game.canvas.width / 2, 300, 'gold');
        }

        this.generateWave(this.scene.wave);
        this.scene.metrics.trackWaveReached(this.scene.wave);



        // Wave visuals now handled by NotificationSystem via EventBus
        // this.scene.ui.update(); // EventBus handles UI
    }

    public update(dt: number) {
        if (!this.isWaveActive) return;

        // –°–ø–∞–≤–Ω –≤—Ä–∞–≥–æ–≤ –∏–∑ –æ—á–µ—Ä–µ–¥–∏
        if (this.spawnQueue.length > 0) {
            this.spawnTimer += dt;

            // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω–∞
            const requiredDelay = this.getNextSpawnDelay();

            if (this.spawnTimer >= requiredDelay) {
                const entry = this.spawnQueue.shift()!;
                this.scene.spawnEnemy(entry.type);

                // Sound: Boss Spawn
                if (entry.type.toUpperCase() === 'SPIDER' || entry.type.toUpperCase() === 'TANK') {
                    SoundManager.play('boss_spawn', SoundPriority.HIGH);
                }

                this.spawnTimer = 0;

                // –û–±–Ω–æ–≤–∏—Ç—å –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –≤—Ä–∞–≥–∞
                this.updateCurrentPattern();
            }
        } else {
            // –ï—Å–ª–∏ –æ—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞ –ò –≤—Ä–∞–≥–æ–≤ –Ω–∞ –∫–∞—Ä—Ç–µ –Ω–µ—Ç -> –ø–æ–±–µ–¥–∞ –≤ –≤–æ–ª–Ω–µ
            if (this.scene.enemies.length === 0) {
                this.endWave();
            }
        }
    }

    private endWave() {
        this.isWaveActive = false;
        EventBus.getInstance().emit(Events.WAVE_COMPLETED, this.scene.wave);
        // Wave clear visuals now handled by NotificationSystem via EventBus

        // Progressive economy: Base reward + scaling per wave
        const reward = CONFIG.ECONOMY.WAVE_BASE_REWARD + (this.scene.wave * CONFIG.ECONOMY.WAVE_SCALING_FACTOR);
        this.scene.addMoney(reward);

        // Perfect wave bonus (no lives lost this game/wave - strictly checking if at max lives)
        // Note: This checks if current lives equals starting lives. 
        // If we want per-wave perfection, we'd need to snapshot lives at wave start.
        // Assuming "Perfect Wave" means "No leaks currently" or "Full Health".
        // Let's go with: If player has full health (startingLives), give bonus.
        if (this.scene.lives >= this.scene.startingLives) {
            this.scene.addMoney(CONFIG.ECONOMY.PERFECT_WAVE_BONUS);
            this.scene.metrics.trackMoneyEarned(CONFIG.ECONOMY.PERFECT_WAVE_BONUS);
            this.scene.showFloatingText(
                `PERFECT! +${CONFIG.ECONOMY.PERFECT_WAVE_BONUS}üí∞`,
                this.scene.game.canvas.width / 2,
                350,
                '#00ffff' // Cyan for perfect
            );
        }

        // Give card for this completed wave (only once per wave number)
        // This ensures card is given even if wave was started early
        if (this.scene.wave > this.lastCardGivenForWave) {
            this.scene.giveRandomCard();
            this.lastCardGivenForWave = this.scene.wave;
        }

        // this.scene.ui.update(); // EventBus handles UI
    }

    public getWaveConfig(waveNum: number): IWaveConfig | null {
        let waveConfig: IWaveConfig | null = null;

        // 1. –ü—ã—Ç–∞–µ–º—Å—è –≤–∑—è—Ç—å –≤–æ–ª–Ω—É –∏–∑ –ö–∞—Ä—Ç—ã (–∏–∑ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞)
        if (this.scene.mapData && this.scene.mapData.waves && this.scene.mapData.waves.length > 0) {
            // Note: Map data often repeats the last wave or loops, but for now we just clamp
            // Actually, if we want "infinite" waves logic, we need to replicate how generateWave picks it.
            // Current generateWave logic: Math.min(waveNum - 1, length - 1)
            const idx = Math.min(waveNum - 1, this.scene.mapData.waves.length - 1);
            waveConfig = this.scene.mapData.waves[idx];
        }

        // 2. –ï—Å–ª–∏ –≤ –∫–∞—Ä—Ç–µ –ø—É—Å—Ç–æ, –±–µ—Ä–µ–º –∏–∑ Config (—Ñ–æ–ª–±–µ–∫)
        if (!waveConfig) {
            const idx = Math.min(waveNum - 1, CONFIG.WAVES.length - 1);
            const rawData = CONFIG.WAVES[idx];

            if (Array.isArray(rawData)) {
                // @ts-ignore
                waveConfig = { enemies: rawData };
            } else {
                waveConfig = rawData as unknown as IWaveConfig;
            }
        }

        return waveConfig;
    }

    private generateWave(waveNum: number) {
        this.spawnQueue = [];
        this.currentIndex = 0;

        const waveConfig = this.getWaveConfig(waveNum);

        // –†–∞–∑–±–æ—Ä –∫–æ–Ω—Ñ–∏–≥–∞ –∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—á–µ—Ä–µ–¥–∏ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
        if (waveConfig && waveConfig.enemies) {
            waveConfig.enemies.forEach((group) => {
                // –ú–∏–≥—Ä–∞—Ü–∏—è –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–∞
                const migrated = this.migrateGroupConfig(group);
                const baseInterval = this.getBaseIntervalFromRate(group.spawnRate);

                for (let i = 0; i < migrated.count; i++) {
                    this.spawnQueue.push({
                        type: migrated.type,
                        pattern: migrated.pattern,
                        baseInterval: baseInterval
                    });
                }
            });
        }

        // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –≤—Ä–∞–≥–æ–≤ –≤ –≤–æ–ª–Ω–µ, —á—Ç–æ–±—ã –±—ã–ª–æ –≤–µ—Å–µ–ª–µ–µ
        this.spawnQueue.sort(() => Math.random() - 0.5);

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω –ø–µ—Ä–≤–æ–≥–æ –≤—Ä–∞–≥–∞
        if (this.spawnQueue.length > 0) {
            this.currentPattern = this.spawnQueue[0].pattern;
            this.currentBaseInterval = this.spawnQueue[0].baseInterval;
        }
    }

    /**
     * –ú–∏–≥—Ä–∏—Ä—É–µ—Ç —Å—Ç–∞—Ä—ã–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∫ –Ω–æ–≤–æ–º—É —Ñ–æ—Ä–º–∞—Ç—É
     * –ë–µ–∑–æ–ø–∞—Å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–æ–ª—è
     */
    private migrateGroupConfig(group: any): { type: string; count: number; pattern: SpawnPattern } {
        // –ï—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å –Ω–æ–≤–æ–µ –ø–æ–ª–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
        if (group.spawnPattern) {
            return {
                type: group.type,
                count: group.count,
                pattern: group.spawnPattern as SpawnPattern
            };
        }

        // –ú–∏–≥—Ä–∞—Ü–∏—è –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞
        // –≠–≤—Ä–∏—Å—Ç–∏–∫–∞: –µ—Å–ª–∏ –±—ã–ª–æ –º–Ω–æ–≥–æ –≤—Ä–∞–≥–æ–≤ —Å fast - –¥–µ–ª–∞–µ–º swarm
        let defaultPattern: SpawnPattern = 'normal';
        if (group.spawnRate === 'fast' && group.count > 15) {
            defaultPattern = 'swarm';
        }

        return {
            type: group.type,
            count: group.count,
            pattern: defaultPattern
        };
    }

    /**
     * –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å—Ç–∞—Ä—ã–π spawnRate –≤ –±–∞–∑–æ–≤—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
     */
    private getBaseIntervalFromRate(rate?: 'fast' | 'medium' | 'slow'): number {
        switch (rate) {
            case 'fast': return 0.4; // 25 / 60
            case 'slow': return 1.0; // 60 / 60
            case 'medium':
            default: return 0.66; // 40 / 60
        }
    }

    /**
     * –í—ã—á–∏—Å–ª—è–µ—Ç —Å–ª–µ–¥—É—é—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª —Å–ø–∞–≤–Ω–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω–∞
     */
    private getNextSpawnDelay(): number {
        // Minimum delay 0.05s (instead of 5 frames) to avoiding instant stacking but allow fast fire
        const baseInterval = Math.max(0.05, this.currentBaseInterval);

        switch (this.currentPattern) {
            case 'normal':
                // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
                return baseInterval;

            case 'random':
                // –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è ¬±30% –æ—Ç –±–∞–∑–æ–≤–æ–≥–æ
                const variance = baseInterval * 0.3;
                const randomDelay = baseInterval + (Math.random() - 0.5) * 2 * variance;
                return Math.max(0.05, randomDelay);

            case 'swarm':
                // –û—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã (10-25% –æ—Ç –±–∞–∑–æ–≤–æ–≥–æ)
                const swarmBase = baseInterval * 0.15;
                const swarmVariance = swarmBase * 0.5;
                const swarmDelay = swarmBase + Math.random() * swarmVariance;
                return Math.max(0.02, swarmDelay);

            default:
                console.warn('[WaveManager] Unknown spawn pattern:', this.currentPattern);
                return baseInterval;
        }
    }

    /**
     * –û–±–Ω–æ–≤–ª—è–µ—Ç —Ç–µ–∫—É—â–∏–π –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –≤—Ä–∞–≥–∞ –≤ –æ—á–µ—Ä–µ–¥–∏
     */
    private updateCurrentPattern(): void {
        if (this.spawnQueue.length > 0) {
            const next = this.spawnQueue[0];
            this.currentPattern = next.pattern;
            this.currentBaseInterval = next.baseInterval;
        }
    }
}
</file>

<file path="src/Enemy.ts">
import { CONFIG, getEnemyType } from './Config';
import { EventBus, Events } from './EventBus';
import { RendererFactory } from './RendererFactory';
import { Assets } from './Assets';
import { Projectile } from './Projectile';
import { EnemyRenderer } from './renderers/EnemyRenderer';

export interface IEnemyConfig {
    id: string;
    health: number;
    speed: number;
    armor?: number;
    x?: number;
    y?: number;
    path: { x: number; y: number }[];
}

interface IStatus {
    type: 'slow' | 'burn';
    duration: number;
    power: number;
}

export class Enemy {
    public id: string;
    public typeId: string = 'grunt';

    public currentHealth: number;
    public maxHealth: number;
    public baseSpeed: number;
    public armor: number;
    public reward: number = 5; // Reward for killing this enemy

    public x: number;
    public y: number;

    public path: { x: number; y: number }[];
    public pathIndex: number = 0;
    public finished: boolean = false;

    public statuses: IStatus[] = [];
    public damageModifier: number = 1.0;     // Damage multiplier (e.g., 1.2 = +20% damage)
    public killedByProjectile: Projectile | null = null;   // Track what projectile killed this enemy
    public hitFlashTimer: number = 0;        // Timer for white flash on hit

    // === BOSS MECHANICS (Spectral Shift) ===
    public isInvulnerable: boolean = false;
    private shieldTimer: number = 0;

    // Magma King Mechanics
    public threatPriority: number = 0; // Higher = focused by towers first
    public spawnThresholds: number[] = []; // HP percentages to trigger spawn (0.75, 0.5, 0.25)

    // Thresholds: [HP Percent, Duration in Seconds]
    private thresholds: { p: number, d: number, used: boolean }[] = [];

    constructor(config?: IEnemyConfig) {
        if (config) {
            this.init(config);
        }
    }

    public init(config: IEnemyConfig) {
        this.id = config.id;
        this.maxHealth = config.health;
        this.currentHealth = config.health;
        this.baseSpeed = config.speed;
        this.armor = config.armor || 0;

        this.x = config.x || 0;
        this.y = config.y || 0;
        this.path = config.path;
        this.pathIndex = 0;
        this.finished = false;

        this.damageModifier = 1.0;
        this.killedByProjectile = null;

        // Reset specific fields
        this.threatPriority = 0;
        this.spawnThresholds = [];
        this.thresholds = [];
    }

    public reset() {
        this.statuses = [];
        this.hitFlashTimer = 0;
        this.pathIndex = 0;
        this.finished = false;
        this.damageModifier = 1.0;
        this.killedByProjectile = null;
        this.x = -1000; // Move offscreen
        this.y = -1000;
        this.threatPriority = 0;
        this.spawnThresholds = [];
        this.thresholds = [];
    }

    public setType(id: string) {
        this.typeId = id;

        // Initialize Boss Mechanics if this is a boss
        if (id.toLowerCase() === 'boss') {
            this.thresholds = [
                { p: 0.8, d: 3.0, used: false },
                { p: 0.5, d: 5.0, used: false },
                { p: 0.2, d: 8.0, used: false }
            ];
        } else if (id === 'magma_king') {
            this.spawnThresholds = [0.75, 0.5, 0.25];
        } else if (id === 'magma_statue') {
            this.threatPriority = 999; // Maximum priority
        } else {
            this.thresholds = [];
            this.spawnThresholds = [];
        }
    }

    public takeDamage(amount: number, projectile?: Projectile): void {
        if (this.isInvulnerable) {
            // Visual Effect "BLOCKED"
            EventBus.getInstance().emit(Events.ENEMY_IMMUNE, { x: this.x, y: this.y });
            return;
        }

        const prevHpPercent = this.currentHealth / this.maxHealth;

        // Apply damage modifier (from slow effects, etc.)
        const modifiedAmount = amount * this.damageModifier;
        const actualDamage = Math.max(1, modifiedAmount - this.armor);
        this.currentHealth -= actualDamage;
        if (this.currentHealth < 0) this.currentHealth = 0;

        const currentHpPercent = this.currentHealth / this.maxHealth;

        // Check Thresholds (Invulnerable Shield Boss)
        for (const t of this.thresholds) {
            if (!t.used && currentHpPercent <= t.p && prevHpPercent > t.p) {
                this.activateShield(t.d);
                t.used = true;
                break; // Activate one threshold at a time
            }
        }

        // Check Spawn Thresholds (Magma King)
        for (let i = this.spawnThresholds.length - 1; i >= 0; i--) {
            const threshold = this.spawnThresholds[i];
            if (currentHpPercent <= threshold && prevHpPercent > threshold) {
                // Trigger Split Event
                EventBus.getInstance().emit('ENEMY_SPLIT', { enemy: this, threshold });
                this.spawnThresholds.splice(i, 1); // Remove used threshold
            }
        }

        // Visual Feedback: Hit Flash
        this.hitFlashTimer = 0.08; // ~5 frames at 60fps

        // Track what killed this enemy
        if (!this.isAlive()) {
            if (projectile) {
                this.killedByProjectile = projectile;
            }
            EventBus.getInstance().emit(Events.ENEMY_DIED, { enemy: this });
        }
    }

    private activateShield(duration: number) {
        this.isInvulnerable = true;
        this.shieldTimer = duration;
        // Float text handled by event listener or renderer (if we want persistency)
        // But for "IMMUNE!" popup, we can emit event
        EventBus.getInstance().emit(Events.ENEMY_IMMUNE, { x: this.x, y: this.y - 40 });
    }

    // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –º–µ—Ç–æ–¥ —Å—Ç–∞–ª public
    public move(dt: number): void {
        let speedMod = 1;
        const slow = this.statuses.find((s) => s.type === 'slow');
        if (slow) speedMod -= slow.power;

        const currentSpeed = Math.max(0, this.baseSpeed * speedMod * dt); // Apply delta time

        if (this.pathIndex >= this.path.length) {
            this.finished = true;
            return;
        }

        const node = this.path[this.pathIndex];
        const targetX = node.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const targetY = node.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist <= currentSpeed) {
            this.x = targetX;
            this.y = targetY;
            this.pathIndex++;
        } else {
            const angle = Math.atan2(dy, dx);
            this.x += Math.cos(angle) * currentSpeed;
            this.y += Math.sin(angle) * currentSpeed;
        }
    }

    public isAlive(): boolean {
        return this.currentHealth > 0;
    }

    public getHealthPercent(): number {
        return this.currentHealth / this.maxHealth;
    }

    public applyStatus(type: 'slow' | 'burn', duration: number, power: number, damageBonus?: number) {
        const existing = this.statuses.find((s) => s.type === type);
        if (existing) {
            existing.duration = duration;
            existing.power = power;
        } else {
            this.statuses.push({ type, duration, power });
        }

        // Apply damage modifier for slowed enemies (Ice level 2+)
        if (type === 'slow' && damageBonus) {
            this.damageModifier = damageBonus;
        }
    }

    public update(dt: number): void {
        // Update status durations
        this.statuses = this.statuses.filter((s) => {
            s.duration -= dt;
            return s.duration > 0;
        });

        // Reset damage modifier if no slow status
        if (!this.statuses.some(s => s.type === 'slow')) {
            this.damageModifier = 1.0;
        }

        // Update flash timer
        if (this.hitFlashTimer > 0) this.hitFlashTimer -= dt;

        // Update Shield
        if (this.isInvulnerable) {
            this.shieldTimer -= dt;
            if (this.shieldTimer <= 0) {
                this.isInvulnerable = false;
            }
        }
    }

    public draw(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawEnemy(ctx, this);
    }

    public drawSprite(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawEnemySprite(ctx, this);
    }

    public drawUI(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawEnemyUI(ctx, this);
    }
}
</file>

<file path="src/Game.ts">
import { Assets } from './Assets';
import { IMapData } from './MapData';
import { Scene } from './Scene';
import { MenuScene } from './scenes/MenuScene';
import { InputSystem } from './InputSystem';
import { SoundManager } from './SoundManager';
import { CardSelectionUI } from './CardSelectionUI';

export class Game {
    public canvas: HTMLCanvasElement;
    public ctx: CanvasRenderingContext2D;

    public input: InputSystem;
    public currentScene: Scene | null = null;
    private lastTime: number = 0;
    private cardSelection: CardSelectionUI;

    constructor(canvasId: string) {
        const canvas = document.getElementById(canvasId) as HTMLCanvasElement;
        if (!canvas) throw new Error('Canvas not found!');
        this.canvas = canvas;
        this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;

        this.input = new InputSystem(this);
        this.loop = this.loop.bind(this);
    }

    public async start() {
        this.drawLoadingScreen();

        try {
            await SoundManager.init();

            // Global Audio Resume logic (Deduplicated from UIManager)
            const resumeAudio = () => {
                SoundManager.resume();
            };
            window.addEventListener('click', resumeAudio, { once: true });
            window.addEventListener('keydown', resumeAudio, { once: true });

            await Assets.loadAll();

            // FIXED: Initialize card selection UI AFTER Assets loaded (DOM is ready)
            this.cardSelection = new CardSelectionUI((selectedCards) => {
                // Callback: when selection is complete, load the game with selected cards
                this.startGameWithCards(selectedCards);
            });

            console.log('Game started!');
            this.toMenu();
            this.loop(0);
        } catch (e) {
            console.error('FATAL ERROR: Failed to load assets', e);
            this.ctx.fillStyle = 'red';
            this.ctx.fillText('FAILED TO LOAD ASSETS', 50, 50);
        }
    }

    private drawLoadingScreen() {
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.fillStyle = '#fff';
        this.ctx.font = '30px Segoe UI';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('LOADING ASSETS...', this.canvas.width / 2, this.canvas.height / 2);
    }

    public changeScene(newScene: Scene) {
        if (this.currentScene) {
            this.currentScene.onExit();
        }

        // Destroy old input listeners to prevent duplication/leaks
        if (this.input) {
            this.input.destroy();
        }
        // Re-initialize input system for the new scene
        this.input = new InputSystem(this);

        this.currentScene = newScene;
        this.currentScene.onEnter();
    }

    public toMenu() {
        this.changeScene(new MenuScene(this));
    }

    private pendingMapData?: IMapData;

    public toGame(mapData?: IMapData) {
        // Store map data and show card selection
        this.pendingMapData = mapData;
        this.cardSelection.show();
    }

    private startGameWithCards(selectedCards: string[]) {
        import('./scenes/GameScene')
            .then(({ GameScene }) => {
                // Pass selected cards to GameScene via global or constructor
                (window as any)._STARTING_CARDS = selectedCards;
                this.changeScene(new GameScene(this, this.pendingMapData));
            })
            .catch((err) => {
                console.error('Failed to load GameScene:', err);
                this.drawError('Failed to load GameScene. Check console.');
                setTimeout(() => this.toMenu(), 3000);
            });
    }

    public toEditor() {
        import('./scenes/EditorScene')
            .then(({ EditorScene }) => {
                this.changeScene(new EditorScene(this));
            })
            .catch((err) => {
                console.error('Failed to load EditorScene:', err);
                this.drawError('Failed to load EditorScene. Check console.');
                setTimeout(() => this.toMenu(), 3000);
            });
    }

    private loop(timestamp: number) {
        // 1. –í—ã—á–∏—Å–ª—è–µ–º –¥–µ–ª—å—Ç—É (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        // –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–∫–∞—á–∫–æ–≤: –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º dt –¥–æ 0.1 (10 FPS –º–∏–Ω–∏–º—É–º)
        // –ï—Å–ª–∏ dt –±–æ–ª—å—à–µ, –ø—Ä–æ—Å—Ç–æ –∑–∞–º–µ–¥–ª—è–µ–º –∏–≥—Ä—É, –Ω–æ –Ω–µ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–∞–¥—Ä
        if (dt > 0.1) {
            // dt = 0.1; // Optional: Force clamp?
            // For now, let's just SKIP the return so logic runs even if slow
            // But if we want to avoid huge jumps, we clamp:
        }
        const safeDt = Math.min(dt, 0.1);

        // 2. –ü–µ—Ä–µ–¥–∞–µ–º safeDt –¥–∞–ª—å—à–µ
        this.input.update(safeDt);
        if (this.currentScene) {
            this.currentScene.update(safeDt);
            this.currentScene.draw(this.ctx);
        }

        requestAnimationFrame(this.loop);
    }
    private drawError(msg: string) {
        this.ctx.fillStyle = 'rgba(0,0,0,0.8)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = 'red';
        this.ctx.font = '30px Segoe UI';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(msg, this.canvas.width / 2, this.canvas.height / 2);
    }
}
</file>

<file path="src/Config.ts">
import type { ICardTypeConfig, IEnemyTypeConfig } from './types';
import { ENEMY_CONFIG, ENEMY_TYPES } from './config/Enemies';
import { TOWER_CONFIG, TARGETING_MODES } from './config/Towers';
import { WAVE_CONFIG, ECONOMY_CONFIG } from './config/Levels';

export const CONFIG = {
    // Configuration flags for safe refactoring
    USE_NEW_RENDERER: true, // Toggle this to enable new modular renderers

    TILE_SIZE: 64,

    AMBIENT: {
        DAY_SPEED: 0.0005,
        NIGHT_SPEED_MULTIPLIER: 1.5,
        LIGHTING: {
            FIRE: '#ff5722',
            ICE: '#00bcd4',
            SNIPER: '#4caf50',
            MINIGUN: '#e040fb',
            STANDARD: '#ffeb3b',
        }
    },

    PLAYER: {
        START_MONEY: 250,
        START_LIVES: 20,
        HAND_LIMIT: 7,
    },

    ECONOMY: ECONOMY_CONFIG,

    TOWER: TOWER_CONFIG,

    TARGETING_MODES: TARGETING_MODES,

    UI: {
        HP_BAR_WIDTH: 40,
        HP_BAR_HEIGHT: 4,
        HP_BAR_OFFSET: -30,
        FLOATING_TEXT_LIFE: 1.0, // 1 second
    },

    CARD_TYPES: {
        FIRE: { id: 'fire', name: '–ú–æ—Ä—Ç–∏—Ä–∞', icon: 'üî•', color: '#f44336', desc: '–£—Ä–æ–Ω –ø–æ –ø–ª–æ—â–∞–¥–∏', turretAsset: 'turret_fire', moduleAsset: 'mod_fire' },
        ICE: { id: 'ice', name: '–°—Ç—É–∂–∞', icon: '‚ùÑÔ∏è', color: '#00bcd4', desc: '–ó–∞–º–µ–¥–ª—è–µ—Ç –≤—Ä–∞–≥–æ–≤', turretAsset: 'turret_ice', moduleAsset: 'mod_ice' },
        SNIPER: { id: 'sniper', name: '–°–Ω–∞–π–ø–µ—Ä', icon: 'üéØ', color: '#4caf50', desc: '–î–∞–ª—å–Ω—è—è —Å—Ç—Ä–µ–ª—å–±–∞', turretAsset: 'turret_sniper', moduleAsset: 'mod_sniper' },
        MULTISHOT: { id: 'multi', name: '–ó–∞–ª–ø', icon: 'üí•', color: '#ff9800', desc: '+1 —Å–Ω–∞—Ä—è–¥, -—É—Ä–æ–Ω', turretAsset: 'turret_split', moduleAsset: 'mod_split' },
        MINIGUN: { id: 'minigun', name: '–ü—É–ª–µ–º—ë—Ç', icon: '‚ö°', color: '#9c27b0', desc: '–ë—ã—Å—Ç—Ä–∞—è —Å—Ç—Ä–µ–ª—å–±–∞, —É—Ä–æ–Ω —Ä–∞—Å—Ç—ë—Ç', turretAsset: 'turret_minigun', moduleAsset: 'mod_minigun' },
    } as Readonly<Record<string, ICardTypeConfig>>,

    ENEMY: ENEMY_CONFIG,

    ENEMY_TYPES: ENEMY_TYPES,

    WAVES: WAVE_CONFIG,
};

/**
 * Type-safe helper to get card type configuration
 */
export function getCardType(key: string): ICardTypeConfig | undefined {
    return CONFIG.CARD_TYPES[key];
}

/**
 * Type-safe helper to get enemy type configuration
 */
export function getEnemyType(key: string): IEnemyTypeConfig | undefined {
    // Try exact match first, then uppercase
    // @ts-ignore
    return CONFIG.ENEMY_TYPES[key] || CONFIG.ENEMY_TYPES[key.toUpperCase()];
}
</file>

<file path="src/Tower.ts">
import { CONFIG } from './Config';
import { RendererFactory } from './RendererFactory';
import { ICard } from './CardSystem';
import { Enemy } from './Enemy';
import { Projectile, IProjectileStats } from './Projectile';
import { ObjectPool } from './Utils';
import { EffectSystem } from './EffectSystem';
import { Assets } from './Assets';
import { VISUALS } from './VisualConfig';
import { getCardUpgrade, getMultishotConfig, ICardEffect } from './cards';
import { mergeCardsWithStacking } from './CardStackingSystem';
import { TowerRenderer } from './renderers/TowerRenderer';

export class Tower {
    public col: number;
    public row: number;
    public x: number;
    public y: number;

    public cards: ICard[] = [];
    public cooldown: number = 0;
    public angle: number = 0;
    public targetingMode: string = 'first'; // Targeting priority: first, closest, strongest, weakest, last

    public isBuilding: boolean = false;
    public buildProgress: number = 0;
    public maxBuildProgress: number = CONFIG.TOWER.BUILD_TIME;

    public costSpent: number = 0;

    // Spinup state (for Minigun cards)
    public spinupTime: number = 0;        // Seconds spent firing continuously
    public maxHeat: number = 5;             // Max seconds before overheat (default 5s)
    public isOverheated: boolean = false;   // Whether tower is overheated
    public overheatCooldown: number = 0;    // Seconds remaining in overheat lockout
    public totalOverheatDuration: number = 0; // Total duration of the current overheat lockout (for UI)

    // Visual state (Phase 3)
    public recoilTimer: number = 0;        // Recoil animation timer (seconds)
    public recoilIntensity: number = 0;     // Recoil strength
    public barrelRotation: number = 0;      // Rotation angle of the barrel (Minigun)
    public barrelRecoil: number = 0;        // Recoil offset of the barrel (px)
    public heatLevel: number = 0;          // Heat level 0-1 (Minigun visual)
    public chargeProgress: number = 0;      // Charge progress 0-1 (Sniper visual)

    constructor(c: number, r: number) {
        this.col = c;
        this.row = r;
        this.x = c * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        this.y = r * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        this.costSpent = CONFIG.ECONOMY.TOWER_COST;
    }

    public static getPreviewStats(cards: ICard[]): any {
        const dummy = new Tower(0, 0);
        dummy.cards = cards;
        return dummy.getStats();
    }

    getStats(): IProjectileStats & { range: number; cd: number; projCount: number; spread: number; projectileType: string; attackSpeedMultiplier: number } {
        // Start with base stats
        let range = CONFIG.TOWER.BASE_RANGE;
        let damage = CONFIG.TOWER.BASE_DMG;
        let attackSpeed = CONFIG.TOWER.BASE_CD;
        let speed = 480; // 8 * 60
        let color = VISUALS.PROJECTILES.STANDARD;
        let critChance = 0;
        let pierce = 0;
        let projectileType = 'standard';

        // Use new card stacking system
        const { modifiers: mergedMods, effects: allEffects } = mergeCardsWithStacking(this.cards);

        // Calculate damage with proper order:
        // 1. Collect base damage and flat bonuses
        const baseDamage = CONFIG.TOWER.BASE_DMG;
        const flatDamageBonuses = mergedMods.damage || 0;

        // 2. Apply damageMultiplier if present (Minigun)
        //    This affects both base and bonuses for better balance
        if (mergedMods.damageMultiplier !== undefined) {
            damage = (baseDamage + flatDamageBonuses) * mergedMods.damageMultiplier;
        } else {
            damage = baseDamage + flatDamageBonuses;
        }

        // Apply range modifiers
        range += mergedMods.range || 0;
        range *= mergedMods.rangeMultiplier || 1.0;

        // Apply attack speed
        attackSpeed = attackSpeed / (mergedMods.attackSpeedMultiplier || 1.0);

        // Apply crit chance
        critChance = mergedMods.critChance || 0;

        // Handle multishot cards
        let projCount = 1;
        let damageMultiplier = 1.0;
        let spread = 0;
        const multiCards = this.cards.filter((c) => c.type.id === 'multi');

        // Get visual overrides from first card (data-driven approach)
        const mainCard = this.cards[0];
        if (mainCard) {
            const upgrade = getCardUpgrade(mainCard.type.id, mainCard.level);
            if (upgrade?.visualOverrides) {
                projectileType = upgrade.visualOverrides.projectileType || 'standard';
                color = upgrade.visualOverrides.projectileColor || VISUALS.PROJECTILES.STANDARD;
                speed = upgrade.visualOverrides.projectileSpeed || 480;
            } else if (mainCard.type.id === 'multi') {
                // Fallback for multishot (no visual overrides needed, it modifies count)
                projectileType = 'split';
                color = VISUALS.PROJECTILES.SPLIT;
            }
        }

        if (multiCards.length > 0) {
            // Use highest level multishot card
            const maxLevel = Math.max(...multiCards.map((c) => c.level));
            const multiConfig = getMultishotConfig(maxLevel);
            projCount = multiConfig.projectileCount;
            damageMultiplier = multiConfig.damageMultiplier;
            spread = multiConfig.spread; // NEW: Get spread from config

            // If main card is NOT multishot, but we have multishot upgrades, 
            // the projectile type stays as main card (e.g. Ice + Split = 3 Ice Shards)
            // But if Multishot is the FIRST card, then it's a "Split Tower"
        }

        // Apply multishot damage penalty
        damage *= damageMultiplier;

        // Find pierce effect
        const pierceEffect = allEffects.find(e => e.type === 'pierce');
        if (pierceEffect) {
            pierce = pierceEffect.pierceCount || 0;
        }

        // === SPINUP MECHANIC ===
        // Find spinup effect and apply bonuses based on current spinupTime
        const spinupEffect = allEffects.find(e => e.type === 'spinup');
        if (spinupEffect) {
            const spinupSeconds = this.spinupTime; // already in seconds

            // Apply damage bonus
            if (spinupEffect.spinupSteps) {
                // Stepped damage (Level 3) - optimized to find max applicable step
                let maxStepDamage = 0;
                for (const step of spinupEffect.spinupSteps) {
                    if (spinupSeconds >= step.threshold) {
                        maxStepDamage = step.damage;
                    } else {
                        // Steps are ordered, so no need to check further
                        break;
                    }
                }
                damage = damage + maxStepDamage;
            } else if (spinupEffect.spinupDamagePerSecond) {
                // Linear damage (Level 1-2)
                const bonusDamage = spinupEffect.spinupDamagePerSecond * spinupSeconds;
                damage += bonusDamage;
            }

            // Apply crit chance bonus
            if (spinupEffect.spinupCritPerSecond) {
                const bonusCrit = spinupEffect.spinupCritPerSecond * spinupSeconds;
                critChance += bonusCrit;
            }

            // Cap spinup at max seconds
            // (actual capping happens in WeaponSystem)
        }

        return {
            range: Math.round(range),
            dmg: damage,
            cd: attackSpeed,
            speed,
            color,
            effects: allEffects,
            pierce,
            projCount,
            spread,
            critChance,
            projectileType,
            attackSpeedMultiplier: mergedMods.attackSpeedMultiplier || 1.0
        };
    }

    addCard(c: ICard): boolean {
        if (this.cards.length < CONFIG.TOWER.MAX_CARDS) {
            this.cards.push(c);
            // this.costSpent += 100; // Removed cost tracking for cards
            return true;
        }
        return false;
    }

    removeCard(index: number): ICard | null {
        if (index < 0 || index >= this.cards.length) return null;
        const card = this.cards.splice(index, 1)[0];
        return card || null;
    }

    updateBuilding(effects: EffectSystem, dt: number) {
        if (this.isBuilding) {
            this.buildProgress += dt;

            // Spawn dust particles during construction (every ~0.15s)
            // Using a hacky random check for now to avoid storing another timer
            if (Math.random() < dt * 6) { // Approx 6 times per second
                effects.add({
                    type: 'particle',
                    x: this.x + (Math.random() - 0.5) * 30,
                    y: this.y + 15,
                    vx: (Math.random() - 0.5) * 120, // ~2 px/frame -> 120 px/sec
                    vy: -Math.random() * 120,
                    life: 0.3 + Math.random() * 0.15, // ~20 frames -> 0.3s
                    color: '#a69060',
                    radius: 2 + Math.random() * 2
                });
            }

            if (this.buildProgress >= this.maxBuildProgress) {
                this.isBuilding = false;

                // Completion burst - dust cloud
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    effects.add({
                        type: 'particle',
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * 180, // 3 px/frame -> 180 px/sec
                        vy: Math.sin(angle) * 180 - 60, // gravity effect approximately
                        life: 0.4 + Math.random() * 0.15,
                        color: '#c0a060',
                        radius: 3 + Math.random() * 2
                    });
                }

                // Flash effect
                effects.add({ type: 'explosion', x: this.x, y: this.y, radius: 25, life: 0.25, color: '#ffd700' });
            }
        }
    }

    draw(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawTower(ctx, this);
    }

    drawSprite(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawTowerSprite(ctx, this);
    }

    drawUI(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawTowerUI(ctx, this);
    }
}
</file>

<file path="src/scenes/GameScene.ts">
import { Game } from '../Game';
import { BaseScene } from '../BaseScene';
import { IGameScene } from './IGameScene';
import { MapManager } from '../Map';
import { UIManager } from '../UIManager';
import { CONFIG } from '../Config';
import { CardSystem, ICard } from '../CardSystem';
import { EventEmitter } from '../Events';
import { EventBus, Events } from '../EventBus';
import { InputSystem } from '../InputSystem';
import { EffectSystem } from '../EffectSystem';
// import { DebugSystem } from '../DebugSystem';
import { DevConsole } from '../ui/DevConsole';
import { Logger, LogChannel } from '../utils/Logger';
import { Tower } from '../Tower';
import { SoundManager } from '../SoundManager';
import { WaveManager } from '../WaveManager';
import { ForgeSystem } from '../ForgeSystem';
import { CollisionSystem } from '../CollisionSystem';
import { InspectorSystem } from '../InspectorSystem';
import { BestiarySystem } from '../BestiarySystem';
import { IMapData, DEMO_MAP } from '../MapData';
import { MetricsSystem } from '../MetricsSystem';
import { WeaponSystem } from '../WeaponSystem';
import { FogSystem } from '../FogSystem';
import { LightingSystem } from '../systems/LightingSystem';
import { NotificationSystem } from '../systems/NotificationSystem';
import { DayNightCycle } from '../DayNightCycle';
import { AtmosphereSystem } from '../systems/AtmosphereSystem';
import { ProjectileSystem } from '../systems/ProjectileSystem';
import { Enemy } from '../Enemy';

import { GameController } from './GameController';
import { GameState } from './GameState';
import { EntityManager } from './EntityManager';
import { RendererFactory } from '../RendererFactory';
import { EnemyRenderer } from '../renderers/EnemyRenderer';
import { AcidPuddleSystem } from '../systems/AcidPuddleSystem';
import { SkeletonCommanderSystem } from '../systems/SkeletonCommanderSystem';

/**
 * Main game scene - REFACTORED VERSION
 * Orchestrates game systems using modular components.
 * Implements IGameScene interface to decouple systems.
 */
export class GameScene extends BaseScene implements IGameScene {
    // Core references
    public game: Game;
    public mapData: IMapData;
    public readonly startingLives: number;

    // Modular components
    public gameState: GameState;
    public entityManager: EntityManager;
    public gameController: GameController;

    // Ambient cycle
    private dayTime: number = 0;

    // Map & rendering
    public map: MapManager;
    public fog: FogSystem;
    public lighting: LightingSystem;

    // Systems
    public ui: UIManager;
    public cardSys: CardSystem;
    public waveManager: WaveManager;
    public events: EventEmitter;
    public input: InputSystem;
    public projectileSystem: ProjectileSystem;
    public effects: EffectSystem;
    public devConsole: DevConsole;
    public forge: ForgeSystem;
    public collision: CollisionSystem;
    public inspector: InspectorSystem;
    public bestiary: BestiarySystem;
    public metrics: MetricsSystem;
    public weaponSystem: WeaponSystem;
    public notifications: NotificationSystem;
    private dayNightCycle!: DayNightCycle;
    private atmosphere!: AtmosphereSystem;
    public acidSystem: AcidPuddleSystem;
    public commanderSystem: SkeletonCommanderSystem;

    // IGameScene compatibility properties (delegate to gameState)
    public get wave(): number { return this.gameState.wave; }
    public set wave(value: number) { this.gameState.wave = value; }

    public get money(): number { return this.gameState.money; }

    public get lives(): number { return this.gameState.lives; }

    public get paused(): boolean { return this.gameState.paused; }

    public get selectedTower(): Tower | null { return this.gameState.selectedTower; }
    public set selectedTower(value: Tower | null) { this.gameState.selectTower(value); }

    public get enemies() { return this.gameState.enemies; }
    public get towers() { return this.gameState.towers; }
    public get projectiles() { return this.projectileSystem.projectiles; }

    public get enemyPool() { return this.gameState.enemyPool; }

    constructor(game: Game, mapData: IMapData) {
        super();
        this.game = game;
        this.mapData = mapData || DEMO_MAP;

        // Initialize core state
        this.gameState = new GameState();
        this.startingLives = CONFIG.PLAYER.START_LIVES;

        // Initialize map and rendering
        this.map = new MapManager(this.mapData);
        this.fog = new FogSystem(this.mapData);
        this.lighting = new LightingSystem(game.canvas.width, game.canvas.height);
        this.map.lighting = this.lighting; // [NEW] Link lighting
        this.dayNightCycle = new DayNightCycle(); // Default cycle (4 min)
        this.atmosphere = new AtmosphereSystem(this.dayNightCycle); // Default config
        // Set world size for cloud positioning (map dimensions in pixels)
        const worldWidth = this.mapData.width * CONFIG.TILE_SIZE;
        const worldHeight = this.mapData.height * CONFIG.TILE_SIZE;
        this.atmosphere.setWorldSize(worldWidth, worldHeight);
        this.events = new EventEmitter();
        this.effects = new EffectSystem(game.ctx);
        this.input = game.input;

        // Initialize systems
        this.projectileSystem = new ProjectileSystem();
        this.weaponSystem = new WeaponSystem();
        this.metrics = new MetricsSystem();
        this.notifications = new NotificationSystem(this.effects, game.canvas);

        this.waveManager = new WaveManager(this);
        this.acidSystem = new AcidPuddleSystem(game.ctx);
        this.commanderSystem = new SkeletonCommanderSystem(game.ctx);

        // Initialize entity manager
        this.entityManager = new EntityManager(
            this.gameState,
            this.effects,
            this.metrics,
        );

        // Initialize UI and card systems
        // Get starting cards from selection or use default
        // CHANGED: Start with ALL 5 card types
        const startingCards = (window as any)._STARTING_CARDS || ['FIRE', 'ICE', 'SNIPER', 'MULTISHOT', 'MINIGUN'];
        delete (window as any)._STARTING_CARDS; // Cleanup after use

        this.ui = new UIManager(this);
        this.cardSys = new CardSystem(this, startingCards);
        this.forge = new ForgeSystem(this);
        this.devConsole = new DevConsole(this);
        this.collision = new CollisionSystem(this.effects); // Debug removed

        Logger.info(LogChannel.GAME, 'GameScene Initialized');
        this.inspector = new InspectorSystem(this);
        this.bestiary = new BestiarySystem(this);

        // Initialize game controller
        this.gameController = new GameController(
            this.gameState,
            this.entityManager,
            this.effects,
            this.inspector,
            this.ui,
            this.metrics,
            this.mapData,
            (col, row) => this.map.isBuildable(col, row),
            this.cardSys,
            this.events,
        );

        // Listen for Global Events
        EventBus.getInstance().on(Events.ENEMY_DIED, (data: any) => {
            const enemy = data.enemy as Enemy;
            if (enemy && enemy.typeId === 'sapper_rat') {
                this.triggerExplosion(enemy.x, enemy.y, 45, 200, true); // –£–º–µ–Ω—å—à–µ–Ω–Ω—ã–π —Ä–∞–¥–∏—É—Å
            }
        });

        // Magma King Split Logic
        EventBus.getInstance().on('ENEMY_SPLIT', (data: any) => {
            const enemy = data.enemy as Enemy;
            if (enemy && enemy.typeId === 'magma_king') {
                // Spawn Decoy
                // Iterate through neighbor points to find a valid spot or just spawn at same location
                // Spawning at exact same location is fine, visually they overlap during "shedding"
                const decoy = this.entityManager.spawnEnemy('MAGMA_STATUE', this.map.waypoints);
                if (decoy) {
                    // Set Decoy Position to Boss Position
                    decoy.x = enemy.x;
                    decoy.y = enemy.y;

                    // Match path progress so it doesn't walk from start
                    decoy.pathIndex = enemy.pathIndex;

                    // Add "Pop" effect
                    this.effects.add({
                        type: 'explosion', // Reusing explosion for visual splash
                        x: enemy.x,
                        y: enemy.y,
                        radius: 40,
                        life: 0.3,
                        color: '#b0bec5' // Silver splash
                    });

                    this.showFloatingText('DECOY!', enemy.x, enemy.y - 30, '#b0bec5');
                }
            }
        });
    }

    public onEnter() {
        const ui = document.getElementById('ui-layer');
        if (ui) ui.style.display = 'block';
        const hand = document.getElementById('hand-container');
        if (hand) hand.style.display = 'flex';

        this.ui.update();
        window.addEventListener('keydown', this.onKeyDown);
    }

    public onExit() {
        const ui = document.getElementById('ui-layer');
        if (ui) ui.style.display = 'none';
        window.removeEventListener('keydown', this.onKeyDown);
        if (this.bestiary) this.bestiary.destroy();
    }

    private onKeyDown = (e: KeyboardEvent) => {
        this.gameController.handleKeyDown(e);
    };

    public update(dt: number) {
        if (!this.gameState.isRunning) return;
        if (this.gameState.paused) return;

        this.gameState.frames++;

        // Time scale support (1x or 2x speed)
        const loops = (this.gameState.timeScale >= 2) ? 2 : 1;

        // Day/Night Cycle (Simple Sine Wave)
        // Cycle duration: approx 60 seconds (3600 frames)

        // Determine current phase (Sine Wave)
        // Math.sin(this.dayTime) -> -1 (Night) to 1 (Day)
        const currentSin = Math.sin(this.dayTime);
        const isNight = currentSin < 0;

        // Modulate speed: Night passes 50% faster, Day is normal
        const speedMultiplier = isNight ? 1.5 : 1.0;

        // Update DayTime
        // Warning: this relies on loops count. We should probably use dt.
        // But for now keeping loops based 
        this.dayTime += 0.0005 * loops * speedMultiplier;

        // Update DayNightCycle system
        // Pass real dt (accumulated per loop if we loop, but here we pass dt * loops roughly?)
        // Actually, if we loop 2 times with dt, we advance 2 * dt time. Correct.

        // Oscillate between 0.5 (Darkest evening) and 0.95 (Brightest day)
        // Math.sin goes -1 to 1. 
        // We want range [0.5, 0.95]. Center is 0.725, Amplitude is 0.225
        const brightness = 0.75 + currentSin * 0.20;
        this.lighting.ambientLight = brightness;

        // delta frames is NOT used anymore for logic, everything uses dt (seconds)
        // const delta = dt * 60; 

        for (let l = 0; l < loops; l++) {
            this.dayNightCycle.update(dt);
            this.atmosphere.update(dt);
            this.waveManager.update(dt);
            this.fog.update(dt);
            // Lighting doesn't need explicit update logic for now, just render

            // Update projectiles
            this.projectileSystem.update(dt, this.effects);

            // Update weapon system (tower shooting)
            this.weaponSystem.update(
                this.gameState.towers,
                this.gameState.enemies,
                this.projectileSystem,
                dt,
                this.effects
            );

            // Update tower visual states
            this.gameState.towers.forEach((t) => t.updateBuilding(this.effects, dt));

            this.collision.update(this.projectileSystem.projectiles, this.gameState.enemies);
            this.entityManager.updateEnemies(dt);
            this.acidSystem.update(dt, this.gameState.enemies);
            this.commanderSystem.update(dt, this.gameState.enemies);

            this.effects.update(dt);

            // Update enemy counter in HUD
            this.ui.hud.updateEnemyCounter(this.gameState.enemies.length);
        }
        // Update shake (once per frame, not per loop)
        this.gameState.updateShake();
        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –®–ê–ì 3: –î—É–±–ª–∏–∫–∞—Ç effects.update() –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω
        // –≠—Ñ—Ñ–µ–∫—Ç—ã —É–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –≤ —Ü–∏–∫–ª–µ –≤—ã—à–µ (—Å—Ç—Ä–æ–∫–∞ 237)
        // –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —ç—Ç—É —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–∫–∞—Ç–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π:
        // this.effects.update();
    }

    public draw(ctx: CanvasRenderingContext2D) {
        ctx.save();

        // Reset global canvas state to prevent artifacts from previous frames
        ctx.globalAlpha = 1.0;
        ctx.globalCompositeOperation = 'source-over';

        // Apply screen shake
        if (this.gameState.shakeTimer > 0) {
            const dx = (Math.random() - 0.5) * this.gameState.shakeIntensity;
            const dy = (Math.random() - 0.5) * this.gameState.shakeIntensity;
            ctx.translate(dx, dy);
        }

        // Complete canvas clearing to prevent "Hall of Mirrors" artifacts
        ctx.clearRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);

        // Draw map and fog
        // Draw map and fog
        RendererFactory.drawMap(ctx, this.map);
        // Torches
        this.map.drawTorches(ctx, this.gameState.frames); // [NEW] Draw torches with time

        // === PHASE 6: VIGNETTE (Cinematic Polish) ===
        // Draw a subtle dark gradient at the edges
        // const w = this.game.canvas.width;
        // const h = this.game.canvas.height;
        //
        // ctx.save();
        // const gradient = ctx.createRadialGradient(w / 2, h / 2, h * 0.45, w / 2, h / 2, h * 0.9);
        // gradient.addColorStop(0, 'rgba(0,0,0,0)');
        // gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
        // ctx.fillStyle = gradient;
        // ctx.fillRect(0, 0, w, h);
        // ctx.restore();
        // === END VIGNETTE ===

        this.fog.draw(ctx);

        // Draw path preview
        this.drawPathPreview(ctx);

        // Draw hover highlight
        this.drawHoverHighlight(ctx);

        // Draw entities
        this.gameState.towers.forEach((t) => t.draw(ctx));
        this.drawSelectedTowerRange(ctx);

        // Draw targeting mode tooltip for hovered tower
        this.drawTargetingModeTooltip(ctx);

        // Draw acid puddles UNDER enemies (z-order fix)
        this.acidSystem.draw();
        this.commanderSystem.draw();

        this.gameState.enemies.forEach((e) => e.draw(ctx));
        this.projectileSystem.draw(ctx);
        // Draw effects
        this.effects.draw();

        // Draw lighting (over everything except UI)
        // Update size if needed
        if (this.game.canvas.width !== this.lighting['width'] || this.game.canvas.height !== this.lighting['height']) {
            this.lighting.resize(this.game.canvas.width, this.game.canvas.height);
        }
        // Reset lights
        this.lighting.clear();
        // Add dynamic lights...
        // Add dynamic lights...
        this.lighting.render(ctx);

        // === EMISSIVE PASS (Glowing Eyes through Fog/Darkness) ===
        // Draw this AFTER lighting so it "pops"
        this.gameState.enemies.forEach((e) => EnemyRenderer.drawEmissive(ctx, e));

        // Draw atmosphere effects (sunlight, moonlight, stars, etc)
        this.atmosphere.draw(ctx);

        ctx.restore();
    }

    private drawPathPreview(ctx: CanvasRenderingContext2D) {
        if (this.map.waypoints && this.map.waypoints.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 10]);

            const start = this.map.waypoints[0];
            const ts = CONFIG.TILE_SIZE;
            const half = ts / 2;

            ctx.moveTo(start.x * ts + half, start.y * ts + half);
            for (let i = 1; i < this.map.waypoints.length; i++) {
                const wp = this.map.waypoints[i];
                ctx.lineTo(wp.x * ts + half, wp.y * ts + half);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    private drawHoverHighlight(ctx: CanvasRenderingContext2D) {
        if (this.input.hoverCol >= 0) {
            const hx = this.input.hoverCol * CONFIG.TILE_SIZE;
            const hy = this.input.hoverRow * CONFIG.TILE_SIZE;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(hx, hy, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
        }
    }

    private drawSelectedTowerRange(ctx: CanvasRenderingContext2D) {
        if (this.gameState.selectedTower) {
            const stats = this.gameState.selectedTower.getStats();
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
            ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(
                this.gameState.selectedTower.x,
                this.gameState.selectedTower.y,
                stats.range,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.stroke();
        }
    }

    private drawTargetingModeTooltip(ctx: CanvasRenderingContext2D) {
        // Find tower under mouse cursor
        if (this.input.hoverCol < 0 || this.input.hoverRow < 0) return;

        const hoverX = this.input.hoverCol * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const hoverY = this.input.hoverRow * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        const hoveredTower = this.gameState.towers.find((t) => {
            const dist = Math.hypot(t.x - hoverX, t.y - hoverY);
            return dist < 32; // Within tower radius
        });

        if (hoveredTower && !hoveredTower.isBuilding) {
            const modeKey = hoveredTower.targetingMode.toUpperCase();
            const mode = Object.values(CONFIG.TARGETING_MODES).find((m: any) => m.id === hoveredTower.targetingMode);
            if (mode) {
                // Draw small icon above tower
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';

                // Background circle
                ctx.fillStyle = 'rgba(50, 50, 70, 0.95)';
                ctx.beginPath();
                ctx.arc(hoveredTower.x, hoveredTower.y - 45, 18, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = '#4caf50';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();

                // Icon
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(mode.icon, hoveredTower.x, hoveredTower.y - 45);

                // Tooltip text below
                ctx.font = '12px Arial';
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(mode.name, hoveredTower.x, hoveredTower.y - 22);
                ctx.fillText(mode.name, hoveredTower.x, hoveredTower.y - 22);
            }
        }
    }

    // === IGameScene Implementation (Delegate to modules) ===

    public addMoney(amount: number): void {
        this.gameState.addMoney(amount);
    }

    public spendMoney(amount: number): boolean {
        return this.gameState.spendMoney(amount);
    }

    public loseLife(amount: number = 1): void {
        this.gameState.loseLife(amount);
    }

    public spawnEnemy(type: string): void {
        this.entityManager.spawnEnemy(type, this.map.waypoints);
    }

    public startBuildingTower(col: number, row: number): void {
        this.gameController.startBuildingTower(col, row);
    }

    public handleGridClick(col: number, row: number): void {
        this.gameController.handleGridClick(col, row);
    }

    public showFloatingText(text: string, x: number, y: number, color: string = '#fff'): void {
        this.gameController.showFloatingText(text, x, y, color);
    }

    public handleCardDrop(card: ICard, x: number, y: number): boolean {
        return this.gameController.handleCardDrop(card, x, y);
    }

    public giveRandomCard(): void {
        this.gameController.giveRandomCard();
    }

    public sellTower(tower: Tower): void {
        this.gameController.sellTower(tower);
    }

    public sellCardFromTower(tower: Tower, cardIndex: number): void {
        this.gameController.sellCardFromTower(tower, cardIndex);
    }

    public restart(): void {
        this.game.changeScene(new GameScene(this.game, this.mapData));
    }

    public togglePause(): void {
        this.gameState.togglePause();
        this.ui.updatePauseMenu(this.gameState.paused);
    }

    public gameOver(): void {
        this.gameState.endGame();
        this.metrics.endGame(false);
        this.ui.showGameOver(this.gameState.wave);
    }

    public triggerShake(duration: number, intensity: number): void {
        this.gameState.triggerShake(duration, intensity);
    }

    /**
     * Spawns an explosion that can damage enemies (Friendly Fire)
     */
    public triggerExplosion(x: number, y: number, radius: number, damage: number, friendlyFire: boolean = false) {
        // 1. Main Explosion Visual
        this.effects.add({
            type: 'explosion',
            x: x,
            y: y,
            radius: radius, // No multiplier - new effect looks good at base size
            life: 0.45,
            color: friendlyFire ? 'rgba(118, 255, 3, 0.8)' : 'rgba(255, 100, 0, 0.7)',
        });

        // 2. Explosion particles (debris flying out)
        const particleCount = friendlyFire ? 8 : 5;
        for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2 + Math.random() * 0.5;
            const speed = 150 + Math.random() * 100;
            this.effects.add({
                type: 'debris',
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 50,
                life: 0.4 + Math.random() * 0.2,
                size: 3 + Math.random() * 3,
                color: friendlyFire ? '#76ff03' : '#ff6d00',
                rotation: Math.random() * Math.PI * 2,
                vRot: (Math.random() - 0.5) * 20,
                gravity: 400,
            });
        }

        // 3. Sound and shake
        SoundManager.play('explosion');
        this.triggerShake(0.4, friendlyFire ? 8 : 5);

        // 4. Damage Logic
        if (friendlyFire) {
            // Damage ALL enemies in range
            const enemies = this.gameState.enemies;
            for (const enemy of enemies) {
                if (!enemy.isAlive()) continue;

                const dist = Math.hypot(enemy.x - x, enemy.y - y);
                if (dist <= radius) {
                    enemy.takeDamage(damage);
                }
            }
        }
    }
}
</file>

</files>
