This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/Assets.ts
src/BaseScene.ts
src/BestiarySystem.ts
src/Card.ts
src/cards/CardEvolutions.ts
src/cards/CardType.ts
src/cards/FireCard.ts
src/cards/IceCard.ts
src/cards/index.ts
src/cards/MinigunCard.ts
src/cards/MultishotCard.ts
src/cards/SniperCard.ts
src/CardSelectionUI.ts
src/CardStackingSystem.ts
src/CardSystem.ts
src/CollisionSystem.ts
src/Config.ts
src/config/Enemies.ts
src/config/Levels.ts
src/config/Towers.ts
src/CrashHandler.ts
src/DayNightCycle.ts
src/design/borders.ts
src/design/colors.ts
src/design/fonts.ts
src/design/index.ts
src/design/shadows.ts
src/design/spacing.ts
src/design/transitions.ts
src/editor/components/BaseComponent.ts
src/editor/components/EnemyGroupRow.ts
src/editor/components/SpawnTimingControl.ts
src/editor/components/ThreatMeter.ts
src/editor/components/ValidationPanel.ts
src/editor/components/WaveList.ts
src/editor/components/WavePresetPanel.ts
src/editor/components/WaveSettingsPanel.ts
src/editor/components/WaveTimeline.ts
src/editor/editor.css
src/editor/EditorHistory.ts
src/editor/EditorToolbar.ts
src/editor/EnemyRegistry.ts
src/editor/ThreatService.ts
src/editor/WaveEditorHistory.ts
src/editor/WaveModel.ts
src/editor/WavePresets.ts
src/editor/WaypointManager.ts
src/effects/animators/README.md
src/effects/DeathAnimations.ts
src/effects/index.ts
src/effects/types.ts
src/EffectSystem.ts
src/Enemy.ts
src/EntityFactory.ts
src/EventBus.ts
src/Events.ts
src/FlowField.ts
src/FogRenderer.ts
src/FogStructure.ts
src/FogSystem.ts
src/ForgeSystem.ts
src/Game.ts
src/GameSession.ts
src/index.ts
src/InputSystem.ts
src/InspectorSystem.ts
src/Map.ts
src/MapData.ts
src/MapStorage.ts
src/MetricsSystem.ts
src/ObjectRenderer.ts
src/Pathfinder.ts
src/ProceduralPatterns.ts
src/Projectile.ts
src/RendererFactory.ts
src/renderers/EnemyRenderer.ts
src/renderers/ProceduralGrass.ts
src/renderers/ProceduralRoad.ts
src/renderers/SpriteProjectileRenderer.ts
src/renderers/TowerRenderer.ts
src/renderers/turrets/FireTurretRenderer.ts
src/renderers/turrets/IceTurretRenderer.ts
src/renderers/turrets/index.ts
src/renderers/turrets/MinigunTurretRenderer.ts
src/renderers/turrets/SniperTurretRenderer.ts
src/renderers/turrets/SplitTurretRenderer.ts
src/renderers/turrets/TurretRenderer.ts
src/renderers/units/BaseSkeletonRenderer.ts
src/renderers/units/CachedUnitRenderer.ts
src/renderers/units/FleshUnitRenderer.ts
src/renderers/units/GoblinUnitRenderer.ts
src/renderers/units/HellhoundUnitRenderer.ts
src/renderers/units/MagmaUnitRenderer.ts
src/renderers/units/OrcUnitRenderer.ts
src/renderers/units/RatUnitRenderer.ts
src/renderers/units/SkeletonBerserkerRenderer.ts
src/renderers/units/SkeletonCommanderUnitRenderer.ts
src/renderers/units/SkeletonMinerRenderer.ts
src/renderers/units/SkeletonUnitRenderer.ts
src/renderers/units/SpiderUnitRenderer.ts
src/renderers/units/TrollUnitRenderer.ts
src/renderers/units/UnitRenderer.ts
src/renderers/units/WraithUnitRenderer.ts
src/SaveManager.ts
src/Scene.ts
src/scenes/EditorScene.ts
src/scenes/EntityManager.ts
src/scenes/GameController.ts
src/scenes/GameScene.ts
src/scenes/GameState.ts
src/scenes/IGameScene.ts
src/scenes/MenuScene.ts
src/scenes/StressTestScene.ts
src/SimplexNoise.ts
src/SoundManager.ts
src/SpatialGrid.ts
src/systems/AcidPuddleSystem.ts
src/systems/AtmosphereSystem.ts
src/systems/LightingSystem.ts
src/systems/NotificationSystem.ts
src/systems/ProjectileSystem.ts
src/systems/SkeletonCommanderSystem.ts
src/systems/TargetingSystem.ts
src/Tower.ts
src/types.ts
src/ui/bestiary/BestiaryUI.ts
src/ui/bestiary/WaveAnalyst.ts
src/ui/DevConsole.ts
src/ui/GameHUD.ts
src/ui/GameOverUI.ts
src/ui/PauseMenu.ts
src/ui/ShopUI.ts
src/ui/TowerMenu.ts
src/UIManager.ts
src/UIRoot.ts
src/UIUtils.ts
src/Utils.ts
src/utils/AssetCache.ts
src/utils/Logger.ts
src/utils/PerformanceMonitor.ts
src/utils/PerformanceProfiler.ts
src/utils/Rng.ts
src/utils/SafeJson.ts
src/utils/SeededRandom.ts
src/utils/SpriteBaker.ts
src/utils/StressLogger.ts
src/VisualConfig.ts
src/vite-env.d.ts
src/WaveEditor.ts
src/WaveManager.ts
src/WeaponSystem.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/cards/CardEvolutions.ts">
/**
 * Card Evolution System ‚Äî DRAMATICALLY DIFFERENT PATHS
 * 
 * Design Philosophy:
 * - Each path is a COMPLETELY different playstyle
 * - Not "slightly better X" but "X vs Y trade-off"
 * - Clear when to pick each path
 */

import { IUpgradeCard } from './CardType';

// ============================================================================
// Evolution Path Metadata
// ============================================================================

export interface IEvolutionPath {
    id: string;
    name: string;
    icon: string;
    description: string;
    playstyle: string;  // One-word descriptor
}

export interface IEvolutionChoice {
    cardTypeId: string;
    sourceLevel: number;
    sourceEvolution?: string;
    pathA: IEvolutionPath;
    pathB: IEvolutionPath;
}

// ============================================================================
// EVOLUTION UPGRADES ‚Äî Dramatic Differences
// ============================================================================

export const EVOLUTION_UPGRADES: Record<string, Record<number, IUpgradeCard>> = {

    // =========================================================================
    // üî• FIRE EVOLUTIONS
    // =========================================================================

    // INFERNO ‚Äî AoE NUKE: Huge splash, slow attack, obliterates groups
    'inferno': {
        2: {
            level: 2,
            modifiers: {
                damage: 35,                    // HIGH burst
                attackSpeedMultiplier: 0.65,   // VERY slow
            },
            effects: [{ type: 'splash', splashRadius: 120 }],  // HUGE AoE
            visualOverrides: { projectileType: 'fire', projectileColor: '#ff3d00' }
        },
    },

    // NAPALM ‚Äî DOT MASTER: Low upfront, massive burn damage
    'napalm': {
        2: {
            level: 2,
            modifiers: {
                damage: 8,                     // LOW upfront
                attackSpeedMultiplier: 1.10,   // FASTER than base!
            },
            effects: [
                { type: 'splash', splashRadius: 35 },
                { type: 'burn', burnDps: 8, burnDuration: 4 }  // 32 total DoT!
            ],
            visualOverrides: { projectileType: 'fire', projectileColor: '#ff9100' }
        },
    },

    // Level 3 from INFERNO
    'meteor': {
        3: {
            level: 3,
            modifiers: {
                damage: 65,                    // MASSIVE
                attackSpeedMultiplier: 0.50,   // VERY slow
            },
            effects: [{ type: 'splash', splashRadius: 160 }],  // GIANT
            visualOverrides: { projectileType: 'fire', projectileColor: '#d50000' }
        },
    },
    'hellfire': {
        3: {
            level: 3,
            modifiers: {
                damage: 40,
                attackSpeedMultiplier: 0.75,
            },
            effects: [
                { type: 'splash', splashRadius: 100 },
                { type: 'explodeOnDeath', explosionDamagePercent: 0.75, explosionRadius: 60 }
            ],
            visualOverrides: { projectileType: 'fire', projectileColor: '#c51162' }
        },
    },

    // Level 3 from NAPALM
    'magma': {
        3: {
            level: 3,
            modifiers: {
                damage: 12,
                attackSpeedMultiplier: 1.0,
            },
            effects: [
                { type: 'splash', splashRadius: 45 },
                { type: 'burn', burnDps: 12, burnDuration: 5 }  // 60 DoT!
            ],
            visualOverrides: { projectileType: 'fire', projectileColor: '#ff6d00' }
        },
    },
    'scorch': {
        3: {
            level: 3,
            modifiers: {
                damage: 5,
                attackSpeedMultiplier: 1.25,   // FAST
            },
            effects: [
                { type: 'splash', splashRadius: 25 },
                { type: 'burn', burnDps: 6, burnDuration: 8 }  // 48 DoT, stacking
            ],
            visualOverrides: { projectileType: 'fire', projectileColor: '#ffab00' }
        },
    },

    // =========================================================================
    // ‚ùÑÔ∏è ICE EVOLUTIONS
    // =========================================================================

    // FROST ‚Äî PURE CONTROL: Maximum slow, zero damage focus
    'frost': {
        2: {
            level: 2,
            modifiers: {
                damage: 0,                     // NO damage bonus
                rangeMultiplier: 0.70,         // Short range
            },
            effects: [{ type: 'slow', slowPower: 0.70, slowDuration: 6 }],  // 70%!
            visualOverrides: { projectileType: 'ice', projectileColor: '#40c4ff' }
        },
    },

    // SHATTER ‚Äî ICE ASSASSIN: Damage dealer with execute
    'shatter': {
        2: {
            level: 2,
            modifiers: {
                damage: 15,                    // HIGH damage
                rangeMultiplier: 1.0,          // Normal range
            },
            effects: [{ type: 'slow', slowPower: 0.25, slowDuration: 2, damageToSlowed: 1.60 }],  // +60%!
            visualOverrides: { projectileType: 'ice', projectileColor: '#18ffff' }
        },
    },

    // Level 3 from FROST
    'absolutezero': {
        3: {
            level: 3,
            modifiers: {
                damage: 0,
                rangeMultiplier: 0.60,
            },
            effects: [{ type: 'slow', slowPower: 0.85, slowDuration: 8 }],  // 85% FROZEN
            visualOverrides: { projectileType: 'ice', projectileColor: '#00b0ff' }
        },
    },
    'blizzard': {
        3: {
            level: 3,
            modifiers: {
                damage: 3,
                rangeMultiplier: 0.75,
            },
            effects: [
                { type: 'slow', slowPower: 0.55, slowDuration: 5 },
                { type: 'chainSlowOnDeath', chainRadius: 100 }  // AoE control
            ],
            visualOverrides: { projectileType: 'ice', projectileColor: '#00e5ff' }
        },
    },

    // Level 3 from SHATTER
    'permafrost': {
        3: {
            level: 3,
            modifiers: {
                damage: 25,
                rangeMultiplier: 1.0,
            },
            effects: [{ type: 'slow', slowPower: 0.30, slowDuration: 2, damageToSlowed: 1.80 }],  // +80%!
            visualOverrides: { projectileType: 'ice', projectileColor: '#64ffda' }
        },
    },
    'glacier': {
        3: {
            level: 3,
            modifiers: {
                damage: 18,
                rangeMultiplier: 1.10,         // Extended range
            },
            effects: [
                { type: 'slow', slowPower: 0.35, slowDuration: 3, damageToSlowed: 1.50 },
                { type: 'chainSlowOnDeath', chainRadius: 70 }
            ],
            visualOverrides: { projectileType: 'ice', projectileColor: '#84ffff' }
        },
    },

    // =========================================================================
    // üéØ SNIPER EVOLUTIONS
    // =========================================================================

    // PRECISION ‚Äî BOSS KILLER: Extreme single-target, very slow
    'precision': {
        2: {
            level: 2,
            modifiers: {
                damage: 40,                    // HIGH
                range: 180,
                attackSpeedMultiplier: 0.25,   // VERY slow
                critChance: 0.30,              // 30% crit
            },
            effects: [],
            visualOverrides: { projectileType: 'sniper', projectileColor: '#76ff03' }
        },
    },

    // PENETRATOR ‚Äî LINE CLEARER: Pierce many, faster shots
    'penetrator': {
        2: {
            level: 2,
            modifiers: {
                damage: 12,                    // Lower per hit
                range: 200,
                attackSpeedMultiplier: 0.55,   // Faster
                critChance: 0.10,
            },
            effects: [{ type: 'pierce', pierceCount: 3, pierceDamageLoss: 0.10 }],
            visualOverrides: { projectileType: 'sniper', projectileColor: '#b2ff59' }
        },
    },

    // Level 3 from PRECISION
    'executor': {
        3: {
            level: 3,
            modifiers: {
                damage: 70,                    // MASSIVE
                range: 220,
                attackSpeedMultiplier: 0.20,   // SNAIL
                critChance: 0.40,              // 40% crit x3.0
            },
            effects: [],
            visualOverrides: { projectileType: 'sniper', projectileColor: '#64dd17' }
        },
    },
    'headhunter': {
        3: {
            level: 3,
            modifiers: {
                damage: 55,
                range: 200,
                attackSpeedMultiplier: 0.30,
                critChance: 0.25,
            },
            effects: [],  // +100% vs >70% HP targets (handled in damage system)
            visualOverrides: { projectileType: 'sniper', projectileColor: '#aeea00' }
        },
    },

    // Level 3 from PENETRATOR
    'railgun': {
        3: {
            level: 3,
            modifiers: {
                damage: 18,
                range: 300,                    // EXTREME range
                attackSpeedMultiplier: 0.50,
                critChance: 0.10,
            },
            effects: [{ type: 'pierce', pierceCount: 6, pierceDamageLoss: 0.05 }],  // Pierce 6!
            visualOverrides: { projectileType: 'sniper', projectileColor: '#eeff41' }
        },
    },
    'marksman': {
        3: {
            level: 3,
            modifiers: {
                damage: 30,
                range: 240,
                attackSpeedMultiplier: 0.45,
                critChance: 0.20,
            },
            effects: [{ type: 'pierce', pierceCount: 4, pierceDamageLoss: 0.08 }],
            visualOverrides: { projectileType: 'sniper', projectileColor: '#c6ff00' }
        },
    },

    // =========================================================================
    // üí• MULTISHOT EVOLUTIONS
    // =========================================================================

    // BARRAGE ‚Äî SPRAY AND PRAY: Many projectiles, wide spread
    'barrage': {
        2: {
            level: 2,
            modifiers: {
                damageMultiplier: 0.40,        // Low per projectile
            },
            effects: [],  // 4 projectiles, 60¬∞ spread
        },
    },

    // SPREAD ‚Äî FOCUSED MULTI: Fewer but stronger projectiles
    'spread': {
        2: {
            level: 2,
            modifiers: {
                damageMultiplier: 0.85,        // High per projectile
            },
            effects: [],  // 2 projectiles, 20¬∞ spread, slight homing
        },
    },

    // Level 3 from BARRAGE
    'storm': {
        3: {
            level: 3,
            modifiers: {
                damageMultiplier: 0.30,
            },
            effects: [],  // 6 projectiles, 90¬∞ spread
        },
    },
    'volley': {
        3: {
            level: 3,
            modifiers: {
                damageMultiplier: 0.45,
                attackSpeedMultiplier: 1.30,   // FAST reload
            },
            effects: [],  // 4 projectiles
        },
    },

    // Level 3 from SPREAD
    'homing': {
        3: {
            level: 3,
            modifiers: {
                damageMultiplier: 0.70,
            },
            effects: [],  // 3 projectiles, full homing
        },
    },
    'twin': {
        3: {
            level: 3,
            modifiers: {
                damageMultiplier: 1.0,         // Full damage each
                attackSpeedMultiplier: 0.80,
            },
            effects: [],  // 2 projectiles, each hits TWICE
        },
    },

    // =========================================================================
    // ‚ö° MINIGUN EVOLUTIONS
    // =========================================================================

    // CHAINGUN ‚Äî QUICK BURSTER: Fast ramp, short sustained
    'chaingun': {
        2: {
            level: 2,
            modifiers: {
                damageMultiplier: 0.60,
                attackSpeedMultiplier: 3.0,    // VERY fast
            },
            effects: [{
                type: 'spinup',
                spinupDamagePerSecond: 8,      // FAST ramp
                maxSpinupSeconds: 3,           // Short window
                overheatDuration: 0.5,         // Quick recovery
            }],
            visualOverrides: { projectileType: 'minigun', projectileColor: '#e0e0e0' }
        },
    },

    // GATLING ‚Äî SUSTAINED BEAST: Slow ramp, massive sustained
    'gatling': {
        2: {
            level: 2,
            modifiers: {
                damageMultiplier: 0.55,
                attackSpeedMultiplier: 2.60,
            },
            effects: [{
                type: 'spinup',
                spinupDamagePerSecond: 4,      // Slow ramp
                maxSpinupSeconds: 10,          // LONG sustain!
                overheatDuration: 2.5,         // Painful recovery
            }],
            visualOverrides: { projectileType: 'minigun', projectileColor: '#bdbdbd' }
        },
    },

    // Level 3 from CHAINGUN
    'autocannon': {
        3: {
            level: 3,
            modifiers: {
                damageMultiplier: 0.75,
                attackSpeedMultiplier: 2.8,
            },
            effects: [{
                type: 'spinup',
                spinupDamagePerSecond: 6,
                maxSpinupSeconds: 999,         // NO OVERHEAT!
                overheatDuration: 0,
            }],
            visualOverrides: { projectileType: 'minigun', projectileColor: '#90a4ae' }
        },
    },
    'rotary': {
        3: {
            level: 3,
            modifiers: {
                damageMultiplier: 0.55,
                attackSpeedMultiplier: 3.5,    // INSANE speed
            },
            effects: [{
                type: 'spinup',
                spinupDamagePerSecond: 10,     // FAST ramp
                spinupCritPerSecond: 0.05,     // 5% crit per second!
                maxSpinupSeconds: 2.5,
                overheatDuration: 0.3,
            }],
            visualOverrides: { projectileType: 'minigun', projectileColor: '#ff8a80' }
        },
    },

    // Level 3 from GATLING
    'devastator': {
        3: {
            level: 3,
            modifiers: {
                damageMultiplier: 0.70,
                attackSpeedMultiplier: 2.5,
            },
            effects: [{
                type: 'spinup',
                spinupSteps: [
                    { threshold: 2, damage: 10 },
                    { threshold: 4, damage: 25 },
                    { threshold: 6, damage: 45 },
                    { threshold: 8, damage: 70 },
                    { threshold: 10, damage: 100 },  // MASSIVE at max
                ],
                spinupCritPerSecond: 0.02,
                maxSpinupSeconds: 12,
                overheatDuration: 4,
            }],
            visualOverrides: { projectileType: 'minigun', projectileColor: '#ffab40' }
        },
    },
    'suppressor': {
        3: {
            level: 3,
            modifiers: {
                damageMultiplier: 0.60,
                attackSpeedMultiplier: 2.8,
            },
            effects: [{
                type: 'spinup',
                spinupDamagePerSecond: 5,
                maxSpinupSeconds: 8,
                overheatDuration: 2,
                // At max spinup: 20% slow to targets (handled in damage system)
            }],
            visualOverrides: { projectileType: 'minigun', projectileColor: '#ce93d8' }
        },
    },
};

// ============================================================================
// Evolution Choice Registry
// ============================================================================

export const EVOLUTION_CHOICES: IEvolutionChoice[] = [
    // === FIRE ===
    {
        cardTypeId: 'fire',
        sourceLevel: 1,
        pathA: { id: 'inferno', name: '–ò–Ω—Ñ–µ—Ä–Ω–æ', icon: 'üåã', description: '–û–≥—Ä–æ–º–Ω—ã–π AoE –≤–∑—Ä—ã–≤', playstyle: '–ù–Æ–ö–ê' },
        pathB: { id: 'napalm', name: '–ù–∞–ø–∞–ª–º', icon: 'üî•', description: '–ì–æ—Ä–µ–Ω–∏–µ 32 —É—Ä–æ–Ω–∞', playstyle: 'DOT' },
    },
    {
        cardTypeId: 'fire',
        sourceLevel: 2,
        sourceEvolution: 'inferno',
        pathA: { id: 'meteor', name: '–ú–µ—Ç–µ–æ—Ä', icon: '‚òÑÔ∏è', description: '–ì–∏–≥–∞–Ω—Ç—Å–∫–∏–π –≤–∑—Ä—ã–≤ 160px', playstyle: 'MEGA' },
        pathB: { id: 'hellfire', name: '–ê–¥—Å–∫–æ–µ –ø–ª–∞–º—è', icon: 'üëπ', description: '–í—Ä–∞–≥–∏ –≤–∑—Ä—ã–≤–∞—é—Ç—Å—è', playstyle: 'CHAIN' },
    },
    {
        cardTypeId: 'fire',
        sourceLevel: 2,
        sourceEvolution: 'napalm',
        pathA: { id: 'magma', name: '–ú–∞–≥–º–∞', icon: 'üåä', description: '60 DoT —É—Ä–æ–Ω–∞', playstyle: 'BURN' },
        pathB: { id: 'scorch', name: '–í—ã–∂–∏–≥–∞–Ω–∏–µ', icon: 'üî•', description: '–ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞–∫–∞—é—â–∏–π—Å—è DoT', playstyle: 'STACK' },
    },

    // === ICE ===
    {
        cardTypeId: 'ice',
        sourceLevel: 1,
        pathA: { id: 'frost', name: '–ú–æ—Ä–æ–∑', icon: '‚ùÑÔ∏è', description: '70% –∑–∞–º–µ–¥–ª–µ–Ω–∏–µ', playstyle: '–ö–û–ù–¢–†–û–õ–¨' },
        pathB: { id: 'shatter', name: '–†–∞—Å–∫–æ–ª', icon: 'üíé', description: '+60% —É—Ä–æ–Ω –ø–æ slow', playstyle: '–£–ë–ò–ô–¶–ê' },
    },
    {
        cardTypeId: 'ice',
        sourceLevel: 2,
        sourceEvolution: 'frost',
        pathA: { id: 'absolutezero', name: '–ê–±—Å. –ù–æ–ª—å', icon: 'üßä', description: '85% –°–¢–û–ü', playstyle: 'FREEZE' },
        pathB: { id: 'blizzard', name: '–ë—É—Ä–∞–Ω', icon: 'üå®Ô∏è', description: '–¶–µ–ø–Ω–æ–π slow', playstyle: 'AOE CC' },
    },
    {
        cardTypeId: 'ice',
        sourceLevel: 2,
        sourceEvolution: 'shatter',
        pathA: { id: 'permafrost', name: '–í–µ—á–Ω–∞—è –º–µ—Ä–∑–ª–æ—Ç–∞', icon: 'üí†', description: '+80% —É—Ä–æ–Ω!', playstyle: 'EXECUTE' },
        pathB: { id: 'glacier', name: '–õ–µ–¥–Ω–∏–∫', icon: 'üèîÔ∏è', description: '–î–∞–ª—å–Ω–æ—Å—Ç—å + chain', playstyle: 'HYBRID' },
    },

    // === SNIPER ===
    {
        cardTypeId: 'sniper',
        sourceLevel: 1,
        pathA: { id: 'precision', name: '–¢–æ—á–Ω–æ—Å—Ç—å', icon: 'üéØ', description: '30% –∫—Ä–∏—Ç, –º–µ–¥–ª–µ–Ω–Ω–æ', playstyle: '–ë–û–°–°' },
        pathB: { id: 'penetrator', name: '–ü—Ä–æ–±–∏–≤–∞–Ω–∏–µ', icon: 'üî´', description: 'Pierce 3 –≤—Ä–∞–≥–æ–≤', playstyle: '–õ–ò–ù–ò–Ø' },
    },
    {
        cardTypeId: 'sniper',
        sourceLevel: 2,
        sourceEvolution: 'precision',
        pathA: { id: 'executor', name: '–ü–∞–ª–∞—á', icon: '‚öîÔ∏è', description: '40% –∫—Ä–∏—Ç x3.0', playstyle: 'DELETE' },
        pathB: { id: 'headhunter', name: '–û—Ö–æ—Ç–Ω–∏–∫', icon: 'üé≠', description: '+100% vs –∑–¥–æ—Ä–æ–≤—ã—Ö', playstyle: 'PRIORITY' },
    },
    {
        cardTypeId: 'sniper',
        sourceLevel: 2,
        sourceEvolution: 'penetrator',
        pathA: { id: 'railgun', name: '–†–µ–ª—å—Å–æ—Ç—Ä–æ–Ω', icon: '‚ö°', description: 'Pierce 6, –¥–∞–ª—å–Ω–æ—Å—Ç—å', playstyle: 'LASER' },
        pathB: { id: 'marksman', name: '–°—Ç—Ä–µ–ª–æ–∫', icon: 'üèπ', description: 'Pierce 4 + –∫—Ä–∏—Ç', playstyle: 'BALANCED' },
    },

    // === MULTISHOT ===
    {
        cardTypeId: 'multi',
        sourceLevel: 1,
        pathA: { id: 'barrage', name: '–®–∫–≤–∞–ª', icon: 'üí•', description: '4 —Å–Ω–∞—Ä—è–¥–∞, –≤–µ–µ—Ä', playstyle: 'SPREAD' },
        pathB: { id: 'spread', name: '–†–∞—Å—Å–µ–∏–≤–∞–Ω–∏–µ', icon: 'üéØ', description: '2 –º–æ—â–Ω—ã—Ö —Å–Ω–∞—Ä—è–¥–∞', playstyle: 'FOCUS' },
    },
    {
        cardTypeId: 'multi',
        sourceLevel: 2,
        sourceEvolution: 'barrage',
        pathA: { id: 'storm', name: '–®—Ç–æ—Ä–º', icon: 'üå™Ô∏è', description: '6 —Å–Ω–∞—Ä—è–¥–æ–≤!', playstyle: 'CHAOS' },
        pathB: { id: 'volley', name: '–ó–∞–ª–ø', icon: 'üéÜ', description: '–ë—ã—Å—Ç—Ä–∞—è –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞', playstyle: 'SPAM' },
    },
    {
        cardTypeId: 'multi',
        sourceLevel: 2,
        sourceEvolution: 'spread',
        pathA: { id: 'homing', name: '–°–∞–º–æ–Ω–∞–≤–µ–¥–µ–Ω–∏–µ', icon: 'üéØ', description: '3 –Ω–∞–≤–æ–¥—è—â–∏—Ö—Å—è', playstyle: 'TRACK' },
        pathB: { id: 'twin', name: '–ë–ª–∏–∑–Ω–µ—Ü—ã', icon: 'üëØ', description: '2 x –¥–≤–æ–π–Ω–æ–π —É–¥–∞—Ä', playstyle: 'DOUBLE' },
    },

    // === MINIGUN ===
    {
        cardTypeId: 'minigun',
        sourceLevel: 1,
        pathA: { id: 'chaingun', name: '–¶–µ–ø–Ω–∞—è –ø—É—à–∫–∞', icon: '‚ö°', description: '–ë—ã—Å—Ç—Ä—ã–π —Ä–∞–∑–≥–æ–Ω 3—Å', playstyle: 'BURST' },
        pathB: { id: 'gatling', name: '–ì–∞—Ç–ª–∏–Ω–≥', icon: 'üí™', description: '–î–æ–ª–≥–∏–π –æ–≥–æ–Ω—å 10—Å', playstyle: 'SUSTAIN' },
    },
    {
        cardTypeId: 'minigun',
        sourceLevel: 2,
        sourceEvolution: 'chaingun',
        pathA: { id: 'autocannon', name: '–ê–≤—Ç–æ–ø—É—à–∫–∞', icon: 'üîß', description: '–ë–ï–ó –ø–µ—Ä–µ–≥—Ä–µ–≤–∞!', playstyle: 'INFINITE' },
        pathB: { id: 'rotary', name: '–†–æ—Ç–æ—Ä', icon: 'üåÄ', description: '3.5x —Å–∫–æ—Ä–æ—Å—Ç—å + –∫—Ä–∏—Ç', playstyle: 'SPEED' },
    },
    {
        cardTypeId: 'minigun',
        sourceLevel: 2,
        sourceEvolution: 'gatling',
        pathA: { id: 'devastator', name: '–û–ø—É—Å—Ç–æ—à–∏—Ç–µ–ª—å', icon: 'üíÄ', description: '+100 —É—Ä–æ–Ω –Ω–∞ –º–∞–∫—Å', playstyle: 'RAMPAGE' },
        pathB: { id: 'suppressor', name: '–ü–æ–¥–∞–≤–∏—Ç–µ–ª—å', icon: 'üõ°Ô∏è', description: 'Slow –Ω–∞ –º–∞–∫—Å —Ä–∞–∑–≥–æ–Ω–µ', playstyle: 'CONTROL' },
    },
];

// ============================================================================
// Display Config for Cards
// ============================================================================

export const EVOLUTION_STATS_DISPLAY: Record<string, { primary: string; secondary: string; color: string }> = {
    // Fire
    'inferno': { primary: 'üí• x120 AoE', secondary: '-35% —Å–∫–æ—Ä–æ—Å—Ç—å', color: '#ff3d00' },
    'napalm': { primary: 'üî• 32 DoT', secondary: '+10% —Å–∫–æ—Ä–æ—Å—Ç—å', color: '#ff9100' },
    'meteor': { primary: '‚òÑÔ∏è x160 MEGA', secondary: '-50% —Å–∫–æ—Ä–æ—Å—Ç—å', color: '#d50000' },
    'hellfire': { primary: 'üëπ –í–∑—Ä—ã–≤', secondary: '75% —É—Ä–æ–Ω–∞', color: '#c51162' },
    'magma': { primary: 'üåä 60 DoT', secondary: '12 dps x 5s', color: '#ff6d00' },
    'scorch': { primary: 'üî• –°–¢–ê–ö–ò', secondary: '+25% —Å–∫–æ—Ä–æ—Å—Ç—å', color: '#ffab00' },

    // Ice
    'frost': { primary: '‚ùÑÔ∏è 70% –°–¢–û–ü', secondary: '0 —É—Ä–æ–Ω–∞', color: '#40c4ff' },
    'shatter': { primary: 'üíé +60%', secondary: 'vs –∑–∞–º–µ–¥–ª.', color: '#18ffff' },
    'absolutezero': { primary: 'üßä 85% FREEZE', secondary: '0 —É—Ä–æ–Ω–∞', color: '#00b0ff' },
    'blizzard': { primary: 'üå®Ô∏è –¶–µ–ø—å', secondary: '100px —Ä–∞–¥–∏—É—Å', color: '#00e5ff' },
    'permafrost': { primary: 'üí† +80%!', secondary: '–ö–∞–∑–Ω—å –≤—Ä–∞–≥–æ–≤', color: '#64ffda' },
    'glacier': { primary: 'üèîÔ∏è –î–∞–ª—å–Ω–æ—Å—Ç—å', secondary: '+10% range', color: '#84ffff' },

    // Sniper
    'precision': { primary: 'üéØ 30% –∫—Ä–∏—Ç', secondary: 'x2.5 –º–Ω–æ–∂–∏—Ç–µ–ª—å', color: '#76ff03' },
    'penetrator': { primary: 'üî´ Pierce 3', secondary: '-10% –∑–∞ —Ü–µ–ª—å', color: '#b2ff59' },
    'executor': { primary: '‚öîÔ∏è 40% –∫—Ä–∏—Ç', secondary: 'x3.0 DELETE', color: '#64dd17' },
    'headhunter': { primary: 'üé≠ +100%', secondary: 'vs >70% HP', color: '#aeea00' },
    'railgun': { primary: '‚ö° Pierce 6', secondary: '300 range', color: '#eeff41' },
    'marksman': { primary: 'üèπ Pierce 4', secondary: '20% –∫—Ä–∏—Ç', color: '#c6ff00' },

    // Multishot
    'barrage': { primary: 'üí• 4 —Å–Ω–∞—Ä—è–¥–∞', secondary: '60¬∞ –≤–µ–µ—Ä', color: '#ea80fc' },
    'spread': { primary: 'üéØ 2 –º–æ—â–Ω—ã—Ö', secondary: '85% —É—Ä–æ–Ω', color: '#b388ff' },
    'storm': { primary: 'üå™Ô∏è 6 —Å–Ω–∞—Ä—è–¥–æ–≤', secondary: '90¬∞ —Ö–∞–æ—Å', color: '#e040fb' },
    'volley': { primary: 'üéÜ +30% APS', secondary: '4 —Å–Ω–∞—Ä—è–¥–∞', color: '#d500f9' },
    'homing': { primary: 'üéØ –ù–∞–≤–µ–¥–µ–Ω–∏–µ', secondary: '3 —Å–Ω–∞—Ä—è–¥–∞', color: '#7c4dff' },
    'twin': { primary: 'üëØ x2 —É–¥–∞—Ä', secondary: '100% —É—Ä–æ–Ω', color: '#651fff' },

    // Minigun
    'chaingun': { primary: '‚ö° 3—Å –æ–≥–æ–Ω—å', secondary: '+8 dps/—Å', color: '#e0e0e0' },
    'gatling': { primary: 'üí™ 10—Å –æ–≥–æ–Ω—å', secondary: '+4 dps/—Å', color: '#bdbdbd' },
    'autocannon': { primary: 'üîß ‚àû –û–ì–û–ù–¨', secondary: '–ë–µ–∑ –ø–µ—Ä–µ–≥—Ä–µ–≤–∞', color: '#90a4ae' },
    'rotary': { primary: 'üåÄ x3.5 speed', secondary: '+5% –∫—Ä–∏—Ç/—Å', color: '#ff8a80' },
    'devastator': { primary: 'üíÄ +100 —É—Ä–æ–Ω', secondary: '–ù–∞ –º–∞–∫—Å', color: '#ffab40' },
    'suppressor': { primary: 'üõ°Ô∏è 20% slow', secondary: '–ù–∞ –º–∞–∫—Å', color: '#ce93d8' },
};

// ============================================================================
// Helper Functions
// ============================================================================

export function getEvolutionChoice(cardTypeId: string, sourceLevel: number, sourceEvolution?: string): IEvolutionChoice | null {
    const evo = sourceEvolution || 'classic';

    return EVOLUTION_CHOICES.find(choice =>
        choice.cardTypeId === cardTypeId &&
        choice.sourceLevel === sourceLevel &&
        (choice.sourceEvolution === undefined || choice.sourceEvolution === evo)
    ) || null;
}

export function getEvolutionUpgrade(evolutionPath: string | undefined, level: number): IUpgradeCard | null {
    if (!evolutionPath || evolutionPath === 'classic') {
        return null;
    }
    return EVOLUTION_UPGRADES[evolutionPath]?.[level] || null;
}

export function getEvolutionMeta(evolutionPath: string): IEvolutionPath | null {
    for (const choice of EVOLUTION_CHOICES) {
        if (choice.pathA.id === evolutionPath) return choice.pathA;
        if (choice.pathB.id === evolutionPath) return choice.pathB;
    }
    return null;
}

export function getEvolutionDisplay(evolutionPath: string): { primary: string; secondary: string; color: string } | null {
    return EVOLUTION_STATS_DISPLAY[evolutionPath] || null;
}
</file>

<file path="src/config/Levels.ts">
export const ECONOMY_CONFIG = {
    WAVE_CLEAR_REWARD: 2,
    WAVE_BASE_REWARD: 20,          // NEW: Base reward for completing a wave
    WAVE_SCALING_FACTOR: 2,        // NEW: Additional reward per wave number (+2 per wave)
    DROP_CHANCE: 0.15,
    EARLY_WAVE_BONUS: 15,          // Reduced from 30 to 15
    PERFECT_WAVE_BONUS: 10,        // NEW: Bonus for no enemy leaks
    TOWER_COST: 55,
    FORGE_COST_LVL1: 50,           // LVL1‚Üí2 forge cost
    FORGE_COST_LVL2: 65,           // LVL2‚Üí3 forge cost (was FORGE_COST: 50)
    SHOP_COST: 100,
    SHOP_REROLL_COST: 25,          // Increased from 15 to 25
    SELL_REFUND: 0.5,
    CARD_SELL_PRICES: [0, 5, 10, 25], // Index = level (0 unused, 1-3 are actual prices)
};

export const WAVE_CONFIG = [
    // –í–æ–ª–Ω–∞ 1: –û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
    {
        enemies: [
            { type: 'GRUNT', count: 10, spawnPattern: 'normal' }
        ]
    },
    // –í–æ–ª–Ω–∞ 2: –†–∞–Ω–¥–æ–º–Ω—ã–π —Ä–µ–∂–∏–º –¥–ª—è –Ω–µ–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ—Å—Ç–∏
    {
        enemies: [
            { type: 'SCOUT', count: 12, spawnPattern: 'random' }
        ]
    },
    // –í–æ–ª–Ω–∞ 3: –ö–æ–º–±–∏–Ω–∞—Ü–∏—è –æ–±—ã—á–Ω–æ–≥–æ –∏ —Ä–æ—è
    {
        enemies: [
            { type: 'GRUNT', count: 15, spawnPattern: 'normal' },
            { type: 'TANK', count: 2, spawnPattern: 'normal' }
        ]
    },
    // –í–æ–ª–Ω–∞ 4: –†–æ–π —Å–∫–∞—É—Ç–æ–≤ + —Ç–∞–Ω–∫–∏ —Ä–∞–Ω–¥–æ–º–Ω–æ
    {
        enemies: [
            { type: 'SCOUT', count: 20, spawnPattern: 'swarm' },
            { type: 'TANK', count: 3, spawnPattern: 'random' }
        ]
    },
    // –í–æ–ª–Ω–∞ 5: –§–∏–Ω–∞–ª—å–Ω–∞—è –≤–æ–ª–Ω–∞ —Å –±–æ—Å—Å–æ–º
    {
        enemies: [
            { type: 'GRUNT', count: 25, spawnPattern: 'random' },
            { type: 'BOSS', count: 1, spawnPattern: 'normal' }
        ]
    }
];
</file>

<file path="src/design/borders.ts">
/**
 * UI Design Tokens - Borders
 * Border radius, width, and style definitions
 */

export const UI_BORDERS = {
    radius: {
        none: '0',
        sm: '4px',
        md: '8px',
        lg: '12px',
        xl: '16px',
        full: '9999px'
    },

    width: {
        none: '0',
        thin: '1px',
        normal: '2px',
        thick: '3px',
        bold: '4px'
    },

    style: {
        solid: 'solid',
        dashed: 'dashed',
        dotted: 'dotted'
    }
} as const;
</file>

<file path="src/design/colors.ts">
/**
 * UI Design Tokens - Color System
 * Centralized color definitions for consistent theming
 */

export const UI_COLORS = {
    // Primary palette
    primary: '#00ffff',      // Cyan - –¥–ª—è –∞–∫—Ü–µ–Ω—Ç–æ–≤, –≤—ã–±–æ—Ä–∞
    secondary: '#ff6b6b',    // Coral Red
    success: '#4caf50',      // Green
    warning: '#ff9800',      // Orange
    danger: '#f44336',       // Red
    info: '#2196f3',         // Blue

    // Glass-morphism effects
    glass: {
        bg: 'rgba(30, 30, 40, 0.85)',
        bgLight: 'rgba(30, 30, 40, 0.6)',
        bgDark: 'rgba(20, 20, 30, 0.95)',
        border: 'rgba(255, 255, 255, 0.1)',
        borderHover: 'rgba(255, 255, 255, 0.2)',
        shadow: '0 8px 32px rgba(0, 0, 0, 0.3)'
    },

    // Text colors
    text: {
        primary: '#ffffff',
        secondary: '#b0b0b0',
        disabled: '#666666',
        hint: '#888888'
    },

    // Neutral palette (–¥–ª—è –∫–Ω–æ–ø–æ–∫, —Ñ–æ–Ω–æ–≤)
    neutral: {
        dark: '#222',
        medium: '#333',
        light: '#555',
        lighter: '#777'
    },

    // Overlays
    overlay: 'rgba(0, 0, 0, 0.8)',
    overlayLight: 'rgba(0, 0, 0, 0.4)',
} as const;
</file>

<file path="src/design/fonts.ts">
/**
 * UI Design Tokens - Typography
 * Font family, size, and weight definitions
 */

export const UI_FONTS = {
    family: {
        primary: 'Segoe UI, sans-serif',
        mono: 'Consolas, monospace'
    },

    size: {
        xs: '11px',
        sm: '12px',
        md: '14px',
        lg: '16px',
        xl: '20px',
        xxl: '24px',
        huge: '42px',
        massive: '60px'
    },

    weight: {
        normal: '400',
        medium: '500',
        bold: '700'
    }
} as const;
</file>

<file path="src/design/index.ts">
/**
 * Design System - Main Export
 * Centralizes all UI design tokens
 */

export { UI_COLORS } from './colors';
export { UI_SPACING, getSpacing } from './spacing';
export { UI_TRANSITIONS, getTransition } from './transitions';
export { UI_BORDERS } from './borders';
export { UI_SHADOWS } from './shadows';
export { UI_FONTS } from './fonts';

// Re-export as single UI object for convenience
import { UI_COLORS } from './colors';
import { UI_SPACING } from './spacing';
import { UI_TRANSITIONS } from './transitions';
import { UI_BORDERS } from './borders';
import { UI_SHADOWS } from './shadows';
import { UI_FONTS } from './fonts';

export const UI = {
    COLORS: UI_COLORS,
    SPACING: UI_SPACING,
    TRANSITIONS: UI_TRANSITIONS,
    BORDERS: UI_BORDERS,
    SHADOWS: UI_SHADOWS,
    FONTS: UI_FONTS
} as const;
</file>

<file path="src/design/shadows.ts">
/**
 * UI Design Tokens - Shadows
 * Box shadow definitions for depth
 */

export const UI_SHADOWS = {
    none: 'none',
    sm: '0 2px 4px rgba(0, 0, 0, 0.1)',
    md: '0 4px 8px rgba(0, 0, 0, 0.2)',
    lg: '0 8px 16px rgba(0, 0, 0, 0.3)',
    xl: '0 12px 24px rgba(0, 0, 0, 0.4)',
    glass: '0 8px 32px rgba(0, 0, 0, 0.3)',

    // Glow effects
    glow: {
        primary: '0 4px 15px rgba(0, 255, 255, 0.4)',
        success: '0 4px 15px rgba(76, 175, 80, 0.4)',
        danger: '0 4px 15px rgba(211, 47, 47, 0.5)'
    }
} as const;
</file>

<file path="src/design/spacing.ts">
/**
 * UI Design Tokens - Spacing System
 * Consistent spacing scale for layouts
 */

export const UI_SPACING = {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
    xxl: 48
} as const;

// Helper function
export const getSpacing = (size: keyof typeof UI_SPACING): string => {
    return `${UI_SPACING[size]}px`;
};
</file>

<file path="src/design/transitions.ts">
/**
 * UI Design Tokens - Transitions
 * Standard animation timings and easing curves
 */

export const UI_TRANSITIONS = {
    // Duration values
    duration: {
        instant: '0ms',
        fast: '150ms',
        normal: '300ms',
        slow: '500ms'
    },

    // Easing curves (Material Design)
    easing: {
        standard: 'cubic-bezier(0.4, 0, 0.2, 1)',
        decelerate: 'cubic-bezier(0.0, 0, 0.2, 1)',
        accelerate: 'cubic-bezier(0.4, 0, 1, 1)',
        sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
    },

    // Preset combinations (duration + easing)
    presets: {
        fast: '150ms cubic-bezier(0.4, 0, 0.2, 1)',
        normal: '300ms cubic-bezier(0.4, 0, 0.2, 1)',
        slow: '500ms cubic-bezier(0.4, 0, 0.2, 1)'
    }
} as const;

// Helper function
export const getTransition = (preset: keyof typeof UI_TRANSITIONS.presets): string => {
    return UI_TRANSITIONS.presets[preset];
};
</file>

<file path="src/editor/components/BaseComponent.ts">
/**
 * Abstract base class for UI components.
 * enforcing a standard lifecycle: constructor -> mount -> render -> partial updates -> destroy.
 */
export abstract class BaseComponent<T = any> {
    protected element: HTMLElement;
    protected parent: HTMLElement | null = null;
    protected data: T;

    constructor(data: T) {
        this.data = data;
        this.element = this.createRootElement();
    }

    /**
     * Creates the main container for this component.
     * Override this to customize the tag and classes.
     */
    protected createRootElement(): HTMLElement {
        return document.createElement('div');
    }

    /**
     * Mounts the component to a parent element.
     */
    public mount(parent: HTMLElement): void {
        this.parent = parent;
        this.parent.appendChild(this.element);
        this.render();
    }

    /**
     * Renders the component content.
     * Should be idempotent or handle clearing.
     */
    public abstract render(): void;

    /**
     * Cleanup listeners and remove from DOM.
     */
    public destroy(): void {
        if (this.parent && this.element.parentNode === this.parent) {
            this.parent.removeChild(this.element);
        }
        this.element.innerHTML = '';
        this.parent = null;
    }

    // --- Helpers ---

    protected createElement<K extends keyof HTMLElementTagNameMap>(
        tag: K,
        className?: string,
        text?: string
    ): HTMLElementTagNameMap[K] {
        const el = document.createElement(tag);
        if (className) el.className = className;
        if (text) el.textContent = text;
        return el;
    }
}
</file>

<file path="src/editor/components/SpawnTimingControl.ts">
import { BaseComponent } from './BaseComponent';

interface SpawnTimingProps {
    value: number;
    min: number;
    max: number;
    step: number;
    label: string;
    suffix: string;
    onChange: (value: number) => void;
}

/**
 * Reusable range slider + number input for precise numeric control.
 * Both inputs stay synchronized.
 */
export class SpawnTimingControl extends BaseComponent<SpawnTimingProps> {

    protected createRootElement(): HTMLElement {
        return this.createElement('div', 'we-timing-control');
    }

    public render(): void {
        this.element.innerHTML = '';

        // Label
        const label = this.createElement('span', 'we-timing-label', this.data.label);
        this.element.appendChild(label);

        // Range slider
        const range = document.createElement('input');
        range.type = 'range';
        range.min = this.data.min.toString();
        range.max = this.data.max.toString();
        range.step = this.data.step.toString();
        range.value = this.data.value.toString();
        range.className = 'we-timing-range';

        // Number input
        const numInput = document.createElement('input');
        numInput.type = 'number';
        numInput.min = this.data.min.toString();
        numInput.max = this.data.max.toString();
        numInput.step = this.data.step.toString();
        numInput.value = this.data.value.toString();
        numInput.className = 'we-timing-number';

        // Suffix
        const suffix = this.createElement('span', 'we-timing-suffix', this.data.suffix);

        // Synchronize both controls
        // IMPORTANT: use onchange (not oninput) on range to avoid flooding undo stack
        range.onchange = () => {
            const val = parseFloat(range.value);
            numInput.value = val.toString();
            this.data.onChange(val);
        };

        // Live visual feedback while dragging (doesn't trigger onChange/history)
        range.oninput = () => {
            numInput.value = range.value;
        };

        numInput.onchange = () => {
            let val = parseFloat(numInput.value) || this.data.min;
            val = Math.max(this.data.min, Math.min(this.data.max, val));
            numInput.value = val.toString();
            range.value = val.toString();
            this.data.onChange(val);
        };

        this.element.appendChild(range);
        this.element.appendChild(numInput);
        this.element.appendChild(suffix);
    }
}
</file>

<file path="src/editor/components/ThreatMeter.ts">
import { BaseComponent } from './BaseComponent';
import { ThreatService } from '../ThreatService';

interface ThreatMeterProps {
    threat: number;
}

export class ThreatMeter extends BaseComponent<ThreatMeterProps> {
    private fillElement!: HTMLElement;
    private badgeElement!: HTMLElement;

    protected createRootElement(): HTMLElement {
        const container = document.createElement('div');
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.gap = '8px';
        return container;
    }

    public render(): void {
        this.element.innerHTML = '';

        // Create Badge
        const color = ThreatService.getThreatColor(this.data.threat);
        const label = ThreatService.getThreatLabel(this.data.threat);

        this.badgeElement = this.createElement('span', 'we-threat-badge', label);
        this.badgeElement.style.color = color;
        this.badgeElement.style.border = `1px solid ${color}`;
        this.element.appendChild(this.badgeElement);

        // Create Wrapper for Bar
        const barWrapper = this.createElement('div', 'we-threat-meter');
        barWrapper.style.flex = '1';

        // Create Fill
        this.fillElement = this.createElement('div', 'we-threat-fill');
        this.updateFill(this.data.threat);

        barWrapper.appendChild(this.fillElement);
        this.element.appendChild(barWrapper);

        // Value Text
        const valueText = this.createElement('span', '', Math.round(this.data.threat).toString());
        valueText.style.fontSize = '11px';
        valueText.style.color = '#aaa';
        this.element.appendChild(valueText);
    }

    public update(threat: number) {
        this.data.threat = threat;
        const color = ThreatService.getThreatColor(threat);
        const label = ThreatService.getThreatLabel(threat);

        if (this.badgeElement) {
            this.badgeElement.textContent = label;
            this.badgeElement.style.color = color;
            this.badgeElement.style.border = `1px solid ${color}`;
        }

        this.updateFill(threat);

        // Update number
        if (this.element.lastElementChild) {
            this.element.lastElementChild.textContent = Math.round(threat).toString();
        }
    }

    private updateFill(threat: number) {
        if (!this.fillElement) return;

        const color = ThreatService.getThreatColor(threat);
        // Normalize 0-3000 to 0-100%
        const percentage = Math.min(100, Math.max(5, (threat / 2500) * 100));

        this.fillElement.style.width = `${percentage}%`;
        this.fillElement.style.backgroundColor = color;
        this.fillElement.style.boxShadow = `0 0 10px ${color}`;
    }
}
</file>

<file path="src/editor/components/ValidationPanel.ts">
import { BaseComponent } from './BaseComponent';
import { IValidationResult } from '../WaveModel';

export class ValidationPanel extends BaseComponent<IValidationResult | null> {
    public render(): void {
        this.element.innerHTML = '';
        this.element.className = 'we-validation-panel';

        if (!this.data) {
            this.element.style.display = 'none';
            return;
        }

        const { isValid, errors, warnings } = this.data;

        if (errors.length === 0 && warnings.length === 0) {
            this.element.style.display = 'none';
            return;
        }

        this.element.style.display = 'flex';
        this.element.style.flexDirection = 'column';
        this.element.style.gap = '4px';
        this.element.style.padding = '8px';
        this.element.style.margin = '8px';
        this.element.style.borderRadius = '4px';
        this.element.style.fontSize = '12px';

        if (errors.length > 0) {
            this.element.style.background = 'rgba(244, 67, 54, 0.2)';
            this.element.style.border = '1px solid rgba(244, 67, 54, 0.5)';
        } else {
            this.element.style.background = 'rgba(255, 152, 0, 0.2)';
            this.element.style.border = '1px solid rgba(255, 152, 0, 0.5)';
        }

        [...errors, ...warnings].forEach(msg => {
            const isError = errors.includes(msg);
            const item = this.createElement('div', isError ? 'we-validation-error' : 'we-validation-warning');
            item.style.color = isError ? '#ff8a80' : '#ffd180';

            let text = '';
            if (msg.waveIndex >= 0) {
                text += `–í–æ–ª–Ω–∞ ${msg.waveIndex + 1}`;
                if (msg.groupIndex !== undefined) {
                    text += `, –ì—Ä—É–ø–ø–∞ ${msg.groupIndex + 1}`;
                }
                text += ': ';
            }
            text += msg.message;
            if (msg.field) {
                text += ` [${msg.field}]`;
            }
            item.textContent = (isError ? 'üî¥ ' : 'üü° ') + text;
            this.element.appendChild(item);
        });
    }

    public updateResult(result: IValidationResult) {
        this.data = result;
        this.render();
    }
}
</file>

<file path="src/editor/components/WavePresetPanel.ts">
import { BaseComponent } from './BaseComponent';
import { WaveModel } from '../WaveModel';
import { getBuiltinPresets, loadCustomPresets, saveCustomPreset, deleteCustomPreset, IWavePreset } from '../WavePresets';

export class WavePresetPanel extends BaseComponent<WaveModel> {
    private select!: HTMLSelectElement;

    protected createRootElement(): HTMLElement {
        const el = document.createElement('div');
        el.className = 'we-preset-panel';
        return el;
    }

    public render(): void {
        this.element.innerHTML = '';
        this.element.style.display = 'flex';
        this.element.style.gap = '8px';
        this.element.style.alignItems = 'center';
        this.element.style.padding = '8px 16px';
        this.element.style.background = 'rgba(0, 0, 0, 0.2)';
        this.element.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';

        const builtinPresets = getBuiltinPresets();
        let customPresets = loadCustomPresets();

        this.select = this.createElement('select', 'we-settings-input') as HTMLSelectElement;
        this.select.style.flex = '1';

        const defaultOption = this.createElement('option', '', '–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ—Å–µ—Ç...');
        defaultOption.value = '';
        this.select.appendChild(defaultOption);

        const builtinGroup = this.createElement('optgroup') as HTMLOptGroupElement;
        builtinGroup.label = '–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ';
        builtinPresets.forEach(p => {
            const option = this.createElement('option', '', `${p.name} ‚Äî ${p.description}`);
            option.value = p.id;
            builtinGroup.appendChild(option);
        });
        this.select.appendChild(builtinGroup);

        if (customPresets.length > 0) {
            const customGroup = this.createElement('optgroup') as HTMLOptGroupElement;
            customGroup.label = '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ';
            customPresets.forEach(p => {
                const option = this.createElement('option', '', `${p.name} ‚Äî ${p.description}`);
                option.value = p.id;
                customGroup.appendChild(option);
            });
            this.select.appendChild(customGroup);
        }

        const applyBtn = this.createElement('button', 'we-btn we-btn-primary', '–ü—Ä–∏–º–µ–Ω–∏—Ç—å');
        applyBtn.disabled = true;
        applyBtn.onclick = () => {
            const id = this.select.value;
            if (!id) return;
            const preset = builtinPresets.find(p => p.id === id) || customPresets.find(p => p.id === id);
            if (preset) {
                if (confirm(`–ó–∞–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–∏–µ –≤–æ–ª–Ω—ã –Ω–∞ –ø—Ä–µ—Å–µ—Ç "${preset.name}"?`)) {
                    this.data.replaceAllWaves(preset.waves);
                }
            }
        };

        const saveAsBtn = this.createElement('button', 'we-btn we-btn-secondary', 'üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫ –ø—Ä–µ—Å–µ—Ç');
        saveAsBtn.onclick = () => {
            const name = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø—Ä–µ—Å–µ—Ç–∞:');
            if (name && name.trim() !== '') {
                saveCustomPreset(name.trim(), this.data.getWaves());
                this.render(); // Re-render to update select list
            }
        };

        this.element.appendChild(this.select);
        this.element.appendChild(applyBtn);
        this.element.appendChild(saveAsBtn);

        // –ö–Ω–æ–ø–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –¥–ª—è –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ
        const deleteBtn = this.createElement('button', 'we-btn we-btn-danger we-btn-icon', 'üóëÔ∏è');
        deleteBtn.title = '–£–¥–∞–ª–∏—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π –ø—Ä–µ—Å–µ—Ç';
        deleteBtn.style.display = 'none';

        this.select.onchange = () => {
            const id = this.select.value;
            applyBtn.disabled = !id;
            const isCustom = customPresets.some(p => p.id === id);
            deleteBtn.style.display = isCustom ? 'flex' : 'none';
        };

        deleteBtn.onclick = () => {
            const id = this.select.value;
            if (id && confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç –ø—Ä–µ—Å–µ—Ç?')) {
                deleteCustomPreset(id);
                this.render();
            }
        };

        this.element.appendChild(deleteBtn);
    }
}
</file>

<file path="src/editor/components/WaveSettingsPanel.ts">
import { BaseComponent } from './BaseComponent';
import { WaveModel } from '../WaveModel';
import { SpawnTimingControl } from './SpawnTimingControl';

interface WaveSettingsProps {
    waveIndex: number;
    model: WaveModel;
}

/**
 * Panel for wave-level metadata:
 * Name, Start Delay, Wait for Clear, Shuffle Mode, Bonus Reward, Summary.
 */
export class WaveSettingsPanel extends BaseComponent<WaveSettingsProps> {

    protected createRootElement(): HTMLElement {
        return this.createElement('div', 'we-settings-panel');
    }

    public render(): void {
        this.element.innerHTML = '';
        const { waveIndex, model } = this.data;
        const wave = model.getWave(waveIndex);
        if (!wave) return;

        // 1. Name input
        const nameRow = this.createElement('div', 'we-settings-row');
        const nameLabel = this.createElement('span', 'we-settings-label', 'üìù –ù–∞–∑–≤–∞–Ω–∏–µ');
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.className = 'we-settings-input';
        nameInput.placeholder = '–Ω–∞–ø—Ä. –í–æ–ª–Ω–∞ –ë–æ—Å—Å–∞!';
        nameInput.value = wave.name || '';
        nameInput.onchange = () => {
            model.updateWaveSettings(waveIndex, { name: nameInput.value.trim() || undefined });
        };
        nameRow.appendChild(nameLabel);
        nameRow.appendChild(nameInput);
        this.element.appendChild(nameRow);

        // 2. Start Delay
        const delayControl = new SpawnTimingControl({
            value: wave.startDelay ?? 0,
            min: 0,
            max: 60,
            step: 0.5,
            label: '‚è±Ô∏è –ó–∞–¥–µ—Ä–∂–∫–∞ —Å—Ç–∞—Ä—Ç–∞',
            suffix: '—Å',
            onChange: (val) => model.updateWaveSettings(waveIndex, { startDelay: val }),
        });
        delayControl.mount(this.element);

        // 3. Wait for Clear (checkbox)
        const clearRow = this.createElement('div', 'we-settings-row');
        const clearLabel = this.createElement('span', 'we-settings-label', '‚èπÔ∏è –ñ–¥–∞—Ç—å –∑–∞—á–∏—Å—Ç–∫–∏');
        const clearCheck = document.createElement('input');
        clearCheck.type = 'checkbox';
        clearCheck.checked = wave.waitForClear ?? false;
        clearCheck.onchange = () => {
            model.updateWaveSettings(waveIndex, { waitForClear: clearCheck.checked });
        };
        clearRow.appendChild(clearLabel);
        clearRow.appendChild(clearCheck);
        this.element.appendChild(clearRow);

        // 4. Shuffle Mode (select)
        const shuffleRow = this.createElement('div', 'we-settings-row');
        const shuffleLabel = this.createElement('span', 'we-settings-label', 'üîÄ –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ');
        const shuffleSelect = document.createElement('select');
        shuffleSelect.className = 'we-settings-input';
        const shuffleOptions: { value: string; label: string }[] = [
            { value: 'none', label: '–ù–µ—Ç (–ø–æ –ø–æ—Ä—è–¥–∫—É)' },
            { value: 'within_group', label: '–í–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã' },
            { value: 'all', label: '–í—Å–µ (—Å—Ç–∞—Ä—ã–µ –∫–∞—Ä—Ç—ã)' },
        ];
        shuffleOptions.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.label;
            if (opt.value === (wave.shuffleMode ?? 'none')) option.selected = true;
            shuffleSelect.appendChild(option);
        });
        shuffleSelect.onchange = () => {
            model.updateWaveSettings(waveIndex, {
                shuffleMode: shuffleSelect.value as 'none' | 'within_group' | 'all',
            });
        };
        shuffleRow.appendChild(shuffleLabel);
        shuffleRow.appendChild(shuffleSelect);
        this.element.appendChild(shuffleRow);

        // 5. Bonus Reward
        const rewardRow = this.createElement('div', 'we-settings-row');
        const rewardLabel = this.createElement('span', 'we-settings-label', 'üí∞ –ë–æ–Ω—É—Å');
        const rewardInput = document.createElement('input');
        rewardInput.type = 'number';
        rewardInput.className = 'we-settings-input';
        rewardInput.min = '0';
        rewardInput.max = '1000';
        rewardInput.value = (wave.bonusReward ?? 0).toString();
        rewardInput.style.width = '70px';
        rewardInput.onchange = () => {
            const val = Math.max(0, parseInt(rewardInput.value) || 0);
            model.updateWaveSettings(waveIndex, { bonusReward: val || undefined });
        };
        rewardRow.appendChild(rewardLabel);
        rewardRow.appendChild(rewardInput);
        this.element.appendChild(rewardRow);

        // 6. Auto-Summary (read-only)
        const totalEnemies = wave.enemies.reduce((sum, g) => sum + g.count, 0);
        const duration = model.getEstimatedDuration(waveIndex);
        const threat = model.getThreat(waveIndex);
        const summary = this.createElement('div', 'we-settings-summary',
            `${totalEnemies} –≤—Ä–∞–≥–æ–≤ ‚Ä¢ ~${duration.toFixed(1)}—Å ‚Ä¢ –£–≥—Ä–æ–∑–∞: ${Math.round(threat)}`
        );
        this.element.appendChild(summary);
    }
}
</file>

<file path="src/editor/components/WaveTimeline.ts">
import { BaseComponent } from './BaseComponent';
import { WaveModel } from '../WaveModel';
import { EnemyRegistry } from '../EnemyRegistry';

interface WaveTimelineProps {
    waveIndex: number;
    model: WaveModel;
}

/**
 * Canvas-based timeline visualization for a wave.
 * Shows colored blocks per group, gray gaps for delays,
 * and a time scale.
 *
 * NOTE: We do NOT store a separate `canvas` field because
 * ES2022 class field initializers run AFTER super() returns,
 * which would overwrite anything set in createRootElement().
 * Instead we use `this.element` (which IS the canvas) and cast it.
 */
export class WaveTimeline extends BaseComponent<WaveTimelineProps> {

    protected createRootElement(): HTMLElement {
        const canvas = document.createElement('canvas');
        canvas.className = 'we-timeline-canvas';
        canvas.height = 40;
        return canvas;
    }

    public render(): void {
        const canvas = this.element as HTMLCanvasElement;
        const { waveIndex, model } = this.data;
        const wave = model.getWave(waveIndex);
        if (!wave) return;

        // Measure actual width from CSS layout
        // On first mount the element may not be in DOM yet, so fallback to a safe default
        const rect = canvas.getBoundingClientRect();
        const canvasWidth = rect.width > 0 ? rect.width : 600;
        const dpr = window.devicePixelRatio || 1;
        const canvasH = 40;

        canvas.width = canvasWidth * dpr;
        canvas.height = canvasH * dpr;
        canvas.style.width = canvasWidth + 'px';
        canvas.style.height = canvasH + 'px';

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        ctx.scale(dpr, dpr);

        // Calculate total duration
        const totalDuration = model.getEstimatedDuration(waveIndex);
        if (totalDuration <= 0) return;

        const pxPerSec = canvasWidth / totalDuration;
        let x = 0;
        const barH = 24;
        const barY = 4;

        // Clear
        ctx.clearRect(0, 0, canvasWidth, canvasH);

        // Start delay
        const startDelay = wave.startDelay ?? 0;
        if (startDelay > 0) {
            const w = startDelay * pxPerSec;
            ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
            ctx.fillRect(x, barY, w, barH);
            ctx.fillStyle = '#666';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`‚è±${startDelay}s`, x + w / 2, barY + barH / 2 + 3);
            x += w;
        }

        // Each group
        wave.enemies.forEach(group => {
            // Delay before
            const delay = group.delayBefore ?? 0;
            if (delay > 0) {
                const w = delay * pxPerSec;
                ctx.fillStyle = 'rgba(100, 100, 100, 0.25)';
                ctx.fillRect(x, barY, w, barH);
                x += w;
            }

            // Group block
            const interval = group.baseInterval ?? 0.66;
            const groupDuration = group.count * interval;
            const w = groupDuration * pxPerSec;

            // Color from EnemyRegistry
            const typeConfig = EnemyRegistry.getType(group.type);
            const color = typeConfig?.color || '#888';
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.7;
            ctx.fillRect(x, barY, Math.max(w, 2), barH);
            ctx.globalAlpha = 1;

            // Border
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, barY, Math.max(w, 2), barH);

            // Label inside
            if (w > 30) {
                const symbol = typeConfig?.symbol || '?';
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`${symbol} √ó${group.count}`, x + w / 2, barY + barH / 2 + 4);
            }

            x += w;
        });

        // Time scale at bottom
        ctx.fillStyle = '#555';
        ctx.font = '8px sans-serif';
        ctx.textAlign = 'center';
        const interval = totalDuration > 20 ? 5 : totalDuration > 10 ? 2 : 1;
        for (let t = 0; t <= totalDuration; t += interval) {
            const tx = t * pxPerSec;
            ctx.fillRect(tx, barY + barH + 2, 1, 4);
            ctx.fillText(`${t}s`, tx, canvasH - 1);
        }
    }
}
</file>

<file path="src/editor/WaveEditorHistory.ts">
import { IWaveConfig } from '../MapData';

/**
 * Undo/Redo history for the Wave Editor.
 * Uses JSON snapshots of the full IWaveConfig[] array.
 * Compact diff is unnecessary ‚Äî wave arrays are small.
 */
export class WaveEditorHistory {
    private undoStack: { label: string; snapshot: string }[] = [];
    private redoStack: { label: string; snapshot: string }[] = [];
    private readonly maxSize = 30;

    /** Save current state before mutation. Call BEFORE modifying data. */
    public push(label: string, waves: IWaveConfig[]): void {
        this.undoStack.push({ label, snapshot: JSON.stringify(waves) });
        this.redoStack = []; // New action invalidates redo
        if (this.undoStack.length > this.maxSize) {
            this.undoStack.shift();
        }
    }

    /** Undo last change. Returns previous state or null. */
    public undo(currentWaves: IWaveConfig[]): IWaveConfig[] | null {
        const entry = this.undoStack.pop();
        if (!entry) return null;

        // Save current state to redo stack
        this.redoStack.push({ label: entry.label, snapshot: JSON.stringify(currentWaves) });

        return JSON.parse(entry.snapshot);
    }

    /** Redo last undone change. Returns next state or null. */
    public redo(currentWaves: IWaveConfig[]): IWaveConfig[] | null {
        const entry = this.redoStack.pop();
        if (!entry) return null;

        // Save current state to undo stack
        this.undoStack.push({ label: entry.label, snapshot: JSON.stringify(currentWaves) });

        return JSON.parse(entry.snapshot);
    }

    public canUndo(): boolean { return this.undoStack.length > 0; }
    public canRedo(): boolean { return this.redoStack.length > 0; }
    public getUndoLabel(): string | null {
        return this.undoStack.length > 0 ? this.undoStack[this.undoStack.length - 1].label : null;
    }

    public clear(): void {
        this.undoStack = [];
        this.redoStack = [];
    }
}
</file>

<file path="src/editor/WavePresets.ts">
import { IWaveConfig } from '../MapData';

export interface IWavePreset {
    id: string;
    name: string;
    description: string;
    waves: IWaveConfig[];
}

const BUILTIN_PRESETS: IWavePreset[] = [
    {
        id: 'early_game',
        name: 'üå± –†–∞–Ω–Ω—è—è –∏–≥—Ä–∞',
        description: '3 –ª—ë–≥–∫–∏–µ –≤–æ–ª–Ω—ã',
        waves: [
            { enemies: [{ type: 'GRUNT', count: 5, pattern: 'normal', baseInterval: 0.8 }] },
            { enemies: [{ type: 'GRUNT', count: 7, pattern: 'normal', baseInterval: 0.7 }] },
            { enemies: [{ type: 'GRUNT', count: 8, pattern: 'normal', baseInterval: 0.6 }] }
        ]
    },
    {
        id: 'mid_game',
        name: '‚öîÔ∏è –°—Ä–µ–¥–Ω—è—è –∏–≥—Ä–∞',
        description: '5 –≤–æ–ª–Ω, –º–∏–∫—Å —Ç–∏–ø–æ–≤',
        waves: [
            { enemies: [{ type: 'GRUNT', count: 10, pattern: 'normal', baseInterval: 0.6 }] },
            { enemies: [{ type: 'SCOUT', count: 5, pattern: 'normal', baseInterval: 0.5 }] },
            { enemies: [{ type: 'GRUNT', count: 8, pattern: 'normal', baseInterval: 0.5 }, { type: 'SCOUT', count: 4, pattern: 'normal', baseInterval: 0.5, delayBefore: 2 }] },
            { enemies: [{ type: 'TANK', count: 2, pattern: 'normal', baseInterval: 0.8 }] },
            { enemies: [{ type: 'GRUNT', count: 15, pattern: 'swarm', baseInterval: 0.4 }] }
        ]
    },
    {
        id: 'boss_rush',
        name: 'üëë –ë–æ—Å—Å-—Ä–∞—à',
        description: '3 –≤–æ–ª–Ω—ã —Å –±–æ—Å—Å–∞–º–∏',
        waves: [
            { waitForClear: true, bonusReward: 50, enemies: [{ type: 'boss', count: 1, pattern: 'normal', baseInterval: 1 }] },
            { waitForClear: true, bonusReward: 100, enemies: [{ type: 'TANK', count: 3, pattern: 'normal', baseInterval: 1 }, { type: 'boss', count: 1, pattern: 'normal', baseInterval: 1, delayBefore: 2 }] },
            { waitForClear: true, bonusReward: 200, enemies: [{ type: 'boss', count: 2, pattern: 'normal', baseInterval: 1.5 }] }
        ]
    },
    {
        id: 'swarm',
        name: 'üêù –†–æ–π',
        description: '4 –≤–æ–ª–Ω—ã –±—ã—Å—Ç—Ä—ã—Ö –≤—Ä–∞–≥–æ–≤',
        waves: [
            { enemies: [{ type: 'SCOUT', count: 10, pattern: 'swarm', baseInterval: 0.15 }] },
            { enemies: [{ type: 'SCOUT', count: 15, pattern: 'swarm', baseInterval: 0.15 }] },
            { startDelay: 3, enemies: [{ type: 'SCOUT', count: 20, pattern: 'swarm', baseInterval: 0.15 }] },
            { startDelay: 3, enemies: [{ type: 'SCOUT', count: 25, pattern: 'swarm', baseInterval: 0.15 }] }
        ]
    },
    {
        id: 'endurance',
        name: 'üíÄ –í—ã–∂–∏–≤–∞–Ω–∏–µ',
        description: '8 –Ω–∞—Ä–∞—Å—Ç–∞—é—â–∏—Ö –≤–æ–ª–Ω',
        waves: [
            { shuffleMode: 'none', enemies: [{ type: 'GRUNT', count: 10, pattern: 'normal', baseInterval: 0.6 }] },
            { shuffleMode: 'none', enemies: [{ type: 'SCOUT', count: 5, pattern: 'normal', baseInterval: 0.5 }] },
            { shuffleMode: 'none', enemies: [{ type: 'GRUNT', count: 15, pattern: 'normal', baseInterval: 0.5 }] },
            { shuffleMode: 'none', enemies: [{ type: 'TANK', count: 3, pattern: 'normal', baseInterval: 0.8 }] },
            { startDelay: 5, shuffleMode: 'none', enemies: [{ type: 'SCOUT', count: 15, pattern: 'swarm', baseInterval: 0.2 }] },
            { shuffleMode: 'none', enemies: [{ type: 'TANK', count: 5, pattern: 'normal', baseInterval: 0.7 }] },
            { shuffleMode: 'none', enemies: [{ type: 'boss', count: 1, pattern: 'normal', baseInterval: 1 }] },
            { shuffleMode: 'none', enemies: [{ type: 'GRUNT', count: 30, pattern: 'swarm', baseInterval: 0.2 }] }
        ]
    }
];

const CUSTOM_PRESETS_KEY = 'NEWTOWER_WAVE_PRESETS';

export function getBuiltinPresets(): IWavePreset[] {
    return JSON.parse(JSON.stringify(BUILTIN_PRESETS));
}

export function loadCustomPresets(): IWavePreset[] {
    try {
        const data = localStorage.getItem(CUSTOM_PRESETS_KEY);
        if (data) {
            const parsed = JSON.parse(data);
            if (Array.isArray(parsed)) {
                return parsed;
            }
        }
    } catch (e) {
        console.warn('Failed to load custom presets', e);
    }
    return [];
}

export function saveCustomPreset(name: string, waves: IWaveConfig[]): void {
    const custom = loadCustomPresets();
    const id = 'custom_' + Date.now();

    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –∏–º–µ–Ω–∏
    const safeName = name.substring(0, 50);

    const preset: IWavePreset = {
        id,
        name: safeName,
        description: `–ö–∞—Å—Ç–æ–º–Ω—ã–π –ø—Ä–µ—Å–µ—Ç (${waves.length} –≤–æ–ª–Ω)`,
        waves: JSON.parse(JSON.stringify(waves))
    };
    custom.push(preset);

    try {
        localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(custom));
    } catch (e) {
        console.error('Failed to save to localStorage (quota exceeded?)', e);
        alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–µ—Å–µ—Ç. –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –ø–∞–º—è—Ç–∏ –≤ localStorage.');
    }
}

export function deleteCustomPreset(id: string): void {
    const custom = loadCustomPresets();
    const filtered = custom.filter(p => p.id !== id);
    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(filtered));
}
</file>

<file path="src/editor/WaypointManager.ts">
import { CONFIG } from '../Config';

export class WaypointManager {
    private start: { x: number; y: number } | null = null;
    private waypoints: { x: number; y: number }[] = [];
    private end: { x: number; y: number } | null = null;

    /**
     * Strict ordering: Start ‚Üí WP1 ‚Üí WP2 ‚Üí ... ‚Üí End
     */

    public setStart(pos: { x: number; y: number }): void {
        this.start = pos;
    }

    public setEnd(pos: { x: number; y: number }): void {
        this.end = pos;
    }

    public canAddWaypoint(): boolean {
        // Can only add waypoints if Start is set
        return this.start !== null;
    }

    public addWaypoint(pos: { x: number; y: number }): void {
        if (!this.canAddWaypoint()) {
            console.warn('Cannot add waypoint: Start point not set');
            return;
        }

        this.waypoints.push(pos);
    }

    public removeLastWaypoint(): void {
        this.waypoints.pop();
    }

    public clearAll(): void {
        this.start = null;
        this.waypoints = [];
        this.end = null;
    }

    public clearWaypoints(): void {
        this.waypoints = [];
    }

    public getStart(): { x: number; y: number } | null {
        return this.start;
    }

    public getEnd(): { x: number; y: number } | null {
        return this.end;
    }

    public getWaypoints(): { x: number; y: number }[] {
        return [...this.waypoints];
    }

    /**
     * Get full path: Start ‚Üí WP1 ‚Üí WP2 ‚Üí ... ‚Üí End
     */
    public getFullPath(): { x: number; y: number }[] {
        const path: { x: number; y: number }[] = [];

        if (this.start) path.push(this.start);
        path.push(...this.waypoints);
        if (this.end) path.push(this.end);

        return path;
    }

    public isValid(): boolean {
        // Valid if at least Start and End are set
        return this.start !== null && this.end !== null;
    }

    /**
     * Draw waypoints with lines and arrows
     */
    public draw(ctx: CanvasRenderingContext2D): void {
        const fullPath = this.getFullPath();

        if (fullPath.length < 2) {
            // Draw only start/end markers if they exist
            if (this.start) this.drawMarker(ctx, this.start, 'üèÅ', '#00bcd4', 0);
            if (this.end) this.drawMarker(ctx, this.end, 'üõë', '#e91e63', -1);
            return;
        }

        // Draw connecting lines with arrows
        ctx.strokeStyle = '#00ff00';
        ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
        ctx.lineWidth = 3;

        ctx.beginPath();
        for (let i = 0; i < fullPath.length; i++) {
            const wp = fullPath[i];
            const wpX = wp.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
            const wpY = wp.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

            if (i === 0) {
                ctx.moveTo(wpX, wpY);
            } else {
                ctx.lineTo(wpX, wpY);
            }
        }
        ctx.stroke();

        // Draw arrows between points
        for (let i = 0; i < fullPath.length - 1; i++) {
            const from = fullPath[i];
            const to = fullPath[i + 1];
            this.drawArrow(ctx, from, to);
        }

        // Draw numbered waypoint markers
        fullPath.forEach((wp, idx) => {
            let label: string;
            let color: string;

            if (idx === 0) {
                // Start
                label = 'üèÅ';
                color = '#00bcd4';
            } else if (idx === fullPath.length - 1) {
                // End
                label = 'üõë';
                color = '#e91e63';
            } else {
                // Waypoint
                label = (idx).toString();
                color = '#9c27b0';
            }

            this.drawMarker(ctx, wp, label, color, idx);
        });
    }

    private drawMarker(
        ctx: CanvasRenderingContext2D,
        pos: { x: number; y: number },
        label: string,
        color: string,
        index: number
    ): void {
        const wpX = pos.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const wpY = pos.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        // Circle
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(wpX, wpY, 14, 0, Math.PI * 2);
        ctx.fill();

        // White border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Label
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, wpX, wpY);
    }

    private drawArrow(
        ctx: CanvasRenderingContext2D,
        from: { x: number; y: number },
        to: { x: number; y: number }
    ): void {
        const fromX = from.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const fromY = from.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const toX = to.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const toY = to.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        // Calculate angle
        const angle = Math.atan2(toY - fromY, toX - fromX);

        // Arrow position (midpoint)
        const midX = (fromX + toX) / 2;
        const midY = (fromY + toY) / 2;

        // Arrow size
        const arrowSize = 12;

        ctx.save();
        ctx.translate(midX, midY);
        ctx.rotate(angle);

        // Draw arrow head
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-arrowSize, -arrowSize / 2);
        ctx.lineTo(-arrowSize, arrowSize / 2);
        ctx.closePath();
        ctx.fill();

        // Arrow outline
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
    }
}
</file>

<file path="src/effects/animators/README.md">
# Animators Directory

–ü–∞–ø–∫–∞ –¥–ª—è –≤—ã–Ω–æ—Å–∞ —Å–ª–æ–∂–Ω—ã—Ö –∞–Ω–∏–º–∞—Ç–æ—Ä–æ–≤ –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã.

## –ö–æ–≥–¥–∞ –≤—ã–Ω–æ—Å–∏—Ç—å

- –ï—Å–ª–∏ –∞–Ω–∏–º–∞—Ç–æ—Ä > 50 —Å—Ç—Ä–æ–∫
- –ï—Å–ª–∏ –Ω—É–∂–Ω—ã —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
- –ï—Å–ª–∏ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è —Ñ–∞–∑—ã –∞–Ω–∏–º–∞—Ü–∏–∏

## –ü—Ä–∏–º–µ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```
animators/
‚îú‚îÄ‚îÄ skeleton.ts
‚îú‚îÄ‚îÄ hellhound.ts
‚îî‚îÄ‚îÄ wraith.ts
```
</file>

<file path="src/effects/index.ts">
/**
 * Effects Module - Barrel Export
 * 
 * –ï–¥–∏–Ω–∞—è —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã —ç—Ñ—Ñ–µ–∫—Ç–æ–≤.
 */

export { playDeathAnimation } from './DeathAnimations';
export type { IDeathAnimator, IDeathEffectConfig } from './types';
</file>

<file path="src/effects/types.ts">
/**
 * Death Animation System Types
 * 
 * –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è –º–æ–¥—É–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã –∞–Ω–∏–º–∞—Ü–∏–π —Å–º–µ—Ä—Ç–∏ –≤—Ä–∞–≥–æ–≤.
 * –ì–æ—Ç–æ–≤–æ –∫ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—é: –º–æ–∂–Ω–æ –≤—ã–Ω–µ—Å—Ç–∏ –∞–Ω–∏–º–∞—Ç–æ—Ä—ã –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã.
 */

import { EffectSystem } from '../EffectSystem';
import { IEnemyTypeConfig } from '../types';

/**
 * –§—É–Ω–∫—Ü–∏—è-–∞–Ω–∏–º–∞—Ç–æ—Ä —Å–º–µ—Ä—Ç–∏.
 * –î–æ–±–∞–≤–ª—è–µ—Ç –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –≤ EffectSystem.
 */
export interface IDeathAnimator {
    (effects: EffectSystem, x: number, y: number, config: IEnemyTypeConfig): void;
}

/**
 * –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–Ω–∏–º–∞—Ü–∏–π (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ).
 */
export interface IDeathEffectConfig {
    debrisCount: number;
    particleCount: number;
    color: string;
    velocityX: number;
    velocityY: number;
    size: number;
}
</file>

<file path="src/FogStructure.ts">
/**
 * Fog Structure - represents a connected region of fog tiles
 */
export interface FogTile {
    x: number;
    y: number;
    density: number; // 0-5
}

export interface FogStructure {
    id: number;
    tiles: FogTile[];
    bounds: {
        minX: number;
        maxX: number;
        minY: number;
        maxY: number;
    };
    // Animation state
    noiseOffsetX: number;
    noiseOffsetY: number;
    noiseOffsetRot: number;
}

/**
 * Build fog structures using flood-fill algorithm
 */
export function buildFogStructures(
    fogData: number[],
    width: number,
    height: number
): FogStructure[] {
    const structures: FogStructure[] = [];
    const visited = new Set<number>();
    let structureId = 0;

    const getIndex = (x: number, y: number) => y * width + x;
    const isValid = (x: number, y: number) =>
        x >= 0 && x < width && y >= 0 && y < height;

    // Flood fill from a starting point
    const floodFill = (startX: number, startY: number): FogTile[] => {
        const tiles: FogTile[] = [];
        const queue: { x: number; y: number }[] = [{ x: startX, y: startY }];
        const startIndex = getIndex(startX, startY);
        visited.add(startIndex);

        while (queue.length > 0) {
            const { x, y } = queue.shift()!;
            const density = fogData[getIndex(x, y)];

            tiles.push({ x, y, density });

            // Check 4 neighbors (N, S, E, W)
            const neighbors = [
                { x: x, y: y - 1 },
                { x: x, y: y + 1 },
                { x: x + 1, y: y },
                { x: x - 1, y: y },
            ];

            for (const neighbor of neighbors) {
                if (!isValid(neighbor.x, neighbor.y)) continue;

                const nIndex = getIndex(neighbor.x, neighbor.y);
                if (visited.has(nIndex)) continue;
                if (fogData[nIndex] === 0) continue; // No fog

                visited.add(nIndex);
                queue.push(neighbor);
            }
        }

        return tiles;
    };

    // Find all structures
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = getIndex(x, y);
            if (visited.has(index)) continue;
            if (fogData[index] === 0) continue; // No fog

            const tiles = floodFill(x, y);
            if (tiles.length === 0) continue;

            // Calculate bounds
            let minX = Infinity,
                maxX = -Infinity;
            let minY = Infinity,
                maxY = -Infinity;

            for (const tile of tiles) {
                minX = Math.min(minX, tile.x);
                maxX = Math.max(maxX, tile.x);
                minY = Math.min(minY, tile.y);
                maxY = Math.max(maxY, tile.y);
            }

            structures.push({
                id: structureId++,
                tiles,
                bounds: { minX, maxX, minY, maxY },
                noiseOffsetX: Math.random() * 1000,
                noiseOffsetY: Math.random() * 1000,
                noiseOffsetRot: Math.random() * 1000,
            });
        }
    }

    return structures;
}
</file>

<file path="src/MapStorage.ts">
import { IMapData, migrateMapData } from './MapData';
import { validateMap, normalizeWaveConfig } from './Utils';

// ============================================================
// MapStorage ‚Äî –ì–∏–±—Ä–∏–¥–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–∞—Ä—Ç (bundled + localStorage)
// ============================================================

/** –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã –¥–ª—è UI */
export interface IMapEntry {
    name: string;
    data: IMapData;
    source: 'bundled' | 'local';
    overridesBundled: boolean;
}

const LOCAL_KEY = 'NEWTOWER_MAPS';

export class MapStorage {

    // === –ö—ç—à bundled –∫–∞—Ä—Ç (–æ–¥–∏–Ω fetch –∑–∞ —Å–µ—Å—Å–∏—é) ===
    private static _bundledCache: Record<string, IMapData> | null = null;
    private static _bundledFetchPromise: Promise<Record<string, IMapData>> | null = null;

    // -----------------------------------------------
    //  LOCAL MAPS (sync ‚Äî localStorage, –∫–∞–∫ —Ä–∞–Ω—å—à–µ)
    // -----------------------------------------------

    /** –í—Å–µ –∫–∞—Ä—Ç—ã –∏–∑ localStorage (sync). –ù–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç –≤–æ–ª–Ω—ã –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏. */
    public static getLocalMaps(): Record<string, IMapData> {
        try {
            const raw = localStorage.getItem(LOCAL_KEY);
            if (!raw) return {};

            const maps = JSON.parse(raw);

            // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤–æ–ª–Ω (–æ–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å)
            Object.keys(maps).forEach(mapName => {
                const mapData = maps[mapName];
                if (mapData.waves && Array.isArray(mapData.waves)) {
                    mapData.waves = mapData.waves.map(normalizeWaveConfig);
                }
            });

            return maps;
        } catch (e) {
            console.error('[MapStorage] Failed to load local maps', e);
            return {};
        }
    }

    /** –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞—Ä—Ç—É –≤ localStorage. */
    public static saveLocal(name: string, data: IMapData): boolean {
        try {
            const maps = this.getLocalMaps();
            maps[name] = data;
            const json = JSON.stringify(maps);

            // Safety check: –ø—Ä–µ–¥—É–ø—Ä–µ–¥–∏—Ç—å –ø—Ä–∏ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–∏ –∫ –ª–∏–º–∏—Ç—É 5MB
            const byteSize = new TextEncoder().encode(json).length;
            if (byteSize > 4 * 1024 * 1024) {
                console.warn(`[MapStorage] Approaching limit: ${(byteSize / 1024 / 1024).toFixed(1)}MB / 5MB`);
            }

            localStorage.setItem(LOCAL_KEY, json);
            return true;
        } catch (e) {
            console.error('[MapStorage] Failed to save map', e);
            return false;
        }
    }

    /** –£–¥–∞–ª–∏—Ç—å –∫–∞—Ä—Ç—É –∏–∑ localStorage. */
    public static deleteLocal(name: string): void {
        try {
            const maps = this.getLocalMaps();
            delete maps[name];
            localStorage.setItem(LOCAL_KEY, JSON.stringify(maps));
        } catch (e) {
            console.error('[MapStorage] Failed to delete map', e);
        }
    }

    // -----------------------------------------------
    //  BUNDLED MAPS (async ‚Äî fetch –∏–∑ public/maps/)
    // -----------------------------------------------

    /** –ü–æ–ª—É—á–∏—Ç—å base URL –¥–ª—è fetch (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ SPA/—Ä–æ—É—Ç–∏–Ω–≥–∞). */
    private static getBaseUrl(): string {
        // import.meta.env.BASE_URL —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è Vite –∏–∑ config.base
        // Fallback –∫ './' –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –æ–∫—Ä—É–∂–µ–Ω–∏—è
        try {
            return (import.meta as any).env?.BASE_URL ?? './';
        } catch {
            return './';
        }
    }

    /**
     * –ó–∞–≥—Ä—É–∑–∏—Ç—å bundled –∫–∞—Ä—Ç—ã –∏–∑ public/maps/.
     * –ö—ç—à–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç ‚Äî –ø–æ–≤—Ç–æ—Ä–Ω—ã–µ –≤—ã–∑–æ–≤—ã –Ω–µ –¥–µ–ª–∞—é—Ç fetch.
     * –ü—Ä–∏ –æ—à–∏–±–∫–µ (404, –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–π JSON) ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç {}, –ª–æ–≥–∏—Ä—É–µ—Ç warning.
     */
    public static async getBundledMaps(): Promise<Record<string, IMapData>> {
        // –í–µ—Ä–Ω—É—Ç—å –∫—ç—à –µ—Å–ª–∏ –µ—Å—Ç—å
        if (this._bundledCache) return this._bundledCache;

        // –î–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è: –µ—Å–ª–∏ fetch —É–∂–µ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ, –≤–µ—Ä–Ω—É—Ç—å —Ç–æ—Ç –∂–µ –ø—Ä–æ–º–∏—Å
        if (this._bundledFetchPromise) return this._bundledFetchPromise;

        this._bundledFetchPromise = this._fetchBundledMaps();
        try {
            this._bundledCache = await this._bundledFetchPromise;
            return this._bundledCache;
        } catch (e) {
            console.warn('[MapStorage] Failed to fetch bundled maps', e);
            return {};
        } finally {
            this._bundledFetchPromise = null;
        }
    }

    /** –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ bundled –∫–∞—Ä—Ç. */
    private static async _fetchBundledMaps(): Promise<Record<string, IMapData>> {
        const base = this.getBaseUrl();
        const result: Record<string, IMapData> = {};

        // 1. –ó–∞–≥—Ä—É–∑–∏—Ç—å manifest
        let index: string[];
        try {
            const resp = await fetch(`${base}maps/_index.json`, { cache: 'no-cache' });
            if (!resp.ok) {
                console.warn(`[MapStorage] _index.json returned ${resp.status}`);
                return result;
            }
            const parsed = await resp.json();
            if (!Array.isArray(parsed)) {
                console.warn('[MapStorage] _index.json is not an array');
                return result;
            }
            index = parsed;
        } catch (e) {
            console.warn('[MapStorage] Failed to fetch _index.json', e);
            return result;
        }

        if (index.length === 0) return result;

        // 2. –ó–∞–≥—Ä—É–∑–∏—Ç—å –∫–∞–∂–¥—É—é –∫–∞—Ä—Ç—É
        const fetches = index.map(async (name: string) => {
            try {
                const resp = await fetch(`${base}maps/${name}.json`);
                if (!resp.ok) {
                    console.warn(`[MapStorage] Map "${name}" returned ${resp.status}, skipping`);
                    return;
                }
                const raw = await resp.json();

                // –ö–†–ò–¢–ò–ß–ù–û: –º–∏–≥—Ä–∞—Ü–∏—è + –≤–∞–ª–∏–¥–∞—Ü–∏—è bundled –∫–∞—Ä—Ç
                const migrated = migrateMapData(raw);
                if (!validateMap(migrated)) {
                    console.warn(`[MapStorage] Bundled map "${name}" failed validation, skipping`);
                    return;
                }

                result[name] = migrated;
            } catch (e) {
                console.warn(`[MapStorage] Failed to load bundled map "${name}"`, e);
            }
        });

        await Promise.all(fetches);
        return result;
    }

    /** –ò–Ω–≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å –∫—ç—à bundled –∫–∞—Ä—Ç (–¥–ª—è HMR). */
    public static invalidateBundledCache(): void {
        this._bundledCache = null;
        this._bundledFetchPromise = null;
    }

    // -----------------------------------------------
    //  UNIFIED API ‚Äî –µ–¥–∏–Ω–∞—è —Ç–æ—á–∫–∞ –ø—Ä–∞–≤–¥—ã
    // -----------------------------------------------

    /**
     * –ü–æ–ª—É—á–∏—Ç—å –í–°–ï –∫–∞—Ä—Ç—ã (bundled + local) —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏.
     * Collision policy: Local Override ‚Äî –µ—Å–ª–∏ –∏–º—è —Å–æ–≤–ø–∞–¥–∞–µ—Ç, local –ø–æ–±–µ–∂–¥–∞–µ—Ç.
     * –ü–æ—Ä—è–¥–æ–∫: bundled (–ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É), –∑–∞—Ç–µ–º local (–ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É).
     */
    public static async getAllMaps(): Promise<IMapEntry[]> {
        const local = this.getLocalMaps();
        const bundled = await this.getBundledMaps();
        const localNames = new Set(Object.keys(local));
        const bundledNames = new Set(Object.keys(bundled));

        const entries: IMapEntry[] = [];

        // Bundled –∫–∞—Ä—Ç—ã (—Ç–æ–ª—å–∫–æ —Ç–µ, —á—Ç–æ –ù–ï –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω—ã –ª–æ–∫–∞–ª—å–Ω—ã–º–∏)
        const sortedBundled = Object.keys(bundled).sort();
        for (const name of sortedBundled) {
            if (localNames.has(name)) {
                // Local override ‚Äî bundled –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º, local –ø–æ–∫–∞–∂–µ–º –Ω–∏–∂–µ —Å overridesBundled=true
                continue;
            }
            entries.push({
                name,
                data: bundled[name],
                source: 'bundled',
                overridesBundled: false,
            });
        }

        // Local –∫–∞—Ä—Ç—ã
        const sortedLocal = Object.keys(local).sort();
        for (const name of sortedLocal) {
            entries.push({
                name,
                data: local[name],
                source: 'local',
                overridesBundled: bundledNames.has(name),
            });
        }

        return entries;
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∫–∞—Ä—Ç–∞ bundled (–∏–∑ –ø—Ä–æ–µ–∫—Ç–∞).
     */
    public static async isBundled(name: string): Promise<boolean> {
        const bundled = await this.getBundledMaps();
        return name in bundled;
    }

    // -----------------------------------------------
    //  IMPORT / EXPORT (—á–∏—Å—Ç–∞—è –ª–æ–≥–∏–∫–∞, –±–µ–∑ UI)
    // -----------------------------------------------

    /**
     * –ò–º–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã –∏–∑ File.
     * –ü—Ä–æ–≥–æ–Ω—è–µ—Ç —á–µ—Ä–µ–∑ –ø–æ–ª–Ω—ã–π validation pipeline: JSON.parse ‚Üí migrateMapData ‚Üí validateMap.
     * @throws Error –ø—Ä–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
     */
    public static async importFromFile(file: File): Promise<IMapData> {
        const text = await file.text();

        let raw: unknown;
        try {
            raw = JSON.parse(text);
        } catch (e) {
            throw new Error(`–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π JSON: ${(e as Error).message}`);
        }

        // –ú–∏–≥—Ä–∞—Ü–∏—è (throws –µ—Å–ª–∏ –Ω–µ—Ç tiles –∏ —Ç.–¥.)
        const migrated = migrateMapData(raw);

        // –í–∞–ª–∏–¥–∞—Ü–∏—è (waypoints ‚â• 2 –∏ —Ç.–¥.)
        if (!validateMap(migrated)) {
            throw new Error('–ö–∞—Ä—Ç–∞ –Ω–µ –ø—Ä–æ—à–ª–∞ –≤–∞–ª–∏–¥–∞—Ü–∏—é (–Ω–µ—Ç –ø—É—Ç–∏ –∏–ª–∏ waypoints < 2)');
        }

        return migrated;
    }

    /**
     * –°–æ–∑–¥–∞—Ç—å Blob –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∫–∞—Ä—Ç—ã –∫–∞–∫ JSON.
     * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç Blob ‚Äî —Å–æ–∑–¥–∞–Ω–∏–µ <a download> –æ—Å—Ç–∞—ë—Ç—Å—è –≤ UI-—Å–ª–æ–µ.
     */
    public static createExportBlob(data: IMapData): Blob {
        const json = JSON.stringify(data, null, 2);
        return new Blob([json], { type: 'application/json' });
    }

    /**
     * –°–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞.
     * –ü—Ä–æ–±–µ–ª—ã ‚Üí _, —É–±—Ä–∞–Ω—ã —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª—ã, lowercase.
     */
    public static sanitizeFileName(name: string): string {
        return name
            .toLowerCase()
            .replace(/\s+/g, '_')
            .replace(/[^a-z0-9_\-]/g, '')
            .replace(/_+/g, '_')         // collapse double underscores
            .replace(/^_|_$/g, '')       // trim leading/trailing _
            .substring(0, 50) || 'map';
    }
}
</file>

<file path="src/ProceduralPatterns.ts">
import { SimplexNoise } from './SimplexNoise';

/**
 * Procedural Pattern Generation Library
 * Provides algorithms for creating organic and technical textures
 * Used by Assets.ts for layered texture generation
 */
export class ProceduralPatterns {
    private static noise = new SimplexNoise();

    /**
     * Perlin Noise overlay (uses existing SimplexNoise)
     * Adds subtle texture variation to surfaces
     */
    static perlinNoise(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        scale: number = 0.05,
        opacity: number = 0.1
    ): void {
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const value = this.noise.noise2D(x * scale, y * scale); // -1 to 1
                const brightness = Math.floor(value * 25); // -25 to 25

                const idx = (y * width + x) * 4;
                // Darken/lighten based on noise
                data[idx] = Math.max(0, Math.min(255, data[idx] + brightness));     // R
                data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + brightness)); // G
                data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + brightness)); // B
            }
        }

        ctx.putImageData(imageData, 0, 0);
    }

    /**
     * Organic Veins (Dark Fantasy)
     * Draws wandering lines like roots or cracks
     */
    static organicVeins(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        density: number = 0.3,
        seed: number = 0
    ): void {
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 1;
        ctx.lineCap = 'round';

        const veinCount = Math.floor(width * height * density / 1000);

        for (let i = 0; i < veinCount; i++) {
            // Pseudo-random based on seed + index
            const s = seed + i * 137;

            // Simple deterministic random function for this scope
            const rnd = (mod: number) => {
                const x = Math.sin(s + mod) * 10000;
                return x - Math.floor(x);
            };

            let x = rnd(1) * width;
            let y = rnd(2) * height;
            let angle = rnd(3) * Math.PI * 2;

            ctx.beginPath();
            ctx.moveTo(x, y);

            // Wandering path
            const steps = 15 + Math.floor(rnd(4) * 10);
            for (let step = 0; step < steps; step++) {
                angle += (rnd(step * 5) - 0.5) * 0.6; // Slight turns
                x += Math.cos(angle) * 3;
                y += Math.sin(angle) * 3;

                // Keep within bounds
                if (x < 0 || x > width || y < 0 || y > height) break;

                ctx.lineTo(x, y);
            }

            ctx.stroke();
        }

        ctx.restore();
    }

    /**
     * Voronoi Grid (Techno)
     * Creates cell-like patterns mimicking circuits/microchips
     */
    static voronoiGrid(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        cellCount: number = 10
    ): void {
        // Generate random points
        const points: { x: number; y: number }[] = [];
        for (let i = 0; i < cellCount; i++) {
            points.push({
                x: Math.random() * width,
                y: Math.random() * height
            });
        }

        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        // For each pixel, find closest point
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                let minDist = Infinity;
                let closestIdx = 0;

                for (let i = 0; i < points.length; i++) {
                    const dist = Math.hypot(points[i].x - x, points[i].y - y);
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = i;
                    }
                }

                // Color by cell index
                const idx = (y * width + x) * 4;
                const shade = 30 + (closestIdx % 5) * 15; // Subtle variation
                data[idx] = Math.max(0, Math.min(255, data[idx] + shade));
                data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + shade));
                data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + shade));
            }
        }

        ctx.putImageData(imageData, 0, 0);

        // Draw cell borders
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 1;

        for (let y = 0; y < height; y += 2) { // Sample every 2 pixels for performance
            for (let x = 0; x < width - 1; x++) {
                let minDist1 = Infinity, minDist2 = Infinity;
                let closest1 = 0, closest2 = 0;

                // Find closest point for current and next pixel
                for (let i = 0; i < points.length; i++) {
                    const dist1 = Math.hypot(points[i].x - x, points[i].y - y);
                    const dist2 = Math.hypot(points[i].x - (x + 1), points[i].y - y);

                    if (dist1 < minDist1) {
                        minDist1 = dist1;
                        closest1 = i;
                    }
                    if (dist2 < minDist2) {
                        minDist2 = dist2;
                        closest2 = i;
                    }
                }

                // Draw border if different cells
                if (closest1 !== closest2) {
                    ctx.beginPath();
                    ctx.moveTo(x + 0.5, y);
                    ctx.lineTo(x + 0.5, y + 1);
                    ctx.stroke();
                }
            }
        }

        ctx.restore();
    }

    /**
     * Bioluminescent Spots (Dark Fantasy accent)
     * Adds glowing spots using deterministic seed
     */
    static biolumSpots(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        color: string,
        density: number = 0.2,
        seed: number = 0
    ): void {
        ctx.save();
        ctx.fillStyle = color;
        ctx.shadowBlur = 3;  // Reduced from 8 for subtler glow
        ctx.shadowColor = color;

        // Deterministic spot placement (–∑–∞–º–µ—á–∞–Ω–∏–µ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ #3!)
        const spotCount = Math.floor(width * height * density / 1000);

        for (let i = 0; i < spotCount; i++) {
            // Pseudo-random –Ω–æ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
            const pseudoX = ((seed + i) * 73) % width;
            const pseudoY = ((seed + i) * 137) % height;
            const size = 0.5 + ((seed + i) % 2) * 0.5;  // Reduced from 1-3px to 0.5-1.5px

            ctx.beginPath();
            ctx.arc(pseudoX, pseudoY, size, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }
}
</file>

<file path="src/renderers/ProceduralGrass.ts">
import { CONFIG } from '../Config';
import { VISUALS } from '../VisualConfig';

/**
 * –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∂–∏–≤–æ–π —Ç—Ä–∞–≤—ã
 * –î–æ–±–∞–≤–ª—è–µ—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ç—Ä–∞–≤–∏–Ω–∫–∏, –∫–∞–º–µ—à–∫–∏ –∏ –º–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏ –ø–æ–≤–µ—Ä—Ö –±–∞–∑–æ–≤–æ–≥–æ —Å–ª–æ—è
 * 
 * –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:
 * - –¢—Ä–∞–≤–∏–Ω–∫–∏: 12-18 –Ω–∞ —Ç–∞–π–ª, –≤—ã—Å–æ—Ç–∞ 4-8px, –Ω–∞–∫–ª–æ–Ω ¬±15¬∞
 * - –ö–∞–º–µ—à–∫–∏: 1-3 –Ω–∞ —Ç–∞–π–ª (60% —Ç–∞–π–ª–æ–≤)
 * - –¶–≤–µ—Ç–æ—á–∫–∏: 0-1 –Ω–∞ —Ç–∞–π–ª (5% —à–∞–Ω—Å)
 * 
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ö–ê–ñ–î–û–ì–û –≤–∞—Ä–∏–∞–Ω—Ç–∞ grass_0...grass_3
 */
export class ProceduralGrass {
    /**
     * –†–µ–Ω–¥–µ—Ä–∏—Ç —Å–ª–æ–π –¥–µ—Ç–∞–ª–µ–π –Ω–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –±–∞–∑—É
     * @param ctx Canvas context
     * @param x Pixel X (–æ–±—ã—á–Ω–æ 0 –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ Assets)
     * @param y Pixel Y (–æ–±—ã—á–Ω–æ 0 –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ Assets)
     * @param size –†–∞–∑–º–µ—Ä —Ç–∞–π–ª–∞ (64px)
     * @param seed –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –¥–ª—è –≤–∞—Ä–∏–∞—Ü–∏–π
     */
    public static draw(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // 1. –¢—Ä–∞–≤–∏–Ω–∫–∏ (–æ—Å–Ω–æ–≤–Ω–æ–π –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç)
        this.drawGrassBlades(ctx, x, y, size, seed);

        // 2. –ú–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏ (–∫–∞–º–µ—à–∫–∏)
        this.drawPebbles(ctx, x, y, size, seed);

        // 3. –¶–≤–µ—Ç–æ—á–∫–∏ (–æ—á–µ–Ω—å —Ä–µ–¥–∫–æ)
        this.drawTinyFlowers(ctx, x, y, size, seed);
    }

    /**
     * –°–ª–æ–π 1: –û—Ç–¥–µ–ª—å–Ω—ã–µ —Ç—Ä–∞–≤–∏–Ω–∫–∏
     */
    private static drawGrassBlades(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–∞–≤–∏–Ω–æ–∫: 12-18
        const bladeCount = 12 + (seed % 7); // 12-18

        ctx.strokeStyle = VISUALS.ENVIRONMENT.GRASS.BLADE; // #8bc34a
        ctx.lineWidth = 1;

        for (let i = 0; i < bladeCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const bx = x + ((seed * 7 + i * 13) % size);
            const by = y + ((seed * 11 + i * 19) % size);

            // –í—ã—Å–æ—Ç–∞ —Ç—Ä–∞–≤–∏–Ω–∫–∏: 4-8px
            const height = 4 + ((seed + i * 3) % 5); // 4-8px

            // –ù–∞–∫–ª–æ–Ω: ¬±15¬∞
            const angleVariation = ((seed + i * 7) % 30) - 15; // -15 to +15
            const angle = angleVariation * Math.PI / 180;

            // –†–∏—Å—É–µ–º —Ç—Ä–∞–≤–∏–Ω–∫—É
            ctx.save();
            ctx.translate(bx, by);
            ctx.rotate(angle);

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -height); // –í–≤–µ—Ä—Ö –æ—Ç —Ç–æ—á–∫–∏
            ctx.stroke();

            ctx.restore();
        }
    }

    /**
     * –°–ª–æ–π 2: –ú–µ–ª–∫–∏–µ –∫–∞–º–µ—à–∫–∏
     */
    private static drawPebbles(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –ù–µ –Ω–∞ –≤—Å–µ—Ö —Ç–∞–π–ª–∞—Ö –µ—Å—Ç—å –∫–∞–º–µ—à–∫–∏ (60% —à–∞–Ω—Å)
        if (seed % 5 === 0 || seed % 5 === 1) {
            return; // –ù–µ—Ç –∫–∞–º–µ—à–∫–æ–≤ –Ω–∞ —ç—Ç–æ–º —Ç–∞–π–ª–µ
        }

        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–º–µ—à–∫–æ–≤: 1-3
        const pebbleCount = 1 + (seed % 3); // 1-3

        ctx.fillStyle = VISUALS.ENVIRONMENT.GRASS.DETAIL; // #757575

        for (let i = 0; i < pebbleCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const px = x + ((seed * 17 + i * 23) % size);
            const py = y + ((seed * 19 + i * 29) % size);

            // –†–∞–∑–º–µ—Ä: 1-2px
            const pebbleSize = 1 + ((seed + i) % 2);

            ctx.fillRect(px, py, pebbleSize, pebbleSize);
        }
    }

    /**
     * –°–ª–æ–π 3: –ú–µ–ª–∫–∏–µ —Ü–≤–µ—Ç–æ—á–∫–∏ (–æ—á–µ–Ω—å —Ä–µ–¥–∫–æ)
     */
    private static drawTinyFlowers(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –û—á–µ–Ω—å —Ä–µ–¥–∫–æ: 5% —à–∞–Ω—Å
        if (seed % 20 !== 0) {
            return; // –ù–µ—Ç —Ü–≤–µ—Ç–æ—á–∫–∞ –Ω–∞ —ç—Ç–æ–º —Ç–∞–π–ª–µ
        }

        // –ü–æ–∑–∏—Ü–∏—è: –±–ª–∏–∂–µ –∫ –∫—Ä–∞—è–º —Ç–∞–π–ª–∞
        const edge = seed % 4; // 0=top, 1=right, 2=bottom, 3=left
        let fx = x;
        let fy = y;

        switch (edge) {
            case 0: // Top
                fx = x + size / 2 + ((seed % 20) - 10);
                fy = y + 5 + (seed % 10);
                break;
            case 1: // Right
                fx = x + size - 10 - (seed % 10);
                fy = y + size / 2 + ((seed % 20) - 10);
                break;
            case 2: // Bottom
                fx = x + size / 2 + ((seed % 20) - 10);
                fy = y + size - 10 - (seed % 10);
                break;
            case 3: // Left
                fx = x + 5 + (seed % 10);
                fy = y + size / 2 + ((seed % 20) - 10);
                break;
        }

        // –†–∞–∑–º–µ—Ä: 2-3px
        const flowerSize = 2 + (seed % 2);

        // –Ø—Ä–∫–∞—è —Ç–æ—á–∫–∞
        ctx.fillStyle = VISUALS.ENVIRONMENT.GRASS.FLOWER; // #ffeb3b
        ctx.beginPath();
        ctx.arc(fx, fy, flowerSize, 0, Math.PI * 2);
        ctx.fill();

        // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –±–ª–∏–∫ (–µ—â–µ —è—Ä—á–µ)
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(fx, fy, flowerSize / 2, 0, Math.PI * 2);
        ctx.fill();
    }
}
</file>

<file path="src/renderers/ProceduralRoad.ts">
import { CONFIG } from '../Config';
import { VISUALS } from '../VisualConfig';

/**
 * –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∫–∞–º–µ–Ω–Ω–æ–π –¥–æ—Ä–æ–≥–∏
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –±–∏—Ç–º–∞—Å–∫–∏–Ω–≥ –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ø–ª–∏—Ç
 * 
 * –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:
 * - –°–≤–µ—Ç–ª–æ-–±–µ–∂–µ–≤—ã–π –∫–∞–º–µ–Ω—å —Å –≤–∞—Ä–∏–∞—Ü–∏—è–º–∏
 * - –¢—Ä–µ—â–∏–Ω—ã (2-4 –Ω–∞ –ø–ª–∏—Ç—É)
 * - –ó–µ—Ä–Ω–∏—Å—Ç–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ (–∫—Ä–∞–ø–∏–Ω–∫–∏)
 * - –¢—ë–º–Ω—ã–µ –∫—Ä–∞—è –º–µ–∂–¥—É –ø–ª–∏—Ç–∞–º–∏
 * - –†–µ–¥–∫–∏–µ –º–æ—Ö–æ–≤—ã–µ –ø—è—Ç–Ω–∞
 */
export class ProceduralRoad {
    /**
     * –†–µ–Ω–¥–µ—Ä–∏—Ç –æ–¥–Ω—É –∫–∞–º–µ–Ω–Ω—É—é –ø–ª–∏—Ç—É —Å —É—á—ë—Ç–æ–º —Å–æ—Å–µ–¥–µ–π
     * @param ctx Canvas context
     * @param x Pixel X (–∫—Ä–∞—Ç–Ω–æ TILE_SIZE)
     * @param y Pixel Y (–∫—Ä–∞—Ç–Ω–æ TILE_SIZE)
     * @param bitmask –ë–∏—Ç–º–∞—Å–∫–∞ —Å–æ—Å–µ–¥–µ–π 0-15 (NORTH|WEST|EAST|SOUTH)
     */
    public static draw(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        bitmask: number
    ): void {
        const TS = CONFIG.TILE_SIZE;
        const col = Math.floor(x / TS);
        const row = Math.floor(y / TS);

        // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –¥–ª—è –≤–∞—Ä–∏–∞—Ü–∏–π
        const seed = col * 73 + row * 37;

        // 1. –ë–∞–∑–æ–≤–∞—è –ø–ª–∏—Ç–∞ (—Å –≤–∞—Ä–∏–∞—Ü–∏—è–º–∏)
        this.drawBaseTile(ctx, x, y, TS, seed);

        // 2. –ö—Ä–∞—è/–≥—Ä–∞–Ω–∏—Ü—ã (—Ç–æ–ª—å–∫–æ —Ç–∞–º –≥–¥–µ –Ω–µ—Ç —Å–æ—Å–µ–¥–µ–π)
        this.drawEdges(ctx, x, y, TS, bitmask, seed);

        // 3. –î–µ—Ç–∞–ª–∏ (—Ç—Ä–µ—â–∏–Ω—ã, –∫—Ä–∞–ø–∏–Ω–∫–∏)
        this.drawDetails(ctx, x, y, TS, seed);
    }

    /**
     * –°–ª–æ–π 1: –ë–∞–∑–æ–≤–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ –∫–∞–º–Ω—è
     */
    private static drawBaseTile(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –í–∞—Ä–∏–∞—Ü–∏—è —è—Ä–∫–æ—Å—Ç–∏: ¬±10%
        const brightness = 0.9 + (seed % 20) * 0.01; // 0.9 - 1.09

        // –í—ã–±—Ä–∞—Ç—å –±–∞–∑–æ–≤—ã–π –æ—Ç—Ç–µ–Ω–æ–∫
        const baseColors = [
            VISUALS.ENVIRONMENT.PATH.STONE_BASE,   // #c5b8a1
            VISUALS.ENVIRONMENT.PATH.STONE_LIGHT,  // #d4c5a9
            VISUALS.ENVIRONMENT.PATH.STONE_DARK    // #b6a890
        ];
        const colorIndex = seed % 3;
        let baseColor = baseColors[colorIndex];

        // –ü—Ä–∏–º–µ–Ω–∏—Ç—å –≤–∞—Ä–∏–∞—Ü–∏—é —è—Ä–∫–æ—Å—Ç–∏
        baseColor = this.adjustBrightness(baseColor, brightness);

        // –ó–∞–ø–æ–ª–Ω–∏—Ç—å –ø–ª–∏—Ç—É
        ctx.fillStyle = baseColor;
        ctx.fillRect(x, y, size, size);

        // –¢–µ–∫—Å—Ç—É—Ä–∞: –º–µ–ª–∫–æ–∑–µ—Ä–Ω–∏—Å—Ç–∞—è (–∫—Ä–∞–ø–∏–Ω–∫–∏)
        this.drawGrainTexture(ctx, x, y, size, seed);
    }

    /**
     * –ó–µ—Ä–Ω–∏—Å—Ç–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ (–º–µ–ª–∫–∏–µ –∫—Ä–∞–ø–∏–Ω–∫–∏)
     */
    private static drawGrainTexture(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        const speckCount = 8 + (seed % 8); // 8-15 –∫—Ä–∞–ø–∏–Ω–æ–∫

        ctx.fillStyle = '#5a5a5a'; // –¢—ë–º–Ω–æ-—Å–µ—Ä—ã–π

        for (let i = 0; i < speckCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const sx = x + ((seed * 7 + i * 13) % size);
            const sy = y + ((seed * 11 + i * 19) % size);
            const speckSize = 1 + ((seed + i) % 3); // 1-3px

            ctx.fillRect(sx, sy, speckSize, speckSize);
        }
    }

    /**
     * –°–ª–æ–π 2: –ö—Ä–∞—è –º–µ–∂–¥—É –ø–ª–∏—Ç–∞–º–∏
     * –†–∏—Å—É–µ–º —Ç–µ–º–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–æ–ª—å–∫–æ —Ç–∞–º, –≥–¥–µ –ù–ï–¢ —Å–æ—Å–µ–¥–µ–π
     */
    private static drawEdges(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        bitmask: number,
        seed: number
    ): void {
        const NORTH = (bitmask & 1) !== 0;
        const WEST = (bitmask & 2) !== 0;
        const EAST = (bitmask & 4) !== 0;
        const SOUTH = (bitmask & 8) !== 0;

        ctx.strokeStyle = VISUALS.ENVIRONMENT.PATH.EDGE; // #9a8d7a
        ctx.lineWidth = 2;

        // –°–µ–≤–µ—Ä–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!NORTH) {
            ctx.beginPath();
            ctx.moveTo(x, y + 1);
            ctx.lineTo(x + size, y + 1);
            ctx.stroke();
        }

        // –Æ–∂–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!SOUTH) {
            ctx.beginPath();
            ctx.moveTo(x, y + size - 1);
            ctx.lineTo(x + size, y + size - 1);
            ctx.stroke();
        }

        // –ó–∞–ø–∞–¥–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!WEST) {
            ctx.beginPath();
            ctx.moveTo(x + 1, y);
            ctx.lineTo(x + 1, y + size);
            ctx.stroke();
        }

        // –í–æ—Å—Ç–æ—á–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!EAST) {
            ctx.beginPath();
            ctx.moveTo(x + size - 1, y);
            ctx.lineTo(x + size - 1, y + size);
            ctx.stroke();
        }
    }

    /**
     * –°–ª–æ–π 3: –î–µ—Ç–∞–ª–∏ (—Ç—Ä–µ—â–∏–Ω—ã, –º–æ—Ö)
     */
    private static drawDetails(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –¢—Ä–µ—â–∏–Ω—ã: 2-4 –Ω–∞ –ø–ª–∏—Ç—É
        const crackCount = 2 + (seed % 3); // 2-4

        ctx.strokeStyle = VISUALS.ENVIRONMENT.PATH.CRACK; // #8b7e6a
        ctx.lineWidth = 1 + (seed % 2); // 1-2px

        for (let i = 0; i < crackCount; i++) {
            this.drawCrack(ctx, x, y, size, seed + i * 100);
        }

        // –ú–æ—Ö (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, —Ä–µ–¥–∫–æ): 0-1 –ø—è—Ç–Ω–æ
        if (seed % 5 === 0) { // 20% —à–∞–Ω—Å
            this.drawMoss(ctx, x, y, size, seed);
        }
    }

    /**
     * –†–∏—Å—É–µ—Ç –æ–¥–Ω—É —Ç—Ä–µ—â–∏–Ω—É
     */
    private static drawCrack(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –°—Ç–∞—Ä—Ç–æ–≤–∞—è —Ç–æ—á–∫–∞ (–∫—Ä–∞–π –ø–ª–∏—Ç—ã –∏–ª–∏ —Ü–µ–Ω—Ç—Ä)
        const startX = x + ((seed * 3) % size);
        const startY = y + ((seed * 7) % size);

        // –î–ª–∏–Ω–∞ —Ç—Ä–µ—â–∏–Ω—ã: 20-40px
        const length = 20 + (seed % 21);
        const angle = (seed % 360) * Math.PI / 180;

        // –ö–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞
        const endX = startX + Math.cos(angle) * length;
        const endY = startY + Math.sin(angle) * length;

        ctx.beginPath();
        ctx.moveTo(startX, startY);

        // –õ–æ–º–∞–Ω–∞—è –ª–∏–Ω–∏—è (3-5 —Å–µ–≥–º–µ–Ω—Ç–æ–≤)
        const segments = 3 + (seed % 3);
        for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            const midX = startX + (endX - startX) * t;
            const midY = startY + (endY - startY) * t;

            // –°–ª—É—á–∞–π–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ ¬±5px
            const offsetX = ((seed * i * 11) % 11) - 5;
            const offsetY = ((seed * i * 13) % 11) - 5;

            ctx.lineTo(midX + offsetX, midY + offsetY);
        }

        ctx.stroke();
    }

    /**
     * –†–∏—Å—É–µ—Ç –º–æ—Ö–æ–≤–æ–µ –ø—è—Ç–Ω–æ
     */
    private static drawMoss(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –ü–æ–∑–∏—Ü–∏—è: —É–≥–æ–ª –ø–ª–∏—Ç—ã
        const corner = seed % 4; // 0=NW, 1=NE, 2=SW, 3=SE
        let mossX = x;
        let mossY = y;

        switch (corner) {
            case 0: mossX = x + 5; mossY = y + 5; break;         // NW
            case 1: mossX = x + size - 10; mossY = y + 5; break; // NE
            case 2: mossX = x + 5; mossY = y + size - 10; break; // SW
            case 3: mossX = x + size - 10; mossY = y + size - 10; break; // SE
        }

        const mossSize = 3 + (seed % 4); // 3-6px

        ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.MOSS; // #7a8f63
        ctx.globalAlpha = 0.6; // –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π
        ctx.beginPath();
        ctx.arc(mossX, mossY, mossSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0; // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å
    }

    /**
     * –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –∏–∑–º–µ–Ω–µ–Ω–∏–µ —è—Ä–∫–æ—Å—Ç–∏ —Ü–≤–µ—Ç–∞
     */
    private static adjustBrightness(color: string, factor: number): string {
        // –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è: –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å HEX ‚Üí RGB ‚Üí —É–º–Ω–æ–∂–∏—Ç—å ‚Üí HEX
        const hex = color.replace('#', '');
        const r = Math.min(255, Math.round(parseInt(hex.substr(0, 2), 16) * factor));
        const g = Math.min(255, Math.round(parseInt(hex.substr(2, 2), 16) * factor));
        const b = Math.min(255, Math.round(parseInt(hex.substr(4, 2), 16) * factor));

        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }
}
</file>

<file path="src/renderers/turrets/index.ts">
/**
 * Turret Renderer Registry
 * Central export point for all turret renderers (Strategy Pattern)
 */

import { ITurretRenderer, DefaultTurretRenderer } from './TurretRenderer';
import { FireTurretRenderer } from './FireTurretRenderer';
import { IceTurretRenderer } from './IceTurretRenderer';
import { SniperTurretRenderer } from './SniperTurretRenderer';
import { SplitTurretRenderer } from './SplitTurretRenderer';
import { MinigunTurretRenderer } from './MinigunTurretRenderer';

// Export types
export type { ITurretRenderer };
export { DefaultTurretRenderer };

// Registry of turret renderers (singleton instances)
const TURRET_RENDERERS: Record<string, ITurretRenderer> = {
    'fire': new FireTurretRenderer(),
    'ice': new IceTurretRenderer(),
    'sniper': new SniperTurretRenderer(),
    'multi': new SplitTurretRenderer(),
    'minigun': new MinigunTurretRenderer(),
};

const defaultRenderer = new DefaultTurretRenderer();

/**
 * Get turret renderer for a card type
 * @param cardId - The card type ID (e.g., 'fire', 'ice', 'sniper', 'multi', 'minigun')
 * @returns The turret renderer for the card type, or default if not found
 */
export function getTurretRenderer(cardId: string): ITurretRenderer {
    return TURRET_RENDERERS[cardId] || defaultRenderer;
}
</file>

<file path="src/renderers/units/SkeletonBerserkerRenderer.ts">
import { BaseSkeletonRenderer, SkeletonPose } from './BaseSkeletonRenderer';
import { SpriteFacing } from './CachedUnitRenderer';
import { Enemy } from '../../Enemy';
import { Assets } from '../../Assets';

export class SkeletonBerserkerRenderer extends BaseSkeletonRenderer {
    protected override boneMain = '#d4cba7'; // Grimy bone color
    protected override eyeGlow = '#d32f2f'; // Enraged red eyes

    private static readonly PELT_COLORS = ['#3e2723', '#4e342e', '#5d4037'];
    private static readonly AXE_HANDLE = '#3e2723';
    private static readonly AXE_BLADE = '#78909c';
    private static readonly WARPAINT_COLOR = '#b71c1c';

    // Optional slightly bulkier look
    public override drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: SpriteFacing): void {
        ctx.save();
        // Scale to make him slightly wider/bulkier without affecting height disproportionately
        ctx.scale(1.1, 1.05);
        super.drawFrameDirectional(ctx, enemy, t, facing);
        ctx.restore();
    }

    protected drawBodyArmor(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        const s = pose.scale;

        ctx.save();
        ctx.translate(pose.anchors.torso.x, pose.anchors.torso.y);

        // Bear pelt / animal skins draped over shoulders and back
        ctx.fillStyle = SkeletonBerserkerRenderer.PELT_COLORS[0];
        ctx.beginPath();

        if (pose.facing === 'SIDE') {
            // Pelt draped over the back and shoulder
            ctx.moveTo(0, -6 * s);
            ctx.quadraticCurveTo(-6 * s, -4 * s, -5 * s, 6 * s); // Hangs down the back
            ctx.quadraticCurveTo(-1 * s, 8 * s, 1 * s, 4 * s);
            ctx.quadraticCurveTo(3 * s, 0, 0, -6 * s);
            ctx.fill();

            // Fur texture breaks
            ctx.strokeStyle = SkeletonBerserkerRenderer.PELT_COLORS[1];
            ctx.lineWidth = 1 * s;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(-4 * s, (-2 + i * 3) * s);
                ctx.lineTo(-6 * s, (-1 + i * 3) * s);
                ctx.stroke();
            }
        } else if (pose.facing === 'UP') {
            // Full back covered in pelt
            ctx.moveTo(-7 * s, -6 * s);
            ctx.quadraticCurveTo(0, -8 * s, 7 * s, -6 * s);
            ctx.lineTo(8 * s, 4 * s);
            // Jagged bottom edge
            ctx.lineTo(4 * s, 7 * s);
            ctx.lineTo(0, 5 * s);
            ctx.lineTo(-4 * s, 7 * s);
            ctx.lineTo(-8 * s, 4 * s);
            ctx.closePath();
            ctx.fill();

            // Spine ridge fur
            ctx.fillStyle = SkeletonBerserkerRenderer.PELT_COLORS[1];
            ctx.beginPath();
            ctx.ellipse(0, 0, 3 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // DOWN (Front)
            // Pelt visible on shoulders, secured by a strap
            ctx.moveTo(-7 * s, -6 * s);
            ctx.quadraticCurveTo(0, -8 * s, 7 * s, -6 * s);
            ctx.lineTo(6 * s, -2 * s);
            ctx.lineTo(4 * s, 2 * s);
            // Hanging down sides
            ctx.quadraticCurveTo(0, -2 * s, -4 * s, 2 * s);
            ctx.lineTo(-6 * s, -2 * s);
            ctx.closePath();
            ctx.fill();

            // Leather cross-belt to hold it
            ctx.strokeStyle = '#2d2d2d';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.moveTo(-4 * s, -2 * s);
            ctx.lineTo(4 * s, 5 * s);
            ctx.moveTo(4 * s, -2 * s);
            ctx.lineTo(-4 * s, 5 * s);
            ctx.stroke();
        }

        ctx.restore();
    }

    protected drawHeadDecoration(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        const s = pose.scale;

        ctx.save();
        ctx.translate(pose.anchors.head.x, pose.anchors.head.y);
        ctx.rotate(pose.anchors.head.angle);

        // 1. MUST DRAW SKULL FIRST
        this.drawSkull(ctx, s, pose.facing);

        // 2. Warpaint on skull
        ctx.strokeStyle = SkeletonBerserkerRenderer.WARPAINT_COLOR;
        ctx.lineWidth = 1 * s;
        ctx.beginPath();
        if (pose.facing === 'DOWN') {
            // Vertical blood stripes over the eyes
            ctx.moveTo(-2 * s, -3 * s); ctx.lineTo(-2 * s, 2 * s);
            ctx.moveTo(2 * s, -3 * s); ctx.lineTo(2 * s, 2 * s);
            // V shape on forehead
            ctx.moveTo(0, -1 * s); ctx.lineTo(-1 * s, -3 * s);
            ctx.moveTo(0, -1 * s); ctx.lineTo(1 * s, -3 * s);
        } else if (pose.facing === 'SIDE') {
            ctx.moveTo(1 * s, -3 * s); ctx.lineTo(3 * s, 2 * s);
            ctx.moveTo(-1 * s, -3 * s); ctx.lineTo(2 * s, 1 * s);
        } else if (pose.facing === 'UP') {
            // Warpaint on back of skull
            ctx.moveTo(-2 * s, -3 * s); ctx.lineTo(2 * s, -1 * s);
            ctx.moveTo(-2 * s, -1 * s); ctx.lineTo(2 * s, -3 * s);
        }
        ctx.stroke();

        // 3. Animal skull/hood worn as a helmet
        ctx.fillStyle = SkeletonBerserkerRenderer.PELT_COLORS[0];
        ctx.beginPath();
        if (pose.facing === 'SIDE') {
            ctx.arc(-1 * s, -3 * s, 6 * s, Math.PI, 0);
            ctx.lineTo(2 * s, -2 * s);
            ctx.lineTo(-4 * s, 0);
            ctx.fill();

            // Little bear ear
            ctx.beginPath();
            ctx.arc(-2 * s, -7 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();
        } else if (pose.facing === 'UP') {
            ctx.arc(0, -3 * s, 6.5 * s, Math.PI, 0); // Covers top
            ctx.fill();
            // Ears
            ctx.beginPath(); ctx.arc(-3 * s, -7 * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(3 * s, -7 * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();
        } else {
            // DOWN - Hood over the top
            ctx.arc(0, -4 * s, 6.5 * s, Math.PI, 0);
            ctx.fill();
            // Ears
            ctx.beginPath(); ctx.arc(-3 * s, -8 * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(3 * s, -8 * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();
        }

        ctx.restore();
    }

    protected drawLeftHandItem(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        // Nothing in left hand (Two-handed axe is drawn in right hand, 
        // but we'll adapt its visual position to look held by both if needed)
    }

    protected drawRightHandItem(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        // Massive Two-Handed Axe
        ctx.save();
        ctx.translate(pose.anchors.rightHand.x, pose.anchors.rightHand.y);
        const s = pose.scale;

        if (pose.facing === 'SIDE') {
            // Dragging or carrying the axe
            ctx.rotate(0.3); // Heavy tilt

            // Handle
            ctx.fillStyle = SkeletonBerserkerRenderer.AXE_HANDLE;
            ctx.fillRect(-1.5 * s, -15 * s, 3 * s, 32 * s); // Thinner, realistic long handle
            // Base pommel
            ctx.fillStyle = '#111';
            ctx.fillRect(-2.5 * s, 15 * s, 5 * s, 3 * s);

            // Double blade - Sharp Battle Axe Crescent shape
            ctx.fillStyle = SkeletonBerserkerRenderer.AXE_BLADE;
            ctx.beginPath();
            // Right Blade
            ctx.moveTo(1.5 * s, -12 * s);
            ctx.quadraticCurveTo(8 * s, -16 * s, 10 * s, -10 * s); // Top edge tapering to tip
            ctx.quadraticCurveTo(12 * s, -6 * s, 8 * s, -1 * s);  // Outer cutting edge
            ctx.quadraticCurveTo(5 * s, -4 * s, 1.5 * s, -5 * s); // Bottom edge hooking back to shaft
            // Left Blade
            ctx.moveTo(-1.5 * s, -12 * s);
            ctx.quadraticCurveTo(-8 * s, -16 * s, -10 * s, -10 * s);
            ctx.quadraticCurveTo(-12 * s, -6 * s, -8 * s, -1 * s);
            ctx.quadraticCurveTo(-5 * s, -4 * s, -1.5 * s, -5 * s);
            ctx.fill();

            // Edge Highlights
            ctx.strokeStyle = '#cfd8dc';
            ctx.lineWidth = 1 * s;
            ctx.beginPath();
            ctx.moveTo(10 * s, -10 * s); ctx.quadraticCurveTo(12 * s, -6 * s, 8 * s, -1 * s);
            ctx.moveTo(-10 * s, -10 * s); ctx.quadraticCurveTo(-12 * s, -6 * s, -8 * s, -1 * s);
            ctx.stroke();

        } else if (pose.facing === 'UP') {
            // Resting on back / carried
            ctx.rotate(Math.PI / 4 || 0.78);

            ctx.fillStyle = SkeletonBerserkerRenderer.AXE_HANDLE;
            ctx.fillRect(-1.5 * s, -18 * s, 3 * s, 32 * s);

            // Same realistic crescent profile
            ctx.fillStyle = SkeletonBerserkerRenderer.AXE_BLADE;
            ctx.beginPath();
            // Right Blade
            ctx.moveTo(1.5 * s, -15 * s);
            ctx.quadraticCurveTo(8 * s, -19 * s, 10 * s, -13 * s);
            ctx.quadraticCurveTo(12 * s, -9 * s, 8 * s, -4 * s);
            ctx.quadraticCurveTo(5 * s, -7 * s, 1.5 * s, -8 * s);
            // Left Blade
            ctx.moveTo(-1.5 * s, -15 * s);
            ctx.quadraticCurveTo(-8 * s, -19 * s, -10 * s, -13 * s);
            ctx.quadraticCurveTo(-12 * s, -9 * s, -8 * s, -4 * s);
            ctx.quadraticCurveTo(-5 * s, -7 * s, -1.5 * s, -8 * s);
            ctx.fill();
        } else {
            // DOWN - Pointing outwards/downwards, highly foreshortened
            ctx.rotate(1.57); // 90 degrees
            ctx.fillStyle = SkeletonBerserkerRenderer.AXE_HANDLE;
            ctx.fillRect(-1.5 * s, -4 * s, 3 * s, 25 * s);

            // Edge-on view of curved blades
            ctx.fillStyle = SkeletonBerserkerRenderer.AXE_BLADE;
            ctx.beginPath();
            // Right half
            ctx.moveTo(1 * s, 12 * s);
            ctx.quadraticCurveTo(11 * s, 13 * s, 11 * s, 17 * s); // Curved tip
            ctx.lineTo(8 * s, 18 * s); // Tapering
            ctx.lineTo(1 * s, 15 * s);
            // Left half
            ctx.moveTo(-1 * s, 12 * s);
            ctx.quadraticCurveTo(-11 * s, 13 * s, -11 * s, 17 * s);
            ctx.lineTo(-8 * s, 18 * s);
            ctx.lineTo(-1 * s, 15 * s);
            ctx.fill();

            ctx.strokeStyle = '#cfd8dc'; // Edge highlight closest to camera
            ctx.lineWidth = 1 * s;
            ctx.beginPath();
            ctx.moveTo(-11 * s, 17 * s); ctx.lineTo(-8 * s, 18 * s);
            ctx.lineTo(8 * s, 18 * s); ctx.lineTo(11 * s, 17 * s);
            ctx.stroke();
        }

        ctx.restore();
    }

    // OVERLAY: Add Enrage Glow when HP < 50%
    protected drawOverlay(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        const enemyAny = (this as any).__currentEnemy; // Small hack to access enemy if needed in overlay
        // However, we don't pass enemy to drawOverlay. 
        // We will do Enrage glow in drawEmissive instead!
    }

    public drawEmissive(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        // Enrage Aura check
        const hpPercent = enemy.currentHealth / enemy.maxHealth;
        if (hpPercent < 0.5) {
            ctx.save();
            const time = performance.now() * 0.005; // Use performance.now() for smoother and consistent time
            const pulse = 0.6 + Math.sin(time) * 0.4; // 0.2 to 1.0

            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.4 * pulse;

            // Red aura around the enemy (using pre-baked asset for performance instead of createRadialGradient)
            const glowAsset = Assets.get('fx_glow_red');
            if (glowAsset) {
                const r = 35 * scale; // Increase slightly for better visual effect matching the original gradient
                ctx.drawImage(glowAsset, -r, -10 * scale - r, r * 2, r * 2);
            }

            ctx.restore();
        }
    }
}
</file>

<file path="src/SimplexNoise.ts">
/**
 * Simple Simplex Noise implementation for fog animation
 * Based on Stefan Gustavson's SimplexNoise
 */
export class SimplexNoise {
    private perm: number[] = [];
    private grad3: number[][] = [
        [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
        [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
        [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
    ];

    constructor(seed: number = Math.random()) {
        // Initialize permutation table with seed
        const p: number[] = [];
        for (let i = 0; i < 256; i++) {
            p[i] = i;
        }

        // Shuffle using seed-based random
        let n, q;
        for (let i = 255; i > 0; i--) {
            seed = (seed * 9301 + 49297) % 233280;
            n = Math.floor((seed / 233280.0) * (i + 1));
            q = p[i];
            p[i] = p[n];
            p[n] = q;
        }

        // Extend to 512 for wrapping
        for (let i = 0; i < 512; i++) {
            this.perm[i] = p[i & 255];
        }
    }

    private dot(g: number[], x: number, y: number): number {
        return g[0] * x + g[1] * y;
    }

    /**
     * 2D Simplex Noise
     * @param x X coordinate
     * @param y Y coordinate
     * @returns value between -1 and 1
     */
    public noise2D(x: number, y: number): number {
        const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
        const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;

        // Skew the input space
        const s = (x + y) * F2;
        const i = Math.floor(x + s);
        const j = Math.floor(y + s);

        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = x - X0;
        const y0 = y - Y0;

        // Determine simplex
        let i1, j1;
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } else {
            i1 = 0;
            j1 = 1;
        }

        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1.0 + 2.0 * G2;
        const y2 = y0 - 1.0 + 2.0 * G2;

        // Hash coordinates
        const ii = i & 255;
        const jj = j & 255;
        const gi0 = this.perm[ii + this.perm[jj]] % 12;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
        const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;

        // Calculate contributions
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        let n0 = 0.0;
        if (t0 >= 0) {
            t0 *= t0;
            n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
        }

        let t1 = 0.5 - x1 * x1 - y1 * y1;
        let n1 = 0.0;
        if (t1 >= 0) {
            t1 *= t1;
            n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
        }

        let t2 = 0.5 - x2 * x2 - y2 * y2;
        let n2 = 0.0;
        if (t2 >= 0) {
            t2 *= t2;
            n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
        }

        // Sum and scale to [-1, 1]
        return 70.0 * (n0 + n1 + n2);
    }
}
</file>

<file path="src/ui/bestiary/BestiaryUI.ts">
import { IGameScene } from '../../scenes/IGameScene';
import { CONFIG } from '../../Config';
import { VISUALS } from '../../VisualConfig';
import { UIUtils } from '../../UIUtils';
import { WaveAnalyst } from './WaveAnalyst';
import { ENEMY_TYPES } from '../../config/Enemies';
import { SoundManager, SoundPriority } from '../../SoundManager';

export class BestiaryUI {
    private scene: IGameScene;
    private analyst: WaveAnalyst;
    private unlockedEnemies: Set<string>;

    private elOverlay!: HTMLElement;
    private elContent!: HTMLElement;
    private elTabsContainer!: HTMLElement;
    private elTabEnemies!: HTMLElement;
    private elTabIntel!: HTMLElement;

    // Content Containers
    private elEnemiesView!: HTMLElement;
    private elIntelView!: HTMLElement;

    private activeTab: 'enemies' | 'intel' = 'enemies';
    private selectedEnemyId: string | null = null;

    constructor(scene: IGameScene, unlockedEnemies: Set<string>) {
        this.scene = scene;
        this.unlockedEnemies = unlockedEnemies;
        this.analyst = new WaveAnalyst(this.scene.waveManager as any, this.unlockedEnemies);

        this.createUI();
    }

    public show() {
        this.elOverlay.style.display = 'flex';
        this.render();
    }

    public hide() {
        this.elOverlay.style.display = 'none';
        SoundManager.play('click', SoundPriority.LOW);
    }

    public toggle() {
        if (this.elOverlay.style.display === 'flex') {
            this.hide();
        } else {
            this.show();
        }
    }

    public unlockEnemy(id: string) {
        if (!this.unlockedEnemies.has(id)) {
            this.unlockedEnemies.add(id);
            if (this.elOverlay.style.display === 'flex') this.render();
        }
    }

    private createUI() {
        // Overlay
        this.elOverlay = UIUtils.createOverlay('bestiary-overlay');
        this.elOverlay.onclick = (e) => {
            if (e.target === this.elOverlay) this.hide();
        };

        // Main Window
        this.elContent = UIUtils.createContainer({
            width: '800px',
            height: '600px',
            background: 'rgba(20, 20, 30, 0.95)',
            border: `2px solid ${VISUALS.UI.COLORS.neutral.light}`,
            borderRadius: '8px',
            display: 'flex',
            flexDirection: 'column',
            position: 'relative',
            overflowY: 'hidden'
        });
        // Stop clicks from closing overlay
        this.elContent.onclick = (e) => e.stopPropagation();

        // Header (Tabs + Close)
        const header = UIUtils.createContainer({
            height: '50px',
            display: 'flex',
            alignItems: 'center',
            background: 'rgba(0,0,0,0.3)',
            border: 'none', // border is handled by item borders usually
        });
        header.style.borderBottom = `1px solid ${VISUALS.UI.COLORS.neutral.light}`;

        this.elTabsContainer = UIUtils.createContainer({
            display: 'flex',
            height: '100%',
            flexGrow: '1'
        });

        this.elTabEnemies = this.createTab('ENEMIES', 'enemies');
        this.elTabIntel = this.createTab('INTEL', 'intel');

        const closeBtn = UIUtils.createButton(header, '‚úñ', () => this.hide(), {
            background: 'transparent',
            border: 'none',
            color: '#ff4444',
            fontSize: '20px',
            padding: '0 20px',
            fontWeight: 'bold'
        });
        closeBtn.style.marginLeft = 'auto';

        this.elTabsContainer.appendChild(this.elTabEnemies);
        this.elTabsContainer.appendChild(this.elTabIntel);
        header.appendChild(this.elTabsContainer);
        header.appendChild(closeBtn);
        this.elContent.appendChild(header);

        // Views Container
        const viewsContainer = UIUtils.createContainer({
            flexGrow: '1',
            padding: '20px',
            overflowY: 'hidden',
            display: 'flex',
            flexDirection: 'column'
        });

        // Enemies View
        this.elEnemiesView = UIUtils.createContainer({
            width: '100%',
            height: '100%',
            display: 'flex',
            gap: '20px'
        });

        // Intel View
        this.elIntelView = UIUtils.createContainer({
            width: '100%',
            height: '100%',
            display: 'none',
            flexDirection: 'column',
            overflowY: 'auto'
        });

        viewsContainer.appendChild(this.elEnemiesView);
        viewsContainer.appendChild(this.elIntelView);
        this.elContent.appendChild(viewsContainer);

        this.elOverlay.appendChild(this.elContent);
    }

    private createTab(label: string, id: 'enemies' | 'intel'): HTMLElement {
        const tab = document.createElement('div');
        tab.innerText = label;
        Object.assign(tab.style, {
            padding: '0 30px',
            height: '100%',
            display: 'flex',
            alignItems: 'center',
            cursor: 'pointer',
            fontWeight: 'bold',
            color: '#888',
            transition: '0.2s'
        });
        tab.onclick = () => {
            this.activeTab = id;
            SoundManager.play('click', SoundPriority.LOW);
            this.render();
        };
        return tab;
    }

    private render() {
        // Tab States
        const activeColor = '#ffd700';
        const inactiveColor = '#888';
        const activeBg = 'rgba(255, 215, 0, 0.1)';

        this.elTabEnemies.style.color = this.activeTab === 'enemies' ? activeColor : inactiveColor;
        this.elTabEnemies.style.background = this.activeTab === 'enemies' ? activeBg : 'transparent';

        this.elTabIntel.style.color = this.activeTab === 'intel' ? activeColor : inactiveColor;
        this.elTabIntel.style.background = this.activeTab === 'intel' ? activeBg : 'transparent';

        // View Visibility
        this.elEnemiesView.style.display = this.activeTab === 'enemies' ? 'flex' : 'none';
        this.elIntelView.style.display = this.activeTab === 'intel' ? 'flex' : 'none';

        if (this.activeTab === 'enemies') {
            this.renderEnemies();
        } else {
            this.renderIntel();
        }
    }

    // --- ENEMIES TAB ---
    private renderEnemies() {
        this.elEnemiesView.innerHTML = '';

        // Left List
        const list = UIUtils.createContainer({
            width: '30%',
            height: '100%',
            overflowY: 'auto',
            display: 'flex',
            flexDirection: 'column',
            gap: '5px',
            padding: '0 5px 0 0' // padding for scrollbar
        });

        // Right Details
        const details = UIUtils.createContainer({
            width: '70%',
            height: '100%',
            background: 'rgba(0,0,0,0.3)',
            borderRadius: '4px',
            padding: '20px',
            display: 'flex',
            flexDirection: 'column'
        });

        const allEnemies = Object.values(ENEMY_TYPES).filter(e => !e.isHidden);
        let firstUnlockedId = '';

        allEnemies.forEach(e => {
            const isUnlocked = this.unlockedEnemies.has(e.id);
            const item = document.createElement('div');
            Object.assign(item.style, {
                padding: '10px',
                background: this.selectedEnemyId === e.id ? 'rgba(255, 215, 0, 0.2)' : 'rgba(255,255,255,0.05)',
                border: this.selectedEnemyId === e.id ? '1px solid #ffd700' : '1px solid transparent',
                borderRadius: '4px',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                gap: '10px'
            });

            if (isUnlocked) {
                if (!firstUnlockedId) firstUnlockedId = e.id;
                item.innerHTML = `<span style="font-size:20px">${e.symbol}</span> <span>${e.name}</span>`;
            } else {
                item.innerHTML = `<span style="filter:grayscale(1)">‚ùì</span> <span style="color:#555">???</span>`;
            }

            item.onclick = () => {
                if (isUnlocked) {
                    this.selectedEnemyId = e.id;
                    SoundManager.play('click', SoundPriority.LOW);
                    this.renderEnemies(); // Re-render to highlight selection and show details
                }
            };

            list.appendChild(item);
        });

        // Auto-select first if none selected
        if (!this.selectedEnemyId && firstUnlockedId) {
            this.selectedEnemyId = firstUnlockedId;
            // Don't re-render here to avoid loop, just rely on next update or user click
        }

        // Render Details
        if (this.selectedEnemyId) {
            const conf = ENEMY_TYPES[this.selectedEnemyId.toUpperCase()];
            if (conf) {
                details.innerHTML = `
                    <div style="display:flex; gap: 20px; margin-bottom: 20px; align-items:center;">
                        <div style="font-size: 64px; background:rgba(0,0,0,0.5); width:100px; height:100px; display:flex; align-items:center; justify-content:center; border-radius:8px;">
                            ${conf.symbol}
                        </div>
                        <div>
                            <h2 style="margin:0; color:${conf.color || '#fff'}">${conf.name}</h2>
                            <div style="color:#aaa; font-style:italic;">${conf.archetype}</div>
                        </div>
                    </div>

                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px;">
                        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:4px;">
                            <div style="color:#888; font-size:12px;">HEALTH</div>
                            <div style="font-size:18px;">${Math.round(CONFIG.ENEMY.BASE_HP * conf.hpMod)} <span style="font-size:12px;color:#aaa">(x${conf.hpMod})</span></div>
                        </div>
                        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:4px;">
                            <div style="color:#888; font-size:12px;">SPEED</div>
                            <div style="font-size:18px;">${conf.speed}</div>
                        </div>
                        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:4px;">
                            <div style="color:#888; font-size:12px;">REWARD</div>
                            <div style="font-size:18px; color:gold;">${conf.reward}üí∞</div>
                        </div>
                        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:4px;">
                            <div style="color:#888; font-size:12px;">THREAT</div>
                            <div style="font-size:18px;">${conf.hpMod > 2 ? 'HIGH' : 'NORMAL'}</div>
                        </div>
                    </div>

                    <div style="background:rgba(0,0,0,0.2); padding:15px; border-radius:4px; border-left: 3px solid ${conf.color}">
                        ${conf.desc}
                    </div>
                `;
            }
        } else {
            details.innerHTML = `<div style="display:flex; align-items:center; justify-content:center; height:100%; color:#555;">Select an enemy</div>`;
        }

        this.elEnemiesView.appendChild(list);
        this.elEnemiesView.appendChild(details);
    }

    // --- INTEL TAB ---
    private renderIntel() {
        this.elIntelView.innerHTML = '';

        const currentWave = this.scene.wave;

        // Show next 5 waves
        for (let i = 0; i < 5; i++) {
            const waveNum = currentWave + i;
            const intel = this.analyst.getWaveIntel(waveNum);

            const card = UIUtils.createContainer({
                width: '100%',
                background: 'rgba(255,255,255,0.03)',
                border: '1px solid rgba(255,255,255,0.1)',
                borderRadius: '6px',
                padding: '15px',
                marginBottom: '10px',
                display: 'flex',
                flexDirection: 'column',
                gap: '10px'
            });

            // Header
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';

            let threatColor = '#4caf50'; // Low
            if (intel.threatLevel === 'MEDIUM') threatColor = '#ffeb3b';
            if (intel.threatLevel === 'HIGH') threatColor = '#ff9800';
            if (intel.threatLevel === 'EXTREME') threatColor = '#f44336';

            header.innerHTML = `
                <div style="font-size: 18px; font-weight: bold; color: ${i === 0 ? '#fff' : '#aaa'}">
                    Wave ${waveNum} ${i === 0 ? '<span style="font-size:12px; background:#4caf50; padding:2px 6px; border-radius:4px; margin-left:10px;">CURRENT</span>' : ''}
                </div>
                <div style="display:flex; gap:15px; font-size:14px;">
                    <span style="color:gold">Est. ${intel.totalReward}üí∞</span>
                    <span style="color:${threatColor}">‚ö†Ô∏è ${intel.threatLevel}</span>
                </div>
            `;
            card.appendChild(header);

            // Enemies List (Redesigned)
            const enemiesContainer = document.createElement('div');
            enemiesContainer.style.display = 'flex';
            enemiesContainer.style.flexDirection = 'column';
            enemiesContainer.style.gap = '4px';

            intel.enemies.forEach((e, idx) => {
                const row = document.createElement('div');
                Object.assign(row.style, {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '10px',
                    padding: '6px 10px',
                    background: (idx % 2 === 0) ? 'rgba(0,0,0,0.2)' : 'transparent',
                    borderRadius: '4px',
                });

                // Add "NEW" tag if applicable
                const newTag = e.isNew ? `<span style="background:#d32f2f; color:#fff; font-size:10px; padding:2px 4px; border-radius:3px; font-weight:bold; margin-right:5px;">NEW</span>` : '';

                // Name & Type
                // If unlocked, show details. If locked, show limited info.
                const nameStyle = e.isNew ? 'color: #aaa; font-style: italic;' : 'color: #fff; font-weight: 500;';
                const nameText = e.isNew ? 'Unknown Threat' : e.name;
                const iconDisplay = e.isNew ? '<span style="filter:blur(2px) grayscale(1); opacity:0.7">‚ùì</span>' : e.icon;

                row.innerHTML = `
                    <div style="width: 30px; text-align:center; font-size: 20px;">${iconDisplay}</div>
                    <div style="flex-grow: 1; ${nameStyle}">
                        ${newTag}${nameText}
                    </div>
                    <div style="font-weight: bold; color: #ddd;">x${e.count}</div>
                `;

                enemiesContainer.appendChild(row);
            });

            if (intel.enemies.length === 0) {
                enemiesContainer.innerHTML = `<span style="color:#555; padding:10px;">No signal...</span>`;
            }

            card.appendChild(enemiesContainer);
            this.elIntelView.appendChild(card);
        }
    }
}
</file>

<file path="src/ui/bestiary/WaveAnalyst.ts">
import { WaveManager } from '../../WaveManager';
import { CONFIG } from '../../Config';
import { ENEMY_TYPES } from '../../config/Enemies';

export interface IWaveSummary {
    waveNumber: number;
    enemies: Array<{
        type: string;
        count: number;
        icon: string;
        name: string;
        isNew: boolean; // Is this the first time this enemy appears?
    }>;
    totalCount: number;
    totalReward: number;
    threatLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'EXTREME';
    threatScore: number;
}

export class WaveAnalyst {
    private waveManager: WaveManager;
    private unlockedEnemies: Set<string>;

    constructor(waveManager: WaveManager, unlockedEnemies: Set<string>) {
        this.waveManager = waveManager;
        this.unlockedEnemies = unlockedEnemies;
    }

    public getWaveIntel(waveNum: number): IWaveSummary {
        const config = this.waveManager.getWaveConfig(waveNum);

        let totalCount = 0;
        let totalReward = 0;
        let totalHP = 0;
        const enemyMap = new Map<string, number>();

        if (config && config.enemies) {
            config.enemies.forEach(group => {
                const count = group.count;
                const type = group.type;

                totalCount += count;
                enemyMap.set(type, (enemyMap.get(type) || 0) + count);

                const stats = ENEMY_TYPES[type.toUpperCase()];
                if (stats) {
                    const hp = CONFIG.ENEMY.BASE_HP * stats.hpMod * Math.pow(CONFIG.ENEMY.HP_GROWTH, waveNum - 1);
                    totalHP += hp * count;
                    totalReward += stats.reward * count;
                }
            });
        }

        // Add base reward
        totalReward += CONFIG.ECONOMY.WAVE_BASE_REWARD + (waveNum * CONFIG.ECONOMY.WAVE_SCALING_FACTOR);

        // Convert map to array
        const enemiesList: IWaveSummary['enemies'] = [];
        enemyMap.forEach((count, type) => {
            const stats = ENEMY_TYPES[type.toUpperCase()];
            const isUnlocked = this.unlockedEnemies.has(type.toLowerCase());

            enemiesList.push({
                type: type,
                count: count,
                icon: isUnlocked ? stats?.symbol || '?' : '?',
                name: isUnlocked ? stats?.name || 'Unknown' : '???',
                isNew: !isUnlocked
            });
        });

        // Threat Calculation
        // Base threat usually increases by ~1.3x per wave in power
        // Simple heuristic: Total HP / Standard Tower DPS (approx 5)
        const dpsBenchmark = 5 * Math.max(1, waveNum * 0.5); // Expected DPS grows with wave
        const timeToKill = totalHP / dpsBenchmark;

        // Normalize threat
        let threat: IWaveSummary['threatLevel'] = 'LOW';
        if (timeToKill > 60) threat = 'MEDIUM';
        if (timeToKill > 120) threat = 'HIGH';
        if (timeToKill > 200) threat = 'EXTREME';

        return {
            waveNumber: waveNum,
            enemies: enemiesList,
            totalCount,
            totalReward: Math.floor(totalReward),
            threatLevel: threat,
            threatScore: Math.floor(timeToKill)
        };
    }
}
</file>

<file path="src/ui/TowerMenu.ts">
import { Tower, SlotState } from '../Tower';
import { CONFIG } from '../Config';
import { VISUALS } from '../VisualConfig';
import { Assets } from '../Assets';

export class TowerMenu {
    // Configuration
    private static readonly RADIUS = 32;
    private static readonly SAT_SIZE = 14;

    // Satellite positions (relative to center)
    private static readonly ANGLES = [
        -Math.PI / 2,       // -90 deg (Top)
        Math.PI / 6,        // 30 deg (Bottom Right)
        Math.PI * 5 / 6     // 150 deg (Bottom Left)
    ];

    public static draw(ctx: CanvasRenderingContext2D, tower: Tower) {
        if (!tower) return;

        // Draw connecting lines first
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);

        this.ANGLES.forEach((angle, index) => {
            const sx = tower.x + Math.cos(angle) * this.RADIUS;
            const sy = tower.y + Math.sin(angle) * this.RADIUS;

            ctx.beginPath();
            ctx.moveTo(tower.x, tower.y);
            ctx.lineTo(sx, sy);
            ctx.stroke();
        });
        ctx.setLineDash([]);

        // Draw Satellites
        this.ANGLES.forEach((angle, index) => {
            const sx = tower.x + Math.cos(angle) * this.RADIUS;
            const sy = tower.y + Math.sin(angle) * this.RADIUS;
            const slot = tower.slots.find(s => s.id === index);

            this.drawSatellite(ctx, sx, sy, slot, index, tower.selectedSlotId === index);
        });
    }

    private static drawSatellite(ctx: CanvasRenderingContext2D, x: number, y: number, slot: SlotState | undefined, index: number, isSelected: boolean) {
        const r = this.SAT_SIZE;

        // Background
        ctx.fillStyle = isSelected ? '#444' : '#222';
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();

        // Border
        ctx.strokeStyle = isSelected ? '#0f0' : (slot?.isLocked ? '#666' : '#fff');
        ctx.lineWidth = isSelected ? 3 : 2;
        ctx.stroke();

        // Content
        if (slot?.isLocked) {
            // LOCK ICON
            this.drawLock(ctx, x, y, r); // Pass radius for scaling

            // Price Tag
            const price = CONFIG.ECONOMY.SLOT_UNLOCK_COST[index];
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${price}`, x, y + r + 10);
        } else if (slot?.card) {
            // CARD ICON
            const color = slot.card.type.color;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r * 0.7, 0, Math.PI * 2);
            ctx.fill();

            // Level indicator
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px Arial';
            ctx.fillText(`${slot.card.level}`, x, y);
        } else {
            // EMPTY (Plus or dashed?)
            ctx.strokeStyle = isSelected ? '#0f0' : '#666';
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.arc(x, y, r * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    private static drawLock(ctx: CanvasRenderingContext2D, x: number, y: number, r: number) {
        const w = r * 0.5;
        const h = r * 0.4;

        ctx.fillStyle = '#ccc';
        // Body
        ctx.fillRect(x - w / 2, y - h / 2, w, h);
        // Shackle
        ctx.beginPath();
        ctx.arc(x, y - h / 2, w / 3, Math.PI, 0);
        ctx.stroke();
    }

    public static getClickedAction(tower: Tower, clickX: number, clickY: number): { type: 'UNLOCK' | 'CLICK_SLOT', slotId: number } | null {
        for (let i = 0; i < this.ANGLES.length; i++) {
            const angle = this.ANGLES[i];
            const sx = tower.x + Math.cos(angle) * this.RADIUS;
            const sy = tower.y + Math.sin(angle) * this.RADIUS;

            // Check Hit
            const dx = clickX - sx;
            const dy = clickY - sy;
            const distSq = dx * dx + dy * dy;

            const HIT_SIZE = this.SAT_SIZE + 5;

            if (distSq <= HIT_SIZE * HIT_SIZE) {
                const slot = tower.slots.find(s => s.id === i);
                if (!slot) return null;

                if (slot.isLocked) {
                    return { type: 'UNLOCK', slotId: i };
                } else {
                    // For both Empty and Card slots, we return CLICK_SLOT
                    // The Controller decides whether to select or remove/interact
                    return { type: 'CLICK_SLOT', slotId: i };
                }
            }
        }
        return null;
    }
}
</file>

<file path="src/UIRoot.ts">
export class UIRoot {
    private gameContainer: HTMLElement;
    private uiLayer: HTMLElement;
    private handContainer: HTMLElement;
    private tooltipContainer: HTMLElement;
    private overlayContainer: HTMLElement;

    constructor() {
        // Find existing stricture or create
        this.gameContainer = document.getElementById('app') || document.body;

        this.uiLayer = this.ensureElement('ui-layer');
        this.handContainer = this.ensureElement('hand-container');
        this.tooltipContainer = this.ensureElement('tooltip-container');
        this.overlayContainer = this.ensureElement('overlay-layer');

        // Ensure z-indices
        this.uiLayer.style.zIndex = '10';
        this.handContainer.style.zIndex = '20';
        this.tooltipContainer.style.zIndex = '100';
        this.overlayContainer.style.zIndex = '1000';
    }

    private ensureElement(id: string): HTMLElement {
        let el = document.getElementById(id);
        if (!el) {
            el = document.createElement('div');
            el.id = id;
            el.style.position = 'absolute';
            el.style.top = '0';
            el.style.left = '0';
            el.style.width = '100%';
            el.style.height = '100%';
            el.style.pointerEvents = 'none'; // Allow clicks to pass through by default

            // Check if specific container needs pointer events
            if (id === 'hand-container') {
                el.style.pointerEvents = 'none'; // Hand items will have pointer-events: auto
            }

            this.gameContainer.appendChild(el);
        }
        return el;
    }

    public showGameUI() {
        this.uiLayer.style.display = 'block';
        this.handContainer.style.display = 'block';
    }

    public hideGameUI() {
        this.uiLayer.style.display = 'none';
        this.handContainer.style.display = 'none';
        // Hide tooltips too?
        this.tooltipContainer.innerHTML = '';
    }

    public getLayer(id: 'ui' | 'hand' | 'tooltip' | 'overlay'): HTMLElement {
        switch (id) {
            case 'ui': return this.uiLayer;
            case 'hand': return this.handContainer;
            case 'tooltip': return this.tooltipContainer;
            case 'overlay': return this.overlayContainer;
        }
    }

    public clearLayer(id: 'ui' | 'hand' | 'tooltip' | 'overlay') {
        this.getLayer(id).innerHTML = '';
    }
}
</file>

<file path="src/utils/Rng.ts">
/**
 * Deterministic Random Number Generator using Mulberry32 algorithm.
 * Fast, lightweight, and suitable for game logic stability.
 */
export class Rng {
    private state: number;

    constructor(seed: number) {
        // Ensure seed is a 32-bit integer
        this.state = seed >>> 0;
    }

    /**
     * Returns a float between 0 (inclusive) and 1 (exclusive).
     */
    public next(): number {
        this.state = (this.state + 0x6D2B79F5) | 0;
        let t = Math.imul(this.state ^ (this.state >>> 15), 1 | this.state);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }

    /**
     * Alias for next()
     */
    public nextFloat(): number {
        return this.next();
    }

    /**
     * Returns an integer between min (inclusive) and max (inclusive).
     */
    public nextInt(min: number, max: number): number {
        return Math.floor(min + this.next() * (max - min + 1));
    }

    /**
     * Shuffles an array in-place using Fisher-Yates algorithm.
     */
    public shuffle<T>(array: T[]): void {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(this.next() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    /**
     * Returns true with probability p (0-1).
     */
    public chance(p: number): boolean {
        return this.next() < p;
    }
}
</file>

<file path="src/utils/SafeJson.ts">
export class SafeJson {
    /**
     * Safely serializes an object to JSON, handling circular references and limiting depth.
     * @param data The object to serialize
     * @param maxDepth Maximum recursion depth (default 3)
     * @param pretty Whether to separate lines (default false)
     */
    public static stringify(data: any, maxDepth: number = 3, pretty: boolean = false): string {
        const seen = new WeakSet();

        const replacer = (key: string, value: any) => {
            // Handle primitives
            if (value === null || typeof value !== 'object') {
                return value;
            }

            // Handle circular references
            if (seen.has(value)) {
                return '[Circular]';
            }
            seen.add(value);

            // Handle DOM elements (too heavy to serialize)
            if (value instanceof HTMLElement) {
                return `[HTMLElement: ${value.tagName}]`;
            }

            // Handle depth manually if needed, but WeakSet handles recursion loops.
            // For true depth limiting, we'd need a recursive custom serializer, 
            // but JSON.stringify compliant replacer is harder to limit by depth directly.
            // So we rely on a custom recursive function instead of standard JSON.stringify if we want strict depth.

            return value;
        };

        // For strict depth control and safety, we implement a custom walker instead of just JSON.stringify
        const sanitized = SafeJson.sanitize(data, maxDepth, new WeakSet());
        return JSON.stringify(sanitized, null, pretty ? 2 : 0);
    }

    private static sanitize(obj: any, depth: number, visited: WeakSet<any>): any {
        // Base cases
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }

        // Check loops
        if (visited.has(obj)) {
            return '[Circular]';
        }

        // Check depth
        if (depth < 0) {
            return '[MaxDepth]';
        }

        // Special types
        if (obj instanceof HTMLElement) return `[HTMLElement: ${obj.tagName}]`;
        if (obj instanceof Function) return `[Function: ${obj.name || 'anonymous'}]`;
        if (obj instanceof Error) return { message: obj.message, stack: obj.stack };

        // Add to visited
        visited.add(obj);

        // Arrays
        if (Array.isArray(obj)) {
            return obj.map(item => SafeJson.sanitize(item, depth - 1, visited));
        }

        // Objects
        const res: any = {};
        for (const key in obj) {
            // Skip large numeric keys usually found in huge lookup tables or large arrays treated as objects
            // Also skip private keys like _private
            if (key.startsWith('_')) continue;

            try {
                res[key] = SafeJson.sanitize(obj[key], depth - 1, visited);
            } catch (e) {
                res[key] = '[Error accessing property]';
            }
        }
        return res;
    }
}
</file>

<file path="src/utils/SeededRandom.ts">
/**
 * Simple Linear Congruential Generator (LCG) for deterministic randomness.
 * Allows reproducible stress tests.
 */
export class SeededRandom {
    private seed: number;

    constructor(seed: number) {
        this.seed = seed;
    }

    /**
     * Returns a float between 0 and 1
     */
    public next(): number {
        this.seed = (this.seed * 9301 + 49297) % 233280;
        return this.seed / 233280;
    }

    /**
     * Returns float between min and max
     */
    public rangeFloat(min: number, max: number): number {
        return min + this.next() * (max - min);
    }

    /**
     * Returns integer between min and max (inclusive min, inclusive max)
     */
    public range(min: number, max: number): number {
        return Math.floor(min + this.next() * (max - min + 1));
    }

    /**
     * Returns true with probability p (0-1)
     */
    public chance(p: number): boolean {
        return this.next() < p;
    }
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="src/Card.ts">
export enum CardType {
    TOWER = 'tower',
    SPELL = 'spell',
}

export interface ICardConfig {
    id: string;
    name: string;
    description: string;
    cost: number;
    type: CardType;
    value: number;
}

export class Card {
    public id: string;
    public name: string;
    public cost: number;
    public level: number = 1;
    private config: ICardConfig;

    constructor(config: ICardConfig) {
        this.id = config.id;
        this.name = config.name;
        this.cost = config.cost;
        this.config = config;
    }

    public upgrade(): void {
        this.level += 1;
        this.cost = Math.floor(this.cost * 1.5);
    }
}
</file>

<file path="src/DayNightCycle.ts">
/**
 * Day/Night cycle system - simple and configurable
 */
export interface IDayNightConfig {
    cycleDuration: number; // seconds for full cycle
    startTime: number; // 0-1, where to start (0=dawn, 0.5=dusk, 1=midnight)
}

export class DayNightCycle {
    private time: number = 0; // 0-1
    private config: IDayNightConfig;

    constructor(config?: Partial<IDayNightConfig>) {
        this.config = {
            cycleDuration: 240, // 4 minutes default (was reduced from original by 30%)
            startTime: 0.15, // Start closer to dawn for brighter initial lighting
            ...config
        };

        this.time = this.config.startTime;
    }

    /**
     * Update the cycle
     * @param deltaTime - time in seconds since last update
     */
    public update(deltaTime: number): void {
        const increment = deltaTime / this.config.cycleDuration;
        this.time = (this.time + increment) % 1;
    }

    /**
     * Get current time of day
     * @returns 0-1 value (0=dawn, 0.25=noon, 0.5=dusk, 0.75=midnight, 1=dawn again)
     */
    public getTimeOfDay(): number {
        return this.time;
    }

    /**
     * Check if it's currently day time
     */
    public isDay(): boolean {
        return this.time < 0.5;
    }

    /**
     * Check if it's currently night time
     */
    public isNight(): boolean {
        return this.time >= 0.5;
    }

    /**
     * Set time manually (for testing/debugging)
     */
    public setTime(time: number): void {
        this.time = Math.max(0, Math.min(1, time));
    }

    /**
     * Get human-readable time string
     */
    public getTimeString(): string {
        if (this.time < 0.25) return 'Morning';
        if (this.time < 0.5) return 'Afternoon';
        if (this.time < 0.75) return 'Evening';
        return 'Night';
    }

    /**
     * Update configuration at runtime
     */
    public updateConfig(newConfig: Partial<IDayNightConfig>): void {
        this.config = { ...this.config, ...newConfig };
    }
}
</file>

<file path="src/editor/EditorHistory.ts">
interface IEditorAction {
    type: 'tile' | 'waypoint' | 'fog';
    undo: () => void;
    redo: () => void;
}

export class EditorHistory {
    private undoStack: IEditorAction[] = [];
    private redoStack: IEditorAction[] = [];
    private readonly maxSize = 50;

    public push(action: IEditorAction): void {
        this.undoStack.push(action);

        // Clear redo stack when new action is added
        this.redoStack = [];

        // Maintain max size
        if (this.undoStack.length > this.maxSize) {
            this.undoStack.shift();
        }
    }

    public undo(): boolean {
        const action = this.undoStack.pop();
        if (!action) return false;

        action.undo();
        this.redoStack.push(action);

        return true;
    }

    public redo(): boolean {
        const action = this.redoStack.pop();
        if (!action) return false;

        action.redo();
        this.undoStack.push(action);

        return true;
    }

    public clear(): void {
        this.undoStack = [];
        this.redoStack = [];
    }

    public canUndo(): boolean {
        return this.undoStack.length > 0;
    }

    public canRedo(): boolean {
        return this.redoStack.length > 0;
    }

    // --- Compound Action Support ---

    private pendingCompound: IEditorAction[] | null = null;
    private pendingLabel: string = '';

    public beginCompound(label: string): void {
        this.pendingCompound = [];
        this.pendingLabel = label;
    }

    public pushInCompound(action: IEditorAction): void {
        if (this.pendingCompound) {
            this.pendingCompound.push(action);
        } else {
            // Fallback: no active compound, push directly
            this.push(action);
        }
    }

    public commitCompound(): void {
        if (!this.pendingCompound || this.pendingCompound.length === 0) {
            this.pendingCompound = null;
            return;
        }

        const actions = this.pendingCompound;
        this.pendingCompound = null;

        // Single undo step that reverses all sub-actions
        this.push({
            type: actions[0].type,
            undo: () => {
                for (let i = actions.length - 1; i >= 0; i--) {
                    actions[i].undo();
                }
            },
            redo: () => {
                for (let i = 0; i < actions.length; i++) {
                    actions[i].redo();
                }
            }
        });
    }

    public cancelCompound(): void {
        // Undo any already applied actions in the compound
        if (this.pendingCompound) {
            for (let i = this.pendingCompound.length - 1; i >= 0; i--) {
                this.pendingCompound[i].undo();
            }
        }
        this.pendingCompound = null;
    }
}

// Action factory helpers
export class EditorActions {
    /**
     * Create a tile change action
     */
    static createTileAction(
        grid: any[][],
        col: number,
        row: number,
        oldType: number,
        newType: number
    ): IEditorAction {
        return {
            type: 'tile',
            undo: () => {
                grid[row][col].type = oldType;
            },
            redo: () => {
                grid[row][col].type = newType;
            }
        };
    }

    /**
     * Create a fog change action
     */
    static createFogAction(
        fog: any,
        col: number,
        row: number,
        oldDensity: number,
        newDensity: number
    ): IEditorAction {
        return {
            type: 'fog',
            undo: () => {
                fog.setFog(col, row, oldDensity);
            },
            redo: () => {
                fog.setFog(col, row, newDensity);
            }
        };
    }

    /**
     * Create a waypoint action
     */
    static createWaypointAction(
        waypointMgr: any,
        actionType: 'addWaypoint' | 'setStart' | 'setEnd',
        position: { x: number; y: number },
        oldState?: any
    ): IEditorAction {
        return {
            type: 'waypoint',
            undo: () => {
                // Restore old state (for simplicity, clear and rebuild)
                if (oldState) {
                    waypointMgr.clearAll();
                    if (oldState.start) waypointMgr.setStart(oldState.start);
                    if (oldState.end) waypointMgr.setEnd(oldState.end);
                    oldState.waypoints?.forEach((wp: any) => waypointMgr.addWaypoint(wp));
                }
            },
            redo: () => {
                if (actionType === 'addWaypoint') {
                    waypointMgr.addWaypoint(position);
                } else if (actionType === 'setStart') {
                    waypointMgr.setStart(position);
                } else if (actionType === 'setEnd') {
                    waypointMgr.setEnd(position);
                }
            }
        };
    }
}
</file>

<file path="src/editor/ThreatService.ts">
import { IWaveConfig, IWaveGroup, IWaveGroupRaw, SpawnPattern } from '../MapData';
import { EnemyRegistry } from './EnemyRegistry';
import { WaveManager } from '../WaveManager';

export class ThreatService {

    /**
     * Multipliers for different spawn patterns.
     */
    private static PATTERN_MULTIPLIERS: Record<SpawnPattern, number> = {
        'normal': 1.0,
        'random': 1.1, // Uncertainty factor
        'swarm': 1.5   // Burst density factor
    };

    /**
     * Calculates the threat level of a single enemy group.
     * Accepts Raw config but normalizes it first for accurate calculation.
     */
    public static calculateGroupThreat(rawGroup: IWaveGroupRaw): number {
        // 1. Normalize using the Runtime Truth (WaveManager)
        let group: IWaveGroup;
        try {
            group = WaveManager.normalizeWaveGroup(rawGroup);
        } catch (e) {
            // Fallback for invalid groups in editor (so it doesn't crash)
            console.warn('[ThreatService] Invalid group:', e);
            return 0;
        }

        // 2. Factors
        const powerPerUnit = EnemyRegistry.getPowerRating(group.type) || 1; // Default to 1 if unknown (e.g. invalid type)
        const patternMult = this.PATTERN_MULTIPLIERS[group.pattern] || 1.0;

        // 3. Density Multiplier (Continuous function)
        // Formula: k = 0.25; Density = 0.75 + (1 / interval) * k
        // 0.1s -> 3.25 (Clamped 2.0)
        // 1.0s -> 1.0
        // 2.0s -> 0.875
        const k = 0.25;
        let density = 0.75 + (1.0 / Math.max(0.05, group.baseInterval)) * k;

        // Clamp to sane limits [0.8, 2.0]
        density = Math.max(0.8, Math.min(density, 2.0));

        // 4. Final Calculation
        return (powerPerUnit * group.count) * patternMult * density;
    }

    /**
     * Calculates the total threat level of a wave.
     */
    public static calculateWaveThreat(wave: IWaveConfig): number {
        if (!wave.enemies) return 0;

        return wave.enemies.reduce((total, group) => {
            return total + this.calculateGroupThreat(group);
        }, 0);
    }

    /**
     * Returns a color code representing the threat level.
     */
    public static getThreatColor(threat: number): string {
        if (threat < 300) return '#4caf50'; // Green
        if (threat < 800) return '#ffd700'; // Gold
        if (threat < 1500) return '#ff9800'; // Orange
        if (threat < 2500) return '#f44336'; // Red
        return '#9c27b0'; // Purple
    }

    public static getThreatLabel(threat: number): string {
        if (threat < 300) return 'SAFE';
        if (threat < 800) return 'NORMAL';
        if (threat < 1500) return 'DANGEROUS';
        if (threat < 2500) return 'LETHAL';
        return 'NIGHTMARE';
    }
}
</file>

<file path="src/effects/DeathAnimations.ts">
/**
 * Death Animation System
 * 
 * –ú–æ–¥—É–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∞–Ω–∏–º–∞—Ü–∏–π —Å–º–µ—Ä—Ç–∏ –≤—Ä–∞–≥–æ–≤ –ø–æ –∞—Ä—Ö–µ—Ç–∏–ø–∞–º.
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π EffectSystem –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞.
 * 
 * –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –≥–æ—Ç–æ–≤–∞ –∫ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—é:
 * - –ê–Ω–∏–º–∞—Ç–æ—Ä—ã –º–æ–∂–Ω–æ –≤—ã–Ω–æ—Å–∏—Ç—å –≤ /animators/*.ts
 * - –•–µ–ª–ø–µ—Ä—ã –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –º–µ–∂–¥—É –∞–Ω–∏–º–∞—Ç–æ—Ä–∞–º–∏
 */

import { EffectSystem } from '../EffectSystem';
import { Enemy } from '../Enemy';
import { IEnemyTypeConfig } from '../types';
import { IDeathAnimator } from './types';

// ============================================
// –†–ï–ï–°–¢–† –ê–ù–ò–ú–ê–¢–û–†–û–í
// ============================================

const ANIMATORS: Record<string, IDeathAnimator> = {
    SKELETON: playBoneScatter,
    SKELETON_COMMANDER: playGoldBones,
    HELLHOUND: playFireBurst,
    ORC: playHeavyDebris,
    WRAITH: playGhostDissolve,
    GOBLIN: playSmallDebris,
    SPIDER: playAcidPop,
    TROLL: playIceShatter,
    MAGMA: playLavaPop,
    RAT: playToxicExplosion,
    WOLF: playDefaultDeath,
};

// ============================================
// –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø
// ============================================

/**
 * –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∞–Ω–∏–º–∞—Ü–∏—é —Å–º–µ—Ä—Ç–∏ –≤—Ä–∞–≥–∞.
 * –í—ã–±–∏—Ä–∞–µ—Ç –∞–Ω–∏–º–∞—Ç–æ—Ä –ø–æ –∞—Ä—Ö–µ—Ç–∏–ø—É –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞.
 */
export function playDeathAnimation(
    effects: EffectSystem,
    enemy: Enemy,
    config: IEnemyTypeConfig | undefined
): void {
    const archetype = config?.archetype || 'SKELETON';
    const animator = ANIMATORS[archetype] || playDefaultDeath;

    // –°–æ–∑–¥–∞—ë–º fallback –∫–æ–Ω—Ñ–∏–≥ –µ—Å–ª–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω
    const safeConfig: IEnemyTypeConfig = config || {
        id: enemy.typeId,
        name: 'Unknown',
        symbol: '?',
        hpMod: 1,
        speed: 60,
        reward: 5,
        color: '#888888',
        desc: '',
    };

    animator(effects, enemy.x, enemy.y, safeConfig);
}

// ============================================
// –ê–ù–ò–ú–ê–¢–û–†–´ (–≥–æ—Ç–æ–≤—ã –∫ –≤—ã–Ω–æ—Å—É –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã)
// ============================================

/** –ë–∞–∑–æ–≤–∞—è –∞–Ω–∏–º–∞—Ü–∏—è ‚Äî –æ–±–ª–æ–º–∫–∏ –ø–æ —Ü–≤–µ—Ç—É –≤—Ä–∞–≥–∞ */
function playDefaultDeath(e: EffectSystem, x: number, y: number, c: IEnemyTypeConfig) {
    addDebris(e, x, y, 5, c.color || '#888', 200, 120);
}

/** –°–∫–µ–ª–µ—Ç ‚Äî –±–µ–ª—ã–µ –∫–æ—Å—Ç–∏ + –ø—ã–ª—å */
function playBoneScatter(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 6, '#e0d0b0', 280, 180); // –ö–æ—Å—Ç–∏
    addDust(e, x, y, 3, 'rgba(180,160,140,0.5)');
}

/** –ö–æ–º–∞–Ω–¥–∏—Ä —Å–∫–µ–ª–µ—Ç–æ–≤ ‚Äî –∑–æ–ª–æ—Ç—ã–µ –∫–æ—Å—Ç–∏ + —Å–∏—è–Ω–∏–µ */
function playGoldBones(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 5, '#ffd700', 260, 160);
    addDust(e, x, y, 2, 'rgba(255,215,0,0.3)');
}

/** –ê–¥—Å–∫–∞—è –≥–æ–Ω—á–∞—è ‚Äî –æ–≥–æ–Ω—å + —É–≥–ª–∏ */
function playFireBurst(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 5, '#ff6d00', 200, 120);
    addEmbers(e, x, y, 5, '#ffab00');
}

/** –û—Ä–∫ ‚Äî —Ç—è–∂—ë–ª—ã–µ –∫—Ä—É–ø–Ω—ã–µ –æ–±–ª–æ–º–∫–∏ */
function playHeavyDebris(e: EffectSystem, x: number, y: number, c: IEnemyTypeConfig) {
    addDebris(e, x, y, 5, c.color || '#558b2f', 160, 80, 4);
}

/** –ü—Ä–∏–∑—Ä–∞–∫ ‚Äî –¥—É—à–∏ —É–ª–µ—Ç–∞—é—Ç –≤–≤–µ—Ä—Ö */
function playGhostDissolve(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addSoulOrbs(e, x, y, 6, '#7c4dff');
}

/** –ì–æ–±–ª–∏–Ω ‚Äî –º–µ–ª–∫–∏–µ –æ–±–ª–æ–º–∫–∏ */
function playSmallDebris(e: EffectSystem, x: number, y: number, c: IEnemyTypeConfig) {
    addDebris(e, x, y, 4, c.color || '#689f38', 150, 100, 2);
}

/** –ü–∞—É–∫ ‚Äî –∫–∏—Å–ª–æ—Ç–Ω—ã–µ –±—Ä—ã–∑–≥–∏ */
function playAcidPop(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 3, '#76ff03', 120, 60, 2);
    addDust(e, x, y, 2, 'rgba(118,255,3,0.3)');
}

/** –¢—Ä–æ–ª–ª—å ‚Äî –ª–µ–¥—è–Ω—ã–µ –æ—Å–∫–æ–ª–∫–∏ */
function playIceShatter(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 5, '#90caf9', 220, 140);
}

/** –ú–∞–≥–º–∞ ‚Äî –ª–∞–≤–∞ + –¥—ã–º –æ—Å—Ç—ã–≤–∞–Ω–∏—è */
function playLavaPop(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    addDebris(e, x, y, 4, '#ff3d00', 180, 100);
    addDust(e, x, y, 2, 'rgba(50,50,50,0.5)');
}

/** –ö—Ä—ã—Å–∞-—Å–∞–ø—ë—Ä ‚Äî —Ç–æ–∫—Å–∏—á–Ω—ã–π –≤–∑—Ä—ã–≤ (—Ä–∞–¥–∏–∞–ª—å–Ω—ã–µ –∏—Å–∫—Ä—ã) */
function playToxicExplosion(e: EffectSystem, x: number, y: number, _c: IEnemyTypeConfig) {
    // –†–∞–¥–∏–∞–ª—å–Ω—ã–µ –∑–µ–ª—ë–Ω—ã–µ –∏—Å–∫—Ä—ã
    const sparkCount = 6;
    for (let i = 0; i < sparkCount; i++) {
        const angle = (i / sparkCount) * Math.PI * 2;
        const speed = 120 + Math.random() * 60;
        e.add({
            type: 'particle',
            x,
            y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 30,
            life: 0.5 + Math.random() * 0.2,
            radius: 4 + Math.random() * 2,
            color: '#76ff03',
        });
    }
    // –¢–æ–∫—Å–∏—á–Ω—ã–π –¥—ã–º
    addDust(e, x, y, 3, 'rgba(118,255,3,0.4)');
    // –û–±–ª–æ–º–∫–∏ –±–æ—á–∫–∏
    addDebris(e, x, y, 3, '#4e342e', 140, 80, 3);
}

// ============================================
// –•–ï–õ–ü–ï–†–´
// ============================================

/**
 * –î–æ–±–∞–≤–∏—Ç—å —Ä–∞–∑–ª–µ—Ç–∞—é—â–∏–µ—Å—è –æ–±–ª–æ–º–∫–∏
 */
function addDebris(
    e: EffectSystem,
    x: number,
    y: number,
    count: number,
    color: string,
    vxRange: number,
    vyBase: number,
    size = 4
) {
    for (let i = 0; i < count; i++) {
        e.add({
            type: 'debris',
            x,
            y,
            vx: (Math.random() - 0.5) * vxRange * 1.5,
            vy: -(Math.random() * vyBase + vyBase * 0.8),
            life: 0.5 + Math.random() * 0.2,
            size: size + Math.random() * 3,
            color,
            rotation: Math.random() * Math.PI * 2,
            vRot: (Math.random() - 0.5) * 15,
            gravity: 500,
        });
    }
}

/**
 * –î–æ–±–∞–≤–∏—Ç—å –ø—ã–ª—å/–¥—ã–º (–º—è–≥–∫–∏–µ —á–∞—Å—Ç–∏—Ü—ã)
 */
function addDust(
    e: EffectSystem,
    x: number,
    y: number,
    count: number,
    color: string
) {
    for (let i = 0; i < count; i++) {
        e.add({
            type: 'particle',
            x: x + (Math.random() - 0.5) * 20,
            y: y + (Math.random() - 0.5) * 15,
            vx: (Math.random() - 0.5) * 50,
            vy: -20 - Math.random() * 40,
            life: 0.4 + Math.random() * 0.2,
            radius: 6 + Math.random() * 6,
            color,
        });
    }
}

/**
 * –î–æ–±–∞–≤–∏—Ç—å —É–≥–ª–∏/–∏—Å–∫—Ä—ã (–æ–≥–Ω–µ–Ω–Ω—ã–µ —á–∞—Å—Ç–∏—Ü—ã)
 */
function addEmbers(
    e: EffectSystem,
    x: number,
    y: number,
    count: number,
    color: string
) {
    for (let i = 0; i < count; i++) {
        e.add({
            type: 'particle',
            x,
            y,
            vx: (Math.random() - 0.5) * 120,
            vy: -(Math.random() * 100 + 60),
            life: 0.5 + Math.random() * 0.3,
            radius: 3 + Math.random() * 2,
            color,
        });
    }
}

/**
 * –î–æ–±–∞–≤–∏—Ç—å –¥—É—à–∏/–æ—Ä–±—ã (–ø—Ä–∏–∑—Ä–∞—á–Ω—ã–µ —á–∞—Å—Ç–∏—Ü—ã –≤–≤–µ—Ä—Ö)
 */
function addSoulOrbs(
    e: EffectSystem,
    x: number,
    y: number,
    count: number,
    color: string
) {
    for (let i = 0; i < count; i++) {
        e.add({
            type: 'particle',
            x: x + (Math.random() - 0.5) * 30,
            y,
            vx: (Math.random() - 0.5) * 60,
            vy: -(Math.random() * 120 + 80),
            life: 0.7 + Math.random() * 0.3,
            radius: 5 + Math.random() * 3,
            color,
        });
    }
}
</file>

<file path="src/Events.ts">
type Listener = (data?: any) => void;

export class EventEmitter {
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –ø–æ–¥–ø–∏—Å–æ–∫: '–Ω–∞–∑–≤–∞–Ω–∏–µ_—Å–æ–±—ã—Ç–∏—è' -> [—Å–ø–∏—Å–æ–∫ —Ñ—É–Ω–∫—Ü–∏–π]
    private events: { [key: string]: Listener[] };

    constructor() {
        this.events = {};
    }

    // –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏–µ
    public on(event: string, listener: Listener): void {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
    }

    // –û—Ç–ø–∏—Å–∞—Ç—å—Å—è
    public off(event: string, listener: Listener): void {
        if (!this.events[event]) return;
        this.events[event] = this.events[event].filter((l) => l !== listener);
    }

    // –ö—Ä–∏–∫–Ω—É—Ç—å –Ω–∞ –≤—Å—é –∏–≥—Ä—É: "–ü—Ä–æ–∏–∑–æ—à–ª–æ —Å–æ–±—ã—Ç–∏–µ!"
    public emit(event: string, data?: any): void {
        if (!this.events[event]) return;
        this.events[event].forEach((listener) => listener(data));
    }
}
</file>

<file path="src/FlowField.ts">
import { CONFIG } from './Config';
import { Cell } from './MapData';

export class FlowField {
    public cols: number;
    public rows: number;
    public target: { x: number; y: number } | null = null;

    // Engine-Grade Buffers (Flat Arrays)
    // Distances: -1 = Unreachable, >=0 = Distance
    public distances: Int32Array;
    // Vectors: interleaved x,y. index*2 = x, index*2+1 = y. Values: -1, 0, 1
    public vectors: Int8Array;

    // Search State (Shared)
    private queue: Int32Array;
    private visited: Uint16Array;
    private searchId: number = 0;

    // Version tracking
    public version: number = 0;

    constructor(cols: number, rows: number) {
        this.cols = cols;
        this.rows = rows;

        // Allocate buffers
        const size = cols * rows;
        this.distances = new Int32Array(size);
        this.vectors = new Int8Array(size * 2);
        this.queue = new Int32Array(size); // Max queue size is whole map
        this.visited = new Uint16Array(size);

        this.reset();
    }

    /**
     * Resizes buffers if map dimensions change (Editor support)
     */
    public resize(cols: number, rows: number) {
        this.cols = cols;
        this.rows = rows;
        const size = cols * rows;
        this.distances = new Int32Array(size);
        this.vectors = new Int8Array(size * 2);
        this.queue = new Int32Array(size);
        this.visited = new Uint16Array(size);
        this.searchId = 0;
        this.reset();
    }

    public reset() {
        this.distances.fill(-1);
        this.vectors.fill(0);
        // We don't need to reset visited/queue as they use searchId/pointers
    }

    /**
     * Generates the Flow Field (Dijkstra Map + Vector Field)
     * Zero-Allocation implementation.
     */
    public generate(grid: Cell[][], target: { x: number; y: number }) {
        this.target = target;
        this.version++;
        this.searchId++;

        // Overflow protection for searchId
        if (this.searchId >= 65000) {
            this.searchId = 1;
            this.visited.fill(0);
        }

        // Initialize Search
        const targetIdx = target.y * this.cols + target.x;

        // Reset buffers logic
        // We can't use fill(-1) on distances efficiently every time?
        // Actually, for FlowField we overwrite reachable values. 
        // But unreachable ones must remain -1.
        // Option: Track 'touched' indices or just fill(-1) since generate is not per-frame.
        // Since generate happens only on build/dirty, fill(-1) is acceptable safety.
        this.distances.fill(-1);
        this.vectors.fill(0);

        // BFS params
        let head = 0;
        let tail = 0;

        // Push Target
        this.queue[tail++] = targetIdx;
        this.visited[targetIdx] = this.searchId;
        this.distances[targetIdx] = 0;

        const cols = this.cols;
        const rows = this.rows;

        // Directions: Up, Right, Down, Left
        // Optimization: Pre-calc neighbor offsets? 
        // For strict grid: -cols, +1, +cols, -1
        const offsets = [-cols, 1, cols, -1];
        const dxs = [0, 1, 0, -1];
        const dys = [-1, 0, 1, 0];

        while (head < tail) {
            const currentIdx = this.queue[head++];
            const dist = this.distances[currentIdx];

            // Reconstruct x,y only if needed for boundary checks
            // Optimization: checking boundaries using 1D index is tricky without x,y
            const cx = currentIdx % cols;
            // const cy = (currentIdx / cols) | 0;

            for (let i = 0; i < 4; i++) {
                const offset = offsets[i];
                const neighborIdx = currentIdx + offset;

                // Simple 1D boundary checks
                // 1. Array bounds
                if (neighborIdx < 0 || neighborIdx >= this.distances.length) continue;

                // 2. Wrap-around checks (e.g. Right edge to Left edge)
                // If moving Right (+1), make sure we didn't jump to x=0
                if (i === 1 && (neighborIdx % cols) === 0) continue;
                // If moving Left (-1), make sure we didn't jump to x=cols-1
                if (i === 3 && ((neighborIdx + 1) % cols) === 0) continue;

                // Valid neighbor
                const nx = cx + dxs[i];
                const ny = (neighborIdx / cols) | 0;

                // Game Logic Rule: Only walk on PATH (type === 1)
                const cell = grid[ny][nx];

                if (cell.type === 1) {
                    if (this.visited[neighborIdx] !== this.searchId) {
                        this.visited[neighborIdx] = this.searchId;
                        this.distances[neighborIdx] = dist + 1;
                        this.queue[tail++] = neighborIdx;
                    }
                }
            }
        }

        // 2. Generate Vectors
        // Iterate only reachable cells? Or all?
        // Can utilize the queue 'touched' cells? No, queue is empty now.
        // We iterate all cells.
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                const idx = y * cols + x;
                const dist = this.distances[idx];

                if (dist === -1) continue; // Unreachable

                let minDist = dist;
                let bestDirIndex = -1;

                // Check neighbors
                for (let i = 0; i < 4; i++) {
                    const offset = offsets[i];
                    const neighborIdx = idx + offset;

                    if (neighborIdx < 0 || neighborIdx >= this.distances.length) continue;
                    // Wrap/Boundary checks
                    if (i === 1 && (neighborIdx % cols) === 0) continue;
                    if (i === 3 && ((neighborIdx + 1) % cols) === 0) continue;

                    const nDist = this.distances[neighborIdx];
                    if (nDist !== -1 && nDist < minDist) {
                        minDist = nDist;
                        bestDirIndex = i;
                    }
                }

                if (bestDirIndex !== -1) {
                    this.vectors[idx * 2] = dxs[bestDirIndex]; // x
                    this.vectors[idx * 2 + 1] = dys[bestDirIndex]; // y
                }
            }
        }
    }

    /**
     * Gets movement vector. Optimized for flat array.
     */
    public getVector(worldX: number, worldY: number, out: { x: number; y: number }): void {
        const col = Math.floor(worldX / CONFIG.TILE_SIZE);
        const row = Math.floor(worldY / CONFIG.TILE_SIZE);

        if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) {
            out.x = 0;
            out.y = 0;
            return;
        }

        const idx = row * this.cols + col;
        const vecIndex = idx * 2;
        const vx = this.vectors[vecIndex];
        const vy = this.vectors[vecIndex + 1];

        if (vx === 0 && vy === 0) {
            out.x = 0;
            out.y = 0;
            return;
        }

        // Steering Logic (Centering)
        const TS = CONFIG.TILE_SIZE;
        const centerX = col * TS + TS / 2;
        const centerY = row * TS + TS / 2;

        let steerX = vx;
        let steerY = vy;

        const centerThreshold = 4.0;
        const steerStrength = 1.5;

        // If moving Horizontal, correct Y
        if (vx !== 0) {
            const dy = centerY - worldY;
            if (Math.abs(dy) > centerThreshold) {
                steerY += Math.sign(dy) * steerStrength;
            }
        }

        // If moving Vertical, correct X
        if (vy !== 0) {
            const dx = centerX - worldX;
            if (Math.abs(dx) > centerThreshold) {
                steerX += Math.sign(dx) * steerStrength;
            }
        }

        // Normalize
        const lenSq = steerX * steerX + steerY * steerY;
        if (lenSq > 0.000001 && Math.abs(lenSq - 1) > 0.01) {
            const len = Math.sqrt(lenSq);
            steerX /= len;
            steerY /= len;
        }

        out.x = steerX;
        out.y = steerY;
    }

    /**
     * Optimized CheckBuildability.
     * Uses SearchId to reuse buffers without allocation.
     */
    public checkBuildability(grid: Cell[][], ox: number, oy: number, spawns: { x: number; y: number }[]): boolean {
        if (!this.target) return true;

        // MAZE RULE OPTIMIZATION:
        // If the tile is a Path (type=1), we can NEVER build there.
        // This is enforced by isBuildable, but we check here for robustness.
        const tile = grid[oy][ox];
        if (tile && tile.type === 1) return false;

        // If we are strictly "Forbidden Maze", we theoretically don't need BFS if we assume
        // the map is valid and we only build on Grass.
        // However, if we built on Grass that somehow blocked a specialized path (e.g. cutting corner?), 
        // we keep BFS for safety but it is super fast now.

        this.searchId++;
        if (this.searchId >= 65000) {
            this.searchId = 1;
            this.visited.fill(0);
        }

        const targetIdx = this.target.y * this.cols + this.target.x;

        let head = 0;
        let tail = 0;

        // Push spawns (Reverse BFS: Spawns -> Target? Or Forward?)
        // Previous logic was Spawns -> Target.

        for (const spawn of spawns) {
            const idx = spawn.y * this.cols + spawn.x;
            this.queue[tail++] = idx;
            this.visited[idx] = this.searchId;
        }

        const cols = this.cols;
        const offsets = [-cols, 1, cols, -1];

        // We only need to find Target.
        while (head < tail) {
            const currentIdx = this.queue[head++];

            if (currentIdx === targetIdx) return true; // Reached target!

            const cx = currentIdx % cols;

            for (let i = 0; i < 4; i++) {
                const neighborIdx = currentIdx + offsets[i];

                if (neighborIdx < 0 || neighborIdx >= this.distances.length) continue;
                if (i === 1 && (neighborIdx % cols) === 0) continue;
                if (i === 3 && ((neighborIdx + 1) % cols) === 0) continue;

                // Check blockage
                const ny = (neighborIdx / cols) | 0;
                const nx = neighborIdx % cols;

                if (nx === ox && ny === oy) continue; // The phantom block

                const cell = grid[ny][nx];
                // Walkability check - STRICT: Only Path (type === 1)
                if (cell.type === 1) {
                    if (this.visited[neighborIdx] !== this.searchId) {
                        this.visited[neighborIdx] = this.searchId;
                        this.queue[tail++] = neighborIdx;
                    }
                }
            }
        }

        return false;
    }
}
</file>

<file path="src/renderers/SpriteProjectileRenderer.ts">
import { Assets } from '../Assets';
import { Projectile } from '../Projectile';

export class SpriteProjectileRenderer {
    static draw(ctx: CanvasRenderingContext2D, projectile: Projectile) {
        if (!projectile.alive) return;

        // Enhanced visual for critical hits
        if (projectile.isCrit) {
            // Enhanced visual for critical hits (kept dynamic for glow intensity)
            ctx.save();
            // Outer glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff3300'; // Orange-red glow
            ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius + 6, 0, Math.PI * 2);
            ctx.fill();

            // Inner core glow
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffff00';
            ctx.fillStyle = '#ffffaa';
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius + 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Inner bright core
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // --- BAKED PROJECTILES ---
            const type = projectile.projectileType || 'standard';
            const img = Assets.get(`projectile_${type}`);

            if (img) {
                const size = 16;
                ctx.save();
                ctx.translate(projectile.x, projectile.y);

                // Rotate if needed (always rotate towards velocity for correct orientation)
                const angle = Math.atan2(projectile.vy, projectile.vx);
                ctx.rotate(angle);

                ctx.drawImage(img, -size / 2, -size / 2);

                // Level-based trail effects
                if (projectile.towerLevel >= 2) {
                    const angle = Math.atan2(projectile.vy, projectile.vx);

                    // Fade in trail over first 30 frames (0.5 seconds)
                    const trailOpacity = Math.min(1, (120 - projectile.life) / 30);

                    ctx.save();
                    ctx.rotate(angle);

                    if (projectile.towerLevel === 2) {
                        // LVL 2: Light trail
                        ctx.strokeStyle = projectile.color;
                        ctx.globalAlpha = 0.4 * trailOpacity;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-size * 1.2, 0);
                        ctx.stroke();
                    } else if (projectile.towerLevel === 3) {
                        // LVL 3: Bright trail with glow
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = projectile.color;
                        ctx.strokeStyle = projectile.color;
                        ctx.globalAlpha = 0.7 * trailOpacity;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-size * 2, 0);
                        ctx.stroke();

                        // Inner bright core trail
                        ctx.shadowBlur = 5;
                        ctx.strokeStyle = '#fff';
                        ctx.globalAlpha = 0.9 * trailOpacity;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-size * 1.5, 0);
                        ctx.stroke();
                    }

                    ctx.restore();
                }

                // Sniper Trail (original, still works)
                if (type === 'sniper') {
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = projectile.color;
                    // Draw line relative to rotated context (backing up)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-size * 1.5, 0);
                    ctx.stroke();
                }

                ctx.restore();
            } else {
                // Fallback
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
}
</file>

<file path="src/renderers/units/BaseSkeletonRenderer.ts">
import { CachedUnitRenderer, SpriteFacing } from './CachedUnitRenderer';
import { Enemy } from '../../Enemy';

export interface SkeletonPose {
    facing: SpriteFacing;
    scale: number;
    cycle: number;     // 0..1 (progress of walk or idle)
    isMoving: boolean; // true = walk, false = idle

    // Joint positions for drawing procedural body
    joints: {
        pelvis: { x: number, y: number },
        neck: { x: number, y: number },
        shoulderL: { x: number, y: number },
        shoulderR: { x: number, y: number },
        elbowL: { x: number, y: number },
        elbowR: { x: number, y: number },
        wristL: { x: number, y: number },
        wristR: { x: number, y: number },
        hipL: { x: number, y: number },
        hipR: { x: number, y: number },
        kneeL: { x: number, y: number },
        kneeR: { x: number, y: number },
        ankleL: { x: number, y: number },
        ankleR: { x: number, y: number }
    };

    // Anchors for child classes to attach equipment
    anchors: {
        head: { x: number, y: number, angle: number },
        leftHand: { x: number, y: number, angle: number },
        rightHand: { x: number, y: number, angle: number },
        back: { x: number, y: number },
        torso: { x: number, y: number }
    };
}

/**
 * Base abstract robust class for all Skeleton variations.
 * Follows AAA Visual Design Guidelines for 2D multi-segment kinematic rendering.
 * Provides a Template Method API for subclasses.
 */
export abstract class BaseSkeletonRenderer extends CachedUnitRenderer {
    protected spriteSize: number = 96; // 1.5x of 64 to fit weapons
    protected orientationMode: 'DIR3' = 'DIR3'; // Force DIR3 baking
    protected walkCycleMultiplier: number = 0.12;

    // Constants    // Bone structure lengths
    protected static readonly THIGH_LEN = 6.5;
    protected static readonly CALF_LEN = 6.5;
    protected static readonly UPPER_ARM_LEN = 5.5;
    protected static readonly LOWER_ARM_LEN = 5.5;

    // Default colors for base bone drawing (Instance properties so subclasses can override)
    protected boneMain = '#e0d0b0'; // Restored original light bone tint
    protected boneShadow = '#4e342e'; // Strong dark brown for outline context to pop from road
    protected boneDark = '#a89070'; // Original recessed bone

    public getBakeFacings(): ('SIDE' | 'UP' | 'DOWN')[] {
        return ['SIDE', 'UP', 'DOWN'];
    }

    // =========================================================
    // TEMPLATE METHOD HOOKS FOR SUBCLASSES (Z-Pass Execution)
    // =========================================================

    /** Pass 1: Objects below the body (e.g., cape back) */
    protected drawUnderlay(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void { }

    /** Pass 2: Objects on the back (e.g., quiver, backpack) */
    protected drawBackItem(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void { }

    /** Pass 3: Torso armor (e.g., chestplate) */
    protected drawBodyArmor(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void { }

    /** Pass 4: Head decoration (e.g., helmet, hood) */
    protected drawHeadDecoration(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void { }

    /** Pass 5: Left hand equipment (e.g., shield, bow) */
    protected drawLeftHandItem(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void { }

    /** Pass 6: Right hand equipment (e.g., sword, wand) */
    protected drawRightHandItem(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void { }

    /** Pass 7: Overlay effects (e.g., magic glow, particles) */
    protected drawOverlay(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void { }


    // =========================================================
    // CORE KINEMATICS AND RENDERING
    // =========================================================

    public override drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: SpriteFacing): void {
        const enemyAny = enemy as any;
        const isMoving = enemyAny.isMoving !== undefined ? enemyAny.isMoving : true;

        ctx.save();

        // Compute Rig
        const pose = this.computePose(t, isMoving, facing);

        // Execute strictly ordered Z-Pass rendering
        this.drawUnderlay(ctx, pose);
        this.renderBodyBase(ctx, pose);
        this.drawBackItem(ctx, pose);
        this.drawBodyArmor(ctx, pose);
        this.drawHeadDecoration(ctx, pose);

        // Hand item depth sorting based on facing
        if (facing === 'UP') {
            // Right hand behind, Left hand behind
            this.drawRightHandItem(ctx, pose);
            this.drawLeftHandItem(ctx, pose);
        } else {
            // SIDE & DOWN: Normal
            this.drawLeftHandItem(ctx, pose);
            this.drawRightHandItem(ctx, pose);
        }

        this.drawOverlay(ctx, pose);

        ctx.restore();
    }

    // Use default drawFrame for SIDE as fallback
    public override drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void {
        this.drawFrameDirectional(ctx, enemy, t, 'SIDE');
    }

    /**
     * Calculates the entire skeletal rig based on the current cycle and orientation.
     */
    private computePose(cycle: number, isMoving: boolean, facing: SpriteFacing): SkeletonPose {
        const s = 1; // Temporary scale multiplier (to be passed down)

        // Basic rhythmic parameters
        let bounce = 0;
        let sway = 0;
        let breath = 0;

        const pi2 = Math.PI * 2;

        if (isMoving) {
            bounce = Math.abs(Math.sin(cycle * pi2)) * 3;
            sway = Math.sin(cycle * pi2) * 2;
        } else {
            // Breathing animation only
            breath = Math.sin(cycle * pi2) * 1.5;
        }

        // Initialize empty pose
        const p: SkeletonPose = {
            facing,
            scale: s,
            cycle,
            isMoving,
            joints: {
                pelvis: { x: 0, y: -bounce + breath * 0.2 },
                neck: { x: 0, y: -20 * s - bounce - breath * 0.8 },
                shoulderL: { x: 0, y: 0 },
                shoulderR: { x: 0, y: 0 },
                elbowL: { x: 0, y: 0 },
                elbowR: { x: 0, y: 0 },
                wristL: { x: 0, y: 0 },
                wristR: { x: 0, y: 0 },
                hipL: { x: 0, y: 0 },
                hipR: { x: 0, y: 0 },
                kneeL: { x: 0, y: 0 },
                kneeR: { x: 0, y: 0 },
                ankleL: { x: 0, y: 0 },
                ankleR: { x: 0, y: 0 }
            },
            anchors: {
                head: { x: 0, y: 0, angle: 0 },
                leftHand: { x: 0, y: 0, angle: 0 },
                rightHand: { x: 0, y: 0, angle: 0 },
                back: { x: 0, y: 0 },
                torso: { x: 0, y: 0 }
            }
        };

        // --- Kinematics Math placeholder logic ---
        // (This will be expanded extensively with 2D IK and math)
        // Set up anchor targets based on facing and cycle
        this.applyProceduralIK(p);

        // Map anchors to computed joints
        p.anchors.head = { x: p.joints.neck.x + sway * 0.5, y: p.joints.neck.y - 3 * s, angle: sway * 0.05 };
        p.anchors.leftHand = { x: p.joints.wristL.x, y: p.joints.wristL.y, angle: 0 };
        p.anchors.rightHand = { x: p.joints.wristR.x, y: p.joints.wristR.y, angle: 0 };
        p.anchors.back = { x: p.joints.neck.x, y: (p.joints.neck.y + p.joints.pelvis.y) / 2 };
        p.anchors.torso = { x: p.joints.neck.x, y: p.joints.neck.y + 5 * s };

        return p;
    }

    /**
     * Internal implementation of 2D Inverse Kinematics for legs and arms.
     */
    private applyProceduralIK(p: SkeletonPose) {
        const s = p.scale;
        const bounce = (p.isMoving ? Math.abs(Math.sin(p.cycle * Math.PI * 2)) * 3 : 0);
        const sway = (p.isMoving ? Math.sin(p.cycle * Math.PI * 2) * 2 : 0);
        const breath = (!p.isMoving ? Math.sin(p.cycle * Math.PI * 2) * 1.5 : 0);

        // Core base positions (pelvis/neck)
        p.joints.pelvis = { x: 0, y: 3 * s - bounce + breath * 0.2 };
        p.joints.neck = { x: 0, y: -7 * s - bounce - breath * 0.8 };

        const pi = Math.PI;
        const cycleL = p.cycle * pi * 2;
        const cycleR = cycleL + pi;
        const feetY = 14 * s;

        // ============================================
        // 1. SIDE VIEW (True 2D IK)
        // ============================================
        if (p.facing === 'SIDE') {
            const strideRadius = 5 * s;
            const strideLift = 4 * s;

            p.joints.hipL = { x: p.joints.pelvis.x, y: p.joints.pelvis.y };
            p.joints.hipR = { x: p.joints.pelvis.x, y: p.joints.pelvis.y };

            if (p.isMoving) {
                p.joints.ankleL = {
                    x: Math.cos(cycleL) * strideRadius,
                    y: feetY + (Math.sin(cycleL) < 0 ? Math.sin(cycleL) * strideLift : 0)
                };
                p.joints.ankleR = {
                    x: Math.cos(cycleR) * strideRadius,
                    y: feetY + (Math.sin(cycleR) < 0 ? Math.sin(cycleR) * strideLift : 0)
                };
            } else {
                p.joints.ankleL = { x: -3 * s, y: feetY };
                p.joints.ankleR = { x: 3 * s, y: feetY };
            }

            // Knees bend forward
            p.joints.kneeL = this.solve2BoneIK(p.joints.hipL.x, p.joints.hipL.y, p.joints.ankleL.x, p.joints.ankleL.y, BaseSkeletonRenderer.THIGH_LEN * s, BaseSkeletonRenderer.CALF_LEN * s, true);
            p.joints.kneeR = this.solve2BoneIK(p.joints.hipR.x, p.joints.hipR.y, p.joints.ankleR.x, p.joints.ankleR.y, BaseSkeletonRenderer.THIGH_LEN * s, BaseSkeletonRenderer.CALF_LEN * s, false);

            p.joints.shoulderL = { x: p.joints.neck.x, y: p.joints.neck.y + 2 * s };
            p.joints.shoulderR = { x: p.joints.neck.x, y: p.joints.neck.y + 2 * s };

            const armSwing = 5 * s;
            if (p.isMoving) {
                p.joints.wristL = {
                    x: p.joints.shoulderL.x + Math.sin(cycleL) * armSwing,
                    y: p.joints.shoulderL.y + 7 * s + (-bounce + breath) * 0.5
                };
                p.joints.wristR = {
                    x: p.joints.shoulderR.x + Math.sin(cycleR) * armSwing,
                    y: p.joints.shoulderR.y + 7 * s + (-bounce + breath) * 0.5
                };
            } else {
                p.joints.wristL = { x: p.joints.shoulderL.x, y: p.joints.shoulderL.y + 7 * s };
                p.joints.wristR = { x: p.joints.shoulderR.x, y: p.joints.shoulderR.y + 7 * s };
            }

            // Elbows bend backward (false)
            p.joints.elbowL = this.solve2BoneIK(p.joints.shoulderL.x, p.joints.shoulderL.y, p.joints.wristL.x, p.joints.wristL.y, BaseSkeletonRenderer.UPPER_ARM_LEN * s, BaseSkeletonRenderer.LOWER_ARM_LEN * s, false);
            p.joints.elbowR = this.solve2BoneIK(p.joints.shoulderR.x, p.joints.shoulderR.y, p.joints.wristR.x, p.joints.wristR.y, BaseSkeletonRenderer.UPPER_ARM_LEN * s, BaseSkeletonRenderer.LOWER_ARM_LEN * s, false);

            // ============================================
            // 2. FRONT/BACK VIEW (Projected Pseudo-3D IK)
            // ============================================
        } else {
            const isUp = p.facing === 'UP';
            const walkDir = isUp ? -1 : 1;
            const strideDepth = 4 * s;
            const strideLift = 4 * s;

            p.joints.hipL = { x: p.joints.pelvis.x - 3 * s, y: p.joints.pelvis.y };
            p.joints.hipR = { x: p.joints.pelvis.x + 3 * s, y: p.joints.pelvis.y };

            if (p.isMoving) {
                // Moving forward relative to facing triggers lift
                const cosL = Math.cos(cycleL);
                const isSwingingForwardL = (cosL * walkDir) > 0;
                p.joints.ankleL = {
                    x: p.joints.hipL.x,
                    y: feetY + Math.sin(cycleL) * strideDepth * walkDir - (isSwingingForwardL ? Math.abs(cosL) * strideLift : 0)
                };

                const cosR = Math.cos(cycleR);
                const isSwingingForwardR = (cosR * walkDir) > 0;
                p.joints.ankleR = {
                    x: p.joints.hipR.x,
                    y: feetY + Math.sin(cycleR) * strideDepth * walkDir - (isSwingingForwardR ? Math.abs(cosR) * strideLift : 0)
                };
            } else {
                p.joints.ankleL = { x: p.joints.hipL.x, y: feetY };
                p.joints.ankleR = { x: p.joints.hipR.x, y: feetY };
            }

            // Projected Knees (foreshortening instead of crab walk)
            const distL = Math.abs(p.joints.ankleL.y - p.joints.hipL.y);
            const compL = Math.max(0, 12 * s - distL); // 12s is approx max leg length
            p.joints.kneeL = {
                x: p.joints.hipL.x - (1 * s + compL * 0.15), // Very slight outward bend based on compression
                y: p.joints.hipL.y + (p.joints.ankleL.y - p.joints.hipL.y) * 0.45
            };

            const distR = Math.abs(p.joints.ankleR.y - p.joints.hipR.y);
            const compR = Math.max(0, 12 * s - distR);
            p.joints.kneeR = {
                x: p.joints.hipR.x + (1 * s + compR * 0.15),
                y: p.joints.hipR.y + (p.joints.ankleR.y - p.joints.hipR.y) * 0.45
            };

            p.joints.shoulderL = { x: p.joints.neck.x - 5 * s + sway, y: p.joints.neck.y + 1 * s };
            p.joints.shoulderR = { x: p.joints.neck.x + 5 * s + sway, y: p.joints.neck.y + 1 * s };

            if (p.isMoving) {
                const armSwingY = 3.5 * s;
                // Opposing arm swing: left arm with right leg (cycleR)
                p.joints.wristL = {
                    x: p.joints.shoulderL.x - 1 * s + sway * -0.5,
                    y: p.joints.shoulderL.y + 7.5 * s + Math.sin(cycleR) * armSwingY * walkDir - Math.abs(Math.sin(cycleR)) * 1 * s
                };
                p.joints.wristR = {
                    x: p.joints.shoulderR.x + 1 * s + sway * 0.5,
                    y: p.joints.shoulderR.y + 7.5 * s + Math.sin(cycleL) * armSwingY * walkDir - Math.abs(Math.sin(cycleL)) * 1 * s
                };
            } else {
                p.joints.wristL = { x: p.joints.shoulderL.x - 1 * s, y: p.joints.shoulderL.y + 7.5 * s + breath };
                p.joints.wristR = { x: p.joints.shoulderR.x + 1 * s, y: p.joints.shoulderR.y + 7.5 * s + breath };
            }

            // Projected Elbows
            const armDistL = p.joints.wristL.y - p.joints.shoulderL.y;
            const armCompL = Math.max(0, 8 * s - armDistL);
            p.joints.elbowL = {
                x: p.joints.shoulderL.x - (1.5 * s + armCompL * 0.2),
                y: p.joints.shoulderL.y + armDistL * 0.45
            };
            const armDistR = p.joints.wristR.y - p.joints.shoulderR.y;
            const armCompR = Math.max(0, 8 * s - armDistR);
            p.joints.elbowR = {
                x: p.joints.shoulderR.x + (1.5 * s + armCompR * 0.2),
                y: p.joints.shoulderR.y + armDistR * 0.45
            };
        }
    }

    /**
     * Renders the base bone structure using the computed IK joints.
     */
    private renderBodyBase(ctx: CanvasRenderingContext2D, pose: SkeletonPose) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Draw order based on facing
        if (pose.facing === 'UP') {
            // Legs -> Arms -> Spine/Ribs -> Skull
            this.drawLeg(ctx, pose.joints.hipL, pose.joints.kneeL, pose.joints.ankleL, pose.facing, true);
            this.drawLeg(ctx, pose.joints.hipR, pose.joints.kneeR, pose.joints.ankleR, pose.facing, false);
            this.drawArm(ctx, pose.joints.shoulderL, pose.joints.elbowL, pose.joints.wristL);
            this.drawArm(ctx, pose.joints.shoulderR, pose.joints.elbowR, pose.joints.wristR);
            this.drawTorso(ctx, pose);
        } else if (pose.facing === 'DOWN') {
            // Legs -> Spine/Ribs -> Arms -> Skull
            this.drawLeg(ctx, pose.joints.hipL, pose.joints.kneeL, pose.joints.ankleL, pose.facing, true);
            this.drawLeg(ctx, pose.joints.hipR, pose.joints.kneeR, pose.joints.ankleR, pose.facing, false);
            this.drawTorso(ctx, pose);
            this.drawArm(ctx, pose.joints.shoulderL, pose.joints.elbowL, pose.joints.wristL);
            this.drawArm(ctx, pose.joints.shoulderR, pose.joints.elbowR, pose.joints.wristR);
        } else {
            // SIDE: Left Arm/Leg -> Torso -> Right Leg/Arm
            this.drawLeg(ctx, pose.joints.hipL, pose.joints.kneeL, pose.joints.ankleL, pose.facing, true);
            this.drawArm(ctx, pose.joints.shoulderL, pose.joints.elbowL, pose.joints.wristL);
            this.drawTorso(ctx, pose);
            this.drawLeg(ctx, pose.joints.hipR, pose.joints.kneeR, pose.joints.ankleR, pose.facing, false);
            this.drawArm(ctx, pose.joints.shoulderR, pose.joints.elbowR, pose.joints.wristR);
        }
    }

    private drawBone(ctx: CanvasRenderingContext2D, p1: { x: number, y: number }, p2: { x: number, y: number }, thickness: number) {
        // Shadow pass
        ctx.strokeStyle = this.boneShadow;
        ctx.lineWidth = thickness + 2;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();

        // Main bone pass
        ctx.strokeStyle = this.boneMain;
        ctx.lineWidth = thickness;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
    }

    private drawLeg(ctx: CanvasRenderingContext2D, hip: { x: number, y: number }, knee: { x: number, y: number }, ankle: { x: number, y: number }, facing: SpriteFacing, isLeft: boolean) {
        this.drawBone(ctx, hip, knee, 3);
        this.drawBone(ctx, knee, ankle, 2.5);

        let dirX = 3;
        let dirY = 1;

        if (facing === 'UP') {
            dirX = isLeft ? -1.5 : 1.5;
            dirY = -1;
        } else if (facing === 'DOWN') {
            dirX = isLeft ? -2 : 2;
            dirY = 2;
        }

        // Simple foot structure
        this.drawBone(ctx, ankle, { x: ankle.x + dirX, y: ankle.y + dirY }, 2);
    }

    private drawArm(ctx: CanvasRenderingContext2D, shoulder: { x: number, y: number }, elbow: { x: number, y: number }, wrist: { x: number, y: number }) {
        this.drawBone(ctx, shoulder, elbow, 2.5);
        this.drawBone(ctx, elbow, wrist, 2);
    }

    private drawTorso(ctx: CanvasRenderingContext2D, p: SkeletonPose) {
        // Spine
        this.drawBone(ctx, p.joints.pelvis, p.joints.neck, 3.5);

        ctx.strokeStyle = this.boneMain;
        ctx.fillStyle = this.boneMain;

        // Pelvis bone block
        ctx.beginPath();
        ctx.arc(p.joints.pelvis.x, p.joints.pelvis.y, 4, 0, Math.PI * 2);
        ctx.fill();

        // Ribs (AAA requirement: defined ribcage)
        ctx.lineWidth = 2;
        const ribsCount = 4;
        const spineLen = p.joints.pelvis.y - p.joints.neck.y;

        // Rib width based on facing
        const baseWidth = p.facing === 'SIDE' ? 4 : 7;

        for (let i = 1; i <= ribsCount; i++) {
            const h = p.joints.neck.y + (spineLen * 0.2) + (i * 3 * p.scale);
            const w = baseWidth * p.scale * (1 - (i * 0.15)); // Ribs get smaller

            ctx.beginPath();
            if (p.facing === 'SIDE') {
                ctx.moveTo(p.joints.neck.x - w * 0.5, h); // A bit back
                ctx.quadraticCurveTo(p.joints.neck.x + w * 1.5, h + 1, p.joints.neck.x + w, h + 3);
            } else {
                // Symmetrical ribs
                ctx.moveTo(p.joints.neck.x - w, h);
                ctx.quadraticCurveTo(p.joints.neck.x, h - 2, p.joints.neck.x + w, h);
            }
            ctx.stroke();
        }


        // Skull is drawn via the shared drawSkull() helper,
        // called explicitly by subclass drawHeadDecoration() hooks.
    }

    // Default eye glow color (subclasses can override)
    protected eyeGlow = '#d32f2f';
    protected headRadius = 5.5;

    /**
     * Shared skull drawing for all skeleton variants.
     * Call from drawHeadDecoration() BEFORE equipment layering.
     * Expects ctx already translated/rotated to head anchor.
     */
    protected drawSkull(ctx: CanvasRenderingContext2D, scale: number, facing: SpriteFacing): void {
        const r = this.headRadius * scale;

        ctx.fillStyle = this.boneMain;
        ctx.beginPath();

        if (facing === 'SIDE') {
            ctx.arc(-1 * scale, -2 * scale, r, 0, Math.PI * 2);
            ctx.fill();

            // Snout
            ctx.beginPath();
            ctx.fillRect(1 * scale, 0, 3 * scale, 3 * scale);

            // Eye socket
            const eyeX = 3 * scale;
            const eyeY = -0.5 * scale;
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.ellipse(eyeX, eyeY, 1.5 * scale, 2 * scale, 0, 0, Math.PI * 2); ctx.fill();

            // Glow
            ctx.fillStyle = this.eyeGlow;
            ctx.beginPath(); ctx.arc(eyeX + 0.5 * scale, eyeY, 0.6 * scale, 0, Math.PI * 2); ctx.fill();

        } else if (facing === 'DOWN') {
            ctx.arc(0, -2 * scale, r, 0, Math.PI * 2);
            ctx.fill();

            // Jaw
            ctx.beginPath();
            ctx.rect(-2.5 * scale, 2 * scale, 5 * scale, 2.5 * scale);
            ctx.fill();

            // Eyes
            const eyeY = 0;
            const eyeX = 2 * scale;
            const eyeSize = 1.8 * scale;
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.arc(-eyeX, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();

            // Glow
            ctx.fillStyle = this.eyeGlow;
            const glowSize = 0.6 * scale;
            ctx.beginPath(); ctx.arc(-eyeX, eyeY, glowSize, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX, eyeY, glowSize, 0, Math.PI * 2); ctx.fill();

        } else {
            // UP ‚Äî plain cranium
            ctx.arc(0, -2 * scale, r, 0, Math.PI * 2);
            ctx.fill();
        }
    }


    // Helper method for 2D IK (2 segments)
    protected solve2BoneIK(
        startX: number, startY: number,
        targetX: number, targetY: number,
        len1: number, len2: number,
        bendForward: boolean
    ): { x: number, y: number } {
        const dx = targetX - startX;
        const dy = targetY - startY;
        let dist = Math.sqrt(dx * dx + dy * dy);

        // Guard against div by 0 and NaN
        if (dist < 0.01) dist = 0.01;

        // Clamp distance to prevent unreachable target tearing
        const maxDist = len1 + len2 - 0.1;
        if (dist > maxDist) {
            const scale = maxDist / dist;
            targetX = startX + dx * scale;
            targetY = startY + dy * scale;
            dist = maxDist;
        }

        // Angle from start to target
        const angle = Math.atan2(targetY - startY, targetX - startX);

        // Law of Cosines to find the inner angle
        let cosInner = (len1 * len1 + dist * dist - len2 * len2) / (2 * len1 * dist);
        cosInner = Math.max(-1, Math.min(1, cosInner));

        const innerAngle = Math.acos(cosInner);

        // Determine bend direction
        const finalAngle = bendForward ? angle - innerAngle : angle + innerAngle;

        return {
            x: startX + Math.cos(finalAngle) * len1,
            y: startY + Math.sin(finalAngle) * len1
        };
    }
}
</file>

<file path="src/renderers/units/SkeletonMinerRenderer.ts">
import { BaseSkeletonRenderer, SkeletonPose } from './BaseSkeletonRenderer';
import { Enemy } from '../../Enemy';
import { SpriteFacing } from './CachedUnitRenderer';

export class SkeletonMinerRenderer extends BaseSkeletonRenderer {
    protected override boneMain = '#d4cba7'; // –ì—Ä—è–∑–Ω–æ–≤–∞—Ç–æ-–∂–µ–ª—Ç—ã–π —Ü–≤–µ—Ç
    protected override boneShadow = '#3e2723'; // –¢–µ–º–Ω–æ-—É–≥–æ–ª—å–Ω–∞—è –æ–±–≤–æ–¥–∫–∞ (—Ä–µ—à–∞–µ–º –ø—Ä–æ–±–ª–µ–º—É –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞)
    protected override boneDark = '#a89070';
    protected override eyeGlow = '#66bb6a'; // –ó–µ–ª–µ–Ω–æ–≤–∞—Ç–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ –≥–ª–∞–∑ —à–∞—Ö—Ç–µ—Ä–∞

    // –¶–≤–µ—Ç–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —à–∞—Ö—Ç–µ—Ä–∞
    private static readonly HELMET_COLOR = '#fbc02d'; // –ñ–µ–ª—Ç–∞—è –∫–∞—Å–∫–∞
    private static readonly HELMET_SHINE = '#fff59d';
    private static readonly PICKAXE_WOOD = '#5d4037';
    private static readonly PICKAXE_METAL = '#9e9e9e';
    private static readonly BAG_COLOR = '#4e342e'; // –ö–æ–∂–∞–Ω—ã–π –º–µ—à–æ–∫
    private static readonly COAL_COLOR = '#212121';

    public override drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: SpriteFacing): void {
        ctx.save();
        // –°–∂–∏–º–∞–µ–º —à–∞—Ö—Ç–µ—Ä–∞ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏ –Ω–∞ 15%
        ctx.scale(1, 0.85);
        super.drawFrameDirectional(ctx, enemy, t, facing);
        ctx.restore();
    }

    protected drawUnderlay(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        // –ï—Å–ª–∏ –∏–¥–µ–º –≤–≤–µ—Ä—Ö, –º–µ—à–æ–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω –ü–û–î —Ç–µ–ª–æ–º (–Ω–∞ —Å–ø–∏–Ω–µ)? 
        // –ù–µ—Ç, –µ—Å–ª–∏ –∏–¥–µ–º –≤–≤–µ—Ä—Ö (–º—ã –≤–∏–¥–∏–º —Å–ø–∏–Ω—É), –º–µ—à–æ–∫ –ø–æ–≤–µ—Ä—Ö —Ç–µ–ª–∞.
        // –ï—Å–ª–∏ –∏–¥–µ–º –≤–Ω–∏–∑ (–º—ã –≤–∏–¥–∏–º –≥—Ä—É–¥—å), –º–µ—à–æ–∫ –∑–∞ —Ç–µ–ª–æ–º.
        if (pose.facing === 'DOWN') {
            this.drawBag(ctx, pose);
        }
    }

    protected drawBodyArmor(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        // –ö–æ–∂–∞–Ω—ã–π —Ä–µ–º–µ–Ω—å —á–µ—Ä–µ–∑ –≥—Ä—É–¥—å/—Å–ø–∏–Ω—É
        ctx.strokeStyle = '#3e2723';
        ctx.lineWidth = 3 * pose.scale;
        ctx.beginPath();
        // –†–µ–º–µ–Ω—å –∏–¥–µ—Ç –æ—Ç –ø—Ä–∞–≤–æ–≥–æ –ø–ª–µ—á–∞ –∫ –ª–µ–≤–æ–º—É –±–µ–¥—Ä—É (–ø—Ä–∏–º–µ—Ä–Ω–æ)
        // –ù–æ –ø—Ä–æ—â–µ –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—É—é –ª–∏–Ω–∏—é —á–µ—Ä–µ–∑ —Ü–µ–Ω—Ç—Ä—ã
        const p1X = pose.anchors.head.x + 3 * pose.scale;
        const p1Y = pose.anchors.head.y + 10 * pose.scale;
        const p2X = pose.anchors.head.x - 3 * pose.scale;
        const p2Y = pose.anchors.head.y + 22 * pose.scale;
        ctx.moveTo(p1X, p1Y);
        ctx.lineTo(p2X, p2Y);
        ctx.stroke();

        // –ú–µ—à–æ–∫ —Ä–∏—Å—É–µ—Ç—Å—è –ø–æ–≤–µ—Ä—Ö —Ç–µ–ª–∞, –µ—Å–ª–∏ –º—ã —Å–º–æ—Ç—Ä–∏–º –Ω–∞ —Å–ø–∏–Ω—É (UP) –∏–ª–∏ —Å–±–æ–∫—É (SIDE)
        if (pose.facing === 'UP' || pose.facing === 'SIDE') {
            this.drawBag(ctx, pose);
        }
    }

    private drawBag(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        const s = pose.scale;
        // –ü–æ–∑–∏—Ü–∏—è –º–µ—à–∫–∞ - –∑–∞ —Å–ø–∏–Ω–æ–π, —á—É—Ç—å –≤—ã—à–µ —Ç–∞–∑–∞
        const bx = pose.anchors.back.x + (pose.facing === 'SIDE' ? -8 * s : -5 * s);
        const by = pose.anchors.back.y - 4 * s;

        ctx.fillStyle = SkeletonMinerRenderer.BAG_COLOR;
        ctx.strokeStyle = '#261b18';
        ctx.lineWidth = 2 * s;

        // –ú–µ—à–æ–∫
        ctx.beginPath();
        ctx.ellipse(bx, by, 6 * s, 10 * s, pose.facing === 'SIDE' ? -0.2 : 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // –ö—É—Å–∫–∏ —É–≥–ª—è —Ç–æ—Ä—á–∞—Ç –∏–∑ –º–µ—à–∫–∞ (–µ—Å–ª–∏ –∏–¥–µ–º —Å–ø–∏–Ω–æ–π)
        if (pose.facing === 'UP' || pose.facing === 'SIDE') {
            ctx.fillStyle = SkeletonMinerRenderer.COAL_COLOR;
            ctx.beginPath();
            ctx.arc(bx - 2 * s, by - 8 * s, 2 * s, 0, Math.PI * 2);
            ctx.arc(bx + 2 * s, by - 9 * s, 2.5 * s, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    protected drawLeftWeapon(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        // –õ–µ–≤–∞—è —Ä—É–∫–∞ —Å–≤–æ–±–æ–¥–Ω–∞
    }

    protected drawRightWeapon(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        // –ö–∏—Ä–∫–∞ –≤ –ø—Ä–∞–≤–æ–π —Ä—É–∫–µ
        const s = pose.scale;
        const anchor = pose.anchors.rightHand;

        ctx.save();
        ctx.translate(anchor.x, anchor.y);

        // –í—Ä–∞—â–µ–Ω–∏–µ –∫–∏—Ä–∫–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–∞–¥—Ä–∞ –∏ —Ä–∞–∫—É—Ä—Å–∞
        if (pose.facing === 'SIDE') {
            ctx.rotate(anchor.angle + Math.PI / 4);
        } else if (pose.facing === 'UP') {
            ctx.rotate(Math.PI / 6);
        } else {
            ctx.rotate(Math.PI / 8);
        }

        // –†—É–∫–æ—è—Ç—å –∫–∏—Ä–∫–∏
        ctx.fillStyle = SkeletonMinerRenderer.PICKAXE_WOOD;
        ctx.fillRect(-2 * s, -15 * s, 4 * s, 25 * s);

        // –¢–µ–Ω—å –Ω–∞ —Ä—É–∫–æ—è—Ç–∏
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(-2 * s, -15 * s, 1 * s, 25 * s);

        // –°—Ç–∞–ª—å–Ω–æ–µ –ª–µ–∑–≤–∏–µ –∫–∏—Ä–∫–∏ (–∏–∑–æ–≥–Ω—É—Ç–æ–µ)
        ctx.fillStyle = SkeletonMinerRenderer.PICKAXE_METAL;
        ctx.beginPath();
        ctx.moveTo(-10 * s, -12 * s);
        ctx.quadraticCurveTo(0, -20 * s, 10 * s, -12 * s);
        ctx.lineTo(8 * s, -10 * s);
        ctx.quadraticCurveTo(0, -15 * s, -8 * s, -10 * s);
        ctx.closePath();
        ctx.fill();

        // –ë–ª–∏–∫ –Ω–∞ –ª–µ–∑–≤–∏–∏
        ctx.fillStyle = '#cfd8dc';
        ctx.beginPath();
        ctx.moveTo(-8 * s, -12 * s);
        ctx.quadraticCurveTo(0, -18 * s, 8 * s, -12 * s);
        ctx.lineTo(6 * s, -11 * s);
        ctx.quadraticCurveTo(0, -14 * s, -6 * s, -11 * s);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    protected drawHeadDecoration(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        const s = pose.scale;
        const head = pose.anchors.head;

        ctx.save();
        ctx.translate(head.x, head.y);
        ctx.rotate(head.angle);

        // [FIX] –†–∏—Å—É–µ–º —á–µ—Ä–µ–ø –ü–û–î –∫–∞—Å–∫–æ–π (—Ä–∞–Ω—å—à–µ –æ–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞–ª!)
        this.drawSkull(ctx, s, pose.facing);

        // –ñ–µ–ª—Ç–∞—è –∫–∞—Å–∫–∞ (–ø–æ–ª—É—Å—Ñ–µ—Ä–∞)
        ctx.fillStyle = SkeletonMinerRenderer.HELMET_COLOR;
        ctx.beginPath();
        if (pose.facing === 'SIDE') {
            ctx.arc(0, -2 * s, 6 * s, Math.PI, 0); // Side view helmet
        } else {
            ctx.arc(0, -3 * s, 6.5 * s, Math.PI, 0); // Front/Back view helmet
        }
        ctx.fill();

        // –û–±–æ–¥–æ–∫ –∫–∞—Å–∫–∏
        ctx.fillStyle = '#f57f17';
        ctx.fillRect(-7 * s, -2 * s, 14 * s, 2 * s);

        // –ë–ª–∏–∫
        ctx.fillStyle = SkeletonMinerRenderer.HELMET_SHINE;
        ctx.beginPath();
        ctx.arc(-2 * s, -5 * s, 1.5 * s, 0, Math.PI * 2);
        ctx.fill();

        // –§–æ–Ω–∞—Ä—å
        if (pose.facing === 'SIDE' || pose.facing === 'DOWN') {
            const lampX = pose.facing === 'SIDE' ? 6 * s : 0;
            const lampY = -4 * s;

            // –û—Å–Ω–æ–≤–∞ —Ñ–æ–Ω–∞—Ä—è
            ctx.fillStyle = '#616161';
            ctx.fillRect(lampX - 2 * s, lampY - 2 * s, 4 * s, 4 * s);

            // –õ–∏–Ω–∑–∞
            ctx.fillStyle = '#e0f7fa';
            if (pose.facing === 'SIDE') {
                ctx.fillRect(lampX, lampY - 1 * s, 2 * s, 2 * s);
            } else {
                ctx.fillRect(lampX - 1 * s, lampY - 1 * s, 2 * s, 2 * s);
            }

            // –°–≤–µ—Ç –æ—Ç —Ñ–æ–Ω–∞—Ä—è (Overlay, —á—Ç–æ–±—ã —Å–≤–µ—Ç–∏–ª–æ –ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ)
            // –ù–æ –º—ã —Ä–∏—Å—É–µ–º –µ–≥–æ –∑–¥–µ—Å—å –¥–ª—è –ø—Ä–∏–≤—è–∑–∫–∏ –∫ –≥–æ–ª–æ–≤–µ.
            // –î–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Ä–∏—Å—É–µ–º —Ä–∞–¥–∏–∞–ª—å–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.5;
            const radGrab = ctx.createRadialGradient(lampX, lampY, 0, lampX, lampY, 15 * s);
            radGrab.addColorStop(0, '#ffff8d');
            radGrab.addColorStop(1, 'rgba(255,255,141,0)');
            ctx.fillStyle = radGrab;
            ctx.beginPath();
            ctx.arc(lampX, lampY, 15 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        ctx.restore();
    }

    protected drawOverlay(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        // –î–æ–±–∞–≤–∏–º –ø—è—Ç–Ω–∞ —É–≥–ª—è –Ω–∞ –∫–æ—Å—Ç–∏ (–ø–æ–≤–µ—Ä—Ö –æ—Å–Ω–æ–≤–Ω–æ–π –æ—Ç—Ä–∏—Å–æ–≤–∫–∏)
        const s = pose.scale;
        const h = pose.anchors.head;

        ctx.fillStyle = 'rgba(33, 33, 33, 0.6)'; // –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —É–≥–æ–ª—å

        if (pose.facing === 'SIDE' || pose.facing === 'DOWN') {
            // –ü—è—Ç–Ω–æ –Ω–∞ –ª–∏—Ü–µ
            ctx.beginPath();
            ctx.arc(h.x + (pose.facing === 'SIDE' ? 2 * s : -2 * s), h.y + 1 * s, 1.5 * s, 0, Math.PI * 2);
            ctx.fill();

            // –ü—è—Ç–Ω–∞ –Ω–∞ —Ä–µ–±—Ä–∞—Ö
            ctx.beginPath();
            ctx.arc(pose.anchors.head.x - 2 * s, pose.anchors.head.y + 12 * s, 2 * s, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}
</file>

<file path="src/SaveManager.ts">
import { ICard } from './CardSystem';
import { CONFIG } from './Config';

export const CURRENT_SCHEMA_VERSION = 1;

export interface IGlobalSaveData {
    schemaVersion: number;
    totalMoneyEarned: number;
    enemiesKilled: number;
    wavesCleared: number;
    unlockedCards: string[]; // keys like 'FIRE', 'ICE'
    maxWaveReached: number;
}

export const DEFAULT_SAVE_DATA: IGlobalSaveData = {
    schemaVersion: CURRENT_SCHEMA_VERSION,
    totalMoneyEarned: 0,
    enemiesKilled: 0,
    wavesCleared: 0,
    unlockedCards: ['FIRE', 'ICE', 'SNIPER'], // Default starters
    maxWaveReached: 0,
};

export class SaveManager {
    private static STORAGE_KEY = 'NEWTOWER_CAMPAIGN';

    public static load(): IGlobalSaveData {
        try {
            const raw = localStorage.getItem(this.STORAGE_KEY);
            if (raw) {
                const data = JSON.parse(raw);
                return this.migrateSave(data);
            }
        } catch (e) {
            console.error('Failed to load save', e);
        }
        return { ...DEFAULT_SAVE_DATA };
    }

    public static save(data: IGlobalSaveData) {
        try {
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
        } catch (e) {
            console.error('Failed to save progress', e);
        }
    }



    private static migrateSave(raw: any): IGlobalSaveData {
        // Safe default
        const safe: IGlobalSaveData = { ...DEFAULT_SAVE_DATA, ...raw };

        // Force current version
        safe.schemaVersion = CURRENT_SCHEMA_VERSION;

        // Ensure arrays are arrays (defensive)
        if (!Array.isArray(safe.unlockedCards)) safe.unlockedCards = [...DEFAULT_SAVE_DATA.unlockedCards];

        return safe;
    }

    public static updateProgress(stats: { money: number; kills: number; waves: number; maxWave: number }) {
        const data = this.load();
        data.totalMoneyEarned += stats.money;
        data.enemiesKilled += stats.kills;
        data.wavesCleared += stats.waves;
        if (stats.maxWave > data.maxWaveReached) {
            data.maxWaveReached = stats.maxWave;
        }
        this.save(data);
        console.log('Campaign Progress Saved', data);
    }
}
</file>

<file path="src/systems/AtmosphereSystem.ts">
import { DayNightCycle } from '../DayNightCycle';

/**
 * Configurable atmosphere parameters - easily tunable
 */
interface IAtmosphereConfig {
    // Sunlight settings
    sunRayCount: number;
    sunRayOpacity: number;
    sunRayWidth: number;
    sunRayAngle: number; // degrees from horizontal

    // Cloud shadow settings
    cloudShadowCount: number;
    cloudShadowSpeed: number; // pixels per second in world space
    cloudShadowOpacity: number;
    cloudShadowMinSize: number;
    cloudShadowMaxSize: number;
    cloudShadowDirection: number; // angle in degrees (0 = right, 90 = down)

    // Moonlight settings
    moonlightOpacity: number;
    moonlightColor: string;

    // Color grading
    dayFilter: string;
    nightFilter: string;

    // Stars settings
    enableStars: boolean;
    starCount: number;
    starOpacity: number;
}

interface CloudShadow {
    x: number;        // world X coordinate
    y: number;        // world Y coordinate  
    width: number;    // fixed width
    height: number;   // fixed height
    speed: number;    // individual speed multiplier (0.8 - 1.2)
    vx: number;       // velocity X (calculated from direction)
    vy: number;       // velocity Y (calculated from direction)
}

export class AtmosphereSystem {
    private dayNightCycle: DayNightCycle;
    private config: IAtmosphereConfig;
    private clouds: CloudShadow[] = [];
    private starPositions: { x: number; y: number }[] = [];
    private worldWidth: number = 1280; // will be updated via setWorldSize
    private worldHeight: number = 800;

    constructor(dayNightCycle: DayNightCycle, config?: Partial<IAtmosphereConfig>) {
        this.dayNightCycle = dayNightCycle;

        // Default config - easily modifiable
        this.config = {
            // Sunlight
            sunRayCount: 5,
            sunRayOpacity: 0.08,
            sunRayWidth: 120,
            sunRayAngle: 30,

            // Cloud shadows
            cloudShadowCount: 8,
            cloudShadowSpeed: 20, // pixels/second
            cloudShadowOpacity: 0.06, // Reduced from 0.12 for brighter atmosphere
            cloudShadowMinSize: 180,
            cloudShadowMaxSize: 320,
            cloudShadowDirection: 45, // diagonal movement (top-left to bottom-right)

            // Moonlight
            moonlightOpacity: 0.15,
            moonlightColor: '#4fc3f7',

            // Color grading
            dayFilter: 'sepia(0.05) saturate(1.1)',
            nightFilter: 'hue-rotate(10deg) saturate(0.9)',

            // Stars
            enableStars: true,
            starCount: 50,
            starOpacity: 0.8,

            ...config // Override with provided config
        };

        this.initializeCloudShadows();
        if (this.config.enableStars) {
            this.initializeStars();
        }
    }

    /**
     * Set world dimensions for proper cloud positioning
     * Should be called once when map is loaded
     */
    public setWorldSize(width: number, height: number): void {
        this.worldWidth = width;
        this.worldHeight = height;
        // Re-initialize clouds with new world bounds
        this.clouds = [];
        this.initializeCloudShadows();
    }

    private initializeCloudShadows(): void {
        const directionRad = (this.config.cloudShadowDirection * Math.PI) / 180;

        for (let i = 0; i < this.config.cloudShadowCount; i++) {
            // Random position across entire world
            const x = Math.random() * this.worldWidth;
            const y = Math.random() * this.worldHeight;

            // Random size between min and max
            const sizeRange = this.config.cloudShadowMaxSize - this.config.cloudShadowMinSize;
            const width = this.config.cloudShadowMinSize + Math.random() * sizeRange;
            const height = width * (0.5 + Math.random() * 0.3); // height is 50-80% of width

            // Slight speed variation for more organic movement
            const speedMultiplier = 0.8 + Math.random() * 0.4; // 0.8 to 1.2

            // Calculate velocity from direction
            const speed = this.config.cloudShadowSpeed * speedMultiplier;
            const vx = Math.cos(directionRad) * speed;
            const vy = Math.sin(directionRad) * speed;

            this.clouds.push({ x, y, width, height, speed: speedMultiplier, vx, vy });
        }
    }

    private initializeStars(): void {
        // Random star positions (fixed, not moving)
        for (let i = 0; i < this.config.starCount; i++) {
            this.starPositions.push({
                x: Math.random(),
                y: Math.random() * 0.6 // Stars in upper 60% of screen
            });
        }
    }

    public update(deltaTime: number): void {
        // Update cloud positions in world space
        this.clouds.forEach(cloud => {
            cloud.x += cloud.vx * deltaTime;
            cloud.y += cloud.vy * deltaTime;

            // Wrap around when cloud exits world bounds
            // Add padding to prevent pop-in
            const padding = Math.max(cloud.width, cloud.height);

            if (cloud.x > this.worldWidth + padding) {
                cloud.x = -padding;
            } else if (cloud.x < -padding) {
                cloud.x = this.worldWidth + padding;
            }

            if (cloud.y > this.worldHeight + padding) {
                cloud.y = -padding;
            } else if (cloud.y < -padding) {
                cloud.y = this.worldHeight + padding;
            }
        });
    }

    public draw(ctx: CanvasRenderingContext2D): void {
        const time = this.dayNightCycle.getTimeOfDay(); // 0 (dawn) to 1 (night)
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;

        // Save original state
        ctx.save();

        // Smooth transition calculation
        // 0.0-0.3: Dawn (transitioning to day)
        // 0.3-0.5: Full day
        // 0.5-0.7: Dusk (transitioning to night)
        // 0.7-1.0: Full night

        let dayIntensity = 0;
        let nightIntensity = 0;

        if (time < 0.3) {
            // Dawn
            dayIntensity = time / 0.3; // 0 to 1
        } else if (time < 0.5) {
            // Day
            dayIntensity = 1;
        } else if (time < 0.7) {
            // Dusk
            dayIntensity = 1 - ((time - 0.5) / 0.2); // 1 to 0
            nightIntensity = (time - 0.5) / 0.2; // 0 to 1
        } else {
            // Night
            nightIntensity = 1;
        }

        // Draw clouds (always visible, independent of day/night blend)
        // We draw them here to ensure they are consistent across transition
        this.drawCloudShadows(ctx, 1.0); // Always draw clouds

        // Draw both day and night effects with smooth blending
        if (dayIntensity > 0) {
            this.drawDayEffects(ctx, canvasWidth, canvasHeight, dayIntensity);
        }
        if (nightIntensity > 0) {
            this.drawNightEffects(ctx, canvasWidth, canvasHeight, nightIntensity);
        }

        ctx.restore();
    }

    private drawDayEffects(ctx: CanvasRenderingContext2D, width: number, height: number, intensity: number): void {
        // 1. Sunlight rays (diagonal lines)
        ctx.save();
        ctx.globalAlpha = this.config.sunRayOpacity * intensity;
        const rayAngleRad = (this.config.sunRayAngle * Math.PI) / 180;

        for (let i = 0; i < this.config.sunRayCount; i++) {
            const spacing = width / (this.config.sunRayCount + 1);
            const startX = spacing * (i + 1);
            const gradient = ctx.createLinearGradient(
                startX, 0,
                startX + Math.cos(rayAngleRad) * height,
                height
            );
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(startX - this.config.sunRayWidth / 2, 0, this.config.sunRayWidth, height);
        }
        ctx.restore();

        // 3. Subtle warm tint (removed harsh overlay)
        // Ambient lighting already handles color temperature
        ctx.restore();
    }

    private drawCloudShadows(ctx: CanvasRenderingContext2D, intensity: number): void {
        ctx.save();
        // Base opacity for clouds
        // At night, maybe slightly less opaque? Or darker? 
        // For now constant opacity from config
        ctx.globalAlpha = this.config.cloudShadowOpacity * intensity;

        this.clouds.forEach(cloud => {
            // Create gradient for soft edges
            const gradient = ctx.createRadialGradient(
                cloud.x, cloud.y, 0,
                cloud.x, cloud.y, cloud.width * 0.6
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.2)');   // Reduced from 0.4
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.1)'); // Reduced from 0.2
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;

            // Draw organic cloud shape (multiple overlapping ellipses)
            ctx.beginPath();
            ctx.ellipse(
                cloud.x,
                cloud.y,
                cloud.width * 0.5,
                cloud.height * 0.5,
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // Add secondary ellipse for organic shape
            ctx.beginPath();
            ctx.ellipse(
                cloud.x + cloud.width * 0.2,
                cloud.y - cloud.height * 0.15,
                cloud.width * 0.35,
                cloud.height * 0.4,
                Math.PI * 0.3, 0, Math.PI * 2
            );
            ctx.fill();

            // Add third ellipse
            ctx.beginPath();
            ctx.ellipse(
                cloud.x - cloud.width * 0.15,
                cloud.y + cloud.height * 0.1,
                cloud.width * 0.3,
                cloud.height * 0.35,
                -Math.PI * 0.25, 0, Math.PI * 2
            );
            ctx.fill();
        });
        ctx.restore();
    }

    private drawNightEffects(ctx: CanvasRenderingContext2D, width: number, height: number, intensity: number): void {
        // 1. Moonlight (soft blue glow from top)
        ctx.save();
        ctx.globalAlpha = this.config.moonlightOpacity * intensity;
        const moonGradient = ctx.createLinearGradient(0, 0, 0, height / 2);
        moonGradient.addColorStop(0, this.config.moonlightColor);
        moonGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
        ctx.fillStyle = moonGradient;
        ctx.fillRect(0, 0, width, height / 2);
        ctx.restore();

        // 2. Stars
        if (this.config.enableStars) {
            ctx.save();
            ctx.globalAlpha = this.config.starOpacity * intensity;
            ctx.fillStyle = '#ffffff';

            this.starPositions.forEach(star => {
                const x = star.x * width;
                const y = star.y * height;
                const radius = 0.5 + Math.random();

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Twinkle effect (subtle)
                if (Math.random() > 0.95) {
                    ctx.globalAlpha = this.config.starOpacity * intensity * 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.restore();
        }

        // 3. Subtle cool tint (removed harsh overlay)
        // Ambient lighting already handles night coloring
        ctx.restore();
    }

    /**
     * Update configuration at runtime
     */
    public updateConfig(newConfig: Partial<IAtmosphereConfig>): void {
        this.config = { ...this.config, ...newConfig };

        // Re-initialize if needed
        if (newConfig.cloudShadowCount !== undefined ||
            newConfig.cloudShadowDirection !== undefined ||
            newConfig.cloudShadowMinSize !== undefined ||
            newConfig.cloudShadowMaxSize !== undefined) {
            this.clouds = [];
            this.initializeCloudShadows();
        }
        if (newConfig.starCount !== undefined || newConfig.enableStars !== undefined) {
            this.starPositions = [];
            if (this.config.enableStars) {
                this.initializeStars();
            }
        }
    }

    public getConfig(): IAtmosphereConfig {
        return { ...this.config };
    }
}
</file>

<file path="src/ui/GameOverUI.ts">
import { IGameScene } from '../scenes/IGameScene';

export class GameOverUI {
    private scene: IGameScene;
    private elGameOver: HTMLElement;
    private elFinalWave: HTMLElement;
    private elRestartBtn: HTMLButtonElement;

    // Bound handler
    private boundRestart: () => void;

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.elGameOver = document.getElementById('game-over')!;
        this.elFinalWave = document.getElementById('final-wave')!;
        this.elRestartBtn = document.getElementById('restart-btn') as HTMLButtonElement;

        this.initListeners();

        this.boundRestart = () => {
            this.scene.restart();
            this.hide();
        };
        this.elRestartBtn.addEventListener('click', this.boundRestart);
    }

    private initListeners() {
        // Empty if everything moved to constructor or keep other listeners here
    }

    public dispose() {
        if (this.elRestartBtn) {
            this.elRestartBtn.removeEventListener('click', this.boundRestart);
        }
    }

    public show(wave: number) {
        this.elFinalWave.innerText = wave.toString();
        this.elGameOver.style.display = 'flex';
    }

    public hide() {
        this.elGameOver.style.display = 'none';
    }
}
</file>

<file path="src/ui/PauseMenu.ts">
import { IGameScene } from '../scenes/IGameScene';
import { UIUtils } from '../UIUtils';
import { SoundManager, SoundPriority } from '../SoundManager';

export class PauseMenu {
    private scene: IGameScene;
    private elUiLayer: HTMLElement;
    private elPauseMenu: HTMLElement | null = null;

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.elUiLayer = document.getElementById('ui-layer')!;
        this.init();
    }

    private init() {
        // ESCAPE TO PAUSE - bind listener
        this.boundKeyHandler = this.handleKeyDown.bind(this);
        window.addEventListener('keydown', this.boundKeyHandler);

        // Create menu overlay
        this.createOverlay();
    }

    private boundKeyHandler: ((e: KeyboardEvent) => void) | null = null;

    private handleKeyDown(e: KeyboardEvent) {
        if (e.code === 'Escape') {
            this.scene.togglePause();
        }
    }

    public destroy() {
        if (this.boundKeyHandler) {
            window.removeEventListener('keydown', this.boundKeyHandler);
            this.boundKeyHandler = null;
        }
        if (this.elPauseMenu) {
            this.elPauseMenu.remove();
            this.elPauseMenu = null;
        }
    }

    private createOverlay() {
        if (!document.getElementById('pause-menu')) {
            const menu = UIUtils.createOverlay('pause-menu');
            this.elPauseMenu = menu;
            this.renderMainMenu(menu);
        } else {
            this.elPauseMenu = document.getElementById('pause-menu');
        }
    }

    private renderMainMenu(menu: HTMLElement) {
        menu.innerHTML = ''; // Clear
        const content = document.createElement('div');
        Object.assign(content.style, {
            background: '#222',
            padding: '40px',
            borderRadius: '8px',
            border: '2px solid #555',
            textAlign: 'center',
            minWidth: '300px'
        });

        content.innerHTML = `
            <h1 style="margin-top: 0; color: #ffd700; text-transform: uppercase; letter-spacing: 2px;">Paused</h1>
            <p style="color: #aaa; font-size: 14px; margin-top: -10px;">Press ESC to resume</p>
        `;

        // Continue
        UIUtils.createButton(content, 'Continue', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.scene.togglePause();
        }, { background: '#4caf50', width: '100%', padding: '12px', fontSize: '16px', border: 'none' });

        content.appendChild(document.createElement('br'));

        // Settings
        UIUtils.createButton(content, 'Settings', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.renderSettings(menu);
        }, { background: '#2196f3', width: '100%', padding: '12px', fontSize: '16px', border: 'none', marginTop: '10px' });

        // Exit
        UIUtils.createButton(content, 'Exit to Menu', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.scene.togglePause();
            this.scene.game.toMenu();
        }, { background: '#f44336', width: '100%', padding: '12px', fontSize: '16px', border: 'none', marginTop: '10px' });

        menu.appendChild(content);
    }

    private renderSettings(menu: HTMLElement) {
        menu.innerHTML = '';
        const content = document.createElement('div');
        Object.assign(content.style, {
            background: '#222',
            padding: '40px',
            borderRadius: '8px',
            border: '2px solid #555',
            textAlign: 'center',
            minWidth: '300px'
        });

        content.innerHTML = `<h2 style="color:#ffd700; margin:0 0 20px 0;">Audio Settings</h2>`;

        const addSlider = (label: string, val: number, onChange: (v: number) => void) => {
            const row = document.createElement('div');
            row.style.marginBottom = '10px';
            row.style.textAlign = 'left';
            row.innerHTML = `<label style="display:inline-block; width:60px;">${label}</label>`;

            const input = document.createElement('input');
            input.type = 'range';
            input.min = '0';
            input.max = '1';
            input.step = '0.1';
            input.value = val.toString();
            input.oninput = (e) => onChange(parseFloat((e.target as HTMLInputElement).value));

            row.appendChild(input);
            content.appendChild(row);
        };

        addSlider('Master', SoundManager.MASTER_VOLUME, (v) => SoundManager.setVolume(v));
        addSlider('SFX', SoundManager.SFX_VOLUME, (v) => SoundManager.SFX_VOLUME = v);
        addSlider('Music', SoundManager.MUSIC_VOLUME, (v) => SoundManager.MUSIC_VOLUME = v);

        // Back button
        UIUtils.createButton(content, 'Back', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.renderMainMenu(menu);
        }, { background: '#555', marginTop: '20px', width: '100%', padding: '10px', border: 'none' });

        menu.appendChild(content);
    }

    public update(paused: boolean) {
        if (this.elPauseMenu) {
            this.elPauseMenu.style.display = paused ? 'flex' : 'none';
        }
    }
}
</file>

<file path="src/utils/Logger.ts">
export enum LogLevel {
    VERBOSE = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3,
    NONE = 99
}

export enum LogChannel {
    SYSTEM = 'SYS',
    GAME = 'GAME',
    RENDER = 'RNDR',
    AUDIO = 'AUDIO',
    INPUT = 'INPT',
    NETWORK = 'NET',
    LIFECYCLE = 'LIFECYCLE',
    ASSETS = 'ASSETS',
    UI = 'UI',
    COMBAT = 'COMBAT',
    PERF = 'PERF',
    SAVE = 'SAVE'
}

export interface LogEntry {
    timestamp: number;
    level: LogLevel;
    channel: LogChannel;
    message: string;
    data?: any;
    count: number; // For collapsed logs
}

export class Logger {
    private static instance: Logger;

    // Configuration
    public minLevel: LogLevel = LogLevel.INFO;
    public maxHistory: number = 200; // Keep last 200 logs

    // State
    private history: LogEntry[] = [];
    private listeners: ((entry: LogEntry) => void)[] = [];

    // Throttling / De-duplication
    private lastLogSignature: string = '';
    private lastLogEntry: LogEntry | null = null;
    private lastLogTime: number = 0;
    private throttleTimeMs: number = 1000; // Reset "count" logic if spam stops for 1 second

    // logOnce TTL Map
    private ttlLogs: Map<string, number> = new Map();

    private constructor() {
        console.log('%c Logger Initialized ', 'background: #222; color: #bada55');
    }

    public static getInstance(): Logger {
        if (!Logger.instance) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }

    // --- Public API ---

    public static debug(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.VERBOSE, channel, msg, data);
    }

    public static info(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.INFO, channel, msg, data);
    }

    public static warn(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.WARN, channel, msg, data);
    }

    public static error(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.ERROR, channel, msg, data);
    }

    public static groupCollapsed(label: string) {
        console.groupCollapsed(label);
    }

    public static groupEnd() {
        console.groupEnd();
    }

    public static logOnce(key: string, channel: LogChannel, msg: string, level: LogLevel = LogLevel.INFO, ttlMs: number = 5000, data?: any) {
        const logger = Logger.getInstance();
        const now = Date.now();
        const lastPrint = logger.ttlLogs.get(key) || 0;

        if (now - lastPrint >= ttlMs) {
            logger.ttlLogs.set(key, now);
            logger.log(level, channel, msg, data);
        }
    }

    public static getHistory(): LogEntry[] {
        return Logger.getInstance().history;
    }

    public static subscribe(callback: (entry: LogEntry) => void) {
        Logger.getInstance().listeners.push(callback);
    }

    public static unsubscribe(callback: (entry: LogEntry) => void) {
        const i = Logger.getInstance().listeners.indexOf(callback);
        if (i > -1) Logger.getInstance().listeners.splice(i, 1);
    }

    // --- Internal Logic ---

    private log(level: LogLevel, channel: LogChannel, msg: string, data?: any) {
        if (level < this.minLevel) return;

        const now = Date.now();
        const signature = `${level}:${channel}:${msg}`;

        // Check for spam/throttling (same message repeated)
        if (this.lastLogEntry && this.lastLogSignature === signature && (now - this.lastLogTime < this.throttleTimeMs)) {
            this.lastLogEntry.count++;
            this.lastLogEntry.timestamp = now; // Update time to latest occurrence
            this.lastLogTime = now;
            // Notify listeners about update (optional, usually listeners just append, so this might be tricky for UI 
            // - UI should re-render or handle updates. For now we rely on UI refreshing or ignoring updates to existing objects)
            return;
        }

        const entry: LogEntry = {
            timestamp: now,
            level,
            channel,
            message: msg,
            data,
            count: 1
        };

        // Add to history
        this.history.push(entry);
        if (this.history.length > this.maxHistory) {
            this.history.shift(); // Remove oldest
        }

        // Update state
        this.lastLogEntry = entry;
        this.lastLogSignature = signature;
        this.lastLogTime = now;

        // Output to Browser Console (Dual Output)
        this.printToConsole(entry);

        // Notify subscribers (The In-Game Console)
        this.listeners.forEach(l => l(entry));
    }

    private printToConsole(entry: LogEntry) {
        const time = new Date(entry.timestamp).toISOString().split('T')[1].slice(0, -1); // HH:MM:SS.ms
        const css = this.getLevelCSS(entry.level);
        const prefix = `%c[${time}] [${entry.channel}]`;

        // Use native console methods for proper stack tracing and object inspection in F12
        switch (entry.level) {
            case LogLevel.ERROR:
                console.error(prefix, css, entry.message, entry.data || '');
                break;
            case LogLevel.WARN:
                console.warn(prefix, css, entry.message, entry.data || '');
                break;
            case LogLevel.INFO:
                console.log(prefix, css, entry.message, entry.data || '');
                break;
            case LogLevel.VERBOSE:
                console.debug(prefix, css, entry.message, entry.data || '');
                break;
        }
    }

    private getLevelCSS(level: LogLevel): string {
        switch (level) {
            case LogLevel.ERROR: return 'color: #ff4444; font-weight: bold;';
            case LogLevel.WARN: return 'color: #ffbb33; font-weight: bold;';
            case LogLevel.INFO: return 'color: #33b5e5; font-weight: bold;';
            case LogLevel.VERBOSE: return 'color: #999;';
            default: return 'color: #fff;';
        }
    }
}
</file>

<file path="src/utils/PerformanceProfiler.ts">
/**
 * PerformanceProfiler - Granular code instrumentation
 * Optimized for zero-allocation during runtime to avoid GC noise.
 */
export class PerformanceProfiler {
    private static enabled = false;
    private static startTimes = new Map<string, number>();
    private static durations = new Map<string, number>();
    private static counts = new Map<string, number>();

    // Sampling strategy: only measure every Nth frame
    private static readonly SAMPLE_RATE = 5;
    private static frameCount = 0;
    private static isActiveFrame = false;

    public static enable() {
        this.enabled = true;
        this.reset();
    }

    public static reset() {
        this.startTimes.clear();
        this.durations.clear();
        this.counts.clear();
        this.frameCount = 0;
        this.isActiveFrame = false;
    }

    public static disable() {
        this.enabled = false;
    }

    public static beginFrame() {
        if (!this.enabled) return;

        this.frameCount++;
        this.isActiveFrame = (this.frameCount % this.SAMPLE_RATE === 0);

        if (this.isActiveFrame) {
            // Clear maps without allocating new ones if possible, 
            // but Map.clear() is efficient enough.
            this.durations.clear();
            this.counts.clear();
            this.startTimes.clear();
        }
    }

    public static start(label: string) {
        if (!this.enabled || !this.isActiveFrame) return;
        this.startTimes.set(label, performance.now());
    }

    public static end(label: string) {
        if (!this.enabled || !this.isActiveFrame) return;

        const startTime = this.startTimes.get(label);
        if (startTime === undefined) return;

        const duration = performance.now() - startTime;
        const currentTotal = this.durations.get(label) || 0;
        this.durations.set(label, currentTotal + duration);

        const currentCount = this.counts.get(label) || 0;
        this.counts.set(label, currentCount + 1);
    }

    public static count(label: string, value: number = 1) {
        if (!this.enabled || !this.isActiveFrame) return;
        const currentCount = this.counts.get(label) || 0;
        this.counts.set(label, currentCount + value);
    }

    public static getFrameData(): Record<string, number> {
        // Return 0s if not active frame, or return cached last frame data?
        // For simplicity, we return the current map as object.
        // In a strict zero-alloc system we wouldn't return an object, 
        // but for reporting we need to serialize eventually.
        const result: Record<string, number> = {};

        // Return 0 if we skipped this frame (or maybe return null/empty)
        if (!this.isActiveFrame) return result;

        this.durations.forEach((val, key) => {
            result[key] = val;
        });
        return result;
    }

    public static getFrameCounts(): Record<string, number> {
        const result: Record<string, number> = {};
        if (!this.isActiveFrame) return result;
        this.counts.forEach((val, key) => {
            result[key] = val;
        });
        return result;
    }
}
</file>

<file path="src/BaseScene.ts">
import { Scene } from './Scene';

/**
 * Base Scene implementation with strict lifecycle and automated cleanup.
 * 
 * - onEnter(): Final. Calls onEnterImpl().
 * - onExit(): Final. Calls onExitImpl() then dispose().
 * - dispose(): Removes all tracked listeners.
 * - on(): Helper to add listeners that are automatically removed.
 */
export abstract class BaseScene implements Scene {
    protected listeners: Array<{ target: EventTarget; type: string; handler: EventListenerOrEventListenerObject }> = [];

    public onEnter(): void {
        this.onEnterImpl();
    }

    public onExit(): void {
        this.onExitImpl();
        this.dispose();
    }

    /**
     * Concrete implementation of scene entry logic.
     * Override this instead of onEnter().
     */
    protected abstract onEnterImpl(): void;

    /**
     * Concrete implementation of scene exit logic.
     * Override this instead of onExit().
     */
    protected abstract onExitImpl(): void;

    public abstract update(dt: number): void;
    public abstract draw(ctx: CanvasRenderingContext2D): void;

    protected on(target: EventTarget, type: string, handler: EventListenerOrEventListenerObject) {
        target.addEventListener(type, handler);
        this.listeners.push({ target, type, handler });
    }

    public dispose() {
        this.listeners.forEach((l) => l.target.removeEventListener(l.type, l.handler));
        this.listeners = [];
    }
}
</file>

<file path="src/cards/index.ts">
/**
 * Card System Module
 * Central export point for all card upgrade definitions
 */

import { IUpgradeCard, ICardModifiers, ICardEffect, mergeModifiers, mergeEffects } from './CardType';
import { FIRE_UPGRADES } from './FireCard';
import { ICE_UPGRADES } from './IceCard';
import { SNIPER_UPGRADES } from './SniperCard';
import { MULTISHOT_UPGRADES, getMultishotConfig } from './MultishotCard';
import { MINIGUN_UPGRADES } from './MinigunCard';
import {
    EVOLUTION_UPGRADES,
    EVOLUTION_CHOICES,
    getEvolutionChoice,
    getEvolutionUpgrade,
    getEvolutionMeta,
    IEvolutionPath,
    IEvolutionChoice
} from './CardEvolutions';

// Export types
export type { IUpgradeCard, ICardModifiers, ICardEffect, IEvolutionPath, IEvolutionChoice };
export { mergeModifiers, mergeEffects };

// Export card upgrade data
export { FIRE_UPGRADES, ICE_UPGRADES, SNIPER_UPGRADES, MULTISHOT_UPGRADES, MINIGUN_UPGRADES, getMultishotConfig };

// Export evolution system
export { EVOLUTION_UPGRADES, EVOLUTION_CHOICES, getEvolutionChoice, getEvolutionUpgrade, getEvolutionMeta };

/**
 * Card upgrade registry (classic paths)
 */
const CARD_REGISTRY: Record<string, Record<number, IUpgradeCard>> = {
    'fire': FIRE_UPGRADES,
    'ice': ICE_UPGRADES,
    'sniper': SNIPER_UPGRADES,
    'multi': MULTISHOT_UPGRADES,
    'minigun': MINIGUN_UPGRADES,
};

/**
 * Get upgrade data for a specific card type and level
 * Prioritizes evolution upgrades if evolutionPath is set
 * 
 * @param cardTypeId - The card type ID (e.g., 'fire', 'ice', 'sniper', 'multi')
 * @param level - The card level (1-3)
 * @param evolutionPath - Optional evolution path ('inferno', 'napalm', etc.)
 * @returns The upgrade data or null if not found
 */
export function getCardUpgrade(cardTypeId: string, level: number, evolutionPath?: string): IUpgradeCard | null {
    // First, check for evolution upgrade
    if (evolutionPath && evolutionPath !== 'classic') {
        const evoUpgrade = getEvolutionUpgrade(evolutionPath, level);
        if (evoUpgrade) {
            return evoUpgrade;
        }
    }

    // Fallback to classic registry
    const cardUpgrades = CARD_REGISTRY[cardTypeId];
    if (!cardUpgrades) {
        console.warn(`Unknown card type: ${cardTypeId}`);
        return null;
    }

    const upgrade = cardUpgrades[level];
    if (!upgrade) {
        console.warn(`Unknown level ${level} for card type ${cardTypeId}`);
        return null;
    }

    return upgrade;
}
</file>

<file path="src/CardSelectionUI.ts">
import { CONFIG } from './Config';

/**
 * Card Selection System
 * Shows overlay where player select s 3 starting cards
 */
export class CardSelectionUI {
    private overlay: HTMLElement;
    private grid: HTMLElement;
    private counter: HTMLElement;
    private startButton: HTMLButtonElement;
    private selectedCards: string[] = [];
    private onComplete: (cards: string[]) => void;

    constructor(onComplete: (cards: string[]) => void) {
        this.onComplete = onComplete;
        console.log('CardSelectionUI: Constructor called');

        // Don't check elements here - they might not exist yet
        // Elements will be checked in show() method
    }

    public show() {
        console.log('CardSelectionUI.show() called');

        // FIXED: Check elements HERE, not in constructor
        this.overlay = document.getElementById('card-selection-overlay')!;
        this.grid = document.getElementById('card-selection-grid')!;
        this.counter = document.getElementById('selected-count')!;
        this.startButton = document.getElementById('start-game-btn') as HTMLButtonElement;

        if (!this.overlay || !this.grid || !this.counter || !this.startButton) {
            console.error('CardSelectionUI: Required DOM elements not found!');
            console.error('overlay:', this.overlay);
            console.error('grid:', this.grid);
            console.error('counter:', this.counter);
            console.error('startButton:', this.startButton);
            alert('ERROR: Card selection UI elements not found. Check console.');
            return;
        }

        // Add click listener (overrides any existing to prevent double triggers)
        this.startButton.onclick = () => this.complete();

        console.log('CardSelectionUI: All elements found successfully');

        this.selectedCards = [];
        this.overlay.classList.add('show');
        this.render();
    }

    public hide() {
        this.overlay.classList.remove('show');
    }

    private render() {
        console.log('CardSelectionUI.render() called');
        this.grid.innerHTML = '';

        // Get all base card types
        const baseCards = Object.keys(CONFIG.CARD_TYPES);
        console.log('Base cards available:', baseCards);

        // Add 2 random cards
        const randomCards = [
            baseCards[Math.floor(Math.random() * baseCards.length)],
            baseCards[Math.floor(Math.random() * baseCards.length)],
        ];

        const availableCards = [...baseCards, ...randomCards];
        console.log('Total cards to display:', availableCards);

        // Render cards
        availableCards.forEach((cardKey, index) => {
            const config = CONFIG.CARD_TYPES[cardKey];
            if (!config) {
                console.warn(`Card config not found for key: ${cardKey}`);
                return;
            }

            const cardEl = document.createElement('div');
            // Use same structure as CardSystem
            cardEl.className = `card type-${config.id} level-1`;
            cardEl.style.animationDelay = `${index * 0.05}s`;
            cardEl.style.cursor = 'pointer';

            // Get stats HTML for level 1
            const statsHTML = this.getCardStatsHTML(config.id);

            cardEl.innerHTML = `
                <div class="card-level">‚òÖ</div>
                <div class="card-icon">${config.icon}</div>
                <div class="card-stats">${statsHTML}</div>
            `;

            cardEl.addEventListener('click', () => this.selectCard(cardKey, cardEl));
            this.grid.appendChild(cardEl);
        });

        console.log(`Rendered ${availableCards.length} cards`);

        // Update counter and button
        this.updateUI();
    }

    private selectCard(cardKey: string, cardEl: HTMLElement) {
        if (cardEl.classList.contains('selected')) {
            // Deselect
            cardEl.classList.remove('selected');
            const index = this.selectedCards.indexOf(cardKey);
            if (index !== -1) {
                this.selectedCards.splice(index, 1);
            }
        } else {
            // Select (if not full)
            if (this.selectedCards.length < 5) {
                cardEl.classList.add('selected');
                this.selectedCards.push(cardKey);
            }
        }

        this.updateUI();
    }

    private updateUI() {
        this.counter.textContent = this.selectedCards.length.toString();
        this.startButton.disabled = this.selectedCards.length !== 5;
    }

    private complete() {
        if (this.selectedCards.length === 5) {
            this.hide();
            this.onComplete(this.selectedCards);
        }
    }

    private getCardStatsHTML(typeId: string): string {
        // Same logic as CardSyst em, but always level 1
        switch (typeId) {
            case 'fire':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +15</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 50</div>`;
            case 'ice':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +3</div><div class="card-stat-line">‚ùÑÔ∏è 30%</div>`;
            case 'sniper':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +14</div><div class="card-stat-line">üéØ +80</div>`;
            case 'multi':
                return `<div class="card-stat-primary">2 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.8x —É—Ä–æ–Ω</div>`;
            case 'minigun':
                return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+3 —É—Ä–æ–Ω/—Å</div>`;
            default:
                return `<div class="card-stat-line">–ö–∞—Ä—Ç–∞</div>`;
        }
    }
}
</file>

<file path="src/config/Towers.ts">
export const TOWER_CONFIG = {
    BASE_RANGE: 120,
    BASE_DMG: 5,
    BASE_CD: 0.9, // 54 / 60 = 0.9 seconds
    BUILD_TIME: 1.0, // 60 / 60 = 1.0 second
    MAX_CARDS: 3,
    BARREL_LENGTH: 22,
    TURN_SPEED: 18.0, // Increased for smoother tracking
    AIM_TOLERANCE: 0.1,
};

export const TARGETING_MODES = {
    FIRST: { id: 'first', name: '–ü–µ—Ä–≤—ã–π', icon: 'üèÉ', desc: '–ë–ª–∏–∂–µ –∫ —Ü–µ–ª–∏' },
    CLOSEST: { id: 'closest', name: '–ë–ª–∏–∂–∞–π—à–∏–π', icon: 'üìç', desc: '–†—è–¥–æ–º —Å –±–∞—à–Ω–µ–π' },
    STRONGEST: { id: 'strongest', name: '–°–∏–ª—å–Ω—ã–π', icon: 'üí™', desc: '–ú–∞–∫—Å. –∑–¥–æ—Ä–æ–≤—å–µ' },
    LAST: { id: 'last', name: '–ü–æ—Å–ª–µ–¥–Ω–∏–π', icon: 'üê¢', desc: '–î–∞–ª—å—à–µ –æ—Ç —Ü–µ–ª–∏' },
};
</file>

<file path="src/CrashHandler.ts">
import { Logger, LogChannel, LogLevel } from './utils/Logger';
import { SafeJson } from './utils/SafeJson';

export class CrashHandler {
    constructor() {
        this.init();
        Logger.info(LogChannel.SYSTEM, 'CrashHandler initialized');
    }

    private init() {
        window.onerror = (message, source, lineno, colno, error) => {
            this.handleError(message as string, source, lineno, colno, error);
            return true; // Prevent default browser console spam if we handle it
        };

        window.addEventListener('unhandledrejection', (event) => {
            this.handleError(event.reason ? event.reason.toString() : 'Unhandled Rejection', 'Promise', 0, 0, event.reason);
        });
    }

    private handleError(msg: string, source: string | undefined, line: number, col: number | undefined, error: any) {
        // 1. Log to our internal logger immediately (so it's in history)
        Logger.error(LogChannel.SYSTEM, `CRASH: ${msg}`, { source, line, stack: error?.stack });

        // 2. Stop Game Loop (Global hack or try to find game instance)
        // We can't easily stop requestAnimationFrame from here without reference, but we can cover the screen.

        // 3. Show BSOD
        this.showBSOD(msg, source || 'unknown', line, error);
    }

    private showBSOD(msg: string, source: string, line: number, error: any) {
        // Stop interaction
        const ui = document.getElementById('ui-layer');
        if (ui) ui.style.display = 'none';

        // Create BSOD
        const bsod = document.createElement('div');
        Object.assign(bsod.style, {
            position: 'fixed', top: '0', left: '0', width: '100%', height: '100%',
            background: 'rgba(50, 0, 0, 0.96)', color: '#fff', fontFamily: 'Consolas, monospace',
            padding: '40px', zIndex: '999999', overflow: 'auto', display: 'flex', flexDirection: 'column',
            backdropFilter: 'blur(5px)'
        });

        const report = this.createFullReport(msg, source, line, error);

        bsod.innerHTML = `
            <h1 style="color: #ff5555; margin: 0 0 20px 0;">‚ò†Ô∏è CRITICAL FAILURE</h1>
            <p style="font-size: 16px; color: #ffaaaa; margin-bottom: 30px;">
                The game encountered an unrecoverable error.
            </p>
            
            <div style="background: #220000; padding: 20px; border: 1px solid #ff4444; border-radius: 6px; margin-bottom: 20px;">
                <div style="color: #ff5555; font-weight: bold; margin-bottom: 10px;">EPOCH ERROR: ${msg}</div>
                <div style="color: #999; font-size: 12px;">${source}:${line}</div>
                <pre style="color: #ccc; margin-top: 15px; font-size: 12px; overflow-x: auto;">${error?.stack || 'No stack trace available'}</pre>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="btn-copy-report" style="padding: 12px 24px; background: #fff; color: #800; border: none; font-weight: bold; cursor: pointer; border-radius: 4px;">
                    üìã COPY FULL DEBUG REPORT
                </button>
                <button onclick="location.reload()" style="padding: 12px 24px; background: #444; color: #fff; border: none; cursor: pointer; border-radius: 4px;">
                    üîÑ RELOAD GAME
                </button>
            </div>
            
            <p style="margin-top: 20px; color: #666; font-size: 12px;">
                Please send this report to the developer.
            </p>
        `;

        document.body.appendChild(bsod);

        document.getElementById('btn-copy-report')!.onclick = () => {
            navigator.clipboard.writeText(report).then(() => {
                const btn = document.getElementById('btn-copy-report')!;
                btn.innerText = '‚úÖ COPIED!';
                btn.style.background = '#4f4';
                btn.style.color = '#000';
            });
        };
    }

    private createFullReport(msg: string, source: string, line: number, error: any): string {
        const report = {
            timestamp: new Date().toISOString(),
            error: {
                message: msg,
                source: `${source}:${line}`,
                stack: error?.stack,
            },
            system: {
                ua: navigator.userAgent,
                resolution: `${window.innerWidth}x${window.innerHeight}`,
                time: performance.now().toFixed(2) + 'ms'
            },
            logs: Logger.getHistory(), // Last 200 logs
            // Ideally we would dump GameState here, but we lack reference. 
            // The logs should contain enough info if properly instrumented.
        };

        return JSON.stringify(report, null, 2);
    }
}
</file>

<file path="src/editor/components/WaveList.ts">
import { BaseComponent } from './BaseComponent';
import { WaveModel } from '../WaveModel';
import { EnemyGroupRow } from './EnemyGroupRow';
import { ThreatMeter } from './ThreatMeter';
import { WaveSettingsPanel } from './WaveSettingsPanel';
import { WaveTimeline } from './WaveTimeline';

export class WaveList extends BaseComponent<WaveModel> {
    private expandedWaveIndex: number = 0; // Default open first wave

    public render(): void {
        const waveCount = this.data.getWaveCount();
        if (this.expandedWaveIndex >= waveCount) {
            this.expandedWaveIndex = waveCount > 0 ? waveCount - 1 : -1;
        }

        this.element.innerHTML = '';
        this.element.className = 'we-wave-list';
        this.element.style.display = 'flex';
        this.element.style.flexDirection = 'column';
        this.element.style.gap = '10px';

        // --- Bulk Toolbar ---
        const bulkToolbar = this.createElement('div', 'we-bulk-toolbar');
        const delAllBtn = this.createElement('button', 'we-btn we-btn-danger we-btn-icon', 'üóëÔ∏è');
        delAllBtn.title = '–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –≤–æ–ª–Ω—ã';
        delAllBtn.onclick = () => {
            if (confirm('–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –≤–æ–ª–Ω—ã?')) {
                this.data.replaceAllWaves([]);
            }
        };
        const dupAllBtn = this.createElement('button', 'we-btn we-btn-icon', 'üìã');
        dupAllBtn.title = '–î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ';
        dupAllBtn.onclick = () => {
            const copy = JSON.parse(JSON.stringify(this.data.getWaves()));
            const newWaves = [];
            for (const w of copy) {
                newWaves.push(w);
                newWaves.push(JSON.parse(JSON.stringify(w)));
            }
            this.data.replaceAllWaves(newWaves);
        };
        bulkToolbar.appendChild(delAllBtn);
        bulkToolbar.appendChild(dupAllBtn);
        this.element.appendChild(bulkToolbar);

        const waves = this.data.getWaves();

        waves.forEach((_wave, index) => {
            this.renderWaveItem(index);
        });

        // Add Wave Button
        const addBtn = this.createElement('button', 'we-btn we-btn-secondary we-btn-full', '+ –î–æ–±–∞–≤–∏—Ç—å –í–æ–ª–Ω—É');
        addBtn.onclick = () => this.data.addWave();
        this.element.appendChild(addBtn);
    }

    private renderWaveItem(index: number) {
        const wave = this.data.getWave(index);
        const threat = this.data.getThreat(index);
        const isLast = index === this.data.getWaveCount() - 1;
        const validation = this.data.validateExtended();

        const container = this.createElement('div', 'we-wave-item');

        const hasError = validation.errors.some(e => e.waveIndex === index);
        const hasWarning = validation.warnings.some(w => w.waveIndex === index);

        if (hasError) container.classList.add('we-wave-item--error');
        else if (hasWarning) container.classList.add('we-wave-item--warning');

        // --- Header ---
        const header = this.createElement('div', 'we-wave-header');
        header.onclick = (e) => {
            // Prevent toggling if clicking buttons
            if ((e.target as HTMLElement).tagName === 'BUTTON') return;

            if (this.expandedWaveIndex === index) {
                this.expandedWaveIndex = -1; // Collapse
            } else {
                this.expandedWaveIndex = index; // Expand
            }
            this.render(); // Re-render
        };

        const titleText = wave.name
            ? `–í–æ–ª–Ω–∞ ${index + 1} ‚Äî ${wave.name}`
            : `–í–æ–ª–Ω–∞ ${index + 1}`;
        const title = this.createElement('span', 'we-wave-title', titleText);
        header.appendChild(title);

        // Cycle badge on last wave
        if (isLast) {
            const cycleBadge = this.createElement('span', 'we-cycle-badge', '‚àû –ü–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è');
            header.appendChild(cycleBadge);
        }

        // Preview of threat in header if collapsed
        if (this.expandedWaveIndex !== index) {
            const duration = this.data.getEstimatedDuration(index);
            const threatPreview = this.createElement('span', '', `${Math.round(threat)} üíÄ ‚Ä¢ ~${duration.toFixed(1)}—Å`);
            threatPreview.style.fontSize = '12px';
            threatPreview.style.color = '#888';
            threatPreview.style.marginLeft = 'auto';
            threatPreview.style.marginRight = '10px';
            header.appendChild(threatPreview);
        }

        // Move Up button
        if (index > 0) {
            const moveUpBtn = this.createElement('button', 'we-move-btn', 'üîº');
            moveUpBtn.title = '–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –≤–æ–ª–Ω—ã –≤–≤–µ—Ä—Ö';
            moveUpBtn.style.marginLeft = this.expandedWaveIndex !== index ? '0' : 'auto';
            moveUpBtn.onclick = () => this.data.moveWaveUp(index);
            header.appendChild(moveUpBtn);
        }

        // Move Down button
        if (!isLast) {
            const moveDownBtn = this.createElement('button', 'we-move-btn', 'üîΩ');
            moveDownBtn.title = '–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –≤–æ–ª–Ω—ã –≤–Ω–∏–∑';
            moveDownBtn.style.marginLeft = (this.expandedWaveIndex !== index && index === 0) ? 'auto' : '0';
            moveDownBtn.onclick = () => this.data.moveWaveDown(index);
            header.appendChild(moveDownBtn);
        }

        // Duplicate Wave button
        const dupBtn = this.createElement('button', 'we-btn we-btn-icon', 'üìã');
        dupBtn.title = '–î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ª–Ω—É';
        dupBtn.style.marginLeft = (this.expandedWaveIndex === index && index === 0 && isLast) ? 'auto' : '0';
        dupBtn.onclick = () => this.data.duplicateWave(index);
        header.appendChild(dupBtn);

        // Delete Wave button
        const delBtn = this.createElement('button', 'we-btn we-btn-icon', '‚úï');
        delBtn.onclick = () => this.data.removeWave(index);
        header.appendChild(delBtn);

        container.appendChild(header);

        // --- Content (if expanded) ---
        if (this.expandedWaveIndex === index) {
            const content = this.createElement('div', 'we-wave-content');

            // 1. Wave Settings Panel (name, delay, shuffle, reward)
            const settingsPanel = new WaveSettingsPanel({
                waveIndex: index,
                model: this.data,
            });
            settingsPanel.mount(content);

            // 2. Timeline visualization
            const timeline = new WaveTimeline({ waveIndex: index, model: this.data });
            timeline.mount(content);

            // 3. Threat Meter
            const meter = new ThreatMeter({ threat });
            meter.mount(content);

            // 3. Enemy Groups
            const groupsContainer = this.createElement('div');
            groupsContainer.style.marginTop = '10px';

            wave.enemies.forEach((group, gIndex) => {
                const isGroupError = validation.errors.some(e => e.waveIndex === index && e.groupIndex === gIndex);

                const row = new EnemyGroupRow({
                    type: group.type,
                    count: group.count,
                    baseInterval: group.baseInterval ?? 0.66,
                    delayBefore: group.delayBefore ?? 0,
                    spawnPattern: group.spawnPattern || group.pattern || 'normal',
                    hasError: isGroupError,
                    onChange: (updates) => {
                        this.data.updateEnemyGroup(index, gIndex, updates);
                    },
                    onDuplicate: () => {
                        this.data.duplicateGroup(index, gIndex);
                    },
                    onRemove: () => {
                        this.data.removeEnemyGroup(index, gIndex);
                    }
                });
                row.mount(groupsContainer);
            });
            content.appendChild(groupsContainer);

            // 4. Add Enemy Button
            const addEnemyBtn = this.createElement('button', 'we-btn we-btn-secondary', '+ –î–æ–±–∞–≤–∏—Ç—å –≥—Ä—É–ø–ø—É –≤—Ä–∞–≥–æ–≤');
            addEnemyBtn.style.marginTop = '8px';
            addEnemyBtn.style.fontSize = '12px';
            addEnemyBtn.style.padding = '4px 8px';
            addEnemyBtn.style.width = '100%';
            addEnemyBtn.onclick = () => this.data.addEnemyGroup(index);
            content.appendChild(addEnemyBtn);

            container.appendChild(content);
        }

        this.element.appendChild(container);
    }
}
</file>

<file path="src/editor/editor.css">
/* Wave Editor Core Styles */

.wave-editor-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.5);
    z-index: 2000;
    display: flex;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(2px);
}

.wave-editor-container {
    max-width: 800px;
    width: 90vw;
    max-height: 85vh;
    background: rgba(30, 30, 35, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
}

/* Header */
.we-header {
    padding: 16px;
    background: rgba(255, 255, 255, 0.05);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.we-header h2 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    color: #fff;
    letter-spacing: 0.5px;
}

/* Content Area */
.we-content {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* Scrollbar */
.we-content::-webkit-scrollbar {
    width: 8px;
}

.we-content::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
}

.we-content::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
}

/* Footer */
.we-footer {
    padding: 16px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    gap: 12px;
    background: rgba(20, 20, 25, 0.95);
}

/* Buttons */
.we-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}

.we-btn-primary {
    background: #4caf50;
    color: white;
}

.we-btn-primary:hover {
    background: #43a047;
}

.we-btn-danger {
    background: #f44336;
    color: white;
}

.we-btn-danger:hover {
    background: #e53935;
}

.we-btn-secondary {
    background: rgba(255, 255, 255, 0.1);
    color: #eee;
}

.we-btn-secondary:hover {
    background: rgba(255, 255, 255, 0.2);
}

.we-btn-icon {
    padding: 4px;
    width: 24px;
    height: 24px;
    border-radius: 4px;
    background: transparent;
    color: #aaa;
}

.we-btn-icon:hover {
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
}

.we-btn-full {
    width: 100%;
}

/* Wave Item */
.we-wave-item {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    overflow: hidden;
    transition: background 0.2s;
}

.we-wave-item:hover {
    background: rgba(255, 255, 255, 0.06);
    border-color: rgba(255, 255, 255, 0.1);
}

.we-wave-header {
    padding: 10px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(0, 0, 0, 0.2);
    cursor: pointer;
}

.we-wave-title {
    font-weight: 600;
    font-size: 14px;
    color: #bbb;
}

.we-wave-content {
    padding: 10px;
    border-top: 1px solid rgba(255, 255, 255, 0.05);
}

/* Enemy Row (see Phase 2 section below) */

.we-enemy-row select,
.we-enemy-row input {
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: #fff;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 13px;
}

.we-enemy-row select:focus,
.we-enemy-row input:focus {
    border-color: #2196f3;
    outline: none;
}

/* Threat Meter */
.we-threat-meter {
    height: 4px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 4px;
    width: 100px;
}

.we-threat-fill {
    height: 100%;
    transition: width 0.3s ease, background-color 0.3s ease;
}

.we-threat-badge {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 10px;
    background: rgba(0, 0, 0, 0.4);
    font-weight: bold;
}

/* ===== Phase 2 Additions ===== */

/* Toolbar */
.we-toolbar {
    display: flex;
    gap: 4px;
    align-items: center;
}

/* Status Bar */
.we-status-bar {
    font-size: 12px;
    color: #888;
    padding: 6px 16px;
    background: rgba(0, 0, 0, 0.15);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    font-family: 'Consolas', 'Courier New', monospace;
}

/* Disabled button */
.we-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    pointer-events: none;
}

/* Timing Control (SpawnTimingControl) */
.we-timing-control {
    display: flex;
    flex-direction: row;
    gap: 6px;
    align-items: center;
    font-size: 12px;
}

.we-timing-label {
    color: #aaa;
    white-space: nowrap;
    min-width: 80px;
}

.we-timing-range {
    width: 80px;
    accent-color: #2196f3;
    cursor: pointer;
}

.we-timing-number {
    width: 55px;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: #fff;
    padding: 2px 4px;
    border-radius: 4px;
    font-size: 12px;
    text-align: center;
}

.we-timing-number:focus {
    border-color: #2196f3;
    outline: none;
}

.we-timing-suffix {
    color: #666;
    font-size: 11px;
}

/* Settings Panel (WaveSettingsPanel) */
.we-settings-panel {
    background: rgba(255, 255, 255, 0.03);
    padding: 10px;
    border-radius: 6px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 8px;
}

.we-settings-row {
    display: flex;
    align-items: center;
    gap: 8px;
}

.we-settings-label {
    color: #aaa;
    font-size: 12px;
    min-width: 110px;
    white-space: nowrap;
}

.we-settings-input {
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: #fff;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 13px;
    flex: 1;
    max-width: 200px;
}

.we-settings-input:focus {
    border-color: #2196f3;
    outline: none;
}

.we-settings-summary {
    font-size: 11px;
    color: #888;
    padding: 6px 8px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
    font-family: 'Consolas', 'Courier New', monospace;
    margin-top: 4px;
}

/* Enemy Row ‚Äî two-row layout */
.we-enemy-row {
    display: flex;
    flex-direction: column;
    gap: 4px;
    margin-bottom: 8px;
    padding: 6px;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.2);
}

.we-enemy-main {
    display: flex;
    gap: 8px;
    align-items: center;
}

.we-enemy-timing {
    display: flex;
    gap: 16px;
    align-items: center;
    padding: 4px 0 0 24px;
    border-top: 1px solid rgba(255, 255, 255, 0.03);
}

/* Type Color Dot */
.we-type-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
}

/* Threat Dot */
.we-threat-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
    margin-left: 4px;
}

/* Duration Label */
.we-duration-label {
    font-size: 11px;
    color: #aaa;
    font-family: 'Consolas', 'Courier New', monospace;
    white-space: nowrap;
}

/* Cycle Badge */
.we-cycle-badge {
    font-size: 10px;
    color: #666;
    font-style: italic;
    margin-left: 8px;
}

/* Timeline Canvas (Phase 3) */
.we-timeline-canvas {
    width: 100%;
    height: 40px;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.3);
    margin: 8px 0;
}

/* ===== Phase 4 Additions ===== */

.we-preset-panel {
    display: flex;
    gap: 8px;
    align-items: center;
    padding: 8px 16px;
    background: rgba(0, 0, 0, 0.2);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.we-bulk-toolbar {
    display: flex;
    gap: 8px;
    padding: 8px;
    background: rgba(0, 0, 0, 0.15);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.we-move-btn {
    padding: 4px;
    width: 20px;
    height: 20px;
    background: transparent;
    border: none;
    color: #aaa;
    cursor: pointer;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
}

.we-move-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
}

/* ===== Phase 5 Additions ===== */

.we-wave-item {
    animation: we-fade-in 0.2s ease;
}

@keyframes we-fade-in {
    from {
        opacity: 0;
        transform: translateY(-8px);
    }

    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.we-validation-panel {
    display: flex;
    flex-direction: column;
    gap: 4px;
    padding: 8px;
    margin: 8px;
    border-radius: 4px;
    font-size: 12px;
}

.we-validation-error {
    color: #ff8a80;
}

.we-validation-warning {
    color: #ffd180;
}

.we-wave-item--error {
    border-color: #f44336 !important;
    box-shadow: 0 0 4px rgba(244, 67, 54, 0.4);
}

.we-wave-item--warning {
    border-color: #ff9800 !important;
    box-shadow: 0 0 4px rgba(255, 152, 0, 0.4);
}

.we-enemy-row--error {
    border: 1px solid rgba(244, 67, 54, 0.6) !important;
    background: rgba(244, 67, 54, 0.1) !important;
}
</file>

<file path="src/editor/EditorToolbar.ts">
import { UIUtils } from '../UIUtils';
import { VISUALS } from '../VisualConfig';

export type EditorMode =
    | 'paint_road'
    | 'paint_grass'
    | 'set_start'
    | 'set_end'
    | 'place_waypoint'
    | 'eraser'
    | 'paint_fog'
    | 'place_stone'
    | 'place_rock'
    | 'place_tree'
    | 'place_wheat'
    | 'place_flowers';

interface ITool {
    id: EditorMode;
    label: string;
    icon: string;
    color: string;
    hotkey?: string;
}

interface IToolCategory {
    id: string;
    name: string;
    icon: string;
    tools: ITool[];
}

export class EditorToolbar {
    private container: HTMLElement;
    private categoriesContainer: HTMLElement;
    private toolsContainer: HTMLElement;

    private categories: IToolCategory[] = [];
    private selectedCategory: number = 0;
    private onModeChange: (mode: EditorMode) => void;

    constructor(onModeChange: (mode: EditorMode) => void) {
        this.onModeChange = onModeChange;

        // Define categories
        this.categories = [
            {
                id: 'environment',
                name: '–û–∫—Ä—É–∂–µ–Ω–∏–µ',
                icon: 'üå≤',
                tools: [
                    { id: 'paint_grass', label: '–¢—Ä–∞–≤–∞', icon: 'üå≤', color: '#388e3c' },
                    { id: 'paint_road', label: '–î–æ—Ä–æ–≥–∞', icon: 'üü´', color: '#795548' },
                    { id: 'paint_fog', label: '–¢—É–º–∞–Ω', icon: 'üå´Ô∏è', color: '#607d8b' },
                ]
            },
            {
                id: 'path',
                name: '–ü—É—Ç—å',
                icon: 'üö©',
                tools: [
                    { id: 'set_start', label: '–°—Ç–∞—Ä—Ç', icon: 'üèÅ', color: '#00bcd4' },
                    { id: 'set_end', label: '–§–∏–Ω–∏—à', icon: 'üõë', color: '#e91e63' },
                    { id: 'place_waypoint', label: '–¢–æ—á–∫–∞', icon: 'üìç', color: '#9c27b0' },
                ]
            },
            {
                id: 'objects',
                name: '–û–±—ä–µ–∫—Ç—ã',
                icon: 'ü™®',
                tools: [
                    { id: 'place_stone', label: '–ö–∞–º–Ω–∏', icon: 'ü™®', color: '#757575' },
                    { id: 'place_rock', label: '–°–∫–∞–ª—ã', icon: '‚õ∞Ô∏è', color: '#616161' },
                    { id: 'place_tree', label: '–õ–µ—Å', icon: 'üå≤', color: '#2e7d32' },
                    { id: 'place_wheat', label: '–ü—à–µ–Ω–∏—Ü–∞', icon: 'üåæ', color: '#f9a825' },
                    { id: 'place_flowers', label: '–¶–≤–µ—Ç—ã', icon: 'üå∏', color: '#c2185b' },
                ]
            },
            {
                id: 'erase',
                name: '–°—Ç–µ—Ä–µ—Ç—å',
                icon: 'üßπ',
                tools: [
                    { id: 'eraser', label: '–õ–∞—Å—Ç–∏–∫', icon: 'üßπ', color: '#ff6600', hotkey: 'E' },
                ]
            }
        ];

        this.container = this.createContainer();
        this.categoriesContainer = this.createCategoriesView();
        this.toolsContainer = this.createToolsView();

        this.container.appendChild(this.categoriesContainer);
        this.container.appendChild(this.toolsContainer);

        document.body.appendChild(this.container);

        this.selectCategory(0);
    }

    private createContainer(): HTMLElement {
        return UIUtils.createContainer({
            position: 'absolute',
            bottom: '20px',
            left: '50%',
            transform: 'translateX(-50%)',
            display: 'flex',
            flexDirection: 'column',
            gap: `${VISUALS.UI.SPACING.sm}px`,
            padding: `${VISUALS.UI.SPACING.md}px`,
            background: VISUALS.UI.COLORS.glass.bgDark,
            borderRadius: VISUALS.UI.BORDERS.radius.lg,
            zIndex: '1000'
        });
    }

    private createCategoriesView(): HTMLElement {
        const container = document.createElement('div');
        Object.assign(container.style, {
            display: 'flex',
            gap: `${VISUALS.UI.SPACING.xs}px`,
            borderBottom: `${VISUALS.UI.BORDERS.width.normal} solid #444`,
            paddingBottom: `${VISUALS.UI.SPACING.sm}px`
        });

        this.categories.forEach((cat, idx) => {
            const btn = document.createElement('button');
            btn.textContent = `${cat.icon} ${cat.name}`;
            btn.dataset.categoryIndex = idx.toString();

            Object.assign(btn.style, {
                background: VISUALS.UI.COLORS.neutral.medium,
                color: VISUALS.UI.COLORS.text.primary,
                border: `${VISUALS.UI.BORDERS.width.normal} solid ${VISUALS.UI.COLORS.neutral.light}`,
                padding: `${VISUALS.UI.SPACING.sm}px ${VISUALS.UI.SPACING.lg}px`,
                borderRadius: VISUALS.UI.BORDERS.radius.md,
                cursor: 'pointer',
                fontSize: VISUALS.UI.FONTS.size.md,
                fontWeight: VISUALS.UI.FONTS.weight.bold,
                transition: VISUALS.UI.TRANSITIONS.presets.fast
            });

            btn.onclick = () => this.selectCategory(idx);
            container.appendChild(btn);
        });

        return container;
    }

    private createToolsView(): HTMLElement {
        const container = document.createElement('div');
        Object.assign(container.style, {
            display: 'flex',
            gap: '8px',
            flexWrap: 'wrap'
        });

        return container;
    }

    public selectCategory(index: number): void {
        if (index < 0 || index >= this.categories.length) return;

        this.selectedCategory = index;

        // Update category button states
        const categoryBtns = this.categoriesContainer.querySelectorAll('button');
        categoryBtns.forEach((btn, idx) => {
            if (idx === index) {
                Object.assign((btn as HTMLElement).style, {
                    background: VISUALS.UI.COLORS.info,
                    borderColor: '#2196f3',
                    transform: 'translateY(-2px)'
                });
            } else {
                Object.assign((btn as HTMLElement).style, {
                    background: VISUALS.UI.COLORS.neutral.medium,
                    borderColor: VISUALS.UI.COLORS.neutral.light,
                    transform: 'translateY(0)'
                });
            }
        });

        // Update tools display
        this.renderTools();
    }

    private renderTools(): void {
        this.toolsContainer.innerHTML = '';

        const category = this.categories[this.selectedCategory];

        category.tools.forEach(tool => {
            const btn = document.createElement('button');
            btn.textContent = `${tool.icon} ${tool.label}`;
            if (tool.hotkey) {
                btn.textContent += ` (${tool.hotkey})`;
            }

            Object.assign(btn.style, {
                background: tool.color,
                color: VISUALS.UI.COLORS.text.primary,
                border: `${VISUALS.UI.BORDERS.width.thin} solid ${VISUALS.UI.COLORS.glass.borderHover}`,
                padding: `${VISUALS.UI.SPACING.sm}px ${VISUALS.UI.SPACING.lg}px`,
                borderRadius: VISUALS.UI.BORDERS.radius.md,
                cursor: 'pointer',
                fontSize: VISUALS.UI.FONTS.size.md,
                fontWeight: VISUALS.UI.FONTS.weight.bold,
                transition: VISUALS.UI.TRANSITIONS.presets.fast
            });

            btn.onmouseenter = () => {
                btn.style.transform = 'scale(1.05)';
                btn.style.boxShadow = VISUALS.UI.SHADOWS.md;
            };

            btn.onmouseleave = () => {
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = 'none';
            };

            btn.onclick = () => {
                console.log('[EditorToolbar] Tool clicked:', tool.id, tool.label);
                this.onModeChange(tool.id);
            };

            this.toolsContainer.appendChild(btn);
        });
    }

    public show(): void {
        this.container.style.display = 'flex';
    }

    public hide(): void {
        this.container.style.display = 'none';
    }

    public destroy(): void {
        if (this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
    }
}
</file>

<file path="src/editor/EnemyRegistry.ts">
import { ENEMY_TYPES, ENEMY_CONFIG } from '../config/Enemies';
import { IEnemyTypeConfig } from '../types';

/**
 * Service to provide access to enemy data for the editor.
 * Wraps the raw configuration to provide helper methods.
 */
export class EnemyRegistry {
    /**
     * Get all available enemy types as an array of entries
     */
    public static getAllEntries(): { key: string; config: IEnemyTypeConfig }[] {
        return Object.entries(ENEMY_TYPES).map(([key, config]) => ({ key, config }));
    }

    /**
     * Get all available enemy types (values only)
     * @deprecated Use getAllEntries for keys
     */
    public static getAllTypes(): IEnemyTypeConfig[] {
        return Object.values(ENEMY_TYPES).filter(e => !e.isHidden);
    }

    /**
     * Get enemy types visible in editor (excludes isHidden)
     */
    public static getVisibleForEditor(): IEnemyTypeConfig[] {
        return Object.values(ENEMY_TYPES).filter(e => !e.isHidden);
    }

    /**
     * Get a specific enemy type by ID (Case insensitive check)
     */
    public static getType(id: string): IEnemyTypeConfig | undefined {
        const key = id.toUpperCase();
        return ENEMY_TYPES[key] || Object.values(ENEMY_TYPES).find(t => t.id === id);
    }

    /**
     * Get enemy types used for dropdowns (keys)
     */
    public static getTypeKeys(): string[] {
        return Object.keys(ENEMY_TYPES);
    }

    /**
     * Calculates an approximate "Power Rating" for a single unit of this type.
     * Used for sorting or rough estimation.
     * Formula: Effective HP * Speed Factor
     */
    public static getPowerRating(typeId: string): number {
        const type = this.getType(typeId);
        if (!type) return 0;

        const hp = ENEMY_CONFIG.BASE_HP * type.hpMod;
        // Normalizing speed: 60 (1 tile/sec) is baseline 1.0
        const speedFactor = type.speed / 60;

        return hp * speedFactor;
    }

    /**
     * Returns types sorted by their Power Rating (weakest to strongest)
     */
    public static getTypesSortedByPower(): IEnemyTypeConfig[] {
        return this.getAllTypes().sort((a, b) => {
            return this.getPowerRating(a.id) - this.getPowerRating(b.id);
        });
    }
}
</file>

<file path="src/FogRenderer.ts">
import { SimplexNoise } from './SimplexNoise';
import { FogStructure } from './FogStructure';
import { CONFIG } from './Config';

/**
 * Fog Renderer - handles animated procedural fog rendering
 */
export class FogRenderer {
    private noise: SimplexNoise;
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;

    // Animation parameters - increased for more visible movement
    private readonly DRIFT_SPEED = 0.0012; // 4x faster (was 0.0003)
    private readonly ROTATION_SPEED = 0.0004; // 4x faster (was 0.0001)
    private readonly NOISE_SCALE = 0.01;
    private readonly MAX_DRIFT = CONFIG.TILE_SIZE * 0.3; // Increased from 0.2
    private readonly MAX_ROTATION = 0.08; // Increased from 0.05 (~4.5¬∞)

    // Visual parameters
    private readonly FOG_COLOR = { r: 200, g: 215, b: 230 };
    private readonly BASE_ALPHA = 0.18;

    constructor(width: number, height: number, seed?: number) {
        this.noise = new SimplexNoise(seed);
        this.canvas = document.createElement('canvas');
        this.canvas.width = width;
        this.canvas.height = height;

        const context = this.canvas.getContext('2d');
        if (!context) throw new Error('Failed to create fog render context');
        this.ctx = context;
    }

    /**
     * Render fog structures
     */
    /**
     * Render fog structures with dual-layer noise and light masking
     */
    public render(structures: FogStructure[], time: number, lights: { x: number, y: number, radius: number }[] = []): void {
        const ctx = this.ctx;
        const width = this.canvas.width;
        const height = this.canvas.height;

        // Clear canvas
        ctx.clearRect(0, 0, width, height);

        // 1. Draw Dual-Layer Fog
        for (let i = 0; i < structures.length; i++) {
            this.renderStructure(structures[i], time);
        }

        // 2. Apply Light Masks (Cut holes)
        if (lights.length > 0) {
            this.applyLightMasks(lights);
        }
    }

    private renderStructure(structure: FogStructure, time: number): void {
        const TS = CONFIG.TILE_SIZE;
        const ctx = this.ctx;

        for (let t = 0; t < structure.tiles.length; t++) {
            const tile = structure.tiles[t];
            if (tile.density === 0) continue;

            const cx = tile.x * TS + TS / 2;
            const cy = tile.y * TS + TS / 2;
            const baseRadius = TS * 1.5; // Larger radius for volumetric feel

            // Base opacity based on density (0.2 to 1.0)
            const densityAlpha = Math.min(tile.density * 0.2, 1.0);

            ctx.save();
            ctx.translate(cx, cy);

            // --- Layer 1: Base Fog (Slow, Heavy) ---
            // Scale 1.0, Speed 0.5x
            const drift1X = this.noise.noise2D(time * 0.0006 + structure.noiseOffsetX, 0) * (TS * 0.4);
            const drift1Y = this.noise.noise2D(0, time * 0.0006 + structure.noiseOffsetY) * (TS * 0.4);
            const rot1 = this.noise.noise2D(time * 0.0002, tile.x * 0.01) * 0.1;

            ctx.save();
            ctx.translate(drift1X, drift1Y);
            ctx.rotate(rot1);

            const grad1 = ctx.createRadialGradient(0, 0, 0, 0, 0, baseRadius);
            grad1.addColorStop(0, `rgba(${this.FOG_COLOR.r}, ${this.FOG_COLOR.g}, ${this.FOG_COLOR.b}, ${densityAlpha * 0.6})`);
            grad1.addColorStop(1, `rgba(${this.FOG_COLOR.r}, ${this.FOG_COLOR.g}, ${this.FOG_COLOR.b}, 0)`);

            ctx.fillStyle = grad1;
            ctx.beginPath();
            ctx.arc(0, 0, baseRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // --- Layer 2: Mist (Fast, Light) ---
            // Scale 0.5, Speed 1.5x, Opposite direction
            const drift2X = this.noise.noise2D(time * 0.0018 + structure.noiseOffsetX + 100, 100) * (TS * 0.2) * -1;
            const drift2Y = this.noise.noise2D(100, time * 0.0018 + structure.noiseOffsetY + 100) * (TS * 0.2) * -1;
            // Higher frequency rotation
            const rot2 = this.noise.noise2D(time * 0.0008, tile.y * 0.02) * 0.2;

            ctx.save();
            ctx.translate(drift2X, drift2Y);
            ctx.rotate(rot2);

            // Smaller, more transparent mist patches
            const mistRadius = baseRadius * 0.7;
            const mistAlpha = densityAlpha * 0.3;

            const grad2 = ctx.createRadialGradient(0, 0, 0, 0, 0, mistRadius);
            grad2.addColorStop(0, `rgba(${this.FOG_COLOR.r + 20}, ${this.FOG_COLOR.g + 20}, ${this.FOG_COLOR.b + 20}, ${mistAlpha})`);
            grad2.addColorStop(1, `rgba(${this.FOG_COLOR.r}, ${this.FOG_COLOR.g}, ${this.FOG_COLOR.b}, 0)`);

            ctx.fillStyle = grad2;
            ctx.beginPath();
            ctx.arc(0, 0, mistRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            ctx.restore();
        }
    }

    private applyLightMasks(lights: { x: number, y: number, radius: number }[]): void {
        const ctx = this.ctx;

        ctx.save();
        // Cut out holes in the fog
        ctx.globalCompositeOperation = 'destination-out';

        for (let i = 0; i < lights.length; i++) {
            const light = lights[i];
            // Flicker effect: radius +/- 5%
            const flicker = 0.95 + Math.random() * 0.1;
            const r = light.radius * flicker;

            // Soft cutout using gradient
            const grad = ctx.createRadialGradient(light.x, light.y, 0, light.x, light.y, r);
            // Inner: completely transparent (removed fog)
            // Outer: fade to original fog
            grad.addColorStop(0, 'rgba(0, 0, 0, 1)');
            grad.addColorStop(0.5, 'rgba(0, 0, 0, 0.8)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(light.x, light.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }

    /**
     * Get the rendered canvas
     */
    public getCanvas(): HTMLCanvasElement {
        return this.canvas;
    }

    /**
     * Resize the render canvas
     */
    public resize(width: number, height: number): void {
        this.canvas.width = width;
        this.canvas.height = height;
    }
}
</file>

<file path="src/GameSession.ts">
import { GameState } from './scenes/GameState';
import { EntityManager } from './scenes/EntityManager';
import { WaveManager } from './WaveManager';
import { ProjectileSystem } from './systems/ProjectileSystem';
import { CollisionSystem } from './CollisionSystem';
import { MetricsSystem } from './MetricsSystem';
import { WeaponSystem } from './WeaponSystem';
import { EffectSystem } from './EffectSystem';
import { MapManager } from './Map';
import { IMapData } from './MapData';
import { CardSystem } from './CardSystem';
import { Rng } from './utils/Rng';
import { ForgeSystem } from './ForgeSystem';
import { InspectorSystem } from './InspectorSystem';
import { BestiarySystem } from './BestiarySystem';
import { NotificationSystem } from './systems/NotificationSystem';
import { AcidPuddleSystem } from './systems/AcidPuddleSystem';
import { SkeletonCommanderSystem } from './systems/SkeletonCommanderSystem';
import { Game } from './Game';
import { IGameScene } from './scenes/IGameScene';

/**
 * GameSession owns the simulation state and logic.
 * It is decoupled from the Scene's rendering and lifecycle as much as possible.
 */
export class GameSession {
    public gameState: GameState;
    public entityManager: EntityManager;
    public waveManager: WaveManager;
    public projectileSystem: ProjectileSystem;
    public collision: CollisionSystem;
    public metrics: MetricsSystem;
    public weaponSystem: WeaponSystem;
    public cardSys: CardSystem;
    public forge: ForgeSystem;
    public inspector: InspectorSystem;
    public bestiary: BestiarySystem;
    public notifications: NotificationSystem;
    public acidSystem: AcidPuddleSystem;
    public commanderSystem: SkeletonCommanderSystem;

    // Randomness State
    public readonly runSeed: number;
    public readonly rng: Rng;

    // References needed for logic
    private game: Game;
    private map: MapManager;
    private effects: EffectSystem;
    private scene: IGameScene; // Back-reference for compatibility (temporary/permanent?)

    constructor(game: Game, scene: IGameScene, map: MapManager, mapData: IMapData, effects: EffectSystem, startingCards: string[], forceSeed?: number) {
        this.game = game;
        this.scene = scene;
        this.map = map;
        this.effects = effects;

        // Initialize RNG
        // @ts-ignore - Allow temporary window override for testing
        const globalForce = (window as any).FORCE_SEED;
        this.runSeed = forceSeed ?? globalForce ?? Date.now();
        this.rng = new Rng(this.runSeed);
        console.log(`[GameSession] Initialized with Run Seed: ${this.runSeed}`);

        // Initialize State
        this.gameState = new GameState();

        // Initialize Systems
        this.metrics = new MetricsSystem();
        this.entityManager = new EntityManager(this.gameState, effects, this.metrics);
        this.projectileSystem = new ProjectileSystem();
        this.weaponSystem = new WeaponSystem();
        this.collision = new CollisionSystem(effects);

        this.waveManager = new WaveManager(scene, this.runSeed); // WaveManager needs IGameScene interface
        this.cardSys = new CardSystem(scene, startingCards);
        this.forge = new ForgeSystem(scene);
        this.inspector = new InspectorSystem(scene);
        this.bestiary = new BestiarySystem(scene);
        this.notifications = new NotificationSystem(effects, game);

        this.acidSystem = new AcidPuddleSystem(game.ctx); // Needs ctx for drawing? Or just update? AcidSystem draws.
        this.commanderSystem = new SkeletonCommanderSystem(game.ctx);
    }

    public update(dt: number) {
        // 1. Update Entities (Move enemies first)
        this.entityManager.updateEnemies(dt, this.map.flowField);
        this.acidSystem.update(dt, this.gameState.enemies);
        this.commanderSystem.update(dt, this.gameState.enemies);

        // 2. Invalidate Grid Check
        this.collision.invalidateGrid();

        // 3. Update Towers
        for (let i = 0; i < this.gameState.towers.length; i++) {
            const t = this.gameState.towers[i];
            t.update(dt, this.collision.getValidGrid(this.gameState.enemies), this.map.flowField);
            t.updateBuilding(this.effects, dt);
            // RendererFactory update moved to Scene? No, RendererFactory updates visual state on Tower. 
            // Ideally Tower update handles logic, RendererFactory handles visual.
            // For now, allow Tower to update its visual state properties here.
        }

        // 4. Weapon System
        this.weaponSystem.update(
            this.gameState.towers,
            this.gameState.enemies,
            this.projectileSystem,
            dt,
            this.effects
        );

        // 5. Projectiles
        this.projectileSystem.update(dt, this.effects);

        // 6. Collisions
        this.collision.update(this.projectileSystem.projectiles, this.gameState.enemies);

        // 7. Wave Manager
        this.waveManager.update(dt);
    }

    public destroy() {
        if (this.bestiary) this.bestiary.destroy();
        if (this.notifications) this.notifications.destroy();
        if (this.acidSystem) this.acidSystem.destroy();
        if (this.commanderSystem) this.commanderSystem.destroy();
    }
}
</file>

<file path="src/MetricsSystem.ts">
import { SaveManager } from './SaveManager';

/**
 * Metrics Collection System
 * Collects gameplay statistics for balancing
 */

export interface IGameMetrics {
    gamesPlayed: number;
    wavesReached: number[];         // Array of max waves reached per game
    averageWaveReached: number;
    towersBuilt: number;
    cardsUsed: Record<string, number>; // Count per card type
    moneySpent: number;
    moneyEarned: number;
    enemiesKilled: number;
    livesLost: number;
    gamesWon: number;
}

export class MetricsSystem {
    private metrics: IGameMetrics;
    private currentGameMetrics: {
        waveReached: number;
        towersBuilt: number;
        cardsUsed: Record<string, number>;
        moneySpent: number;
        moneyEarned: number;
        enemiesKilled: number;
        livesLost: number;
    };

    constructor() {
        // Try to load from localStorage
        const saved = localStorage.getItem('towerDefenseMetrics');
        if (saved) {
            this.metrics = JSON.parse(saved);
        } else {
            this.metrics = {
                gamesPlayed: 0,
                wavesReached: [],
                averageWaveReached: 0,
                towersBuilt: 0,
                cardsUsed: {},
                moneySpent: 0,
                moneyEarned: 0,
                enemiesKilled: 0,
                livesLost: 0,
                gamesWon: 0,
            };
        }

        this.currentGameMetrics = {
            waveReached: 0,
            towersBuilt: 0,
            cardsUsed: {},
            moneySpent: 0,
            moneyEarned: 0,
            enemiesKilled: 0,
            livesLost: 0,
        };
    }

    // Track actions
    public trackTowerBuilt() {
        this.currentGameMetrics.towersBuilt++;
    }

    public trackCardUsed(cardType: string) {
        if (!this.currentGameMetrics.cardsUsed[cardType]) {
            this.currentGameMetrics.cardsUsed[cardType] = 0;
        }
        this.currentGameMetrics.cardsUsed[cardType]++;
    }

    public trackMoneySpent(amount: number) {
        this.currentGameMetrics.moneySpent += amount;
    }

    public trackMoneyEarned(amount: number) {
        this.currentGameMetrics.moneyEarned += amount;
    }

    public trackEnemyKilled() {
        this.currentGameMetrics.enemiesKilled++;
    }

    public trackLifeLost() {
        this.currentGameMetrics.livesLost++;
    }

    public trackWaveReached(wave: number) {
        this.currentGameMetrics.waveReached = Math.max(this.currentGameMetrics.waveReached, wave);
    }

    // End game and save metrics
    public endGame(won: boolean) {
        this.metrics.gamesPlayed++;
        this.metrics.wavesReached.push(this.currentGameMetrics.waveReached);
        this.metrics.towersBuilt += this.currentGameMetrics.towersBuilt;
        this.metrics.moneySpent += this.currentGameMetrics.moneySpent;
        this.metrics.moneyEarned += this.currentGameMetrics.moneyEarned;
        this.metrics.enemiesKilled += this.currentGameMetrics.enemiesKilled;
        this.metrics.livesLost += this.currentGameMetrics.livesLost;

        // Merge card usage
        for (const [card, count] of Object.entries(this.currentGameMetrics.cardsUsed)) {
            if (!this.metrics.cardsUsed[card]) {
                this.metrics.cardsUsed[card] = 0;
            }
            this.metrics.cardsUsed[card] += count;
        }

        if (won) {
            this.metrics.gamesWon++;
        }

        // Calculate average wave reached
        const total = this.metrics.wavesReached.reduce((a, b) => a + b, 0);
        this.metrics.averageWaveReached = total / this.metrics.wavesReached.length;

        // Save to localStorage
        this.save();

        // Update Campaign Persistence
        SaveManager.updateProgress({
            money: this.currentGameMetrics.moneyEarned,
            kills: this.currentGameMetrics.enemiesKilled,
            waves: this.currentGameMetrics.waveReached,
            maxWave: this.currentGameMetrics.waveReached
        });

        // Log to console for debugging
        console.log('=== GAME METRICS ===');
        console.log(`Games Played: ${this.metrics.gamesPlayed}`);
        console.log(`Average Wave: ${this.metrics.averageWaveReached.toFixed(1)}`);
        console.log(`Win Rate: ${((this.metrics.gamesWon / this.metrics.gamesPlayed) * 100).toFixed(1)}%`);
        console.log('Card Usage:', this.metrics.cardsUsed);
    }

    public save() {
        localStorage.setItem('towerDefenseMetrics', JSON.stringify(this.metrics));
    }

    public getMetrics(): IGameMetrics {
        return { ...this.metrics };
    }

    public getCurrentSessionStats() {
        return {
            money: this.currentGameMetrics.moneyEarned,
            kills: this.currentGameMetrics.enemiesKilled,
            waves: this.currentGameMetrics.waveReached,
        };
    }

    public getCardUsagePercentages(): Record<string, number> {
        const total = Object.values(this.metrics.cardsUsed).reduce((a, b) => a + b, 0);
        const percentages: Record<string, number> = {};

        for (const [card, count] of Object.entries(this.metrics.cardsUsed)) {
            percentages[card] = (count / total) * 100;
        }

        return percentages;
    }

    public reset() {
        this.metrics = {
            gamesPlayed: 0,
            wavesReached: [],
            averageWaveReached: 0,
            towersBuilt: 0,
            cardsUsed: {},
            moneySpent: 0,
            moneyEarned: 0,
            enemiesKilled: 0,
            livesLost: 0,
            gamesWon: 0,
        };
        this.save();
    }
}
</file>

<file path="src/renderers/turrets/FireTurretRenderer.ts">
import { ITurretRenderer } from './TurretRenderer';
import { Tower } from '../../Tower';

/**
 * Fire Card Turret Renderer
 */
export class FireTurretRenderer implements ITurretRenderer {
    readonly cardId = 'fire';

    getTurretAsset(level: number): string {
        return `turret_fire_${level}`;
    }

    getModuleAsset(): string {
        return 'mod_fire';
    }

    getMuzzleOffset(): number {
        return 15; // Short barrel for Mortar/Fire
    }

    update(dt: number, tower: Tower): void {
        // Initialize visual state if needed
        if (!tower.visualState.magmaPhase) tower.visualState.magmaPhase = 0;

        // Animate magma pulse (sine wave phase)
        tower.visualState.magmaPhase += dt * 3; // Speed of pulse
    }

    drawEffects(ctx: CanvasRenderingContext2D, tower: Tower): void {
        // Draw Magma Glow in center
        const phase = tower.visualState.magmaPhase || 0;
        const glow = 0.5 + Math.sin(phase) * 0.3; // 0.2 to 0.8 opacity

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = '#ff5722'; // Deep Orange
        ctx.globalAlpha = glow;

        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();

        // Heat rising (simple particles if card level > 1)
        // Note: For full particle system we'd use EffectSystem, but small local effects can be drawn here
        ctx.restore();
    }
}
</file>

<file path="src/renderers/turrets/IceTurretRenderer.ts">
import { ITurretRenderer } from './TurretRenderer';
import { Tower } from '../../Tower';

/**
 * Ice Turret Renderer
 * Features:
 * - Orbiting ice shards with sparkle
 * - Frost aura (cold mist effect)
 * - Crystal pulse glow
 */
export class IceTurretRenderer implements ITurretRenderer {
    readonly cardId = 'ice';

    getTurretAsset(level: number): string {
        return `turret_ice_${level}`;
    }

    getModuleAsset(): string {
        return 'mod_ice';
    }

    getMuzzleOffset(): number {
        return 28;
    }

    update(dt: number, tower: Tower): void {
        // Shard orbit
        if (tower.visualState.shardAngle === undefined) {
            tower.visualState.shardAngle = 0;
        }
        tower.visualState.shardAngle += dt * 1.2;
        tower.visualState.shardAngle %= Math.PI * 2;

        // Frost pulse
        if (tower.visualState.frostPulse === undefined) {
            tower.visualState.frostPulse = 0;
        }
        tower.visualState.frostPulse += dt * 2;
        tower.visualState.frostPulse %= Math.PI * 2;

        // Sparkle timer
        if (tower.visualState.sparkleTime === undefined) {
            tower.visualState.sparkleTime = 0;
        }
        tower.visualState.sparkleTime += dt;
    }

    drawEffects(ctx: CanvasRenderingContext2D, tower: Tower): void {
        const level = Math.max(1, Math.max(...tower.cards.map(c => c.level)));

        // Frost aura (always visible, subtle)
        this.drawFrostAura(ctx, tower, level);

        // Orbiting shards (level 2+)
        if (level >= 2) {
            this.drawOrbitingShards(ctx, tower, level);
        }

        // Sparkles
        this.drawSparkles(ctx, tower);
    }

    private drawFrostAura(ctx: CanvasRenderingContext2D, tower: Tower, level: number): void {
        const pulse = tower.visualState.frostPulse || 0;
        const radius = 18 + level * 2 + Math.sin(pulse) * 2;
        const alpha = 0.15 + level * 0.05;

        const grad = ctx.createRadialGradient(0, 0, 5, 0, 0, radius);
        grad.addColorStop(0, `rgba(77,208,225,${alpha})`);
        grad.addColorStop(0.6, `rgba(128,222,234,${alpha * 0.5})`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawOrbitingShards(ctx: CanvasRenderingContext2D, tower: Tower, level: number): void {
        const angle = tower.visualState.shardAngle || 0;
        const shardCount = level; // 2 or 3 shards
        const radius = 22 + level * 2;

        for (let i = 0; i < shardCount; i++) {
            const shardAngle = angle + (i * Math.PI * 2 / shardCount);
            const x = Math.cos(shardAngle) * radius;
            const y = Math.sin(shardAngle) * radius * 0.6; // Squished orbit

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(shardAngle);

            // Shard glow
            ctx.fillStyle = 'rgba(77,208,225,0.3)';
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fill();

            // Shard body (diamond)
            const grad = ctx.createLinearGradient(0, -4, 0, 4);
            grad.addColorStop(0, '#e0f7fa');
            grad.addColorStop(0.5, '#4dd0e1');
            grad.addColorStop(1, '#00acc1');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(0, -4);
            ctx.lineTo(2.5, 0);
            ctx.lineTo(0, 4);
            ctx.lineTo(-2.5, 0);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }
    }

    private drawSparkles(ctx: CanvasRenderingContext2D, tower: Tower): void {
        const time = tower.visualState.sparkleTime || 0;
        const sparkleCount = 3;

        ctx.fillStyle = '#fff';

        for (let i = 0; i < sparkleCount; i++) {
            const t = ((time * 0.8 + i * 1.5) % 2) / 2;
            const angle = i * 2.1 + time * 0.3;
            const dist = 10 + t * 15;

            const x = Math.cos(angle) * dist;
            const y = Math.sin(angle) * dist;
            const alpha = (1 - t) * 0.8;
            const size = (1 - t) * 2;

            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
}
</file>

<file path="src/renderers/turrets/MinigunTurretRenderer.ts">
import { ITurretRenderer } from './TurretRenderer';
import { Tower } from '../../Tower';
import { Assets } from '../../Assets';

/**
 * Void Prism v4.0 ‚Äî Correct Top-Down Perspective
 * 
 * The crystal STANDS VERTICALLY on the pedestal.
 * In top-down view, we see the TOP of the crystal (looking down at it).
 * 
 * Visual: Glowing octagram/star shape with directional aiming indicator
 * Rotation: Crystal spins around its vertical axis (center stays fixed)
 */
export class MinigunTurretRenderer implements ITurretRenderer {
    readonly cardId = 'minigun';

    getTurretAsset(level: number): string {
        return `turret_minigun_${level}`;
    }

    getModuleAsset(): string {
        return 'mod_minigun';
    }

    getMuzzleOffset(): number {
        return 18;
    }

    update(dt: number, tower: Tower): void {
        // Pulse phase for glow effects
        if (tower.visualState.pulsePhase === undefined) {
            tower.visualState.pulsePhase = 0;
        }
        const pulseSpeed = 2 + (tower.spinupTime || 0) * 4;
        tower.visualState.pulsePhase += dt * pulseSpeed;
        tower.visualState.pulsePhase %= Math.PI * 2;

        // Inner rotation (slow ambient spin when idle)
        if (tower.visualState.innerSpin === undefined) {
            tower.visualState.innerSpin = 0;
        }
        tower.visualState.innerSpin += dt * 0.5;
        tower.visualState.innerSpin %= Math.PI * 2;
    }

    drawTurret(ctx: CanvasRenderingContext2D, tower: Tower): void {
        const level = Math.max(1, Math.max(...tower.cards.map(c => c.level)));
        const heat = tower.heatLevel || 0;
        const spinup = tower.spinupTime || 0;
        const isOverheated = tower.isOverheated;

        // === 1. PEDESTAL (Counter-rotate to stay static) ===
        ctx.save();
        ctx.rotate(-tower.angle);

        const pedestalImg = Assets.get(this.getTurretAsset(level));
        if (pedestalImg) {
            ctx.drawImage(pedestalImg, -24, -24);
        }

        // === 2. CRYSTAL (Top-down view, rotates with aim) ===
        // We're still in counter-rotated context, so rotate BY tower.angle
        // to get the crystal pointing at target
        ctx.rotate(tower.angle);

        this.drawCrystalTopDown(ctx, tower, level, heat, spinup, isOverheated);

        ctx.restore();
    }

    private drawCrystalTopDown(
        ctx: CanvasRenderingContext2D,
        tower: Tower,
        level: number,
        heat: number,
        spinup: number,
        isOverheated: boolean
    ): void {
        const baseRadius = 10 + level * 2; // 12-16px
        const pulse = tower.visualState.pulsePhase || 0;
        const innerSpin = tower.visualState.innerSpin || 0;

        const colors = this.getColors(heat, isOverheated);
        const glowIntensity = 0.2 + spinup * 0.25 + Math.sin(pulse) * 0.08;

        // === OUTER GLOW (aura around crystal) ===
        const glowRadius = baseRadius + 6 + spinup * 3;
        const glowGrad = ctx.createRadialGradient(0, 0, baseRadius * 0.5, 0, 0, glowRadius);
        glowGrad.addColorStop(0, colors.glow.replace('1)', `${glowIntensity * 0.7})`));
        glowGrad.addColorStop(0.6, colors.glow.replace('1)', `${glowIntensity * 0.2})`));
        glowGrad.addColorStop(1, 'rgba(0,0,0,0)');

        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
        ctx.fill();

        // === CRYSTAL BODY (Top view = octagonal star) ===
        // This represents looking DOWN at the top facet of the crystal
        ctx.save();
        ctx.rotate(innerSpin * 0.3); // Subtle ambient shimmer

        // Outer octagon (main crystal top)
        ctx.fillStyle = colors.main;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI / 4) - Math.PI / 8;
            const r = baseRadius;
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();

        // Inner facet (lighter center)
        ctx.fillStyle = colors.highlight;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI / 4);
            const r = baseRadius * 0.5;
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();

        // Edge highlights (facet reflections)
        ctx.strokeStyle = 'rgba(255,255,255,0.4)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 4; i++) {
            const angle = (i * Math.PI / 2) + innerSpin * 0.2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(angle) * baseRadius * 0.9, Math.sin(angle) * baseRadius * 0.9);
            ctx.stroke();
        }

        ctx.restore();

        // === INNER CORE (pulsing center) ===
        const corePulse = 0.6 + Math.sin(pulse) * 0.4;
        const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, baseRadius * 0.4);
        coreGrad.addColorStop(0, `rgba(255,255,255,${corePulse})`);
        coreGrad.addColorStop(0.5, colors.core);
        coreGrad.addColorStop(1, 'rgba(0,0,0,0)');

        ctx.fillStyle = coreGrad;
        ctx.beginPath();
        ctx.arc(0, 0, baseRadius * 0.4, 0, Math.PI * 2);
        ctx.fill();

        // === AIMING INDICATOR (points toward target) ===
        // This shows which direction the crystal is "facing"
        ctx.fillStyle = colors.highlight;
        ctx.beginPath();
        ctx.moveTo(baseRadius + 4, 0); // Tip
        ctx.lineTo(baseRadius - 2, -4); // Back left
        ctx.lineTo(baseRadius - 2, 4); // Back right
        ctx.closePath();
        ctx.fill();

        // Glow on indicator
        ctx.fillStyle = colors.glow.replace('1)', '0.6)');
        ctx.beginPath();
        ctx.arc(baseRadius + 2, 0, 3, 0, Math.PI * 2);
        ctx.fill();

        // === CRACKS (overheat only) ===
        if (isOverheated) {
            ctx.strokeStyle = 'rgba(30,30,30,0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-baseRadius * 0.3, -baseRadius * 0.5);
            ctx.lineTo(baseRadius * 0.1, 0);
            ctx.lineTo(-baseRadius * 0.2, baseRadius * 0.4);
            ctx.stroke();
        }

        // === ENERGY PARTICLES (when active) ===
        if (spinup > 0.3) {
            this.drawEnergyParticles(ctx, tower, spinup, baseRadius, colors);
        }
    }

    private drawEnergyParticles(
        ctx: CanvasRenderingContext2D,
        tower: Tower,
        spinup: number,
        radius: number,
        colors: ReturnType<typeof this.getColors>
    ): void {
        const phase = tower.visualState.pulsePhase || 0;
        const count = Math.floor(2 + spinup * 4);

        ctx.fillStyle = colors.glow.replace('1)', '0.7)');

        for (let i = 0; i < count; i++) {
            const t = ((phase * 0.8 + i * 1.2) % Math.PI) / Math.PI;
            const angle = (i * 1.7) + phase * 0.5;
            const dist = radius * 1.2 + t * 8;

            const x = Math.cos(angle) * dist;
            const y = Math.sin(angle) * dist;
            const size = (1 - t) * 2 + 0.5;

            ctx.globalAlpha = (1 - t) * 0.8;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    private getColors(heat: number, isOverheated: boolean) {
        if (isOverheated) {
            return {
                main: '#757575',
                highlight: '#9e9e9e',
                shadow: '#424242',
                core: 'rgba(158,158,158,0.6)',
                glow: 'rgba(120,120,120,1)'
            };
        }

        if (heat < 0.25) {
            return {
                main: '#5e35b1',
                highlight: '#9575cd',
                shadow: '#4527a0',
                core: 'rgba(179,136,255,0.8)',
                glow: 'rgba(103,58,183,1)'
            };
        } else if (heat < 0.6) {
            return {
                main: '#8e24aa',
                highlight: '#ce93d8',
                shadow: '#6a1b9a',
                core: 'rgba(234,128,252,0.85)',
                glow: 'rgba(156,39,176,1)'
            };
        } else {
            return {
                main: '#ab47bc',
                highlight: '#f3e5f5',
                shadow: '#7b1fa2',
                core: 'rgba(255,255,255,0.9)',
                glow: 'rgba(224,64,251,1)'
            };
        }
    }

    drawEffects(ctx: CanvasRenderingContext2D, tower: Tower): void {
        // All effects integrated in drawTurret
    }
}
</file>

<file path="src/renderers/turrets/SplitTurretRenderer.ts">
import { ITurretRenderer } from './TurretRenderer';
import type { Tower } from '../../Tower';

/**
 * Split/Volley Turret Renderer
 * Features:
 * - Rocket exhaust glow on tubes
 * - Targeting arcs showing spread
 * - Energy buildup effect
 */
export class SplitTurretRenderer implements ITurretRenderer {
    readonly cardId = 'multi';

    getTurretAsset(level: number): string {
        return `turret_split_${level}`;
    }

    getModuleAsset(): string {
        return 'mod_split';
    }

    getMuzzleOffset(): number {
        return 26;
    }

    update(dt: number, tower: Tower): void {
        // Exhaust pulse
        if (tower.visualState.exhaustPulse === undefined) {
            tower.visualState.exhaustPulse = 0;
        }
        tower.visualState.exhaustPulse += dt * 4;
        tower.visualState.exhaustPulse %= Math.PI * 2;

        // Arc animation
        if (tower.visualState.arcPhase === undefined) {
            tower.visualState.arcPhase = 0;
        }
        tower.visualState.arcPhase += dt * 2;
    }

    drawEffects(ctx: CanvasRenderingContext2D, tower: Tower): void {
        const level = Math.max(1, Math.max(...tower.cards.map(c => c.level)));

        // Targeting spread arcs
        this.drawTargetingArcs(ctx, tower, level);

        // Tube exhaust glow
        this.drawExhaustGlow(ctx, tower, level);
    }

    private drawTargetingArcs(ctx: CanvasRenderingContext2D, tower: Tower, level: number): void {
        const barrelCount = level + 1;
        const spreadAngle = 0.25;
        const startAngle = -spreadAngle * (barrelCount - 1) / 2;
        const arcPhase = tower.visualState.arcPhase || 0;

        ctx.strokeStyle = 'rgba(255,143,0,0.25)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);

        const pulseOffset = Math.sin(arcPhase) * 5;
        const arcLength = 40 + pulseOffset;

        for (let i = 0; i < barrelCount; i++) {
            const angle = startAngle + i * spreadAngle;

            ctx.save();
            ctx.rotate(angle);

            ctx.beginPath();
            ctx.moveTo(25, 0);
            ctx.lineTo(arcLength, 0);
            ctx.stroke();

            ctx.restore();
        }

        ctx.setLineDash([]);
    }

    private drawExhaustGlow(ctx: CanvasRenderingContext2D, tower: Tower, level: number): void {
        const barrelCount = level + 1;
        const spreadAngle = 0.25;
        const startAngle = -spreadAngle * (barrelCount - 1) / 2;
        const pulse = tower.visualState.exhaustPulse || 0;

        const glowIntensity = 0.15 + Math.sin(pulse) * 0.1;

        for (let i = 0; i < barrelCount; i++) {
            const angle = startAngle + i * spreadAngle;
            const tubeEnd = 23 + level * 3;

            ctx.save();
            ctx.rotate(angle);

            // Small exhaust glow at tube end
            const grad = ctx.createRadialGradient(tubeEnd, 0, 0, tubeEnd, 0, 6);
            grad.addColorStop(0, `rgba(255,171,0,${glowIntensity})`);
            grad.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(tubeEnd, 0, 6, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
    }
}
</file>

<file path="src/renderers/units/WraithUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import { CONFIG } from '../../Config';
import { Assets } from '../../Assets';
import type { Enemy } from '../../Enemy';

export class WraithUnitRenderer implements UnitRenderer {
    // üé® Palette (Final Polish)
    private static readonly C_ROBE_DARK = '#120524'; // Deepest Void
    private static readonly C_ROBE_MID = '#311b92';  // Indigo
    private static readonly C_ACCENT = '#d500f9';    // Bright Magenta
    private static readonly C_SOUL_CORE = '#e0f7fa'; // White core
    private static readonly C_SOUL_GLOW = '#00e5ff'; // Cyan Glow
    private static readonly C_SHIELD = '#ffd700';    // Gold
    private static readonly C_HORN = '#263238';      // Dark Horn
    private static readonly C_EMERALD_FIRE = '#00e676'; // Emerald Fire

    // BAKING SUPPORT
    public getBakeFacings(): ('SIDE' | 'UP' | 'DOWN')[] {
        return ['SIDE', 'UP', 'DOWN'];
    }

    public drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: 'SIDE' | 'UP' | 'DOWN') {
        const scale = 1.0;
        const bossScale = scale * 1.7;
        const time = t * 10;

        // No hover in bake, or baked in?
        // Let's bake in some hover movement
        const hover = Math.sin(time * 1.2) * (10 * scale);

        ctx.save();
        ctx.translate(0, hover - 18 * scale);

        if (facing === 'UP') {
            this.drawBack(ctx, bossScale, time, enemy);
        } else if (facing === 'DOWN') {
            this.drawFront(ctx, bossScale, time, enemy);
        } else {
            this.drawSide(ctx, bossScale, time, enemy);
        }
        ctx.restore();
    }

    drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void {
        this.drawFrameDirectional(ctx, enemy, t, 'SIDE');
    }

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.002;
        const cycle = time; // Use time as cycle for consistent lookup if needed, but Wraith doesn't have frame-based walk cycle
        // Wraith is floating, so maybe we just use a loop for frames?
        // Since it's floating, let's use a 32-frame loop based on time
        const t = (cycle % (Math.PI * 2)) / (Math.PI * 2);
        const frameIdx = Math.floor(t * 32) % 32;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        const facingLeft = Math.cos(rotation) < 0;
        const frameKey = `unit_${enemy.typeId}_${facing.toLowerCase()}_walk_${frameIdx}`;
        const sprite = Assets.get(frameKey);

        if (sprite) {
            ctx.save();
            const size = 128 * scale; // Big sprite
            if (facing === 'SIDE') {
                if (facingLeft) ctx.scale(-1, 1);
            }
            ctx.drawImage(sprite, -size / 2, -size / 2, size, size);
            ctx.restore();
            return;
        }

        // Fallback
        const bossScale = scale * 1.7;
        const hover = Math.sin(time * 1.2) * (10 * scale);

        ctx.save();
        ctx.translate(0, hover - 18 * scale);

        if (facing === 'SIDE') {
            if (facingLeft) ctx.scale(-1, 1);
            this.drawSide(ctx, bossScale, time, enemy);
        } else if (facing === 'UP') {
            this.drawBack(ctx, bossScale, time, enemy);
        } else {
            this.drawFront(ctx, bossScale, time, enemy);
        }

        ctx.restore();
    }

    // === FRONT VIEW ===
    private drawFront(ctx: CanvasRenderingContext2D, s: number, t: number, enemy: Enemy) {
        // 1. Robe Back Layer (Inside)
        this.drawRobeSilhouette(ctx, s, t, 0, 'BACK_LAYER');

        // 2. Void Body / Ribs
        ctx.fillStyle = WraithUnitRenderer.C_ROBE_MID;
        ctx.beginPath();
        ctx.moveTo(-10 * s, -14 * s);
        ctx.bezierCurveTo(-5 * s, 10 * s, 5 * s, 10 * s, 10 * s, -14 * s); // Ribs shape
        ctx.fill();

        // 3. Robe Front Layer (Edges)
        this.drawRobeSilhouette(ctx, s, t, 0, 'FRONT_EDGES');

        // 4. Void Heart (Pulsing)
        const pulse = 1.0 + Math.sin(t * 3) * 0.2;
        ctx.shadowBlur = 25 * pulse;
        ctx.shadowColor = WraithUnitRenderer.C_SOUL_GLOW;
        ctx.fillStyle = WraithUnitRenderer.C_SOUL_CORE;
        ctx.beginPath();
        ctx.arc(0, -4 * s, 2 * s * pulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // 5. Claws (Spread out)
        const handFloat = Math.sin(t * 2) * 2 * s;
        this.drawClaw(ctx, -16 * s, -4 * s + handFloat, s, 0.4);
        this.drawClaw(ctx, 16 * s, -4 * s - handFloat, s, -0.4);

        // 6. Head
        ctx.translate(0, -18 * s);
        this.drawHorns(ctx, s, 'FRONT', t);
        this.drawHoodFront(ctx, s, t);

        // 7. FX
        ctx.translate(0, 18 * s);
        this.drawEffects(ctx, s, t, enemy);
    }

    // === BACK VIEW ===
    private drawBack(ctx: CanvasRenderingContext2D, s: number, t: number, enemy: Enemy) {
        // 1. Full Robe
        this.drawRobeSilhouette(ctx, s, t, 0, 'FULL');

        // 2. Spiked Collar
        ctx.fillStyle = '#0f041e';
        ctx.beginPath();
        ctx.moveTo(-12 * s, -16 * s);
        ctx.lineTo(0, -22 * s); // Tall spike
        ctx.lineTo(12 * s, -16 * s);
        ctx.lineTo(0, -5 * s);
        ctx.fill();

        // 3. Claws (Visible at sides)
        const handFloat = Math.sin(t * 2) * 2 * s;
        this.drawClaw(ctx, -16 * s, -4 * s + handFloat, s, 0.4, true);
        this.drawClaw(ctx, 16 * s, -4 * s - handFloat, s, -0.4, true);

        // 4. Head
        ctx.translate(0, -18 * s);
        this.drawHorns(ctx, s, 'BACK', t);

        ctx.fillStyle = WraithUnitRenderer.C_ROBE_DARK;
        ctx.beginPath();
        // Hood from back
        ctx.ellipse(0, 0, 9 * s, 11 * s, 0, Math.PI, 0);
        ctx.lineTo(9 * s, 8 * s);
        ctx.bezierCurveTo(0, 12 * s, 0, 12 * s, -9 * s, 8 * s);
        ctx.fill();

        // Glowing Rune
        ctx.strokeStyle = WraithUnitRenderer.C_ACCENT;
        ctx.lineWidth = 1.8 * s;
        ctx.shadowBlur = 10;
        ctx.shadowColor = WraithUnitRenderer.C_ACCENT;
        ctx.beginPath();
        ctx.moveTo(0, -5 * s); ctx.lineTo(0, 5 * s);
        ctx.moveTo(-3 * s, 0); ctx.lineTo(3 * s, 0);
        ctx.arc(0, 0, 3 * s, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;

        ctx.translate(0, 18 * s);
        this.drawEffects(ctx, s, t, enemy);
    }

    // === SIDE VIEW (RE-DESIGNED) ===
    private drawSide(ctx: CanvasRenderingContext2D, s: number, t: number, enemy: Enemy) {
        // 1. Robe (Dynamic "S" Shape Wind)
        // Instead of a block, we draw a flowing cape behind and exposed void in front

        // Back Cape Flowing
        const wave = Math.sin(t * 2.5) * 3 * s;
        ctx.fillStyle = this.getRobeGradient(ctx, s);
        ctx.beginPath();
        ctx.moveTo(-2 * s, -18 * s); // Shoulder back
        // Flowing back line
        ctx.bezierCurveTo(-15 * s, -5 * s, -10 * s + wave, 20 * s, -20 * s + wave, 35 * s);
        // Bottom jagged
        ctx.lineTo(5 * s, 35 * s);
        // Front line (Cut away to reveal body)
        ctx.bezierCurveTo(0, 20 * s, 5 * s, -5 * s, 2 * s, -18 * s);
        ctx.fill();

        // 2. Void Body (Visible chest)
        ctx.fillStyle = WraithUnitRenderer.C_ROBE_MID;
        ctx.beginPath();
        ctx.ellipse(2 * s, -8 * s, 4 * s, 8 * s, -0.2, 0, Math.PI * 2);
        ctx.fill();

        // 3. Claw (Reaching Forward - MENACING)
        const armWave = Math.sin(t * 2) * 0.1;
        ctx.save();
        ctx.translate(10 * s, -6 * s); // Far forward
        ctx.rotate(-0.3 + armWave);
        this.drawClawSide(ctx, s); // Specialized side claw
        ctx.restore();

        // 4. Head (Properly Seated)
        ctx.translate(2 * s, -17 * s);

        // Horns (Large & Fiery)
        this.drawHorns(ctx, s, 'SIDE', t);

        // Hood Profile
        ctx.fillStyle = WraithUnitRenderer.C_ROBE_DARK;
        ctx.beginPath();
        // Neck connection
        ctx.moveTo(-4 * s, 8 * s);
        ctx.quadraticCurveTo(-8 * s, -5 * s, -2 * s, -10 * s); // Back
        ctx.lineTo(8 * s, -5 * s); // Peak
        ctx.lineTo(7 * s, 3 * s); // Front
        ctx.quadraticCurveTo(2 * s, 6 * s, -4 * s, 8 * s);
        ctx.fill();

        // Face Void (Deep)
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(3 * s, 0, 2 * s, 5 * s, 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Eye (Burning)
        ctx.translate(4 * s, -0.5 * s);
        ctx.fillStyle = WraithUnitRenderer.C_SOUL_GLOW;
        ctx.shadowBlur = 15;
        ctx.shadowColor = WraithUnitRenderer.C_SOUL_GLOW;
        ctx.beginPath();
        ctx.moveTo(-1.5 * s, 0); ctx.lineTo(1.5 * s, -0.8 * s); ctx.lineTo(0.5 * s, 1.5 * s);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.translate(-6 * s, 17 * s);
        this.drawEffects(ctx, s, t, enemy);
    }

    // --- DETAILED COMPONENTS ---

    private getRobeGradient(ctx: CanvasRenderingContext2D, s: number): CanvasGradient {
        const grad = ctx.createLinearGradient(0, -20 * s, 0, 40 * s);
        grad.addColorStop(0, WraithUnitRenderer.C_ROBE_DARK);
        grad.addColorStop(0.5, WraithUnitRenderer.C_ROBE_MID);
        grad.addColorStop(0.85, 'rgba(49, 27, 146, 0.3)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        return grad;
    }

    private drawRobeSilhouette(ctx: CanvasRenderingContext2D, s: number, t: number, tilt: number, mode: 'FULL' | 'BACK_LAYER' | 'FRONT_EDGES') {
        ctx.fillStyle = this.getRobeGradient(ctx, s);
        if (tilt !== 0) ctx.rotate(tilt);

        ctx.beginPath();
        const waveL = Math.sin(t * 2) * 2 * s;
        const waveR = Math.cos(t * 2.5) * 2 * s;

        // Base Cloth Shape
        const drawCloth = () => {
            ctx.moveTo(-12 * s, -18 * s);
            ctx.bezierCurveTo(-18 * s, -5 * s, -14 * s + waveL, 20 * s, -20 * s + waveL, 35 * s);
            ctx.lineTo(20 * s + waveR, 35 * s);
            ctx.bezierCurveTo(14 * s + waveR, 20 * s, 18 * s, -5 * s, 12 * s, -18 * s);
        };

        if (mode === 'FULL') {
            drawCloth();
            ctx.fill();
        } else if (mode === 'BACK_LAYER') {
            // Draw mostly the wide part
            drawCloth();
            ctx.fill();
        } else if (mode === 'FRONT_EDGES') {
            // Draw open cloak
            ctx.beginPath();
            ctx.moveTo(-12 * s, -18 * s);
            ctx.quadraticCurveTo(-14 * s, 0, -8 * s, 30 * s); // Left drapea
            ctx.lineTo(-5 * s, 30 * s);
            ctx.quadraticCurveTo(-8 * s, 0, -6 * s, -14 * s);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(12 * s, -18 * s);
            ctx.quadraticCurveTo(14 * s, 0, 8 * s, 30 * s); // Right drape
            ctx.lineTo(5 * s, 30 * s);
            ctx.quadraticCurveTo(8 * s, 0, 6 * s, -14 * s);
            ctx.fill();
        }

        if (tilt !== 0) ctx.rotate(-tilt);
    }

    private drawClaw(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, angle: number, back: boolean = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        // Palm
        ctx.fillStyle = back ? '#000' : '#2c1e3d';
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.5 * s, 3.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Fingers with Glowing Tips
        const fingers = [-1.5, -0.5, 0.5, 1.5];
        for (let f of fingers) {
            ctx.fillStyle = back ? '#1a1a1a' : '#4a148c';
            ctx.beginPath();
            ctx.moveTo(f * s, 1 * s);
            ctx.lineTo((f * 2.0) * s, 7 * s); // Longer fingers
            ctx.lineTo((f * 0.8) * s, 1 * s);
            ctx.fill();

            // Glow Tip
            if (!back) {
                ctx.fillStyle = WraithUnitRenderer.C_ACCENT;
                ctx.beginPath();
                ctx.arc((f * 2.0) * s, 7 * s, 0.4 * s, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        ctx.restore();
    }

    private drawClawSide(ctx: CanvasRenderingContext2D, s: number) {
        ctx.fillStyle = '#2c1e3d';
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.5 * s, 3.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Reaching Fingers
        const drawFinger = (ang: number, len: number) => {
            ctx.save();
            ctx.rotate(ang);
            ctx.fillStyle = '#4a148c';
            ctx.beginPath();
            ctx.moveTo(0, 2 * s);
            ctx.lineTo(0.5 * s, len * s);
            ctx.lineTo(1.5 * s, 2 * s);
            ctx.fill();
            // Tip
            ctx.fillStyle = WraithUnitRenderer.C_ACCENT;
            ctx.beginPath(); ctx.arc(0.5 * s, len * s, 0.4 * s, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        };

        drawFinger(0.2, 7);
        drawFinger(0, 8);
        drawFinger(-0.3, 6);
    }

    private drawHorns(ctx: CanvasRenderingContext2D, s: number, view: 'FRONT' | 'BACK' | 'SIDE', t: number) {
        // Emerald Fire Gradient
        const fireGrad = ctx.createLinearGradient(0, -10 * s, 0, -22 * s);
        fireGrad.addColorStop(0, WraithUnitRenderer.C_HORN);
        fireGrad.addColorStop(0.6, WraithUnitRenderer.C_HORN);
        fireGrad.addColorStop(1, WraithUnitRenderer.C_EMERALD_FIRE); // Tip glow

        ctx.fillStyle = fireGrad;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 0.5 * s;

        // Flicker effect
        const flicker = Math.sin(t * 15) * 0.5;

        if (view === 'SIDE') {
            // Massive Swept Horn
            ctx.beginPath();
            ctx.moveTo(0, -5 * s);
            // Big curve back
            ctx.bezierCurveTo(4 * s, -14 * s, -6 * s, -18 * s, -12 * s, -14 * s + flicker);
            ctx.lineTo(-10 * s, -11 * s);
            ctx.bezierCurveTo(-6 * s, -14 * s, 2 * s, -12 * s, 0, -5 * s);
            ctx.fill(); ctx.stroke();

            // Emerald Particles
            this.drawHornParticles(ctx, -12 * s, -14 * s, s, t);

        } else {
            // Symmetrical Horns
            const drawHorn = (mirror: number) => {
                ctx.beginPath();
                ctx.moveTo(mirror * 6 * s, -6 * s);
                // Curve Out -> In -> Out
                ctx.bezierCurveTo(mirror * 14 * s, -12 * s, mirror * 8 * s, -20 * s, mirror * 18 * s, -24 * s + flicker);
                // Inner edge
                ctx.lineTo(mirror * 15 * s, -22 * s);
                ctx.bezierCurveTo(mirror * 8 * s, -18 * s, mirror * 10 * s, -10 * s, mirror * 6 * s, -6 * s);
                ctx.fill(); ctx.stroke();

                this.drawHornParticles(ctx, mirror * 18 * s, -24 * s, s, t);
            };
            drawHorn(1);
            drawHorn(-1);
        }
    }

    private drawHornParticles(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, t: number) {
        ctx.fillStyle = WraithUnitRenderer.C_EMERALD_FIRE;
        for (let i = 0; i < 3; i++) {
            const px = x + Math.sin(t * 10 + i) * 2 * s;
            const py = y - Math.abs(Math.cos(t * 8 + i)) * 4 * s;
            const size = (Math.sin(t * 5 + i) + 1.5) * 0.5 * s;
            ctx.globalAlpha = 0.6;
            ctx.beginPath(); ctx.arc(px, py, size, 0, Math.PI * 2); ctx.fill();
        }
        ctx.globalAlpha = 1.0;
    }

    private drawHoodFront(ctx: CanvasRenderingContext2D, s: number, t: number) {
        // Inner Void
        ctx.fillStyle = '#100020';
        ctx.beginPath();
        ctx.arc(0, 0, 9 * s, 0, Math.PI * 2);
        ctx.fill();

        // Cowl
        ctx.fillStyle = WraithUnitRenderer.C_ROBE_DARK;
        ctx.beginPath();
        ctx.moveTo(0, -12 * s);
        ctx.bezierCurveTo(11 * s, -12 * s, 11 * s, 9 * s, 0, 9 * s);
        ctx.bezierCurveTo(-11 * s, 9 * s, -11 * s, -12 * s, 0, -12 * s);
        ctx.fill();

        // Face Hole shape
        ctx.fillStyle = '#000';
        ctx.beginPath();
        // Shield shape face
        ctx.moveTo(-5 * s, -2 * s);
        ctx.lineTo(5 * s, -2 * s);
        ctx.lineTo(0, 8 * s);
        ctx.lineTo(-5 * s, -2 * s);
        ctx.fill();
        // Upper dome
        ctx.beginPath(); ctx.arc(0, -2 * s, 5 * s, Math.PI, 0); ctx.fill();

        // Glowing Eyes
        const eyePulse = 0.8 + Math.sin(t * 8) * 0.2;
        this.drawEye(ctx, -2.5 * s, -1 * s, s * eyePulse, true);
        this.drawEye(ctx, 2.5 * s, -1 * s, s * eyePulse, false);
    }

    private drawEye(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, left: boolean) {
        const eyeImg = Assets.get('fx_boss_eye');
        if (eyeImg) {
            ctx.drawImage(eyeImg, x - 16 * s, y - 16 * s, 32 * s, 32 * s);
        } else {
            // Fallback
            ctx.translate(x, y);
            ctx.fillStyle = WraithUnitRenderer.C_SOUL_GLOW;
            ctx.beginPath();
            if (left) {
                ctx.moveTo(-1.2 * s, -0.6 * s); ctx.lineTo(1.2 * s, 0); ctx.lineTo(0, 1.2 * s);
            } else {
                ctx.moveTo(1.2 * s, -0.6 * s); ctx.lineTo(-1.2 * s, 0); ctx.lineTo(0, 1.2 * s);
            }
            ctx.fill();
            ctx.translate(-x, -y);
        }
    }

    private drawEffects(ctx: CanvasRenderingContext2D, s: number, t: number, enemy: Enemy) {
        const soulSpeed = enemy.isInvulnerable ? 8 : 2;
        this.drawGhostSouls(ctx, s, t * soulSpeed, enemy.isInvulnerable);
        if (enemy.isInvulnerable) {
            this.drawInvulnerabilityShield(ctx, s, t);
        }
    }

    private drawGhostSouls(ctx: CanvasRenderingContext2D, s: number, t: number, angry: boolean) {
        const count = 5;
        const soulImg = Assets.get('fx_soul');

        for (let i = 0; i < count; i++) {
            const angle = t + (i * (Math.PI * 2) / count);
            const rx = Math.cos(angle) * 18 * s;
            const ry = Math.sin(angle) * 6 * s;
            const z = Math.sin(angle);

            const scaleFactor = (1.5 + z * 0.5);
            const size = scaleFactor * s * 2.5;
            const alpha = 0.4 + z * 0.2;

            ctx.save();
            ctx.translate(rx, ry - 5 * s);

            if (soulImg && !angry) {
                // Use cached sprite for normal state
                ctx.globalAlpha = alpha;
                // Center sprite (16x16 original)
                // Scale it up
                const dSize = 16 * (size / 8); // approximate scaling
                ctx.drawImage(soulImg, -dSize, -dSize, dSize * 2, dSize * 2);
            } else {
                // Angry or fallback
                const color = angry ? '#ffeb3b' : WraithUnitRenderer.C_SOUL_GLOW;
                ctx.fillStyle = color;
                ctx.globalAlpha = alpha;
                ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.fill();
            }

            // Trail (Simple Line)
            const color = angry ? '#ffeb3b' : WraithUnitRenderer.C_SOUL_GLOW;
            ctx.strokeStyle = color;
            ctx.lineWidth = size * 0.8;
            ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(0, 0);
            const trailX = -Math.sin(angle) * -12 * s;
            const trailY = Math.cos(angle) * 3 * s;
            ctx.quadraticCurveTo(trailX * 0.5, trailY * 0.5, trailX, trailY);
            ctx.stroke();

            ctx.restore();
        }
        ctx.globalAlpha = 1.0;
    }

    private drawInvulnerabilityShield(ctx: CanvasRenderingContext2D, s: number, t: number) {
        const shieldImg = Assets.get('fx_boss_shield');
        if (shieldImg) {
            ctx.save();
            // Pulse scale
            const pulse = Math.sin(t * 10) * 0.05 + 1.0;
            ctx.scale(pulse, pulse);
            // Draw centered (128x128 original)
            const size = 64 * s;
            ctx.drawImage(shieldImg, -size, -size, size * 2, size * 2);
            ctx.restore();
        } else {
            // Fallback
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            const pulse = Math.sin(t * 10) * 0.1;
            ctx.fillStyle = 'rgba(255, 235, 59, 0.4)';
            ctx.beginPath(); ctx.arc(0, -5 * s, 24 * s, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2 * s;
            ctx.setLineDash([6 * s, 4 * s]);
            ctx.beginPath(); ctx.arc(0, -5 * s, 24 * s + pulse * 5, 0 + t, Math.PI * 2 + t); ctx.stroke();
            ctx.restore();
        }
    }
}
</file>

<file path="src/Scene.ts">
export interface Scene {
    // –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏ –Ω–∞ —ç—Ç—É —Å—Ü–µ–Ω—É
    onEnter(): void;

    // –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —É—Ö–æ–¥–µ —Å–æ —Å—Ü–µ–Ω—ã
    onExit(): void;

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–æ–≥–∏–∫–∏ (60 —Ä–∞–∑ –≤ —Å–µ–∫)
    update(dt: number): void;

    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
    draw(ctx: CanvasRenderingContext2D): void;
}
</file>

<file path="src/systems/AcidPuddleSystem.ts">
import { EventBus, Events } from '../EventBus';
import { Enemy } from '../Enemy';
import { getEnemyType } from '../Config';

export class AcidPuddle {
    x: number;
    y: number;
    radius: number;
    duration: number;
    healTimer: number;

    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
        this.radius = 25; // Smaller, concentrated puddle
        this.duration = 5.0; // 5 seconds
        this.healTimer = 0;
    }

    update(dt: number, enemies: Enemy[]) {
        this.duration -= dt;
        this.healTimer += dt;

        // Heal every 0.5 seconds
        if (this.healTimer >= 0.5) {
            this.healTimer = 0;
            const healAmountPercent = 0.03;

            enemies.forEach(e => {
                if (!e.isAlive() || e.finished) return;

                const dist = Math.hypot(e.x - this.x, e.y - this.y);
                if (dist < this.radius) {
                    // Heal 3% of MAX HP
                    const heal = e.maxHealth * healAmountPercent;
                    if (e.currentHealth < e.maxHealth) {
                        e.currentHealth = Math.min(e.maxHealth, e.currentHealth + heal);
                        // Visual feedback maybe?
                    }
                }
            });
        }
    }

    isExpired(): boolean {
        return this.duration <= 0;
    }
}

export class AcidPuddleSystem {
    private puddles: AcidPuddle[] = [];
    private ctx: CanvasRenderingContext2D;
    private unsubDied: () => void;

    constructor(ctx: CanvasRenderingContext2D) {
        this.ctx = ctx;
        // Listen for enemy deaths
        this.unsubDied = EventBus.getInstance().on(Events.ENEMY_DIED, this.onEnemyDied.bind(this));
    }

    public destroy() {
        if (this.unsubDied) this.unsubDied();
    }

    private onEnemyDied(data: { enemy: Enemy }) {
        const enemy = data.enemy;
        if (!enemy) return;

        // Try lookup with Upper Case (Config often uses upper keys but ID property might be lower)
        const typeKey = enemy.typeId.toUpperCase();
        let config = getEnemyType(typeKey);

        // Fallback for strict ID match if upper fails
        if (!config) config = getEnemyType(enemy.typeId);

        if (config && config.archetype === 'SPIDER') {
            this.spawnPuddle(enemy.x, enemy.y);
        }
    }

    public spawnPuddle(x: number, y: number) {
        this.puddles.push(new AcidPuddle(x, y));
    }

    public update(dt: number, enemies: Enemy[]) {
        for (const puddle of this.puddles) {
            puddle.update(dt, enemies);
        }
        // Remove expired
        this.puddles = this.puddles.filter(p => !p.isExpired());
    }

    public draw() {
        if (this.puddles.length === 0) return;

        this.ctx.save();

        // Toxic Sludge Colors
        const LIQUID_COLOR = '#33691e';      // Dark swampy base
        const LIQUID_MID = '#64dd17';        // Poison green mid
        const LIQUID_HIGHLIGHT = '#ccff90';  // Pale toxic top

        for (const p of this.puddles) {
            const time = Date.now() * 0.001;
            const remaining = p.duration;

            // Fade out
            let globalAlpha = 1.0;
            if (remaining < 1.0) globalAlpha = remaining;
            this.ctx.globalAlpha = globalAlpha * 0.85;

            // Generate deterministic shape based on position (seed)
            // We want it to look "splattered", not round.
            // Technique: Draw 3-5 overlapping "blobs" with different distortions

            const seed = p.x + p.y; // Static seed for this puddle
            const numBlobs = 3 + (Math.floor(seed) % 3); // 3 to 5 blobs

            this.ctx.translate(p.x, p.y);

            // Draw Blobs
            for (let i = 0; i < numBlobs; i++) {
                const angle = (i / numBlobs) * Math.PI * 2 + seed;
                const dist = (seed % 10) + 5; // Offset from center
                const bx = Math.cos(angle) * dist;
                const by = Math.sin(angle) * dist;

                // Blob Radius
                const br = p.radius * (0.6 + Math.sin(seed * i) * 0.2);

                // Draw distorted blob
                this.ctx.fillStyle = (i % 2 === 0) ? LIQUID_COLOR : LIQUID_MID;
                this.ctx.beginPath();

                const segments = 12;
                for (let j = 0; j <= segments; j++) {
                    const theta = (j / segments) * Math.PI * 2;
                    // High frequency noise for "jagged liquid" edge
                    const noise = Math.sin(theta * 6 + time * 2) * 0.1;
                    const staticNoise = Math.cos(theta * 4 + seed) * 0.2;

                    const r = br * (1 + noise + staticNoise);
                    const px = bx + Math.cos(theta) * r;
                    const py = by + Math.sin(theta) * r;

                    if (j === 0) this.ctx.moveTo(px, py);
                    else this.ctx.lineTo(px, py);
                }
                this.ctx.fill();
            }

            // Bubbles (Popping)
            // Draw bubbles ON TOP
            const numBubbles = 2 + (Math.floor(time * 2) % 3);
            this.ctx.fillStyle = LIQUID_HIGHLIGHT;
            for (let k = 0; k < numBubbles; k++) {
                const bAngle = (time + k) * 2;
                const bDist = (Math.sin(time * 3 + k) + 1) * p.radius * 0.4;
                const bx = Math.cos(bAngle) * bDist;
                const by = Math.sin(bAngle) * bDist;
                const bSize = 2 + Math.sin(time * 10 + k) * 1.5;
                if (bSize > 0.5) {
                    this.ctx.beginPath();
                    this.ctx.arc(bx, by, bSize, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            this.ctx.translate(-p.x, -p.y);
        }
        this.ctx.restore();
    }
}
</file>

<file path="src/systems/SkeletonCommanderSystem.ts">
import { EventBus, Events } from '../EventBus';
import { Enemy } from '../Enemy';
import { getEnemyType } from '../Config';

export class SkeletonCommanderSystem {
    private ctx: CanvasRenderingContext2D;
    private listenersSetup = false;
    private unsubDied: () => void = () => { };

    // Visual Effects List
    private buffEffects: Array<{
        startX: number, startY: number,
        target: Enemy, // Reference to living target
        currX: number, currY: number,
        life: number,
        maxLife: number
    }> = [];

    private recentDeaths: Array<{ x: number, y: number, typeId: string }> = [];

    constructor(ctx: CanvasRenderingContext2D) {
        this.ctx = ctx;
        if (!this.listenersSetup) {
            this.unsubDied = EventBus.getInstance().on(Events.ENEMY_DIED, this.onEnemyDied.bind(this));
            this.listenersSetup = true;
        }
    }

    public destroy() {
        this.unsubDied();
        this.listenersSetup = false;
    }

    private onEnemyDied(data: { enemy: Enemy }) {
        const deadEnemy = data.enemy;
        if (!deadEnemy) return;
        this.recentDeaths.push({ x: deadEnemy.x, y: deadEnemy.y, typeId: deadEnemy.typeId });
    }

    public update(dt: number, enemies: Enemy[]) {
        // Process recent deaths
        if (this.recentDeaths.length > 0) {

            // Find Active Commanders
            const commanders = enemies.filter(e => {
                if (!e.isAlive() || e.finished) return false;
                const conf = getEnemyType(e.typeId.toUpperCase()) || getEnemyType(e.typeId);
                return conf && conf.archetype === 'SKELETON_COMMANDER';
            });

            if (commanders.length > 0) {
                for (const death of this.recentDeaths) {
                    const deadConf = getEnemyType(death.typeId.toUpperCase()) || getEnemyType(death.typeId);

                    // Allow Buff from SKELETON or COMMANDER chains
                    const isSkeleton = deadConf && (deadConf.archetype === 'SKELETON' || deadConf.archetype === 'SKELETON_COMMANDER');

                    if (isSkeleton) {
                        // Find CLOSEST Commander within range
                        let bestCmd: Enemy | null = null;
                        let minDist = 192; // Max range (3 tiles)

                        for (const cmd of commanders) {
                            const dist = Math.hypot(cmd.x - death.x, cmd.y - death.y);
                            if (dist < minDist) {
                                minDist = dist;
                                bestCmd = cmd;
                            }
                        }

                        if (bestCmd) {
                            this.spawnSoulEffect(bestCmd, death.x, death.y);
                        }
                    }
                }
            }
            this.recentDeaths = []; // Clear queue
        }

        // Update Effects
        this.buffEffects.forEach(fx => {
            fx.life -= dt;

            // Update target pos
            const tx = fx.target.x;
            const ty = fx.target.y;

            // Move towards target
            const t = 1.0 - (fx.life / fx.maxLife); // 0 to 1
            // Ease out cubic
            const ease = 1 - Math.pow(1 - t, 3);

            fx.currX = fx.startX + (tx - fx.startX) * ease;
            fx.currY = fx.startY + (ty - fx.startY) * ease;

            // If extremely close, trigger impact?
            // We do impact logic in update OR draw. 
            // Logic: Healing happens on impact? Or instantly?
            // User asked: "Soul flies to commander". implies delayed effect.
            // But for gameplay responsiveness, instant heal is safer. 
            // However, let's make heal happen when particle arrives for "correctness".
        });

        // Trigger Heal on arrival (approximate check)
        // Actually, let's keep heal instant for now? No, user wants polish.
        // Let's check for arrival.
        for (let i = this.buffEffects.length - 1; i >= 0; i--) {
            const fx = this.buffEffects[i];
            const dist = Math.hypot(fx.currX - fx.target.x, fx.currY - fx.target.y);
            if (dist < 10 && fx.life > 0) {
                // Arrived!
                this.buffCommander(fx.target);
                fx.life = 0; // End effect
            }
        }

        this.buffEffects = this.buffEffects.filter(fx => fx.life > 0 && fx.target.isAlive() && !fx.target.finished);
    }

    private spawnSoulEffect(target: Enemy, startX: number, startY: number) {
        this.buffEffects.push({
            startX: startX, startY: startY,
            target: target,
            currX: startX, currY: startY,
            life: 0.6, // Faster flight
            maxLife: 0.6
        });
    }

    private buffCommander(cmd: Enemy) {
        // Heal
        const heal = cmd.maxHealth * 0.05; // 5%
        if (cmd.currentHealth < cmd.maxHealth) {
            cmd.currentHealth = Math.min(cmd.maxHealth, cmd.currentHealth + heal);
        }
        // Maybe spawn a "Heal Flash" effect here?
        // Rely on draw() to show impact flash.
    }

    public draw() {
        if (this.buffEffects.length === 0) return;

        this.ctx.save();

        for (const fx of this.buffEffects) {
            // "Soul" Particle flying to Commander
            // Smaller size requested
            this.ctx.fillStyle = '#ffd700'; // Gold Soul
            this.ctx.shadowBlur = 5;
            this.ctx.shadowColor = '#ffd700';

            this.ctx.beginPath();
            this.ctx.arc(fx.currX, fx.currY, 2.5, 0, Math.PI * 2); // Smaller (was 4)
            this.ctx.fill();

            // Trail
            this.ctx.shadowBlur = 0;
            this.ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            this.ctx.moveTo(fx.startX, fx.startY);
            this.ctx.lineTo(fx.currX, fx.currY);
            this.ctx.stroke();

            // Flash on commander (Impact visual)
            // If very close to end of life (arrival)
            if (fx.life < 0.1) {
                this.ctx.globalAlpha = 0.6;
                this.ctx.fillStyle = '#fff';
                this.ctx.beginPath();
                this.ctx.arc(fx.target.x, fx.target.y, 12, 0, Math.PI * 2); // Smaller flash
                this.ctx.fill();
            }
        }
        this.ctx.restore();
    }
}
</file>

<file path="src/systems/TargetingSystem.ts">
import { Tower } from '../Tower';
import { Enemy } from '../Enemy';
import { SpatialGrid } from '../SpatialGrid';
import { FlowField } from '../FlowField';
import { CONFIG } from '../Config';

/**
 * Optimized Targeting System
 * - Zero Allocation (uses static buffer)
 * - O(N) Single Pass Loop
 * - Supports Taunt (Threat Priority)
 * - Implements Modes: FIRST, LAST, CLOSEST, STRONGEST
 * - Sub-tile precision for smoother tracking
 */
export class TargetingSystem {
    // Shared buffer to avoid Garbage Collection
    private static buffer: Enemy[] = [];

    // Constants for Hysteresis (Sticky Targeting)
    // Prevents rapid switching when a new target is marginally better
    private static readonly HYSTERESIS_FACTOR = 1.15; // 15% bias
    private static readonly CELL_SIZE = CONFIG.TILE_SIZE;

    /**
     * Finds the best target for a tower based on its mode and range.
     */
    public static findTarget(tower: Tower, grid: SpatialGrid<Enemy>, flowField: FlowField): Enemy | null {
        const tx = tower.x;
        const ty = tower.y;
        const range = tower.getRange();
        const rangeSq = range * range;

        // 1. Zero-Alloc Query
        grid.queryInRadius(tx, ty, range, this.buffer);

        if (this.buffer.length === 0) return null;

        const currentTarget = tower.target;
        const mode = tower.targetingMode;

        // State for Single-Pass Selection
        let bestTarget: Enemy | null = null;
        let bestScore = -Infinity; // We normalize all scores to "higher is better"
        let bestPriority = -1;

        // 2. Single Pass Loop (O(N))
        for (let i = 0; i < this.buffer.length; i++) {
            const e = this.buffer[i];

            // Basic Validity Checks
            if (!e.isAlive()) continue;

            const dx = e.x - tx;
            const dy = e.y - ty;
            const distSq = dx * dx + dy * dy;

            if (distSq > rangeSq) continue;

            // --- PRIORITY LOGIC (Taunt) ---
            // If this enemy has lower priority than the current best, skip it
            if (e.threatPriority < bestPriority) continue;

            // If we find an enemy with HIGHER priority, reset the best score
            if (e.threatPriority > bestPriority) {
                bestPriority = e.threatPriority;
                bestScore = -Infinity; // Reset score because priority overrides it
                bestTarget = null;
            }

            // --- SCORING LOGIC ---
            // Normalize scores so that "Higher = Better"
            let score = 0;
            const isCurrent = (e === currentTarget);

            switch (mode) {
                case 'closest':
                    // Lower distance is better -> Invert: -distSq
                    score = -distSq;
                    break;

                case 'strongest':
                    // Higher health is better
                    score = e.currentHealth;
                    break;

                case 'first':
                    // Lower distance to base is better -> Invert: -dist
                    // Uses sub-tile precision for smoothness
                    score = -this.getPreciseFlowDistance(e, flowField);
                    break;

                case 'last':
                    // Higher distance to base is better
                    score = this.getPreciseFlowDistance(e, flowField);
                    break;
            }

            // --- HYSTERESIS BIAS ---
            // Apply bias to the current target to prevent "flickering"
            if (isCurrent && bestTarget !== null) {
                // If score is negative (distance based), division reduces magnitude (makes it "larger" / closer to 0)
                // If score is positive (health based), multiplication increases magnitude
                if (score < 0) score /= this.HYSTERESIS_FACTOR;
                else score *= this.HYSTERESIS_FACTOR;
            }

            // Update Champion
            if (score > bestScore) {
                bestScore = score;
                bestTarget = e;
            }
        }

        return bestTarget;
    }

    /**
     * Calculates precise distance to base using FlowField + Sub-tile position
     * Fixes the "stuttering" issue in First/Last modes.
     */
    private static getPreciseFlowDistance(e: Enemy, flowField: FlowField): number {
        const cellSize = this.CELL_SIZE;
        const col = (e.x / cellSize) | 0;
        const row = (e.y / cellSize) | 0;

        // 1. Grid Distance (Integer)
        let gridDist = 99999;

        // Safety Check & Grid Lookup
        if (row >= 0 && row < flowField.rows && col >= 0 && col < flowField.cols) {
            // Flattened 1D Access
            gridDist = flowField.distances[row * flowField.cols + col];
        }

        // 2. Sub-tile Precision (Float)
        if (gridDist !== -1 && gridDist !== 99999) { // -1 is unreachable in new FlowField
            // Use helper to get vector (handles array access transparently)
            // We reuse a static small buffer for vector retrieval to avoid allocation?
            // Actually getVector writes to an 'out' object. Let's create a temp static one.
            if (!this.tempVec) this.tempVec = { x: 0, y: 0 };

            // We need RAW vector from grid, not steering vector?
            // getPreciseFlowDistance logic relies on flow direction.
            // FlowField.getVector returns STEERING vector (centered).
            // We probably want the raw grid vector for distance calculation.

            const idx = row * flowField.cols + col;
            const vx = flowField.vectors[idx * 2];
            const vy = flowField.vectors[idx * 2 + 1];

            if (vx !== 0 || vy !== 0) {
                const cellCenterX = col * cellSize + cellSize / 2;
                const cellCenterY = row * cellSize + cellSize / 2;

                const dx = e.x - cellCenterX;
                const dy = e.y - cellCenterY;

                // Project position onto flow vector
                const progress = (dx * vx + dy * vy);

                // Refined Distance
                return (gridDist * cellSize) - progress;
            }
        }

        return (gridDist * cellSize);
    }

    private static tempVec: { x: number, y: number } | null = null;
}
</file>

<file path="src/UIUtils.ts">
import { VISUALS } from './VisualConfig';

export interface IButtonOptions {
    background?: string;
    color?: string;
    fontSize?: string;
    padding?: string;
    border?: string;
    borderRadius?: string;
    width?: string;
    zIndex?: string;
    fontFamily?: string;
    cursor?: string;
    position?: string;
    top?: string;
    right?: string;
    bottom?: string;
    left?: string;
    title?: string;
    pointerEvents?: string;
    fontWeight?: string;
    marginTop?: string;
    id?: string;
    height?: string;
    boxShadow?: string;
    display?: string;
    alignItems?: string;
    justifyContent?: string;
    marginLeft?: string;
    flex?: string;
    flexShrink?: string;
    flexGrow?: string;
}

export interface IContainerOptions {
    position?: string;
    top?: string;
    left?: string;
    bottom?: string;
    right?: string;
    width?: string;
    height?: string;
    display?: string;
    flexDirection?: string;
    alignItems?: string;
    justifyContent?: string;
    gap?: string;
    background?: string;
    color?: string;
    padding?: string;
    border?: string;
    borderRadius?: string;
    zIndex?: string;
    pointerEvents?: string;
    maxWidth?: string;
    maxHeight?: string;
    overflowY?: string;
    overflowX?: string;
    transform?: string;
    flexGrow?: string;
    flexShrink?: string;
    marginBottom?: string;
}

export class UIUtils {
    /**
     * Creates a styled button and appends it to the parent.
     */
    public static createButton(
        parent: HTMLElement,
        text: string,
        onClick: (e: MouseEvent) => void,
        options: IButtonOptions = {}
    ): HTMLButtonElement {
        const btn = document.createElement('button');
        btn.innerHTML = text;

        // UPDATED: Use design tokens from VISUALS.UI
        const defaults: Partial<CSSStyleDeclaration> = {
            padding: `${VISUALS.UI.SPACING.sm}px ${VISUALS.UI.SPACING.lg}px`,
            fontSize: VISUALS.UI.FONTS.size.lg,
            cursor: 'pointer',
            background: VISUALS.UI.COLORS.neutral.medium,
            color: VISUALS.UI.COLORS.text.primary,
            border: `${VISUALS.UI.BORDERS.width.normal} solid ${VISUALS.UI.COLORS.neutral.light}`,
            borderRadius: VISUALS.UI.BORDERS.radius.md,
            fontFamily: VISUALS.UI.FONTS.family.primary,
            pointerEvents: 'auto',
            transition: VISUALS.UI.TRANSITIONS.presets.fast
        };

        // Merge options
        Object.assign(btn.style, defaults);

        // Apply overrides
        if (options.background) btn.style.background = options.background;
        if (options.color) btn.style.color = options.color;
        if (options.fontSize) btn.style.fontSize = options.fontSize;
        if (options.padding) btn.style.padding = options.padding;
        if (options.border) btn.style.border = options.border;
        if (options.borderRadius) btn.style.borderRadius = options.borderRadius;
        if (options.width) btn.style.width = options.width;
        if (options.zIndex) btn.style.zIndex = options.zIndex;
        if (options.fontFamily) btn.style.fontFamily = options.fontFamily;
        if (options.cursor) btn.style.cursor = options.cursor;
        if (options.position) btn.style.position = options.position;
        if (options.top) btn.style.top = options.top;
        if (options.right) btn.style.right = options.right;
        if (options.bottom) btn.style.bottom = options.bottom;
        if (options.left) btn.style.left = options.left;
        if (options.title) btn.title = options.title;
        if (options.pointerEvents) btn.style.pointerEvents = options.pointerEvents;
        if (options.fontWeight) btn.style.fontWeight = options.fontWeight;
        if (options.marginTop) btn.style.marginTop = options.marginTop;
        if (options.id) btn.id = options.id;
        if (options.height) btn.style.height = options.height;
        if (options.boxShadow) btn.style.boxShadow = options.boxShadow;
        if (options.display) btn.style.display = options.display;
        if (options.alignItems) btn.style.alignItems = options.alignItems;
        if (options.justifyContent) btn.style.justifyContent = options.justifyContent;
        if (options.marginLeft) btn.style.marginLeft = options.marginLeft;
        if (options.flex) btn.style.flex = options.flex;
        if (options.flexShrink) btn.style.flexShrink = options.flexShrink;
        if (options.flexGrow) btn.style.flexGrow = options.flexGrow;

        btn.onclick = onClick;

        // Simple hover effect
        const originalBg = btn.style.background;
        btn.onmouseover = () => {
            btn.style.filter = 'brightness(1.2)';
        };
        btn.onmouseout = () => {
            btn.style.filter = 'none';
        };

        parent.appendChild(btn);
        return btn;
    }

    /**
     * Creates a container (div) with standard styling options.
     */
    public static createContainer(options: IContainerOptions = {}): HTMLElement {
        const div = document.createElement('div');

        // Apply options
        if (options.position) div.style.position = options.position;
        if (options.top) div.style.top = options.top;
        if (options.left) div.style.left = options.left;
        if (options.bottom) div.style.bottom = options.bottom;
        if (options.right) div.style.right = options.right;
        if (options.width) div.style.width = options.width;
        if (options.height) div.style.height = options.height;
        if (options.display) div.style.display = options.display;
        if (options.flexDirection) div.style.flexDirection = options.flexDirection;
        if (options.alignItems) div.style.alignItems = options.alignItems;
        if (options.justifyContent) div.style.justifyContent = options.justifyContent;
        if (options.gap) div.style.gap = options.gap;
        if (options.background) div.style.background = options.background;
        if (options.color) div.style.color = options.color;
        if (options.padding) div.style.padding = options.padding;
        if (options.border) div.style.border = options.border;
        if (options.borderRadius) div.style.borderRadius = options.borderRadius;
        if (options.zIndex) div.style.zIndex = options.zIndex;
        if (options.pointerEvents) div.style.pointerEvents = options.pointerEvents;
        if (options.maxWidth) div.style.maxWidth = options.maxWidth;
        if (options.maxHeight) div.style.maxHeight = options.maxHeight;
        if (options.overflowY) div.style.overflowY = options.overflowY;
        if (options.overflowX) div.style.overflowX = options.overflowX;
        if (options.transform) div.style.transform = options.transform;
        if (options.flexGrow) div.style.flexGrow = options.flexGrow;
        if (options.flexShrink) div.style.flexShrink = options.flexShrink;
        if (options.marginBottom) div.style.marginBottom = options.marginBottom;

        return div;
    }

    /**
     * Creates a full-screen overlay for menus/modals.
     */
    public static createOverlay(id?: string): HTMLElement {
        const overlay = document.createElement('div');
        if (id) overlay.id = id;
        Object.assign(overlay.style, {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: VISUALS.UI.COLORS.overlay,
            zIndex: '2000',
            display: 'none',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            color: VISUALS.UI.COLORS.text.primary,
            fontFamily: VISUALS.UI.FONTS.family.primary
        });
        document.body.appendChild(overlay);
        return overlay;
    }

    /**
     * Animates an element with a flash effect.
     */
    public static flashElement(el: HTMLElement, color: string, durationMs: number = 200) {
        const originalColor = el.style.color;
        const originalTransform = el.style.transform;

        // UPDATED: Use design token easing curve
        const easing = VISUALS.UI.TRANSITIONS.easing.standard;
        el.style.transition = `color ${durationMs / 2}ms ${easing}, transform ${durationMs / 2}ms ${easing}`;
        el.style.color = color;
        el.style.transform = 'scale(1.3)';

        setTimeout(() => {
            el.style.color = originalColor;
            el.style.transform = originalTransform || 'scale(1)';
        }, durationMs);
    }
}
</file>

<file path="src/utils/AssetCache.ts">
export class AssetCache {
    private static cache: Map<string, HTMLCanvasElement> = new Map();

    /**
     * –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –ø–æ–ª—É—á–µ–Ω–∏—è/—Å–æ–∑–¥–∞–Ω–∏—è –∞—Å—Å–µ—Ç–∞.
     * @param key –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–ª—é—á (–Ω–∞–ø—Ä. 'enemy_orc_walk_0')
     * @param factory –§—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –Ω–∞—Ä–∏—Å—É–µ—Ç –∞—Å—Å–µ—Ç, –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
     */
    public static get(key: string, factory: (ctx: CanvasRenderingContext2D, w: number, h: number) => void, width: number, height: number): HTMLCanvasElement {
        if (!this.cache.has(key)) {
            // Simple Cache Cap (Phase 5.C Lite)
            // If cache grows too large, clear it completely to prevent memory leaks
            if (this.cache.size > 4096) {
                console.warn(`[AssetCache] Cache limit reached (${this.cache.size}). Clearing!`);
                this.cache.clear();
            }

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            if (!ctx) return canvas; // Should not happen

            // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –æ—Ç–∫–ª—é—á–∞–µ–º —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ, –µ—Å–ª–∏ –Ω—É–∂–µ–Ω –ø–∏–∫—Å–µ–ª—å-–∞—Ä—Ç
            // ctx.imageSmoothingEnabled = false; 

            factory(ctx, width, height);
            this.cache.set(key, canvas);
            // console.log(`[AssetCache] Baked: ${key}`);
        }
        return this.cache.get(key)!;
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞–ª–∏—á–∏–µ –∞—Å—Å–µ—Ç–∞ –≤ –∫—ç—à–µ –±–µ–∑ —Å–æ–∑–¥–∞–Ω–∏—è.
     */
    public static has(key: string): boolean {
        return this.cache.has(key);
    }

    /**
     * –ü–æ–ª—É—á–∏—Ç—å –∞—Å—Å–µ—Ç –∏–∑ –∫—ç—à–∞ –±–µ–∑ —Å–æ–∑–¥–∞–Ω–∏—è (–≤–µ—Ä–Ω–µ—Ç undefined –µ—Å–ª–∏ –Ω–µ—Ç).
     */
    public static peek(key: string): HTMLCanvasElement | undefined {
        return this.cache.get(key);
    }

    /**
     * –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã—Ö —à–∞—Ä–æ–≤ (Particles/Projectiles)
     */
    public static getGlow(color: string, size: number): HTMLCanvasElement {
        const key = `glow_${color}_${size}`;
        return this.get(key, (ctx, w, h) => {
            const center = w / 2;
            const gradient = ctx.createRadialGradient(center, center, 0, center, center, center);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, 'rgba(0,0,0,0)'); // –ü–æ–ª–Ω–∞—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –Ω–∞ –∫—Ä–∞—è—Ö

            // Fixed: removed confusing 'lighter' op that was immediately overwritten
            // The 'lighter' effect should be applied when drawing this sprite to the game canvas, not here.

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, w, h);
        }, size, size);
    }

    public static clear() {
        this.cache.clear();
    }
}
</file>

<file path="src/utils/PerformanceMonitor.ts">
/**
 * PerformanceMonitor - Real-time FPS and metrics tracking
 * @performance Lightweight overlay for debugging performance issues
 */
export class PerformanceMonitor {
    private static enabled = false;
    private static frameCount = 0;
    private static fpsTimer = performance.now();    // For FPS calculation (per second)
    private static lastFrameTime = performance.now(); // For frame delta (per frame)
    private static fps = 0;
    // PERF: Ring Buffer instead of array with shift() - O(1) vs O(n)
    private static frameTimes = new Float64Array(60);
    private static frameIndex = 0;
    private static frameCount60 = 0; // How many samples in ring buffer

    // Metrics
    private static peakFps = 0;
    private static minFps = 999;
    private static profiling = false;
    private static profileData: { timestamp: number; fps: number; entities: number }[] = [];

    // Advanced Metrics for Stutter Detection
    private static worstFrameTime = 0;       // Max frame time in current session
    private static spikeCount = 0;           // Frames > 33ms (below 30 FPS)
    private static lastSpikeTime = 0;        // When last spike occurred
    private static onePercentLowFps = 60;    // 1% low FPS (worst 1%)

    // Custom Timers & Counters (Per Frame)
    private static timers: Map<string, number> = new Map();
    private static metrics: Map<string, number> = new Map();
    private static timerStartTimes: Map<string, number> = new Map();

    /**
     * Call this at the start of each frame
     */
    public static beginFrame(): void {
        const now = performance.now();

        // Frame delta calculation (per-frame)
        const frameDelta = now - this.lastFrameTime;
        this.lastFrameTime = now;

        // PERF: Ring buffer - O(1) write, no shift()
        this.frameTimes[this.frameIndex] = frameDelta;
        this.frameIndex = (this.frameIndex + 1) % 60;
        if (this.frameCount60 < 60) this.frameCount60++;

        // Track worst frame time and spikes (for stutter detection)
        if (frameDelta > this.worstFrameTime) this.worstFrameTime = frameDelta;
        if (frameDelta > 33.33) { // Below 30 FPS
            this.spikeCount++;
            this.lastSpikeTime = now;
        }

        // FPS calculation (per second)
        this.frameCount++;
        const fpsElapsed = now - this.fpsTimer;
        if (fpsElapsed >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / fpsElapsed);
            this.frameCount = 0;
            this.fpsTimer = now;

            // Track min/max
            if (this.fps > this.peakFps) this.peakFps = this.fps;
            if (this.fps < this.minFps && this.fps > 0) this.minFps = this.fps;

            // Calculate 1% low FPS (worst 1% of frame times)
            this.calculateOnePercentLow();
        }

        // Reset per-frame metrics
        this.metrics.clear();
        this.timers.clear();
    }

    /**
     * Calculate 1% low FPS from worst frame times
     */
    private static calculateOnePercentLow(): void {
        if (this.frameCount60 < 10) return;
        // Copy and sort frameTimes to find worst 1%
        const sorted: number[] = [];
        for (let i = 0; i < this.frameCount60; i++) {
            sorted.push(this.frameTimes[i]);
        }
        sorted.sort((a, b) => b - a); // Descending
        // Take worst 1% (at least 1 sample)
        const worstCount = Math.max(1, Math.floor(this.frameCount60 * 0.01));
        let sum = 0;
        for (let i = 0; i < worstCount; i++) {
            sum += sorted[i];
        }
        const avgWorstFrameTime = sum / worstCount;
        this.onePercentLowFps = Math.round(1000 / avgWorstFrameTime);
    }

    /**
     * Get current FPS
     */
    public static getFps(): number {
        return this.fps;
    }

    /**
     * Get average frame time in ms
     */
    public static getAvgFrameTime(): number {
        if (this.frameCount60 === 0) return 0;
        let sum = 0;
        for (let i = 0; i < this.frameCount60; i++) {
            sum += this.frameTimes[i];
        }
        return sum / this.frameCount60;
    }

    /**
     * Toggle overlay visibility
     */
    public static toggle(): void {
        this.enabled = !this.enabled;
    }

    /**
     * Check if overlay is enabled
     */
    public static isEnabled(): boolean {
        return this.enabled;
    }

    /**
     * Start profiling session
     */
    public static startProfile(durationMs: number = 5000): void {
        this.profiling = true;
        this.profileData = [];
        this.minFps = 999;
        this.peakFps = 0;

        setTimeout(() => {
            this.profiling = false;
            console.log('[PerformanceMonitor] Profile complete');
            console.log(`FPS Range: ${this.minFps} - ${this.peakFps}`);
            console.log(`Avg Frame Time: ${this.getAvgFrameTime().toFixed(2)}ms`);
        }, durationMs);
    }

    /**
     * Record current state for profiling
     */
    public static recordFrame(entityCount: number): void {
        if (!this.profiling) return;
        this.profileData.push({
            timestamp: performance.now(),
            fps: this.fps,
            entities: entityCount
        });
    }

    /**
     * Get profile results
     */
    public static getProfileResults(): string {
        if (this.profileData.length === 0) return 'No profile data';

        const avgFps = this.profileData.reduce((a, b) => a + b.fps, 0) / this.profileData.length;
        const avgEntities = this.profileData.reduce((a, b) => a + b.entities, 0) / this.profileData.length;

        return `Samples: ${this.profileData.length}\nAvg FPS: ${avgFps.toFixed(1)}\nAvg Entities: ${avgEntities.toFixed(0)}\nFPS Range: ${this.minFps}-${this.peakFps}`;
    }

    /**
     * Draw overlay on canvas
     */
    /**
     * Draw overlay on canvas (Smart HUD)
     * Layout:
     * FPS: 45 (Min: 19) | Frame: 22.2ms üî¥ (Budget: 16.6ms)
     * -----------------------------------------------------
     * CPU (Logic):  18.5ms üî¥
     *    ‚îú‚îÄ Pathfinding: 12.0ms (200 calls)
     *    ‚îú‚îÄ Collision:    4.2ms (Checks: 4500)
     *    ‚îú‚îÄ Entities:     2.1ms (Update: 350)
     * 
     * GPU (Render):  3.5ms üü¢
     *    ‚îú‚îÄ Main:         3.0ms
     */
    public static draw(ctx: CanvasRenderingContext2D, stats: {
        enemies: number;
        towers: number;
        projectiles: number;
        effects: number;
    }): void {
        if (!this.enabled) return;

        const x = 10;
        const y = 10;
        const lineHeight = 14;
        const width = 260; // Wider for detailed info
        const height = 240;

        ctx.save();
        ctx.font = 'bold 12px monospace';

        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(x - 5, y - 5, width, height);

        // --- HEADER ---
        let currentY = y + lineHeight;

        // FPS Colors
        const fpsColor = this.fps < 30 ? '#f00' : (this.fps < 50 ? '#ff0' : '#0f0');
        const budgetColor = this.getAvgFrameTime() > 16.6 ? '#f00' : '#0f0';

        ctx.fillStyle = fpsColor;
        ctx.fillText(`FPS: ${this.fps} (Min: ${this.minFps})`, x, currentY);

        ctx.fillStyle = budgetColor;
        const frameTimeStr = `Frame: ${this.getAvgFrameTime().toFixed(1)}ms`;
        const budgetStr = `(Limit: 16.6ms)`;
        const frameTextWidth = ctx.measureText(frameTimeStr).width;
        ctx.fillText(frameTimeStr, x + 120, currentY);

        ctx.fillStyle = '#888';
        ctx.fillText(budgetStr, x + 120 + frameTextWidth + 5, currentY);

        currentY += 8;
        ctx.fillStyle = '#444';
        ctx.fillRect(x, currentY, width - 10, 1); // Separator
        currentY += lineHeight + 5;

        // --- CPU (LOGIC) ---
        const logicTime = this.timers.get('Logic') || 0;
        const logicColor = logicTime > 10 ? '#f44' : '#8f8'; // Warn if logic > 10ms (leaving 6ms for render)

        ctx.fillStyle = logicColor;
        ctx.fillText(`CPU (Logic):  ${logicTime.toFixed(1)}ms ${logicTime > 10 ? 'üî¥' : 'üü¢'}`, x, currentY);
        currentY += lineHeight;

        // Sub-systems
        this.drawSubMetric(ctx, x, currentY, 'Pathfinding', 'PathCalls', 'calls');
        currentY += lineHeight;
        this.drawSubMetric(ctx, x, currentY, 'Collision', 'CollisionChecks', 'checks');
        currentY += lineHeight;
        this.drawSubMetric(ctx, x, currentY, 'Entities', 'EntityCount', 'active'); // Helper method needed? Or just inline?
        currentY += lineHeight;
        this.drawSubMetric(ctx, x, currentY, 'Projectiles', null, '');
        currentY += lineHeight;
        // Check for Spawn spikes
        const spawnTime = this.timers.get('Spawn') || 0;
        if (spawnTime > 1.0) {
            ctx.fillStyle = '#f88';
            ctx.fillText(`   ‚îú‚îÄ Spawn:      ${spawnTime.toFixed(1)}ms ‚ö†Ô∏è`, x, currentY);
            currentY += lineHeight;
        } else {
            currentY += 5; // spacing
        }

        // --- GPU (RENDER) ---
        const renderTime = this.timers.get('Render') || 0;
        const renderColor = renderTime > 10 ? '#f44' : '#8f8';

        ctx.fillStyle = renderColor;
        ctx.fillText(`GPU (Render): ${renderTime.toFixed(1)}ms ${renderTime > 10 ? 'üî¥' : 'üü¢'}`, x, currentY);
        currentY += lineHeight;

        this.drawSubMetric(ctx, x, currentY, 'RenderEntities', null, ''); // render entities
        currentY += lineHeight;

        // Entity Counts
        ctx.fillStyle = '#8f8';
        ctx.fillText(`   ‚îú‚îÄ Particles: ${stats.effects}`, x, currentY);
        currentY += lineHeight + 5;

        // --- MEMORY ---
        const mem = (performance as any).memory;
        if (mem) {
            const usedMB = (mem.usedJSHeapSize / 1024 / 1024).toFixed(1);
            const totalMB = (mem.jsHeapSizeLimit / 1024 / 1024).toFixed(0);
            ctx.fillStyle = '#88f';
            ctx.fillText(`Memory: ${usedMB} MB / ${totalMB} MB`, x, currentY);
            currentY += lineHeight;
        }

        // Pools (Visual estimate)
        ctx.fillStyle = '#888';
        ctx.fillText(`Enemies: ${stats.enemies} | Proj: ${stats.projectiles}`, x, currentY);

        ctx.restore();
    }

    private static drawSubMetric(ctx: CanvasRenderingContext2D, x: number, y: number, timerName: string, countName: string | null, countLabel: string) {
        const time = this.timers.get(timerName) || 0;
        const count = countName ? (this.metrics.get(countName) || 0) : null;

        ctx.fillStyle = '#ccc';
        let text = `   ‚îú‚îÄ ${timerName}: ${time.toFixed(1)}ms`;
        if (count !== null) {
            text += ` (${count} ${countLabel})`;
            // Highlight high counts
            if (count > 1000) ctx.fillStyle = '#f88';
        }
        ctx.fillText(text, x, y);
    }

    /**
     * Get advanced statistics for DevConsole
     */
    public static getAdvancedStats(): {
        fps: number;
        avgFrameTime: number;
        worstFrameTime: number;
        onePercentLow: number;
        spikeCount: number;
        minFps: number;
        peakFps: number;
        memoryMB: number | null;
    } {
        const mem = (performance as any).memory;
        return {
            fps: this.fps,
            avgFrameTime: this.getAvgFrameTime(),
            worstFrameTime: this.worstFrameTime,
            onePercentLow: this.onePercentLowFps,
            spikeCount: this.spikeCount,
            minFps: this.minFps,
            peakFps: this.peakFps,
            memoryMB: mem ? mem.usedJSHeapSize / 1024 / 1024 : null
        };
    }

    /**
     * Reset spike counter only (for fresh measurement sessions)
     */
    public static resetSpikes(): void {
        this.spikeCount = 0;
        this.worstFrameTime = 0;
    }

    /**
     * Reset all metrics
     */
    public static reset(): void {
        this.frameCount = 0;
        this.fpsTimer = performance.now();
        this.lastFrameTime = performance.now();
        this.fps = 0;
        this.frameTimes.fill(0); // PERF: Reset ring buffer in-place
        this.frameIndex = 0;
        this.frameCount60 = 0;
        this.peakFps = 0;
        this.minFps = 999;
        this.profileData = [];
        this.worstFrameTime = 0;
        this.spikeCount = 0;
        this.onePercentLowFps = 60;
        this.metrics.clear();
        this.timers.clear();
    }

    /**
     * Start a named timer
     */
    public static startTimer(label: string): void {
        if (!this.enabled) return;
        this.timerStartTimes.set(label, performance.now());
    }

    /**
     * End a named timer and add to the cumulative time for this frame
     */
    public static endTimer(label: string): void {
        if (!this.enabled) return;
        const startTime = this.timerStartTimes.get(label);
        if (startTime !== undefined) {
            const duration = performance.now() - startTime;
            const current = this.timers.get(label) || 0;
            this.timers.set(label, current + duration);
        }
    }

    /**
     * Increment a named counter
     */
    public static addCount(label: string, value: number = 1): void {
        if (!this.enabled) return;
        const current = this.metrics.get(label) || 0;
        this.metrics.set(label, current + value);
    }

    /**
     * Get value of a timer (ms)
     */
    public static getTimer(label: string): number {
        return this.timers.get(label) || 0;
    }

    /**
     * Get value of a metric
     */
    public static getMetric(label: string): number {
        return this.metrics.get(label) || 0;
    }
}
</file>

<file path="src/utils/StressLogger.ts">
import { PerformanceProfiler } from './PerformanceProfiler';

export interface StressPhaseStats {
    phaseName: string;
    duration: number;
    avgFps: number;
    minFps: number; // Absolute minimum
    p01Fps: number; // 1% low
    p05Fps: number; // 5% low
    maxEntities: number;

    // Avg timings per frame
    avgLogic: number;
    avgRender: number;
    avgPathfinding: number;
    avgCollision: number;
    avgDrawParticles: number;

    // Advanced Metrics
    // Keep strictly sorted
    medianFps: number;
    stddevFps: number;

    avgFrameMs?: number;
    p95FrameMs?: number;
    p99FrameMs?: number;

    // Counters
    avgDrawCalls: number;
    avgDrawImage: number;
    avgFillRect: number;
    avgPathOps: number;
    avgTextOps: number;
    avgSaveRestore: number;
    avgTransform: number;
    avgGradientOps: number;
    avgStateChanges: number;

    avgParticlesDrawn: number;
    avgGridQueries: number;
    avgPairsChecked: number;

    // Memory
    memoryStart: number;
    memoryEnd: number;
}

export class StressLogger {
    private static phases: StressPhaseStats[] = [];
    private static currentPhase: StressPhaseStats | null = null;

    // Accumulators for current phase
    private static frameCount = 0;
    private static totalFps = 0;
    private static fpsSamples: number[] = [];
    private static frameMsSamples: number[] = [];
    private static phaseStartTime = 0;

    private static totalLogic = 0;
    private static totalRender = 0;
    private static totalPath = 0;
    private static totalCollision = 0;
    private static totalParticles = 0;
    private static samplesCount = 0; // Distinct from frameCount because of sampling

    private static totalDrawCalls = 0;
    private static totalDrawImage = 0;
    private static totalFillRect = 0;
    private static totalPathOps = 0;
    private static totalTextOps = 0;
    private static totalSaveRestore = 0;
    private static totalTransform = 0;
    private static totalGradientOps = 0;
    private static totalStateChanges = 0;

    private static totalParticlesDrawn = 0;
    private static totalGridQueries = 0;
    private static totalPairsChecked = 0;

    public static startPhase(name: string) {
        this.finishPhase(); // Finish previous if exists

        const mem = (performance as any).memory ? (performance as any).memory.usedJSHeapSize : 0;

        this.currentPhase = {
            phaseName: name,
            duration: 0,
            avgFps: 0,
            minFps: 999,
            maxEntities: 0,
            avgLogic: 0,
            avgRender: 0,
            avgPathfinding: 0,
            avgCollision: 0,
            avgDrawParticles: 0,
            medianFps: 0,
            p05Fps: 0,
            p01Fps: 0,
            stddevFps: 0,
            avgDrawCalls: 0,
            avgDrawImage: 0,
            avgFillRect: 0,
            avgPathOps: 0,
            avgTextOps: 0,
            avgSaveRestore: 0,
            avgTransform: 0,
            avgGradientOps: 0,
            avgStateChanges: 0,
            avgParticlesDrawn: 0,
            avgGridQueries: 0,
            avgPairsChecked: 0,
            memoryStart: mem,
            memoryEnd: 0
        };

        this.frameCount = 0;
        this.totalFps = 0;
        this.fpsSamples = [];
        this.frameMsSamples = [];
        this.phaseStartTime = performance.now();
        this.totalLogic = 0;
        this.totalRender = 0;
        this.totalPath = 0;
        this.totalCollision = 0;
        this.totalParticles = 0;
        this.samplesCount = 0;

        this.totalDrawCalls = 0;
        this.totalDrawImage = 0;
        this.totalFillRect = 0;
        this.totalPathOps = 0;
        this.totalTextOps = 0;
        this.totalSaveRestore = 0;
        this.totalTransform = 0;
        this.totalGradientOps = 0;
        this.totalStateChanges = 0;

        this.totalParticlesDrawn = 0;
        this.totalGridQueries = 0;
        this.totalPairsChecked = 0;

        console.log(`[StressTest] Starting Phase: ${name}`);
    }

    public static logFrame(dt: number, currentFps: number, entityCount: number) {
        if (!this.currentPhase) return;

        this.frameCount++;
        this.totalFps += currentFps;
        this.fpsSamples.push(currentFps);
        this.frameMsSamples.push(dt * 1000);

        if (entityCount > this.currentPhase.maxEntities) {
            this.currentPhase.maxEntities = entityCount;
        }

        // Get Profiler Data
        const data = PerformanceProfiler.getFrameData();
        // Check if data is not empty (it returns empty object on skipped frames)
        if (Object.keys(data).length > 0) {
            this.samplesCount++;
            this.totalLogic += (data['Logic'] || 0);
            this.totalRender += (data['Render'] || 0);
            this.totalPath += (data['Pathfinding'] || 0);
            this.totalCollision += (data['Collision'] || 0);
            // Assuming 'Render' includes particles, but if we have specific 'DrawParticles' label:
            this.totalParticles += (data['DrawParticles'] || 0);

            const counts = PerformanceProfiler.getFrameCounts();
            this.totalDrawCalls += (counts['drawCalls'] || 0);
            this.totalDrawImage += (counts['drawImage'] || 0);
            this.totalFillRect += (counts['fillRect'] || 0);
            this.totalPathOps += (counts['pathOps'] || 0);
            this.totalTextOps += (counts['textOps'] || 0);
            this.totalSaveRestore += (counts['saveRestore'] || 0);
            this.totalTransform += (counts['transform'] || 0);
            this.totalGradientOps += (counts['gradientOps'] || 0);
            this.totalStateChanges += (counts['stateChanges'] || 0);

            this.totalParticlesDrawn += (counts['particlesDrawn'] || 0);
            this.totalGridQueries += (counts['gridQueries'] || 0);
            this.totalPairsChecked += (counts['pairsChecked'] || 0);
        }
    }

    public static finishPhase() {
        if (!this.currentPhase) return;

        const mem = (performance as any).memory ? (performance as any).memory.usedJSHeapSize : 0;
        this.currentPhase.memoryEnd = mem;

        // Averages
        this.currentPhase.avgFps = this.frameCount > 0 ? this.totalFps / this.frameCount : 0;

        // 1% Low FPS, p95, median, stddev
        this.fpsSamples.sort((a, b) => a - b);
        const l01 = Math.floor(this.fpsSamples.length * 0.01);
        const l05 = Math.floor(this.fpsSamples.length * 0.05);
        const l50 = Math.floor(this.fpsSamples.length * 0.50);

        this.currentPhase.minFps = this.fpsSamples[0] || 0;
        this.currentPhase.p01Fps = this.fpsSamples[l01] || 0;
        this.currentPhase.p05Fps = this.fpsSamples[l05] || 0;
        this.currentPhase.medianFps = this.fpsSamples[l50] || 0;

        // Frame MS metrics
        this.frameMsSamples.sort((a, b) => a - b);
        const t01 = Math.floor(this.frameMsSamples.length * 0.99); // Worst 1% time
        const t05 = Math.floor(this.frameMsSamples.length * 0.95);

        let sumMs = 0;
        for (let i = 0; i < this.frameMsSamples.length; i++) sumMs += this.frameMsSamples[i];

        this.currentPhase.avgFrameMs = this.frameMsSamples.length > 0 ? sumMs / this.frameMsSamples.length : 0;
        this.currentPhase.p95FrameMs = this.frameMsSamples[t05] || 0;
        this.currentPhase.p99FrameMs = this.frameMsSamples[t01] || 0;
        this.currentPhase.duration = performance.now() - this.phaseStartTime;

        // Stddev (Jitter)
        if (this.frameCount > 0) {
            const mean = this.currentPhase.avgFps;
            const variance = this.fpsSamples.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / this.fpsSamples.length;
            this.currentPhase.stddevFps = Math.sqrt(variance);
        }

        // Timing Averages
        const div = this.samplesCount > 0 ? this.samplesCount : 1;
        this.currentPhase.avgLogic = this.totalLogic / div;
        this.currentPhase.avgRender = this.totalRender / div;
        this.currentPhase.avgPathfinding = this.totalPath / div;
        this.currentPhase.avgCollision = this.totalCollision / div;
        this.currentPhase.avgDrawParticles = this.totalParticles / div;

        this.currentPhase.avgDrawCalls = this.totalDrawCalls / div;
        this.currentPhase.avgDrawImage = this.totalDrawImage / div;
        this.currentPhase.avgFillRect = this.totalFillRect / div;
        this.currentPhase.avgPathOps = this.totalPathOps / div;
        this.currentPhase.avgTextOps = this.totalTextOps / div;
        this.currentPhase.avgSaveRestore = this.totalSaveRestore / div;
        this.currentPhase.avgTransform = this.totalTransform / div;
        this.currentPhase.avgGradientOps = this.totalGradientOps / div;
        this.currentPhase.avgStateChanges = this.totalStateChanges / div;

        this.currentPhase.avgParticlesDrawn = this.totalParticlesDrawn / div;
        this.currentPhase.avgGridQueries = this.totalGridQueries / div;
        this.currentPhase.avgPairsChecked = this.totalPairsChecked / div;

        this.phases.push(this.currentPhase);
        this.currentPhase = null;
    }

    public static generateReport(): string {
        this.finishPhase(); // Ensure last phase is saved

        let md = `# üß™ NewTower Deep Stress Test Report\n`;
        md += `Date: ${new Date().toLocaleString()}\n\n`;

        md += `## üî¨ Phase Breakdown\n`;
        md += `| Phase | Dur(s) | FPS(Med|Avg) | P05 | P01 | FrameMs(Avg/P95) | Jitter | Ents | Core(ms) | Rend(ms) | Draws (Img/Rect/Path) | Tx/S/State |\n`;
        md += `|-------|--------|--------------|-----|-----|------------------|--------|------|----------|----------|-----------------------|------------|\n`;

        this.phases.forEach(p => {
            const memStart = (p.memoryStart / 1024 / 1024).toFixed(0);
            const memEnd = (p.memoryEnd / 1024 / 1024).toFixed(0);
            const memStr = `${memStart} -> ${memEnd}`;

            const coreMs = (p.avgLogic + p.avgPathfinding + p.avgCollision).toFixed(2);
            const durationSec = (p.duration / 1000).toFixed(1);

            const frameMetrics = `${(p.avgFrameMs || 0).toFixed(1)} / ${(p.p95FrameMs || 0).toFixed(1)}`;
            const fpsStr = `${p.medianFps.toFixed(0)}|${p.avgFps.toFixed(0)}`;

            const drawBreakdown = `${p.avgDrawImage.toFixed(0)}/${p.avgFillRect.toFixed(0)}/${p.avgPathOps.toFixed(0)}`;
            const stateBreakdown = `${p.avgTransform.toFixed(0)}/${p.avgSaveRestore.toFixed(0)}/${p.avgStateChanges.toFixed(0)}`;

            md += `| ${p.phaseName} | ${durationSec} | ${fpsStr} | ${p.p05Fps.toFixed(0)} | ${p.p01Fps.toFixed(0)} | ${frameMetrics} | ${p.stddevFps.toFixed(1)} | ${p.maxEntities} | ${coreMs} | ${p.avgRender.toFixed(2)} | ${drawBreakdown} | ${stateBreakdown} |\n`;
        });

        md += `\n## üö® Analysis\n`;
        // Simple heuristic analysis
        this.phases.forEach(p => {
            if (p.avgFps < 30) {
                md += `- **${p.phaseName}**: Low FPS (${p.avgFps.toFixed(0)}). `;
                if (p.avgLogic > p.avgRender) {
                    md += `Bottleneck: CPU Logic. `;
                    if (p.avgPathfinding > 5) md += `Major Load: Pathfinding. `;
                    if (p.avgCollision > 5) md += `Major Load: Collision. `;
                } else {
                    md += `Bottleneck: GPU/Render. `;
                }
                md += `\n`;
            }
        });

        return md;
    }

    public static generateJson(): string {
        return JSON.stringify({
            date: new Date().toISOString(),
            phases: this.phases,
            userAgent: navigator.userAgent
        }, null, 2);
    }

    public static reset() {
        this.phases = [];
        this.currentPhase = null;
        this.frameCount = 0;
        this.totalFps = 0;
        this.fpsSamples = [];
        this.frameMsSamples = [];
    }
}
</file>

<file path="src/cards/MultishotCard.ts">
import { IUpgradeCard } from './CardType';
import { EVOLUTION_UPGRADES } from './CardEvolutions';

/**
 * Multishot Card Upgrades
 * 
 * Level 1: 2 projectiles at 60% damage each
 * Level 2: 2 projectiles at 70% damage each
 * Level 3: 3 projectiles at 55% damage each
 * 
 * Note: Multishot is handled differently - it modifies projectile count
 * and damage multiplier rather than using effects system
 */
export const MULTISHOT_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {},
        effects: []
        // Projectile count: 2, damage multiplier: 0.60
    },
    2: {
        level: 2,
        modifiers: {},
        effects: []
        // Projectile count: 2, damage multiplier: 0.70
    },
    3: {
        level: 3,
        modifiers: {},
        effects: []
        // Projectile count: 3, damage multiplier: 0.55
    }
};

// Lookup tables for Multishot Evolutions
const EVOLUTION_PROJECTILE_COUNTS: Record<string, number> = {
    'barrage': 4, 'spread': 2, 'storm': 6,
    'volley': 4, 'homing': 3, 'twin': 2,
};

const EVOLUTION_SPREADS: Record<string, number> = {
    'barrage': 0.35, 'spread': 0.12, 'storm': 0.52,
    'volley': 0.30, 'homing': 0.20, 'twin': 0.10,
};

/**
 * Get multishot configuration for a given level
 */
export function getMultishotConfig(
    level: number,
    evolutionPath?: string
): { projectileCount: number; damageMultiplier: number; spread: number } {

    // Check for evolution first
    if (evolutionPath && evolutionPath !== 'classic') {
        // We use local lookup tables and hardcoded damage multipliers 
        // to avoid circular dependency issues with EVOLUTION_UPGRADES if imported from index.
        // We DO NOT use EVOLUTION_UPGRADES here to affect the config directly yet, 
        // to match the previous Safe implementation step.

        const damageMultipliers: Record<string, number> = {
            'barrage': 0.40, 'spread': 0.85,
            'storm': 0.30, 'volley': 0.45,
            'homing': 0.70, 'twin': 1.0,
        };

        const count = EVOLUTION_PROJECTILE_COUNTS[evolutionPath] || 2;
        const spread = EVOLUTION_SPREADS[evolutionPath] || 0.30;
        const dmgMult = damageMultipliers[evolutionPath] || 0.60;

        return { projectileCount: count, damageMultiplier: dmgMult, spread: spread };
    }

    // Classic path
    switch (level) {
        case 1:
            return { projectileCount: 2, damageMultiplier: 0.60, spread: 0.30 };
        case 2:
            return { projectileCount: 2, damageMultiplier: 0.70, spread: 0.20 };
        case 3:
            return { projectileCount: 3, damageMultiplier: 0.55, spread: 0.25 };
        default:
            return { projectileCount: 1, damageMultiplier: 1.0, spread: 0 };
    }
}
</file>

<file path="src/CardStackingSystem.ts">
import { ICard } from './CardSystem';
import { ICardModifiers, ICardEffect } from './cards/CardType';
import { getCardUpgrade } from './cards';

/**
 * Card Stacking System
 * 
 * Implements the advanced card stacking logic where:
 * - Different card types: All bonuses sum normally
 * - Same card types: Highest level = 100%, others contribute by level:
 *   - Level 3: 70% of stats
 *   - Level 2: 50% of stats
 *   - Level 1: 35% of stats
 */

/**
 * Get stacking bonus percentage based on card level
 */
export function getStackingBonus(level: number): number {
    switch (level) {
        case 3: return 0.70;
        case 2: return 0.50;
        case 1: return 0.35;
        default: return 0.35;
    }
}

/**
 * Group cards by type ID
 */
function groupCardsByType(cards: ICard[]): Map<string, ICard[]> {
    const grouped = new Map<string, ICard[]>();

    for (const card of cards) {
        const typeId = card.type.id;
        if (!grouped.has(typeId)) {
            grouped.set(typeId, []);
        }
        grouped.get(typeId)!.push(card);
    }

    return grouped;
}

export interface MergedCardData {
    modifiers: ICardModifiers;
    effects: ICardEffect[];
}

/**
 * Merge modifiers and effects from cards with advanced stacking rules
 */
export function mergeCardsWithStacking(cards: ICard[]): MergedCardData {
    const result: ICardModifiers = {
        damage: 0,
        damageMultiplier: undefined,
        attackSpeedMultiplier: 1.0,
        range: 0,
        rangeMultiplier: 1.0,
        critChance: 0,
    };
    const allEffects: ICardEffect[] = [];

    // Group cards by type
    const grouped = groupCardsByType(cards);

    // Process each card type group
    for (const [typeId, typeCards] of grouped) {
        // Sort by level (highest first)
        typeCards.sort((a, b) => b.level - a.level);

        if (typeId === 'minigun') {
            // Special handling for Minigun
            processMinigunGroup(typeCards, result, allEffects);
        } else if (typeId === 'multi') {
            // Multishot doesn't add standard modifiers usually, 
            // but Evolutions (like Volley) might have attackSpeedMultiplier.

            // We only look at the main card (highest level) for evolution stats
            const mainCard = typeCards[0];
            const upgrade = getCardUpgrade(typeId, mainCard.level, mainCard.evolutionPath);

            if (upgrade && upgrade.modifiers) {
                // Apply attackSpeedMultiplier if present (e.g. Volley 1.3x)
                if (upgrade.modifiers.attackSpeedMultiplier) {
                    result.attackSpeedMultiplier = (result.attackSpeedMultiplier || 1.0) * upgrade.modifiers.attackSpeedMultiplier;
                }
                // Note: damageMultiplier is handled in Tower.ts via getMultishotConfig
                // So we do NOT apply it here to avoid double application.
            }
            continue;
        } else if (typeCards.length === 1) {
            // Single card of this type: 100% bonus
            const card = typeCards[0];
            const upgrade = getCardUpgrade(typeId, card.level, card.evolutionPath);
            if (upgrade) {
                applyModifiers(result, upgrade.modifiers, 1.0);
                allEffects.push(...upgrade.effects);
            }
        } else {
            // Multiple cards of same type: use stacking rules
            processSameTypeGroup(typeCards, result, allEffects);
        }
    }

    return { modifiers: result, effects: allEffects };
}

/**
 * Process multiple cards of the same type (non-minigun)
 */
function processSameTypeGroup(
    cards: ICard[],
    result: ICardModifiers,
    allEffects: ICardEffect[]
) {
    // Already sorted by level (highest first)

    // First card (highest level): 100%
    const mainCard = cards[0];
    const mainUpgrade = getCardUpgrade(mainCard.type.id, mainCard.level, mainCard.evolutionPath);
    if (mainUpgrade) {
        applyModifiers(result, mainUpgrade.modifiers, 1.0);
        allEffects.push(...mainUpgrade.effects);
    }

    // Rest of the cards: apply stacking bonus
    for (let i = 1; i < cards.length; i++) {
        const card = cards[i];
        const upgrade = getCardUpgrade(card.type.id, card.level, card.evolutionPath);
        if (!upgrade) continue;

        const bonus = getStackingBonus(card.level);

        // Apply modifiers with bonus percentage
        applyModifiers(result, upgrade.modifiers, bonus);

        // Apply effects with bonus (if they have numeric values)
        applyEffectsWithBonus(upgrade.effects, allEffects, bonus);
    }
}

/**
 * Special processing for Minigun cards
 * 
 * - Takes highest level card for base damageMultiplier
 * - Additional minigun cards add penalties:
 *   - LVL 1: -5% damage
 *   - LVL 2: -7% damage
 *   - LVL 3: -9% damage
 *   - Penalties are summed
 */
function processMinigunGroup(
    cards: ICard[],
    result: ICardModifiers,
    allEffects: ICardEffect[]
) {
    // Already sorted by level
    const mainCard = cards[0];
    const mainUpgrade = getCardUpgrade('minigun', mainCard.level, mainCard.evolutionPath);

    if (!mainUpgrade) return;

    // Start with main card's damageMultiplier
    let baseDamageMultiplier = mainUpgrade.modifiers.damageMultiplier || 0.30;

    // Calculate penalties from additional minigun cards
    let totalPenalty = 0;
    for (let i = 1; i < cards.length; i++) {
        const level = cards[i].level;
        switch (level) {
            case 1:
                totalPenalty += 0.05; // 5%
                break;
            case 2:
                totalPenalty += 0.07; // 7%
                break;
            case 3:
                totalPenalty += 0.09; // 9%
                break;
        }
    }

    // Apply penalty to damageMultiplier (subtract from multiplier)
    baseDamageMultiplier -= totalPenalty;

    // Ensure minimum multiplier (can't go below 10%)
    baseDamageMultiplier = Math.max(0.10, baseDamageMultiplier);

    // Apply to result
    result.damageMultiplier = baseDamageMultiplier;
    result.attackSpeedMultiplier! *= mainUpgrade.modifiers.attackSpeedMultiplier || 1.0;

    // Add effects from main card only
    allEffects.push(...mainUpgrade.effects);
}

/**
 * Apply modifiers with a bonus multiplier
 */
function applyModifiers(
    result: ICardModifiers,
    modifiers: ICardModifiers,
    bonus: number
) {
    // Flat bonuses: multiply by bonus percentage
    if (modifiers.damage !== undefined) {
        result.damage! += modifiers.damage * bonus;
    }

    if (modifiers.range !== undefined) {
        result.range! += modifiers.range * bonus;
    }

    // Multipliers: scale the effect
    if (modifiers.attackSpeedMultiplier !== undefined) {
        // Effect = (multiplier - 1.0), e.g., 0.85 -> effect = -0.15
        const effect = modifiers.attackSpeedMultiplier - 1.0;
        const scaledEffect = effect * bonus;
        const finalMultiplier = 1.0 + scaledEffect;
        result.attackSpeedMultiplier! *= finalMultiplier;
    }

    if (modifiers.rangeMultiplier !== undefined) {
        const effect = modifiers.rangeMultiplier - 1.0;
        const scaledEffect = effect * bonus;
        const finalMultiplier = 1.0 + scaledEffect;
        result.rangeMultiplier! *= finalMultiplier;
    }

    // Crit chance: sum with bonus (not just max)
    if (modifiers.critChance !== undefined) {
        result.critChance! += modifiers.critChance * bonus;
    }

    // DamageMultiplier: only used by Minigun, handled specially
    // Don't merge here
}

/**
 * Apply effects with bonus percentage and deduplication
 */
function applyEffectsWithBonus(
    effects: ICardEffect[],
    allEffects: ICardEffect[],
    bonus: number
) {
    // Add effects with deduplication - only keep strongest version of each effect type
    for (const effect of effects) {
        const existing = allEffects.find(e => e.type === effect.type);

        if (!existing) {
            // New effect type - add it
            allEffects.push({ ...effect });
        } else {
            // Effect already exists - update to maximum values
            if (effect.splashRadius !== undefined && existing.splashRadius !== undefined) {
                existing.splashRadius = Math.max(existing.splashRadius, effect.splashRadius);
            }
            if (effect.slowDuration !== undefined && existing.slowDuration !== undefined) {
                existing.slowDuration = Math.max(existing.slowDuration, effect.slowDuration);
            }
            if (effect.slowPower !== undefined && existing.slowPower !== undefined) {
                existing.slowPower = Math.max(existing.slowPower, effect.slowPower);
            }
            if (effect.damageToSlowed !== undefined && existing.damageToSlowed !== undefined) {
                existing.damageToSlowed = Math.max(existing.damageToSlowed, effect.damageToSlowed);
            }
            if (effect.pierceCount !== undefined && existing.pierceCount !== undefined) {
                existing.pierceCount = Math.max(existing.pierceCount, effect.pierceCount);
            }
            if (effect.explosionDamagePercent !== undefined && existing.explosionDamagePercent !== undefined) {
                existing.explosionDamagePercent = Math.max(existing.explosionDamagePercent, effect.explosionDamagePercent);
            }
            if (effect.explosionRadius !== undefined && existing.explosionRadius !== undefined) {
                existing.explosionRadius = Math.max(existing.explosionRadius, effect.explosionRadius);
            }
            if (effect.chainRadius !== undefined && existing.chainRadius !== undefined) {
                existing.chainRadius = Math.max(existing.chainRadius, effect.chainRadius);
            }
            // Burn effect: keep strongest values
            if (effect.burnDps !== undefined && existing.burnDps !== undefined) {
                existing.burnDps = Math.max(existing.burnDps, effect.burnDps);
            }
            if (effect.burnDuration !== undefined && existing.burnDuration !== undefined) {
                existing.burnDuration = Math.max(existing.burnDuration, effect.burnDuration);
            }
            // Spinup effects - keep from main card (already handled in processMinigunGroup)
        }
    }
}
</file>

<file path="src/editor/components/EnemyGroupRow.ts">
import { BaseComponent } from './BaseComponent';
import { SpawnPattern, IWaveGroupRaw } from '../../MapData';
import { EnemyRegistry } from '../EnemyRegistry';
import { ThreatService } from '../ThreatService';
import { SpawnTimingControl } from './SpawnTimingControl';
import { IEnemyTypeConfig } from '../../types';

interface EnemyGroupProps {
    type: string;
    count: number;
    baseInterval: number;
    delayBefore: number;
    spawnPattern: SpawnPattern;
    hasError?: boolean;
    onChange: (updates: Partial<IWaveGroupRaw>) => void;
    onDuplicate: () => void;
    onRemove: () => void;
}

export class EnemyGroupRow extends BaseComponent<EnemyGroupProps> {

    protected createRootElement(): HTMLElement {
        const el = this.createElement('div', 'we-enemy-row');
        if (this.data.hasError) {
            el.classList.add('we-enemy-row--error');
        }
        return el;
    }

    public render(): void {
        this.element.innerHTML = '';

        // Row 1: Type + Count + Pattern + Actions
        const mainRow = this.createElement('div', 'we-enemy-main');

        // Color dot for enemy type
        const typeConfig = EnemyRegistry.getType(this.data.type);
        if (typeConfig) {
            const colorDot = document.createElement('div');
            colorDot.className = 'we-type-dot';
            colorDot.style.background = typeConfig.color;
            colorDot.title = typeConfig.name;
            mainRow.appendChild(colorDot);
        }

        // 1. Enemy Type Selector
        const typeSelect = document.createElement('select');
        typeSelect.title = 'Enemy Type';
        typeSelect.style.maxWidth = '130px';

        const types: IEnemyTypeConfig[] = EnemyRegistry.getVisibleForEditor();
        types.forEach((config: IEnemyTypeConfig) => {
            const opt = document.createElement('option');
            opt.value = config.id;
            opt.textContent = `${config.symbol} ${config.name}`;

            const currentType = this.data.type;
            const isMatch = config.id === currentType ||
                config.id === currentType.toLowerCase() ||
                config.id.toUpperCase() === currentType;

            if (isMatch) {
                opt.selected = true;
                if (currentType !== config.id) {
                    this.data.onChange({ type: config.id });
                }
            }
            typeSelect.appendChild(opt);
        });

        typeSelect.onchange = (e) => {
            this.data.onChange({ type: (e.target as HTMLSelectElement).value });
        };
        mainRow.appendChild(typeSelect);

        // 2. √ó label + Count input
        const xLabel = this.createElement('span', '', '√ó');
        xLabel.style.color = '#888';
        mainRow.appendChild(xLabel);

        const countInput = document.createElement('input');
        countInput.type = 'number';
        countInput.min = '1';
        countInput.max = '100';
        countInput.value = this.data.count.toString();
        countInput.style.width = '40px';
        countInput.onchange = (e) => {
            const val = parseInt((e.target as HTMLInputElement).value) || 1;
            this.data.onChange({ count: val });
        };
        mainRow.appendChild(countInput);

        // 3. Pattern Selector
        const patternSelect = document.createElement('select');
        patternSelect.title = 'Spawn Pattern';
        patternSelect.style.minWidth = '50px';
        patternSelect.style.cursor = 'pointer';

        const patterns: Array<{ value: SpawnPattern; label: string }> = [
            { value: 'normal', label: '‚è±Ô∏è Norm' },
            { value: 'random', label: 'üé≤ Rand' },
            { value: 'swarm', label: 'üêù Swrm' }
        ];

        patterns.forEach(p => {
            const opt = document.createElement('option');
            opt.value = p.value;
            opt.textContent = p.label;
            opt.title = p.value;
            if (p.value === (this.data.spawnPattern || 'normal')) opt.selected = true;
            patternSelect.appendChild(opt);
        });
        patternSelect.onchange = (e) => {
            this.data.onChange({ spawnPattern: (e.target as HTMLSelectElement).value as SpawnPattern });
        };
        mainRow.appendChild(patternSelect);

        // 4. Duration label
        const interval = this.data.baseInterval;
        const dur = (this.data.count * interval).toFixed(1);
        const durLabel = this.createElement('span', 'we-duration-label', `${this.data.count} √ó ${interval}—Å = ${dur}—Å`);
        mainRow.appendChild(durLabel);

        // 5. Threat dot
        const threat = ThreatService.calculateGroupThreat({
            type: this.data.type,
            count: this.data.count,
            spawnPattern: this.data.spawnPattern
        });
        const threatDot = document.createElement('div');
        threatDot.className = 'we-threat-dot';
        threatDot.style.background = ThreatService.getThreatColor(threat);
        threatDot.title = `–£–≥—Ä–æ–∑–∞: ${Math.round(threat)}`;
        mainRow.appendChild(threatDot);

        // 6. Duplicate button
        const dupBtn = this.createElement('button', 'we-btn we-btn-icon', 'üîÑ');
        dupBtn.title = '–î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –≥—Ä—É–ø–ø—É';
        dupBtn.onclick = () => this.data.onDuplicate();
        mainRow.appendChild(dupBtn);

        // 7. Delete button
        const delBtn = this.createElement('button', 'we-btn we-btn-icon', '‚úï');
        delBtn.style.marginLeft = 'auto';
        delBtn.onclick = () => this.data.onRemove();
        mainRow.appendChild(delBtn);

        this.element.appendChild(mainRow);

        // Row 2: Timing controls (interval + delay)
        const timingRow = this.createElement('div', 'we-enemy-timing');

        const intervalCtrl = new SpawnTimingControl({
            value: this.data.baseInterval,
            min: 0.05,
            max: 5.0,
            step: 0.05,
            label: '‚è±Ô∏è –ò–Ω—Ç–µ—Ä–≤–∞–ª',
            suffix: '—Å',
            onChange: (val) => this.data.onChange({ baseInterval: val }),
        });
        intervalCtrl.mount(timingRow);

        const delayCtrl = new SpawnTimingControl({
            value: this.data.delayBefore,
            min: 0,
            max: 30,
            step: 0.5,
            label: '‚è∏Ô∏è –ó–∞–¥–µ—Ä–∂–∫–∞',
            suffix: '—Å',
            onChange: (val) => this.data.onChange({ delayBefore: val }),
        });
        delayCtrl.mount(timingRow);

        this.element.appendChild(timingRow);
    }
}
</file>

<file path="src/editor/WaveModel.ts">
import { IWaveConfig, IWaveGroupRaw } from '../MapData';
import { EnemyRegistry } from './EnemyRegistry';
import { ThreatService } from './ThreatService';
import { WaveEditorHistory } from './WaveEditorHistory';

export interface IValidationMessage {
    waveIndex: number;
    groupIndex?: number;
    message: string;
    field?: string;
}

export interface IValidationResult {
    isValid: boolean;
    errors: IValidationMessage[];
    warnings: IValidationMessage[];
}

type ChangeListener = () => void;

/**
 * Model class for the Wave Editor.
 * Manages the data state and ensures we work on a draft copy.
 */
export class WaveModel {
    private waves: IWaveConfig[];
    private listeners: ChangeListener[] = [];
    private history = new WaveEditorHistory();

    constructor(initialWaves: IWaveConfig[]) {
        // Deep copy to ensure we hold a draft state
        this.waves = JSON.parse(JSON.stringify(initialWaves || []));

        // Ensure at least one wave if empty
        if (this.waves.length === 0) {
            this.addWave();
        }
    }

    // --- Data Access ---

    public getWaves(): IWaveConfig[] {
        return this.waves;
    }

    public getWave(index: number): IWaveConfig {
        return this.waves[index];
    }

    public getWaveCount(): number {
        return this.waves.length;
    }

    public getThreat(waveIndex: number): number {
        return ThreatService.calculateWaveThreat(this.waves[waveIndex]);
    }

    // --- Mutation Methods ---

    public addWave() {
        this.history.push('Add Wave', this.waves);
        this.waves.push({
            enemies: [{
                type: 'GRUNT',
                count: 5,
                pattern: 'normal',
                baseInterval: 0.66,
            }],
            shuffleMode: 'none', // New maps: designer controls order
        });
        this.notify();
    }

    public removeWave(index: number) {
        if (index >= 0 && index < this.waves.length) {
            this.history.push('Remove Wave', this.waves);
            this.waves.splice(index, 1);
            this.notify();
        }
    }

    public addEnemyGroup(waveIndex: number) {
        const wave = this.waves[waveIndex];
        if (wave) {
            this.history.push('Add Enemy Group', this.waves);
            wave.enemies.push({
                type: 'GRUNT',
                count: 1,
                pattern: 'normal',
                baseInterval: 0.66,
            });
            this.notify();
        }
    }

    public removeEnemyGroup(waveIndex: number, groupIndex: number) {
        const wave = this.waves[waveIndex];
        if (wave && wave.enemies.length > groupIndex) {
            this.history.push('Remove Enemy Group', this.waves);
            wave.enemies.splice(groupIndex, 1);
            this.notify();
        }
    }

    // Explicitly typed for IWaveGroupRaw partial updates
    public updateEnemyGroup(waveIndex: number, groupIndex: number, updates: Partial<IWaveGroupRaw>) {
        const wave = this.waves[waveIndex];
        if (wave && wave.enemies[groupIndex]) {
            this.history.push('Update Enemy Group', this.waves);
            Object.assign(wave.enemies[groupIndex], updates);
            this.notify();
        }
    }

    public moveWave(fromIndex: number, toIndex: number) {
        if (fromIndex < 0 || fromIndex >= this.waves.length || toIndex < 0 || toIndex >= this.waves.length) return;

        this.history.push('Move Wave', this.waves);
        const element = this.waves[fromIndex];
        this.waves.splice(fromIndex, 1);
        this.waves.splice(toIndex, 0, element);
        this.notify();
    }

    public replaceAllWaves(newWaves: IWaveConfig[]) {
        this.history.push('–ó–∞–º–µ–Ω–∏—Ç—å –≤—Å–µ –≤–æ–ª–Ω—ã', this.waves);
        this.waves = JSON.parse(JSON.stringify(newWaves));
        if (this.waves.length === 0) {
            this.waves.push({
                enemies: [{
                    type: 'GRUNT',
                    count: 5,
                    pattern: 'normal',
                    baseInterval: 0.66,
                }],
                shuffleMode: 'none',
            });
        }
        this.notify();
    }

    public moveWaveUp(index: number) {
        if (index > 0) this.moveWave(index, index - 1);
    }

    public moveWaveDown(index: number) {
        if (index < this.waves.length - 1) this.moveWave(index, index + 1);
    }

    // --- New Methods ---

    public updateWaveSettings(index: number, updates: Partial<Pick<IWaveConfig, 'name' | 'startDelay' | 'waitForClear' | 'bonusReward' | 'shuffleMode'>>) {
        const wave = this.waves[index];
        if (!wave) return;
        this.history.push('Update Wave Settings', this.waves);
        Object.assign(wave, updates);
        this.notify();
    }

    public updateGroupTiming(waveIndex: number, groupIndex: number, updates: { baseInterval?: number; delayBefore?: number }) {
        const wave = this.waves[waveIndex];
        if (!wave || !wave.enemies[groupIndex]) return;
        this.history.push('Update Group Timing', this.waves);
        Object.assign(wave.enemies[groupIndex], updates);
        this.notify();
    }

    public duplicateWave(index: number) {
        if (index < 0 || index >= this.waves.length) return;
        this.history.push('Duplicate Wave', this.waves);
        const copy: IWaveConfig = JSON.parse(JSON.stringify(this.waves[index]));
        this.waves.splice(index + 1, 0, copy);
        this.notify();
    }

    public duplicateGroup(waveIndex: number, groupIndex: number) {
        const wave = this.waves[waveIndex];
        if (!wave || !wave.enemies[groupIndex]) return;
        this.history.push('Duplicate Group', this.waves);
        const copy: IWaveGroupRaw = JSON.parse(JSON.stringify(wave.enemies[groupIndex]));
        wave.enemies.splice(groupIndex + 1, 0, copy);
        this.notify();
    }

    public moveGroup(waveIndex: number, fromIdx: number, toIdx: number) {
        const wave = this.waves[waveIndex];
        if (!wave || fromIdx < 0 || fromIdx >= wave.enemies.length || toIdx < 0 || toIdx >= wave.enemies.length) return;
        this.history.push('Move Group', this.waves);
        const [element] = wave.enemies.splice(fromIdx, 1);
        wave.enemies.splice(toIdx, 0, element);
        this.notify();
    }

    public getEstimatedDuration(waveIndex: number): number {
        const wave = this.waves[waveIndex];
        if (!wave || !wave.enemies) return 0;
        let total = wave.startDelay ?? 0;
        wave.enemies.forEach(g => {
            total += g.delayBefore ?? 0;
            const interval = g.baseInterval ?? 0.66;
            total += g.count * interval;
        });
        return total;
    }

    public undo(): boolean {
        const state = this.history.undo(this.waves);
        if (!state) return false;
        this.waves = state;
        this.notify();
        return true;
    }

    public redo(): boolean {
        const state = this.history.redo(this.waves);
        if (!state) return false;
        this.waves = state;
        this.notify();
        return true;
    }

    public canUndo(): boolean { return this.history.canUndo(); }
    public canRedo(): boolean { return this.history.canRedo(); }

    // --- Validation ---

    public validateExtended(): IValidationResult {
        const errors: IValidationMessage[] = [];
        const warnings: IValidationMessage[] = [];

        if (this.waves.length === 0) {
            errors.push({ waveIndex: -1, message: '–ù–µ—Ç –Ω–∏ –æ–¥–Ω–æ–π –≤–æ–ª–Ω—ã' });
        }

        this.waves.forEach((wave, wi) => {
            if (!wave.enemies || wave.enemies.length === 0) {
                errors.push({ waveIndex: wi, message: '–í–æ–ª–Ω–∞ –±–µ–∑ –≥—Ä—É–ø–ø –≤—Ä–∞–≥–æ–≤' });
            }
            wave.enemies?.forEach((g, gi) => {
                if (g.count < 1) {
                    errors.push({ waveIndex: wi, groupIndex: gi, message: '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ < 1', field: 'count' });
                }
                if ((g.baseInterval ?? 0.66) <= 0) {
                    errors.push({ waveIndex: wi, groupIndex: gi, message: '–ò–Ω—Ç–µ—Ä–≤–∞–ª <= 0', field: 'baseInterval' });
                }
                if (!g.type) {
                    errors.push({ waveIndex: wi, groupIndex: gi, message: '–ù–µ –≤—ã–±—Ä–∞–Ω —Ç–∏–ø –≤—Ä–∞–≥–∞', field: 'type' });
                }
                if (g.type && !EnemyRegistry.getType(g.type)) {
                    warnings.push({ waveIndex: wi, groupIndex: gi, message: `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø: ${g.type}`, field: 'type' });
                }
            });

            const threat = this.getThreat(wi);
            if (threat > 3000) {
                warnings.push({ waveIndex: wi, message: `–£–≥—Ä–æ–∑–∞ ${Math.round(threat)} ‚Äî NIGHTMARE!` });
            }
            const dur = this.getEstimatedDuration(wi);
            if (dur > 120) {
                warnings.push({ waveIndex: wi, message: `–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å ${dur.toFixed(0)}—Å ‚Äî –æ—á–µ–Ω—å –¥–æ–ª–≥–æ` });
            }
        });

        return { isValid: errors.length === 0, errors, warnings };
    }

    public validate(): boolean {
        return this.validateExtended().isValid;
    }

    // --- Observer Pattern ---

    public subscribe(listener: ChangeListener) {
        this.listeners.push(listener);
    }

    public unsubscribe(listener: ChangeListener) {
        this.listeners = this.listeners.filter(l => l !== listener);
    }

    private notify() {
        this.listeners.forEach(l => l());
    }

    public destroy() {
        this.listeners = [];
        this.history.clear();
    }
}
</file>

<file path="src/ObjectRenderer.ts">
import { CONFIG } from './Config';
import { VISUALS } from './VisualConfig';
import { ProceduralGrass } from './renderers/ProceduralGrass';

/**
 * ObjectRenderer - programmatic rendering for map objects
 * Supports 5 object types: stone, rock, tree, wheat, flowers
 * Designed to be easily replaced with asset-based rendering later
 */

export type ObjectType = 'stone' | 'rock' | 'tree' | 'wheat' | 'flowers';

export class ObjectRenderer {
    /**
     * Draw an object at specified pixel coordinates
     * @param ctx Canvas rendering context
     * @param type Object type
     * @param x Pixel x coordinate
     * @param y Pixel y coordinate
     * @param size Tile size (1 for most objects, 2-3 for rocks)
     */
    static draw(ctx: CanvasRenderingContext2D, type: ObjectType, x: number, y: number, size: number = 1): void {
        const TS = CONFIG.TILE_SIZE;

        switch (type) {
            case 'stone':
                this.drawStone(ctx, x, y, TS);
                break;
            case 'rock':
                this.drawRock(ctx, x, y, TS, size);
                break;
            case 'tree':
                this.drawTree(ctx, x, y, TS);
                break;
            case 'wheat':
                this.drawWheat(ctx, x, y, TS);
                break;
            case 'flowers':
                this.drawFlowers(ctx, x, y, TS);
                break;
        }
    }

    /**
     * Draw small stones (1 tile)
     * Phase 5: Uses global light direction from VISUALS.LIGHTING
     */
    private static drawStone(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        const centerX = x + TS / 2;
        const centerY = y + TS / 2;

        // Draw 2-3 small gray stones
        const stoneCount = 2 + Math.floor((x + y) % 2);

        for (let i = 0; i < stoneCount; i++) {
            const offsetX = ((x + i * 17) % 30) - 15;
            const offsetY = ((y + i * 23) % 30) - 15;
            const radius = 6 + ((x + y + i) % 4);

            // Stone shadow (uses global light direction)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Slightly darker
            ctx.beginPath();
            ctx.ellipse(
                centerX + offsetX + VISUALS.LIGHTING.SHADOW_OFFSET_X,
                centerY + offsetY + VISUALS.LIGHTING.SHADOW_OFFSET_Y,
                radius, radius * 0.8, 0, 0, Math.PI * 2
            );
            ctx.fill();

            // Stone body
            ctx.fillStyle = '#757575';
            ctx.beginPath();
            ctx.ellipse(centerX + offsetX, centerY + offsetY, radius, radius * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Highlight (opposite direction from shadow)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; // Brighter
            ctx.beginPath();
            ctx.ellipse(
                centerX + offsetX + VISUALS.LIGHTING.HIGHLIGHT_OFFSET_X,
                centerY + offsetY + VISUALS.LIGHTING.HIGHLIGHT_OFFSET_Y,
                radius * 0.4, radius * 0.3, 0, 0, Math.PI * 2
            );
            ctx.fill();
        }
    }

    /**
     * Draw large rocks (2-3 tiles) with varied shapes
     * Phase 5: Uses global light direction
     */
    private static drawRock(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number, size: number): void {
        const width = size * TS;
        const height = size * TS;
        const centerX = x + width / 2;
        const centerY = y + height / 2;

        // More varied vertices based on size and position
        const vertices = 5 + (size - 1) + ((x + y) % 3);

        // Create pseudo-random but deterministic variations
        const seed = x * 73 + y * 137;

        // Shadow with varied shape
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        for (let i = 0; i < vertices; i++) {
            const angle = (i / vertices) * Math.PI * 2;
            const variance = ((seed + i * 43) % 20) - 10; // -10 to +10
            const radius = width * 0.35 + variance;
            const angleOffset = ((seed + i * 23) % 30 - 15) * 0.01; // Small angle variation
            const px = centerX + Math.cos(angle + angleOffset) * radius + 4;
            const py = centerY + Math.sin(angle + angleOffset) * radius + 4;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        // Rock body with varied color
        const grayVariance = ((seed % 30) - 15);
        const grayValue = 97 + grayVariance; // Around #616161
        ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
        ctx.beginPath();
        for (let i = 0; i < vertices; i++) {
            const angle = (i / vertices) * Math.PI * 2;
            const variance = ((seed + i * 43) % 20) - 10;
            const radius = width * 0.35 + variance;
            const angleOffset = ((seed + i * 23) % 30 - 15) * 0.01;
            const px = centerX + Math.cos(angle + angleOffset) * radius;
            const py = centerY + Math.sin(angle + angleOffset) * radius;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        // Add varied texture lines
        ctx.strokeStyle = '#424242';
        ctx.lineWidth = 1 + (size - 1) * 0.5;
        const lineCount = 2 + ((seed % 4));
        for (let i = 0; i < lineCount; i++) {
            const startAngle = ((seed + i * 67) % 360) * Math.PI / 180;
            const endAngle = startAngle + (Math.PI / 4) + ((seed + i) % 20) * 0.05;
            const r1 = width * (0.1 + ((seed + i * 13) % 10) * 0.01);
            const r2 = width * (0.25 + ((seed + i * 17) % 15) * 0.01);
            ctx.beginPath();
            ctx.moveTo(centerX + Math.cos(startAngle) * r1, centerY + Math.sin(startAngle) * r1);
            ctx.lineTo(centerX + Math.cos(endAngle) * r2, centerY + Math.sin(endAngle) * r2);
            ctx.stroke();
        }

        // Varied highlight position
        const highlightX = centerX - width * 0.15 + ((seed % 20) - 10);
        const highlightY = centerY - height * 0.15 + ((seed % 15) - 7);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        ctx.arc(highlightX, highlightY, width * 0.08, 0, Math.PI * 2);
        ctx.fill();
    }

    /**
     * Draw tree (1 tile)
     * Phase 5: Uses global light direction, gradient trunk, layered foliage
     */
    private static drawTree(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        const centerX = x + TS / 2;
        const bottomY = y + TS - 5;

        // Trunk shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(centerX - 6, bottomY - 25, 14, 28);

        // Trunk
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(centerX - 5, bottomY - 25, 10, 25);

        // Foliage shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.arc(centerX + 3, bottomY - 20, 18, 0, Math.PI * 2);
        ctx.fill();

        // Foliage (3 circles for depth)
        const foliageColors = ['#1b5e20', '#2e7d32', '#388e3c'];
        const foliageOffsets = [
            { x: -5, y: -5, r: 14 },
            { x: 5, y: -3, r: 16 },
            { x: 0, y: -10, r: 15 }
        ];

        foliageOffsets.forEach((offset, i) => {
            ctx.fillStyle = foliageColors[i];
            ctx.beginPath();
            ctx.arc(centerX + offset.x, bottomY - 20 + offset.y, offset.r, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    /**
     * Draw wheat field (1 tile)
     */
    private static drawWheat(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        // Background (darker gold)
        ctx.fillStyle = '#f9a825';
        ctx.fillRect(x, y, TS, TS);

        // Wheat stalks pattern
        ctx.strokeStyle = '#fbc02d';
        ctx.lineWidth = 2;

        for (let row = 0; row < 4; row++) {
            for (let col = 0; col < 4; col++) {
                const stalkX = x + col * (TS / 4) + (TS / 8);
                const stalkY = y + row * (TS / 4) + (TS / 8);
                const offset = ((row + col) % 2) * 3;

                // Stalk
                ctx.beginPath();
                ctx.moveTo(stalkX, stalkY + 10);
                ctx.lineTo(stalkX + offset, stalkY - 2);
                ctx.stroke();

                // Wheat head
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.ellipse(stalkX + offset, stalkY - 4, 3, 5, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Border removed - was causing bright white artifacts on tiles
        // ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
        // ctx.lineWidth = 1;
        // ctx.strokeRect(x, y, TS, TS);
    }

    /**
     * Draw flowering grass (1 tile) - grass colored with varied flowers
     * –§–ê–ó–ê 3: –û–±–Ω–æ–≤–ª–µ–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ProceduralGrass –¥–ª—è —Ñ–æ–Ω–∞
     */
    private static drawFlowers(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        // –®–ê–ì 1: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å ProceduralGrass –¥–ª—è —Ñ–æ–Ω–∞
        // –í–ê–ñ–ù–û: –≠—Ç–æ —Å–æ–∑–¥–∞—ë—Ç –∏–¥–µ–Ω—Ç–∏—á–Ω—ã–π —Ñ–æ–Ω —Å –æ–±—ã—á–Ω–æ–π —Ç—Ä–∞–≤–æ–π

        // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∞–π–ª–∞
        const seed = x * 73 + y * 137;

        // –†–µ–Ω–¥–µ—Ä–∏–º –∂–∏–≤—É—é —Ç—Ä–∞–≤—É –∫–∞–∫ —Ñ–æ–Ω
        try {
            ProceduralGrass.draw(ctx, x, y, TS, seed);
        } catch (error) {
            console.error('[ObjectRenderer] ProceduralGrass.draw failed:', error);
            // Fallback - –ø—Ä–æ—Å—Ç–æ–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
            const gradient = ctx.createLinearGradient(x, y, x, y + TS);
            gradient.addColorStop(0, VISUALS.ENVIRONMENT.GRASS.LIGHT);
            gradient.addColorStop(1, VISUALS.ENVIRONMENT.GRASS.BASE);
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, TS, TS);
        }

        // –®–ê–ì 2: –ú–ù–û–ì–û –º–µ–ª–∫–∏—Ö —Ü–≤–µ—Ç–æ–≤ –ø–æ–≤–µ—Ä—Ö —Ç—Ä–∞–≤—ã
        const flowerCount = 20 + (seed % 11); // 20-30 (–±—ã–ª–æ 10-17)

        // –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –ø–∞–ª–∏—Ç—Ä–∞ (7 —Ü–≤–µ—Ç–æ–≤, –¥–æ–±–∞–≤–ª–µ–Ω –∂—ë–ª—Ç—ã–π)
        const flowerColors = [
            '#e91e63', // –†–æ–∑–æ–≤—ã–π
            '#9c27b0', // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
            '#2196f3', // –°–∏–Ω–∏–π
            '#ff9800', // –û—Ä–∞–Ω–∂–µ–≤—ã–π
            '#ffeb3b', // –ñ—ë–ª—Ç—ã–π (–ù–û–í–´–ô)
            '#f44336', // –ö—Ä–∞—Å–Ω—ã–π
            '#fff'     // –ë–µ–ª—ã–π
        ];

        for (let i = 0; i < flowerCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const fx = x + ((seed * 7 + i * 13) % TS);
            const fy = y + ((seed * 11 + i * 19) % TS);

            // –†–∞–∑–º–µ—Ä: 1.0-1.8px (–º–µ–Ω—å—à–µ —á–µ–º –±—ã–ª–æ 1.5-3px)
            const flowerSize = 1.0 + ((seed + i * 7) % 8) * 0.1; // 1.0-1.8px

            // –¶–≤–µ—Ç –∏–∑ –ø–∞–ª–∏—Ç—Ä—ã
            const colorIdx = (seed + i * 3) % flowerColors.length;

            // –£–ü–†–û–©–Å–ù–ù–ê–Ø –ì–ï–û–ú–ï–¢–†–ò–Ø: –ü—Ä–æ—Å—Ç–æ–π –∫—Ä—É–∂–æ–∫ (–≤–º–µ—Å—Ç–æ –ª–µ–ø–µ—Å—Ç–∫–æ–≤)
            // –í–Ω–µ—à–Ω–∏–π –∫—Ä—É–≥ (—Ü–≤–µ—Ç)
            ctx.fillStyle = flowerColors[colorIdx];
            ctx.beginPath();
            ctx.arc(fx, fy, flowerSize, 0, Math.PI * 2);
            ctx.fill();

            // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –±–ª–∏–∫ (–±–µ–ª—ã–π —Ü–µ–Ω—Ç—Ä)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(fx, fy, flowerSize * 0.5, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}
</file>

<file path="src/RendererFactory.ts">
import { Tower } from './Tower';
import { Enemy } from './Enemy';
import { MapManager } from './Map';
import { Projectile } from './Projectile';
import { TowerRenderer } from './renderers/TowerRenderer';
import { EnemyRenderer } from './renderers/EnemyRenderer';
import { SpriteProjectileRenderer } from './renderers/SpriteProjectileRenderer';
import { IEffect } from './EffectSystem';
// SpriteEffectRenderer is currently inline in EffectSystem.ts, we will handle that there.

export class RendererFactory {
    static drawTower(ctx: CanvasRenderingContext2D, tower: Tower) {
        // Draw Both (Legacy/Default)
        TowerRenderer.drawSprite(ctx, tower);
        TowerRenderer.drawUI(ctx, tower);
    }

    static updateTower(dt: number, tower: Tower) {
        TowerRenderer.update(dt, tower);
    }

    static drawTowerSprite(ctx: CanvasRenderingContext2D, tower: Tower) {
        TowerRenderer.drawSprite(ctx, tower);
    }

    static drawTowerUI(ctx: CanvasRenderingContext2D, tower: Tower) {
        TowerRenderer.drawUI(ctx, tower);
    }

    static drawEnemy(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        // Draw Both (Legacy/Default)
        EnemyRenderer.drawSprite(ctx, enemy);
        EnemyRenderer.drawUI(ctx, enemy);
    }

    static drawEnemySprite(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        EnemyRenderer.drawSprite(ctx, enemy);
    }

    static drawEnemyUI(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        EnemyRenderer.drawUI(ctx, enemy);
    }

    static drawMap(ctx: CanvasRenderingContext2D, map: MapManager) {
        map.draw(ctx);
    }

    static drawProjectile(ctx: CanvasRenderingContext2D, projectile: Projectile) {
        SpriteProjectileRenderer.draw(ctx, projectile);
    }

    static drawEffect(ctx: CanvasRenderingContext2D, effect: IEffect) {
        return false; // Return false to fallback to default logic in EffectSystem
    }
}
</file>

<file path="src/renderers/turrets/SniperTurretRenderer.ts">
import { ITurretRenderer } from './TurretRenderer';
import type { Tower } from '../../Tower';

/**
 * Sniper Turret Renderer
 * Features:
 * - Pulsing laser sight
 * - Scope lens flare
 * - Charging glow when targeting
 */
export class SniperTurretRenderer implements ITurretRenderer {
    readonly cardId = 'sniper';

    getTurretAsset(level: number): string {
        return `turret_sniper_${level}`;
    }

    getModuleAsset(): string {
        return 'mod_sniper';
    }

    getMuzzleOffset(): number {
        return 38;
    }

    update(dt: number, tower: Tower): void {
        // Laser pulse
        if (tower.visualState.laserPhase === undefined) {
            tower.visualState.laserPhase = 0;
        }
        tower.visualState.laserPhase += dt * 5;
        tower.visualState.laserPhase %= Math.PI * 2;

        // Lens flare
        if (tower.visualState.lensFlare === undefined) {
            tower.visualState.lensFlare = 0;
        }
        tower.visualState.lensFlare += dt * 3;
    }

    drawEffects(ctx: CanvasRenderingContext2D, tower: Tower): void {
        const level = Math.max(1, Math.max(...tower.cards.map(c => c.level)));
        const stats = tower.getStats();

        // Laser sight
        this.drawLaserSight(ctx, tower, stats.range, level);

        // Scope lens flare
        if (level >= 2) {
            this.drawLensFlare(ctx, tower, level);
        }

        // Energy rails glow (level 3)
        if (level === 3) {
            this.drawEnergyRails(ctx, tower);
        }
    }

    private drawLaserSight(
        ctx: CanvasRenderingContext2D,
        tower: Tower,
        range: number,
        level: number
    ): void {
        const phase = tower.visualState.laserPhase || 0;
        const opacity = 0.3 + Math.sin(phase) * 0.15;
        const muzzle = this.getMuzzleOffset();

        ctx.save();
        ctx.globalCompositeOperation = 'screen';

        // Main laser line
        ctx.strokeStyle = '#ff1744';
        ctx.globalAlpha = opacity;
        ctx.lineWidth = 1 + level * 0.3;

        ctx.beginPath();
        ctx.moveTo(muzzle, 0);
        ctx.lineTo(range, 0);
        ctx.stroke();

        // Targeting dot
        ctx.fillStyle = '#ff1744';
        ctx.globalAlpha = opacity * 1.5;
        ctx.beginPath();
        ctx.arc(range, 0, 2 + level * 0.5, 0, Math.PI * 2);
        ctx.fill();

        // Dot glow (Simple transparency layers instead of gradient)
        // PERF: Replaced createRadialGradient with multiple arc fills or just simple glow

        // Layer 1: Outer soft glow
        ctx.fillStyle = 'rgba(255, 23, 68, 0.2)';
        ctx.beginPath();
        ctx.arc(range, 0, 6, 0, Math.PI * 2);
        ctx.fill();

        // Layer 2: Inner core
        ctx.fillStyle = 'rgba(255, 23, 68, 0.8)';
        ctx.beginPath();
        ctx.arc(range, 0, 2 + level * 0.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    private drawLensFlare(ctx: CanvasRenderingContext2D, tower: Tower, level: number): void {
        const flare = tower.visualState.lensFlare || 0;
        const intensity = 0.3 + Math.sin(flare) * 0.2;

        // Scope position (on turret body, offset for scope)
        const scopeX = 6;
        const scopeY = -10;

        ctx.fillStyle = `rgba(77,208,225,${intensity})`;
        ctx.beginPath();
        ctx.arc(scopeX, scopeY, 4, 0, Math.PI * 2);
        ctx.fill();

        // Reflection highlight
        ctx.fillStyle = `rgba(255,255,255,${intensity * 0.8})`;
        ctx.beginPath();
        ctx.arc(scopeX - 1, scopeY - 1, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawEnergyRails(ctx: CanvasRenderingContext2D, tower: Tower): void {
        const phase = tower.visualState.laserPhase || 0;
        const intensity = 0.3 + Math.sin(phase * 1.5) * 0.2;

        ctx.strokeStyle = `rgba(105,240,174,${intensity})`;
        ctx.lineWidth = 1.5;

        // Energy arc along rails
        const arcLen = 20 + Math.sin(phase) * 5;

        ctx.beginPath();
        ctx.moveTo(10, -4);
        ctx.lineTo(10 + arcLen, -3);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(10, 4);
        ctx.lineTo(10 + arcLen, 3);
        ctx.stroke();
    }
}
</file>

<file path="src/renderers/turrets/TurretRenderer.ts">
import type { Tower } from '../../Tower';

/**
 * Interface for turret-specific renderers
 * Similar to UnitRenderer for enemies
 */
export interface ITurretRenderer {
    /** Card ID for mapping */
    readonly cardId: string;

    /** Get turret asset name based on level */
    getTurretAsset(level: number): string;

    /** Get module asset name (for slots 1-2) */
    getModuleAsset(): string;

    /** 
     * Get muzzle offset from tower center (px) 
     * Used for projectile spawn point and muzzle flash
     */
    getMuzzleOffset(): number;

    /** 
     * Additional rendering after turret (laser, heat haze)
     * Called INSIDE rotated+recoiled context ‚Äî effects move with barrel
     */
    drawEffects?(ctx: CanvasRenderingContext2D, tower: Tower): void;

    /**
     * Update visual state (animations, particles)
     * Called every frame
     */
    update?(dt: number, tower: Tower): void;

    /**
     * Draw preview of turret for ghost building
     * @param ctx Context to draw to
     * @param x Center X
     * @param y Center Y
     */
    drawPreview?(ctx: CanvasRenderingContext2D, x: number, y: number): void;

    /**
     * Custom turret drawing (replaces standard sprite drawing)
     * 
     * Rendering Contract (set by TowerRenderer.drawActiveSprite):
     * 1. Context translated to tower center (tower.x, tower.y).
     * 2. Context rotated by tower.angle (0 = East/Right).
     * 3. Context scaled by level multiplier (1.0 + (level-1) * 0.15).
     * 4. Context translated by tower.barrelRecoil on X axis (negative = kickback).
     * 5. +X axis is forward (towards target).
     * 6. Origin (0,0) is tower center.
     * 7. drawEffects() is called in the SAME transformed context.
     * 
     * @param ctx Context to draw to
     * @param tower Tower instance
     */
    drawTurret?(ctx: CanvasRenderingContext2D, tower: Tower): void;
}

/**
 * Default renderer for unknown cards or empty towers
 */
export class DefaultTurretRenderer implements ITurretRenderer {
    readonly cardId = 'default';

    getTurretAsset(level: number): string {
        return 'turret_standard';
    }

    getModuleAsset(): string {
        return '';
    }

    getMuzzleOffset(): number {
        return 22; // Default barrel length
    }
}
</file>

<file path="src/renderers/units/FleshUnitRenderer.ts">
import { CachedUnitRenderer } from './CachedUnitRenderer';
import { UnitRenderer } from './UnitRenderer';
import type { Enemy } from '../../Enemy';
import { Assets } from '../../Assets';

/**
 * FleshUnitRenderer v2.0 ‚Äî "Flesh Colossus" / "Meat Pi√±ata"
 * 
 * AAA-Quality Visual: Grotesque abomination of stitched flesh, embedded victims,
 * pulsating organs, tentacle appendages, dripping gore, heavy shambling animation.
 */
export class FleshUnitRenderer extends CachedUnitRenderer {
    // ü©∏ FLESH PALETTE ‚Äî Layered tones for depth
    private static readonly FLESH_DEEPEST = '#3a1818';

    protected walkCycleMultiplier: number = 0.2; // Slower, heavy movement
    protected override orientationMode = 'DIR3' as const;
    private static readonly FLESH_DARK = '#4a2020';
    private static readonly FLESH_MID = '#6d3030';
    private static readonly FLESH_LIGHT = '#8d4545';
    private static readonly FLESH_PALE = '#a06060';
    private static readonly FLESH_HIGHLIGHT = '#c08080';

    // ü¶¥ BONE & STITCH
    private static readonly STITCH_DARK = '#0a0a0a';
    private static readonly STITCH_THREAD = '#2a2020';
    private static readonly BONE_PALE = '#e8e0d8';
    private static readonly BONE_MID = '#d7ccc8';
    private static readonly BONE_DARK = '#a1887f';

    // ü©∏ GORE
    private static readonly BLOOD_BRIGHT = '#cc0000';
    private static readonly BLOOD_DARK = '#5c1010';
    private static readonly BLOOD_DRIP = '#8b0000';
    private static readonly GORE_PINK = '#cc6666';
    private static readonly ORGAN_RED = '#991111';
    private static readonly ORGAN_PURPLE = '#6a1b4d';

    // üëÅ EYES & GLOW
    private static readonly EYE_WHITE = '#f5f5dc';
    private static readonly EYE_PUPIL = '#1a1a1a';
    private static readonly EYE_BLOODSHOT = '#ff6666';
    private static readonly GLOW_SICKLY = '#88ff88';

    constructor() {
        super();
        this.walkCycleMultiplier = 0.06; // Very slow shamble
    }

    // BAKING SUPPORT
    public getBakeFacings(): ('SIDE' | 'UP' | 'DOWN')[] {
        return ['SIDE', 'UP', 'DOWN'];
    }

    public drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: 'SIDE' | 'UP' | 'DOWN') {
        const cycle = t * Math.PI * 2;
        const scale = 1.0;
        const colossusScale = scale * 1.1;
        const isMoving = true;
        const time = t * 10;
        const hp = 1.0; // Bake healthy

        if (facing === 'UP') return this.drawBack(ctx, colossusScale, cycle, isMoving, time, hp);
        if (facing === 'DOWN') return this.drawFront(ctx, colossusScale, cycle, isMoving, time, hp);
        return this.drawSide(ctx, colossusScale, cycle, isMoving, time, hp);
    }

    drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void {
        this.drawFrameDirectional(ctx, enemy, t, 'SIDE');
    }

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const hpPercent = enemy.currentHealth / enemy.maxHealth;

        // 1. If Damaged (HP < 50%), force procedural rendering to show gore/wounds
        if (hpPercent <= 0.5) {
            const time = Date.now() * 0.001;
            const walkCycle = time * (enemy.baseSpeed * this.walkCycleMultiplier);
            const isMoving = !enemy.finished && enemy.currentHealth > 0;

            this.drawProceduralFull(ctx, enemy, scale, rotation, walkCycle, isMoving, hpPercent);
            return;
        }

        // 2. Otherwise use Cached version
        super.drawBody(ctx, enemy, scale, rotation);
    }

    /**
     * Full procedural rendering with directional support (Used for Damaged state or fallback)
     */
    private drawProceduralFull(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number, walkCycle: number, isMoving: boolean, hpPercent: number) {
        const colossusScale = scale * 1.1;
        const time = Date.now() * 0.001; // Need absolute time for breathing/pulsing

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        ctx.save();

        // Manual hit flash since we bypassed super.drawBody
        if (enemy.hitFlashTimer > 0) {
            ctx.globalAlpha = 0.7;
        }

        if (facing === 'SIDE') {
            if (Math.abs(rotation) > Math.PI / 2) {
                ctx.scale(-1, 1);
            }
            this.drawSide(ctx, colossusScale, walkCycle, isMoving, time, hpPercent);
        } else if (facing === 'UP') {
            this.drawBack(ctx, colossusScale, walkCycle, isMoving, time, hpPercent);
        } else {
            this.drawFront(ctx, colossusScale, walkCycle, isMoving, time, hpPercent);
        }

        ctx.restore();
    }


    // =====================================================================
    // SIDE VIEW ‚Äî Shambling Horror
    // =====================================================================
    private drawSide(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, t: number, hp: number) {
        // Animation variables
        const sway = isMoving ? Math.sin(cycle) * 0.06 : Math.sin(t * 0.5) * 0.02;
        const bounce = isMoving ? Math.abs(Math.sin(cycle * 0.5)) * 3 * s : 0;
        const breathe = Math.sin(t * 1.5) * 0.08;
        const pulse = 1 + breathe;
        const heavePulse = 1 + Math.sin(t * 2.5) * 0.04;

        ctx.translate(0, -bounce);
        ctx.rotate(sway);

        // Slime trail removed - was static and unnatural

        // 2. BACK TENTACLES (behind body)
        this.drawTentacles(ctx, -6 * s, 2 * s, s, t, true);

        // 3. FAR LEG ‚Äî connected to body at waist
        this.drawLegSide(ctx, -3 * s, 6 * s, cycle, Math.PI, s * 0.85, true);

        // 4. MAIN BODY MASS
        this.drawMainBodySide(ctx, s, t, pulse, heavePulse);

        // 5. FAT ROLLS & SKIN FOLDS
        this.drawFatRolls(ctx, s, t);

        // 6. EMBEDDED BONES & WEAPONS
        this.drawEmbeddedDebris(ctx, s, t);

        // 7. INTERNAL ORGANS (visible through wounds)
        this.drawVisibleOrgans(ctx, s, t, hp);

        // 8. STITCHES ‚Äî crude surgical seams
        this.drawStitchesSide(ctx, s, t);

        // 9. NEAR LEG ‚Äî connected at waist level
        this.drawLegSide(ctx, 4 * s, 6 * s, cycle, 0, s, false);

        // 10. FRONT TENTACLE/ARM
        this.drawTentacles(ctx, 8 * s, -2 * s, s, t, false);

        // 11. EMBEDDED FACES (victims)
        this.drawEmbeddedFaces(ctx, s, t);

        // 12. HEAD ‚Äî Small, grotesque
        ctx.save();
        ctx.translate(9 * s, -10 * s);
        ctx.rotate(Math.sin(t * 0.8) * 0.1);
        this.drawHeadSide(ctx, s * 0.6, t);
        ctx.restore();

        // 13. DRIPPING GORE
        this.drawDrippingGore(ctx, s, t, isMoving);

        // 14. DAMAGE EFFECTS (low HP = more gore)
        if (hp < 0.5) {
            this.drawDamageEffects(ctx, s, t, hp);
        }
    }

    private drawMainBodySide(ctx: CanvasRenderingContext2D, s: number, t: number, pulse: number, heavePulse: number) {
        // ============================================
        // MUSCULAR UPPER BODY (Shoulders + Torso)
        // ============================================

        // Strong shoulder/back muscles
        const shoulderGrad = ctx.createLinearGradient(-8 * s, -12 * s, 8 * s, -4 * s);
        shoulderGrad.addColorStop(0, FleshUnitRenderer.FLESH_DARK);
        shoulderGrad.addColorStop(0.5, FleshUnitRenderer.FLESH_MID);
        shoulderGrad.addColorStop(1, FleshUnitRenderer.FLESH_DARK);

        ctx.fillStyle = shoulderGrad;
        ctx.beginPath();

        // Neck base
        ctx.moveTo(8 * s, -6 * s);

        // BROAD SHOULDERS ‚Äî angular, powerful
        ctx.lineTo(6 * s, -10 * s);
        ctx.bezierCurveTo(4 * s, -14 * s, -2 * s, -14 * s, -6 * s, -12 * s);

        // TRAPEZIUS hump (muscle)
        ctx.bezierCurveTo(-10 * s, -11 * s, -11 * s, -8 * s, -10 * s, -4 * s);

        // LATS (side muscles) ‚Äî angular cut
        ctx.lineTo(-9 * s, 0);
        ctx.lineTo(-7 * s, 2 * s);

        // Waist (narrower than shoulders)
        ctx.lineTo(-5 * s, 3 * s);

        // Connect to chest
        ctx.lineTo(4 * s, 0);
        ctx.lineTo(8 * s, -2 * s);
        ctx.closePath();
        ctx.fill();

        // Shoulder muscle definition
        ctx.fillStyle = FleshUnitRenderer.FLESH_LIGHT;
        ctx.beginPath();
        ctx.ellipse(-2 * s, -10 * s, 5 * s, 3 * s, -0.2, 0, Math.PI * 2);
        ctx.fill();

        // Deltoid highlight
        ctx.fillStyle = FleshUnitRenderer.FLESH_HIGHLIGHT;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.ellipse(-1 * s, -11 * s, 2.5 * s, 1.5 * s, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;

        // ============================================
        // BLOATED BELLY (Where enemies are hidden)
        // ============================================

        const bellyPulse = 1 + Math.sin(t * 1.5) * 0.08; // Slow, heavy breathing
        const bellyKick = Math.sin(t * 3 + 1) * 0.05; // Something moving inside

        // Belly gradient ‚Äî stretched, veiny
        const bellyGrad = ctx.createRadialGradient(0, 5 * s, 1 * s, 0, 5 * s, 10 * s * bellyPulse);
        bellyGrad.addColorStop(0, FleshUnitRenderer.FLESH_PALE);
        bellyGrad.addColorStop(0.6, FleshUnitRenderer.FLESH_LIGHT);
        bellyGrad.addColorStop(1, FleshUnitRenderer.FLESH_MID);

        ctx.fillStyle = bellyGrad;
        ctx.beginPath();

        // Belly attached at waist
        ctx.moveTo(-5 * s, 3 * s);

        // Massive protruding belly
        ctx.bezierCurveTo(
            -8 * s * bellyPulse, 6 * s,
            -10 * s * (bellyPulse + bellyKick), 10 * s,
            -4 * s, 12 * s
        );

        // Bottom of belly (saggy, heavy)
        ctx.bezierCurveTo(
            0, 14 * s * bellyPulse,
            6 * s, 13 * s,
            8 * s, 10 * s * (bellyPulse + bellyKick)
        );

        // Back to waist
        ctx.bezierCurveTo(
            6 * s, 5 * s,
            5 * s, 2 * s,
            4 * s, 0
        );

        ctx.closePath();
        ctx.fill();

        // BELLY STRETCH MARKS ‚Äî skin under tension
        ctx.strokeStyle = FleshUnitRenderer.FLESH_DARK;
        ctx.lineWidth = 0.6 * s;
        ctx.globalAlpha = 0.6;
        for (let i = 0; i < 4; i++) {
            const angle = -0.5 + i * 0.3;
            ctx.beginPath();
            ctx.moveTo(-2 * s + i * 2 * s, 4 * s);
            ctx.quadraticCurveTo(
                -4 * s + i * 2 * s + Math.sin(t + i) * s * bellyKick,
                8 * s,
                -3 * s + i * 2 * s,
                11 * s
            );
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;

        // SOMETHING MOVING INSIDE ‚Äî visible bump
        const bumpX = Math.sin(t * 2) * 3 * s;
        const bumpY = 7 * s + Math.cos(t * 2.5) * 2 * s;
        ctx.fillStyle = FleshUnitRenderer.FLESH_HIGHLIGHT;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.ellipse(bumpX, bumpY, 2.5 * s, 2 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;

        // Belly veins (stressed skin)
        this.drawBellyVeins(ctx, s, t, bellyPulse);

        // Surface veins on upper body
        this.drawVeins(ctx, s, t);
    }

    private drawBellyVeins(ctx: CanvasRenderingContext2D, s: number, t: number, pulse: number) {
        const veinPulse = 0.6 + Math.sin(t * 4) * 0.4;

        ctx.strokeStyle = FleshUnitRenderer.BLOOD_DARK;
        ctx.lineWidth = 1 * s;
        ctx.globalAlpha = veinPulse * 0.5;

        // Prominent veins radiating from belly center
        ctx.beginPath();
        ctx.moveTo(-5 * s, 5 * s);
        ctx.quadraticCurveTo(-7 * s, 8 * s, -6 * s, 11 * s);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(2 * s, 5 * s);
        ctx.quadraticCurveTo(5 * s, 8 * s, 6 * s, 11 * s);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(-1 * s, 6 * s);
        ctx.quadraticCurveTo(-2 * s, 10 * s, 0, 13 * s);
        ctx.stroke();

        ctx.globalAlpha = 1.0;
    }

    private drawVeins(ctx: CanvasRenderingContext2D, s: number, t: number) {
        const veinPulse = 0.7 + Math.sin(t * 3) * 0.3;

        ctx.strokeStyle = FleshUnitRenderer.BLOOD_DARK;
        ctx.lineWidth = 0.8 * s;
        ctx.globalAlpha = veinPulse * 0.5;

        // Branching veins
        ctx.beginPath();
        ctx.moveTo(-4 * s, -6 * s);
        ctx.quadraticCurveTo(-2 * s, -3 * s, 0, 0);
        ctx.quadraticCurveTo(3 * s, 2 * s, 5 * s, 0);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(2 * s, -10 * s);
        ctx.quadraticCurveTo(4 * s, -6 * s, 3 * s, -2 * s);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(-8 * s, -2 * s);
        ctx.quadraticCurveTo(-5 * s, 2 * s, -2 * s, 4 * s);
        ctx.stroke();

        ctx.globalAlpha = 1.0;
    }

    private drawFatRolls(ctx: CanvasRenderingContext2D, s: number, t: number) {
        const wobble = Math.sin(t * 2) * 0.5 * s;

        // Multiple overlapping fat folds
        ctx.fillStyle = FleshUnitRenderer.FLESH_DARK;

        // Lower belly roll
        ctx.beginPath();
        ctx.ellipse(2 * s, 6 * s + wobble, 6 * s, 2 * s, 0.1, 0, Math.PI);
        ctx.fill();

        // Side roll
        ctx.beginPath();
        ctx.ellipse(-8 * s, 0, 3 * s, 4 * s, 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Upper fold crease
        ctx.strokeStyle = FleshUnitRenderer.FLESH_DEEPEST;
        ctx.lineWidth = 1.2 * s;
        ctx.beginPath();
        ctx.moveTo(-6 * s, -4 * s);
        ctx.quadraticCurveTo(-2 * s, -2 * s + wobble, 4 * s, -3 * s);
        ctx.stroke();
    }

    private drawEmbeddedDebris(ctx: CanvasRenderingContext2D, s: number, t: number) {
        // Bone shard 1 ‚Äî protruding from shoulder
        ctx.save();
        ctx.translate(-4 * s, -10 * s);
        ctx.rotate(-0.5);

        ctx.fillStyle = FleshUnitRenderer.BONE_PALE;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(1.5 * s, -1 * s);
        ctx.lineTo(1 * s, -8 * s);
        ctx.lineTo(-0.5 * s, -7 * s);
        ctx.lineTo(-1 * s, 0);
        ctx.fill();

        // Bone joint
        ctx.fillStyle = FleshUnitRenderer.BONE_DARK;
        ctx.beginPath();
        ctx.ellipse(0.3 * s, -7.5 * s, 1.5 * s, 1 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Rusted blade embedded
        ctx.save();
        ctx.translate(4 * s, -4 * s);
        ctx.rotate(0.6);

        // Blade
        ctx.fillStyle = '#5d4037';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(2 * s, 0);
        ctx.lineTo(1 * s, 10 * s);
        ctx.lineTo(-0.5 * s, 9 * s);
        ctx.fill();

        // Blood around entry
        ctx.fillStyle = FleshUnitRenderer.BLOOD_DARK;
        ctx.beginPath();
        ctx.ellipse(0.5 * s, 1 * s, 2 * s, 1.5 * s, 0.3, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Chain links
        ctx.strokeStyle = '#78909c';
        ctx.lineWidth = 1.5 * s;
        ctx.beginPath();
        ctx.ellipse(-9 * s, -6 * s, 1.5 * s, 2 * s, 0.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(-10 * s, -4 * s, 1.5 * s, 2 * s, -0.3, 0, Math.PI * 2);
        ctx.stroke();
    }

    private drawVisibleOrgans(ctx: CanvasRenderingContext2D, s: number, t: number, hp: number) {
        const organPulse = 1 + Math.sin(t * 4) * 0.15;
        const visibility = hp < 0.7 ? 0.8 : 0.5; // More visible when damaged

        ctx.globalAlpha = visibility;

        // Wound opening
        ctx.fillStyle = FleshUnitRenderer.FLESH_DEEPEST;
        ctx.beginPath();
        ctx.ellipse(-2 * s, 1 * s, 3 * s, 2 * s, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Intestine coils
        ctx.fillStyle = FleshUnitRenderer.GORE_PINK;
        ctx.beginPath();
        ctx.arc(-2 * s, 1.5 * s, 1.5 * s * organPulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(-0.5 * s, 0.5 * s, 1 * s * organPulse, 0, Math.PI * 2);
        ctx.fill();

        // Pulsating organ (heart-like)
        const heartBeat = 1 + Math.sin(t * 6) * 0.2;
        ctx.fillStyle = FleshUnitRenderer.ORGAN_RED;

        // Fake Glow
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.ellipse(0, -2 * s, 2.5 * s * heartBeat, 2.0 * s * heartBeat, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1.0;
        ctx.beginPath();
        ctx.ellipse(0, -2 * s, 2 * s * heartBeat, 1.5 * s * heartBeat, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1.0;
    }

    private drawStitchesSide(ctx: CanvasRenderingContext2D, s: number, t: number) {
        ctx.strokeStyle = FleshUnitRenderer.STITCH_DARK;
        ctx.lineWidth = 1.8 * s;

        // Main horizontal stitch
        ctx.setLineDash([3 * s, 2 * s]);
        ctx.beginPath();
        ctx.moveTo(-8 * s, -4 * s);
        ctx.quadraticCurveTo(0, -2 * s, 7 * s, -5 * s);
        ctx.stroke();

        // Diagonal stitch across body
        ctx.beginPath();
        ctx.moveTo(3 * s, -12 * s);
        ctx.quadraticCurveTo(-2 * s, -4 * s, -4 * s, 4 * s);
        ctx.stroke();

        // Cross-stitch detail
        ctx.setLineDash([]);
        ctx.lineWidth = 1 * s;

        // Individual stitch marks (X pattern)
        const stitchPoints = [
            { x: -6, y: -4 }, { x: -2, y: -3 }, { x: 2, y: -4 }, { x: 5, y: -5 }
        ];

        stitchPoints.forEach(p => {
            ctx.beginPath();
            ctx.moveTo((p.x - 0.8) * s, (p.y - 0.8) * s);
            ctx.lineTo((p.x + 0.8) * s, (p.y + 0.8) * s);
            ctx.moveTo((p.x + 0.8) * s, (p.y - 0.8) * s);
            ctx.lineTo((p.x - 0.8) * s, (p.y + 0.8) * s);
            ctx.stroke();
        });

        // Stitch thread ends
        ctx.strokeStyle = FleshUnitRenderer.STITCH_THREAD;
        ctx.lineWidth = 0.6 * s;
        ctx.beginPath();
        ctx.moveTo(-8 * s, -4 * s);
        ctx.lineTo(-9 * s, -3 * s);
        ctx.moveTo(7 * s, -5 * s);
        ctx.lineTo(8 * s, -4 * s);
        ctx.stroke();
    }

    private drawEmbeddedFaces(ctx: CanvasRenderingContext2D, s: number, t: number) {
        // Screaming face embedded in flesh
        ctx.save();
        ctx.translate(-5 * s, 3 * s);
        ctx.rotate(0.4);

        // Face outline (partially absorbed)
        ctx.fillStyle = FleshUnitRenderer.FLESH_PALE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.5 * s, 3 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Stitched shut eyes
        ctx.strokeStyle = FleshUnitRenderer.STITCH_DARK;
        ctx.lineWidth = 0.6 * s;
        ctx.beginPath();
        ctx.moveTo(-1.5 * s, -1 * s);
        ctx.lineTo(-0.5 * s, -0.8 * s);
        ctx.moveTo(0.5 * s, -0.8 * s);
        ctx.lineTo(1.5 * s, -1 * s);
        ctx.stroke();

        // Screaming mouth (opening and closing)
        const mouthOpen = Math.sin(t * 2) * 0.3 + 0.5;
        ctx.fillStyle = FleshUnitRenderer.FLESH_DEEPEST;
        ctx.beginPath();
        ctx.ellipse(0, 1.5 * s, 1 * s, mouthOpen * s, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Second face (barely visible, absorbed)
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = FleshUnitRenderer.FLESH_MID;
        ctx.beginPath();
        ctx.ellipse(6 * s, 4 * s, 1.8 * s, 2 * s, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    private drawTentacles(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, t: number, back: boolean) {
        const wave1 = Math.sin(t * 2 + x * 0.1);
        const wave2 = Math.sin(t * 2.5 + y * 0.1);

        ctx.save();
        ctx.translate(x, y);

        const alpha = back ? 0.7 : 1.0;
        ctx.globalAlpha = alpha;

        // Create gradient for tentacle
        const tentGrad = ctx.createLinearGradient(0, 0, 0, 8 * s);
        tentGrad.addColorStop(0, FleshUnitRenderer.FLESH_MID);
        tentGrad.addColorStop(1, FleshUnitRenderer.FLESH_DARK);

        ctx.fillStyle = tentGrad;
        ctx.strokeStyle = FleshUnitRenderer.FLESH_DARK;
        ctx.lineWidth = 0.8 * s;

        // Wavy tentacle shape
        ctx.beginPath();
        ctx.moveTo(-1.5 * s, 0);
        ctx.quadraticCurveTo(
            wave1 * 3 * s, 3 * s,
            wave2 * 2 * s, 7 * s
        );
        ctx.quadraticCurveTo(
            wave1 * 2 * s + 1 * s, 3 * s,
            1.5 * s, 0
        );
        ctx.fill();
        ctx.stroke();

        // Suction cups
        if (!back) {
            ctx.fillStyle = FleshUnitRenderer.FLESH_DEEPEST;
            for (let i = 0; i < 3; i++) {
                const cupY = 2 * s + i * 2 * s;
                const cupX = wave1 * (1 + i * 0.3) * s;
                ctx.beginPath();
                ctx.ellipse(cupX, cupY, 0.5 * s, 0.3 * s, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.globalAlpha = 1.0;
        ctx.restore();
    }

    private drawSlimeTrail(ctx: CanvasRenderingContext2D, s: number, t: number) {
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = FleshUnitRenderer.GORE_PINK;

        // Multiple slime puddles behind
        for (let i = 0; i < 3; i++) {
            const offset = -15 * s - i * 8 * s;
            const size = (3 - i) * 1.5 * s;
            ctx.beginPath();
            ctx.ellipse(offset, 10 * s, size, size * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.globalAlpha = 1.0;
    }

    private drawDrippingGore(ctx: CanvasRenderingContext2D, s: number, t: number, isMoving: boolean) {
        // Blood drips
        const dripPhase = (t * 2) % 1;

        ctx.fillStyle = FleshUnitRenderer.BLOOD_DRIP;
        ctx.globalAlpha = 0.8;

        // Drip 1 ‚Äî from belly
        const drip1Y = 8 * s + dripPhase * 10 * s;
        const drip1Alpha = 1 - dripPhase;
        ctx.globalAlpha = drip1Alpha * 0.8;
        ctx.beginPath();
        ctx.ellipse(2 * s, drip1Y, 0.8 * s, 1.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Drip 2 ‚Äî from wound (offset phase)
        const drip2Phase = ((t * 1.7) + 0.5) % 1;
        const drip2Y = 5 * s + drip2Phase * 12 * s;
        ctx.globalAlpha = (1 - drip2Phase) * 0.7;
        ctx.beginPath();
        ctx.ellipse(-3 * s, drip2Y, 0.6 * s, 1.2 * s, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Constant ooze at bottom
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = FleshUnitRenderer.GORE_PINK;
        ctx.beginPath();
        ctx.ellipse(0, 11 * s, 5 * s, 1.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1.0;
    }

    private drawDamageEffects(ctx: CanvasRenderingContext2D, s: number, t: number, hp: number) {
        // More wounds visible at low HP
        const woundCount = hp < 0.3 ? 3 : 2;

        ctx.fillStyle = FleshUnitRenderer.BLOOD_DARK;

        for (let i = 0; i < woundCount; i++) {
            const wx = (-4 + i * 4) * s;
            const wy = (-8 + i * 5) * s;

            // Dark wound cavity
            ctx.fillStyle = FleshUnitRenderer.FLESH_DEEPEST;
            ctx.beginPath();
            ctx.ellipse(wx, wy, 1.5 * s, 2 * s, i * 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Blood oozing
            ctx.fillStyle = FleshUnitRenderer.BLOOD_DARK;
            ctx.beginPath();
            ctx.ellipse(wx, wy + 2 * s, 1 * s, 1.5 * s, 0, 0, Math.PI);
            ctx.fill();
        }
    }

    private drawHeadSide(ctx: CanvasRenderingContext2D, s: number, t: number) {
        // Misshapen lump of a head
        ctx.fillStyle = FleshUnitRenderer.FLESH_MID;
        ctx.beginPath();
        ctx.ellipse(0, 0, 5 * s, 4 * s, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Tumor/growth
        ctx.fillStyle = FleshUnitRenderer.FLESH_LIGHT;
        ctx.beginPath();
        ctx.ellipse(-2 * s, -2 * s, 2 * s, 1.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // MULTIPLE EYES ‚Äî asymmetric
        // Main eye (bloodshot, staring)
        const eyePulse = 1 + Math.sin(t * 6) * 0.1;
        ctx.fillStyle = FleshUnitRenderer.EYE_WHITE;
        ctx.beginPath();
        ctx.ellipse(2 * s, 0, 1.8 * s * eyePulse, 1.4 * s * eyePulse, 0.1, 0, Math.PI * 2);
        ctx.fill();

        // Bloodshot veins in eye
        ctx.strokeStyle = FleshUnitRenderer.EYE_BLOODSHOT;
        ctx.lineWidth = 0.3 * s;
        ctx.beginPath();
        ctx.moveTo(0.5 * s, 0);
        ctx.lineTo(1.5 * s, -0.3 * s);
        ctx.moveTo(0.5 * s, 0.3 * s);
        ctx.lineTo(1.3 * s, 0.5 * s);
        ctx.stroke();

        // Pupil (tiny, pinpoint)
        ctx.fillStyle = FleshUnitRenderer.EYE_PUPIL;
        ctx.beginPath();
        ctx.arc(2.2 * s, 0, 0.5 * s, 0, Math.PI * 2);
        ctx.fill();

        // Second eye (smaller, half-closed)
        ctx.fillStyle = FleshUnitRenderer.EYE_WHITE;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.ellipse(0, 1.5 * s, 1 * s, 0.6 * s, -0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = FleshUnitRenderer.EYE_PUPIL;
        ctx.beginPath();
        ctx.arc(0.3 * s, 1.5 * s, 0.3 * s, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;

        // Third eye (closed/stitched shut)
        ctx.strokeStyle = FleshUnitRenderer.STITCH_DARK;
        ctx.lineWidth = 0.8 * s;
        ctx.beginPath();
        ctx.moveTo(-2 * s, 0.5 * s);
        ctx.lineTo(-0.5 * s, 0.8 * s);
        ctx.stroke();

        // Mouth ‚Äî drooling maw, no lips
        ctx.fillStyle = FleshUnitRenderer.FLESH_DEEPEST;
        ctx.beginPath();
        ctx.ellipse(3 * s, 2 * s, 1.5 * s, 1 * s, 0.3, 0, Math.PI);
        ctx.fill();

        // Drool
        ctx.strokeStyle = FleshUnitRenderer.GORE_PINK;
        ctx.lineWidth = 0.5 * s;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.moveTo(3 * s, 3 * s);
        ctx.quadraticCurveTo(3.5 * s, 5 * s, 3 * s, 7 * s);
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }

    // =====================================================================
    // FRONT VIEW ‚Äî Full detail matching Side view (14 elements)
    // =====================================================================
    private drawFront(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, t: number, hp: number) {
        // Animation variables (same as Side)
        const sway = isMoving ? Math.sin(cycle) * 0.04 : Math.sin(t * 0.5) * 0.02;
        const bounce = isMoving ? Math.abs(Math.sin(cycle * 0.5)) * 2 * s : 0;
        const breathe = Math.sin(t * 1.5) * 0.06;
        const pulse = 1 + breathe;
        const heavePulse = 1 + Math.sin(t * 2.5) * 0.03;

        ctx.translate(0, -bounce);
        ctx.rotate(sway);

        // 1. BACK TENTACLES (behind body, near shoulders)
        this.drawTentacles(ctx, -9 * s, -3 * s, s * 0.7, t, true);
        this.drawTentacles(ctx, 9 * s, -3 * s, s * 0.7, t, true);

        // 2. FAR LEGS (behind)
        this.drawLegFront(ctx, -4 * s, 5 * s, cycle, Math.PI, s * 0.8, true);
        this.drawLegFront(ctx, 4 * s, 5 * s, cycle, 0, s * 0.75, true);

        // 3. MAIN BODY ‚Äî Muscular upper body
        this.drawMainBodyFront(ctx, s, t, pulse, heavePulse);

        // 4. FAT ROLLS (on sides)
        this.drawFatRollsFront(ctx, s, t);

        // 5. EMBEDDED DEBRIS (bones, chains, weapons)
        this.drawEmbeddedDebrisFront(ctx, s, t);

        // 6. VISIBLE ORGANS (wound on belly)
        this.drawVisibleOrgansFront(ctx, s, t, hp);

        // 7. STITCHES (vertical and horizontal)
        this.drawStitchesFront(ctx, s, t);

        // 8. NEAR ARMS / TENTACLES (in front)
        this.drawTentacles(ctx, -11 * s, 0, s * 0.8, t, false);
        this.drawTentacles(ctx, 11 * s, 0, s * 0.8, t, false);

        // 9. EMBEDDED FACES
        this.drawEmbeddedFacesFront(ctx, s, t);

        // 10. HEAD ‚Äî Small, grotesque, animated
        ctx.save();
        ctx.translate(0, -9 * s);
        ctx.rotate(Math.sin(t * 0.8) * 0.08);
        this.drawHeadFront(ctx, s * 0.55, t);
        ctx.restore();

        // 11. DRIPPING GORE
        this.drawDrippingGore(ctx, s, t, isMoving);

        // 12. DAMAGE EFFECTS (low HP)
        if (hp < 0.5) {
            this.drawDamageEffectsFront(ctx, s, t, hp);
        }
    }

    // =====================================================================
    // FRONT VIEW HELPER METHODS
    // =====================================================================

    private drawMainBodyFront(ctx: CanvasRenderingContext2D, s: number, t: number, pulse: number, heavePulse: number) {
        // UPPER BODY ‚Äî Massive, rounded shoulders
        const bodyGrad = ctx.createRadialGradient(0, -3 * s, 2 * s, 0, 0, 12 * s);
        bodyGrad.addColorStop(0, FleshUnitRenderer.FLESH_LIGHT);
        bodyGrad.addColorStop(0.5, FleshUnitRenderer.FLESH_MID);
        bodyGrad.addColorStop(1, FleshUnitRenderer.FLESH_DARK);

        ctx.fillStyle = bodyGrad;
        ctx.beginPath();

        // Neck
        ctx.moveTo(0, -9 * s);

        // LEFT SHOULDER
        ctx.bezierCurveTo(-3 * s, -10 * s, -8 * s * pulse, -8 * s, -9 * s, -4 * s);

        // LEFT SIDE
        ctx.bezierCurveTo(-10 * s * heavePulse, -1 * s, -8 * s, 2 * s, -5 * s, 4 * s);

        // WAIST
        ctx.lineTo(5 * s, 4 * s);

        // RIGHT SIDE
        ctx.bezierCurveTo(8 * s, 2 * s, 10 * s * heavePulse, -1 * s, 9 * s, -4 * s);

        // RIGHT SHOULDER
        ctx.bezierCurveTo(8 * s * pulse, -8 * s, 3 * s, -10 * s, 0, -9 * s);

        ctx.fill();

        // Shoulder highlights
        ctx.fillStyle = FleshUnitRenderer.FLESH_LIGHT;
        ctx.beginPath();
        ctx.ellipse(-6 * s, -5 * s, 3 * s * pulse, 2 * s, -0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(6 * s, -5 * s, 3 * s * pulse, 2 * s, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // BLOATED BELLY
        const bellyPulse = 1 + Math.sin(t * 1.5) * 0.07;
        const bellyKick = Math.sin(t * 3) * 0.04;

        const bellyGrad = ctx.createRadialGradient(0, 7 * s, 1 * s, 0, 7 * s, 8 * s * bellyPulse);
        bellyGrad.addColorStop(0, FleshUnitRenderer.FLESH_PALE);
        bellyGrad.addColorStop(0.5, FleshUnitRenderer.FLESH_LIGHT);
        bellyGrad.addColorStop(1, FleshUnitRenderer.FLESH_MID);

        ctx.fillStyle = bellyGrad;
        ctx.beginPath();
        ctx.moveTo(-5 * s, 4 * s);
        ctx.bezierCurveTo(
            -9 * s * bellyPulse, 7 * s,
            -8 * s * (bellyPulse + bellyKick), 11 * s,
            0, 12 * s * bellyPulse
        );
        ctx.bezierCurveTo(
            8 * s * (bellyPulse + bellyKick), 11 * s,
            9 * s * bellyPulse, 7 * s,
            5 * s, 4 * s
        );
        ctx.fill();

        // Belly veins
        this.drawBellyVeinsFront(ctx, s, t, bellyPulse);

        // Something moving inside
        const bumpX = Math.sin(t * 2) * 3 * s;
        const bumpY = 8 * s + Math.cos(t * 2.5) * 1.5 * s;
        ctx.fillStyle = FleshUnitRenderer.FLESH_HIGHLIGHT;
        ctx.globalAlpha = 0.35;
        ctx.beginPath();
        ctx.ellipse(bumpX, bumpY, 2.5 * s, 2 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    private drawBellyVeinsFront(ctx: CanvasRenderingContext2D, s: number, t: number, pulse: number) {
        const veinPulse = 0.5 + Math.sin(t * 4) * 0.4;

        ctx.strokeStyle = FleshUnitRenderer.BLOOD_DARK;
        ctx.lineWidth = 0.8 * s;
        ctx.globalAlpha = veinPulse * 0.5;

        // Left vein
        ctx.beginPath();
        ctx.moveTo(-4 * s, 5 * s);
        ctx.quadraticCurveTo(-6 * s, 8 * s, -5 * s, 11 * s);
        ctx.stroke();

        // Right vein
        ctx.beginPath();
        ctx.moveTo(4 * s, 5 * s);
        ctx.quadraticCurveTo(6 * s, 8 * s, 5 * s, 11 * s);
        ctx.stroke();

        // Center vein
        ctx.beginPath();
        ctx.moveTo(0, 5 * s);
        ctx.quadraticCurveTo(-1 * s, 8 * s, 0, 11 * s);
        ctx.stroke();

        ctx.globalAlpha = 1.0;
    }

    private drawFatRollsFront(ctx: CanvasRenderingContext2D, s: number, t: number) {
        const wobble = Math.sin(t * 2) * 0.5 * s;

        // Side fat rolls
        ctx.fillStyle = FleshUnitRenderer.FLESH_DARK;
        ctx.beginPath();
        ctx.ellipse(-7 * s, 1 * s + wobble, 2 * s, 3 * s, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(7 * s, 1 * s + wobble, 2 * s, 3 * s, -0.3, 0, Math.PI * 2);
        ctx.fill();

        // Lower belly fold
        ctx.strokeStyle = FleshUnitRenderer.FLESH_DEEPEST;
        ctx.lineWidth = 1 * s;
        ctx.beginPath();
        ctx.moveTo(-4 * s, 4 * s);
        ctx.quadraticCurveTo(0, 5 * s + wobble, 4 * s, 4 * s);
        ctx.stroke();
    }

    private drawEmbeddedDebrisFront(ctx: CanvasRenderingContext2D, s: number, t: number) {
        // LEFT SHOULDER ‚Äî Bone shard
        ctx.save();
        ctx.translate(-7 * s, -6 * s);
        ctx.rotate(-0.4);
        ctx.fillStyle = FleshUnitRenderer.BONE_PALE;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(1.2 * s, -0.5 * s);
        ctx.lineTo(0.8 * s, -6 * s);
        ctx.lineTo(-0.5 * s, -5 * s);
        ctx.fill();
        ctx.fillStyle = FleshUnitRenderer.BONE_DARK;
        ctx.beginPath();
        ctx.ellipse(0.3 * s, -5.5 * s, 1 * s, 0.7 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // RIGHT SIDE ‚Äî Chain links
        ctx.strokeStyle = '#78909c';
        ctx.lineWidth = 1.5 * s;
        ctx.beginPath();
        ctx.ellipse(8 * s, -2 * s, 1.2 * s, 1.8 * s, 0.4, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(9 * s, 0, 1.2 * s, 1.8 * s, -0.3, 0, Math.PI * 2);
        ctx.stroke();

        // CENTER ‚Äî Rusted blade
        ctx.save();
        ctx.translate(3 * s, -2 * s);
        ctx.rotate(0.5);
        ctx.fillStyle = '#5d4037';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(1.5 * s, 0);
        ctx.lineTo(0.8 * s, 7 * s);
        ctx.lineTo(-0.3 * s, 6 * s);
        ctx.fill();
        // Blood around entry
        ctx.fillStyle = FleshUnitRenderer.BLOOD_DARK;
        ctx.beginPath();
        ctx.ellipse(0.5 * s, 0.5 * s, 1.5 * s, 1 * s, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    private drawVisibleOrgansFront(ctx: CanvasRenderingContext2D, s: number, t: number, hp: number) {
        const organPulse = 1 + Math.sin(t * 4) * 0.15;
        const visibility = hp < 0.7 ? 0.8 : 0.5;

        ctx.globalAlpha = visibility;

        // Wound opening on belly
        ctx.fillStyle = FleshUnitRenderer.FLESH_DEEPEST;
        ctx.beginPath();
        ctx.ellipse(-2 * s, 8 * s, 2.5 * s, 1.5 * s, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Intestine coils
        ctx.fillStyle = FleshUnitRenderer.GORE_PINK;
        ctx.beginPath();
        ctx.arc(-2 * s, 8 * s, 1.2 * s * organPulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(-0.5 * s, 7.5 * s, 0.8 * s * organPulse, 0, Math.PI * 2);
        ctx.fill();

        // Pulsating organ (heart-like)
        const heartBeat = 1 + Math.sin(t * 6) * 0.2;
        ctx.fillStyle = FleshUnitRenderer.ORGAN_RED;
        ctx.shadowBlur = 6;
        ctx.shadowColor = FleshUnitRenderer.BLOOD_BRIGHT;
        ctx.beginPath();
        ctx.ellipse(2 * s, 6 * s, 1.5 * s * heartBeat, 1 * s * heartBeat, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.globalAlpha = 1.0;
    }

    private drawStitchesFront(ctx: CanvasRenderingContext2D, s: number, t: number) {
        ctx.strokeStyle = FleshUnitRenderer.STITCH_DARK;
        ctx.lineWidth = 1.6 * s;

        // Main vertical stitch
        ctx.setLineDash([3 * s, 2 * s]);
        ctx.beginPath();
        ctx.moveTo(0, -8 * s);
        ctx.lineTo(0, 10 * s);
        ctx.stroke();

        // Horizontal stitch across belly
        ctx.beginPath();
        ctx.moveTo(-6 * s, 6 * s);
        ctx.quadraticCurveTo(0, 5 * s, 6 * s, 6 * s);
        ctx.stroke();
        ctx.setLineDash([]);

        // X-stitch marks
        ctx.lineWidth = 0.8 * s;
        const stitchPoints = [
            { x: 0, y: -6 }, { x: 0, y: -2 }, { x: 0, y: 2 }, { x: 0, y: 6 }
        ];
        stitchPoints.forEach(p => {
            ctx.beginPath();
            ctx.moveTo((p.x - 1) * s, (p.y - 1) * s);
            ctx.lineTo((p.x + 1) * s, (p.y + 1) * s);
            ctx.moveTo((p.x + 1) * s, (p.y - 1) * s);
            ctx.lineTo((p.x - 1) * s, (p.y + 1) * s);
            ctx.stroke();
        });
    }

    private drawEmbeddedFacesFront(ctx: CanvasRenderingContext2D, s: number, t: number) {
        // LEFT SIDE ‚Äî Screaming face
        ctx.save();
        ctx.translate(-4 * s, 5 * s);
        ctx.rotate(0.3);

        ctx.fillStyle = FleshUnitRenderer.FLESH_PALE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 2 * s, 2.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Stitched eyes
        ctx.strokeStyle = FleshUnitRenderer.STITCH_DARK;
        ctx.lineWidth = 0.5 * s;
        ctx.beginPath();
        ctx.moveTo(-1 * s, -0.8 * s);
        ctx.lineTo(-0.3 * s, -0.6 * s);
        ctx.moveTo(0.3 * s, -0.6 * s);
        ctx.lineTo(1 * s, -0.8 * s);
        ctx.stroke();

        // Screaming mouth
        const mouthOpen = Math.sin(t * 2.5) * 0.3 + 0.5;
        ctx.fillStyle = FleshUnitRenderer.FLESH_DEEPEST;
        ctx.beginPath();
        ctx.ellipse(0, 1 * s, 0.8 * s, mouthOpen * s, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // RIGHT SIDE ‚Äî Half-absorbed face
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = FleshUnitRenderer.FLESH_MID;
        ctx.beginPath();
        ctx.ellipse(5 * s, 6 * s, 1.5 * s, 2 * s, -0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    private drawDamageEffectsFront(ctx: CanvasRenderingContext2D, s: number, t: number, hp: number) {
        const woundCount = hp < 0.3 ? 3 : 2;

        for (let i = 0; i < woundCount; i++) {
            const wx = (-3 + i * 3) * s;
            const wy = (-5 + i * 4) * s;

            ctx.fillStyle = FleshUnitRenderer.FLESH_DEEPEST;
            ctx.beginPath();
            ctx.ellipse(wx, wy, 1.2 * s, 1.8 * s, i * 0.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = FleshUnitRenderer.BLOOD_DARK;
            ctx.beginPath();
            ctx.ellipse(wx, wy + 1.5 * s, 0.8 * s, 1.2 * s, 0, 0, Math.PI);
            ctx.fill();
        }
    }

    private drawBellyMawFront(ctx: CanvasRenderingContext2D, s: number, t: number) {
        const mawPulse = Math.sin(t * 2) * 0.3 + 0.7;

        // Dark interior
        ctx.fillStyle = FleshUnitRenderer.FLESH_DEEPEST;
        ctx.beginPath();
        ctx.ellipse(0, 4 * s, 4 * s * mawPulse, 3 * s * mawPulse, 0, 0, Math.PI * 2);
        ctx.fill();

        // Teeth around opening
        ctx.fillStyle = FleshUnitRenderer.BONE_PALE;
        const teethCount = 8;
        for (let i = 0; i < teethCount; i++) {
            const angle = (i / teethCount) * Math.PI * 2;
            const tx = Math.cos(angle) * 3.5 * s * mawPulse;
            const ty = 4 * s + Math.sin(angle) * 2.5 * s * mawPulse;

            ctx.save();
            ctx.translate(tx, ty);
            ctx.rotate(angle + Math.PI / 2);
            ctx.beginPath();
            ctx.moveTo(-0.5 * s, 0);
            ctx.lineTo(0, -2 * s);
            ctx.lineTo(0.5 * s, 0);
            ctx.fill();
            ctx.restore();
        }

        // Inner glow
        ctx.fillStyle = FleshUnitRenderer.ORGAN_RED;
        ctx.globalAlpha = 0.5 + Math.sin(t * 4) * 0.3;
        ctx.beginPath();
        ctx.ellipse(0, 4 * s, 2 * s, 1.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    private drawEmbeddedFaceFront(ctx: CanvasRenderingContext2D, s: number, t: number) {
        // Face struggling beneath surface
        ctx.fillStyle = FleshUnitRenderer.FLESH_PALE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 3 * s, 3.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Closed eyes
        ctx.strokeStyle = FleshUnitRenderer.STITCH_DARK;
        ctx.lineWidth = 0.7 * s;
        ctx.beginPath();
        ctx.arc(-1 * s, -0.5 * s, 0.8 * s, Math.PI, 0);
        ctx.arc(1 * s, -0.5 * s, 0.8 * s, Math.PI, 0);
        ctx.stroke();

        // Open mouth screaming
        const scream = Math.sin(t * 3) * 0.2 + 0.6;
        ctx.fillStyle = FleshUnitRenderer.FLESH_DEEPEST;
        ctx.beginPath();
        ctx.ellipse(0, 1.5 * s, 1.2 * s * scream, 0.8 * s * scream, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawHeadFront(ctx: CanvasRenderingContext2D, s: number, t: number) {
        // Lumpy, asymmetric head
        ctx.fillStyle = FleshUnitRenderer.FLESH_MID;
        ctx.beginPath();
        ctx.ellipse(0, 0, 5 * s, 5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Growth on side
        ctx.fillStyle = FleshUnitRenderer.FLESH_LIGHT;
        ctx.beginPath();
        ctx.ellipse(3 * s, -2 * s, 2 * s, 1.5 * s, 0.4, 0, Math.PI * 2);
        ctx.fill();

        // Eyes ‚Äî asymmetric
        // Left eye (big, staring)
        const eyePulse = 1 + Math.sin(t * 6) * 0.1;
        ctx.fillStyle = FleshUnitRenderer.EYE_WHITE;
        ctx.beginPath();
        ctx.ellipse(-2 * s, -1 * s, 1.5 * s * eyePulse, 1.2 * s * eyePulse, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = FleshUnitRenderer.EYE_PUPIL;
        ctx.beginPath();
        ctx.arc(-2 * s, -1 * s, 0.5 * s, 0, Math.PI * 2);
        ctx.fill();

        // Right eye (smaller, different position)
        ctx.fillStyle = FleshUnitRenderer.EYE_WHITE;
        ctx.beginPath();
        ctx.ellipse(1.5 * s, 0, 1 * s, 0.8 * s, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = FleshUnitRenderer.EYE_PUPIL;
        ctx.beginPath();
        ctx.arc(1.6 * s, 0, 0.35 * s, 0, Math.PI * 2);
        ctx.fill();

        // Third eye (stitched)
        ctx.strokeStyle = FleshUnitRenderer.STITCH_DARK;
        ctx.lineWidth = 1 * s;
        ctx.beginPath();
        ctx.moveTo(-0.5 * s, 1.5 * s);
        ctx.lineTo(0.5 * s, 2 * s);
        ctx.stroke();

        // Mouth (drooling)
        ctx.fillStyle = FleshUnitRenderer.FLESH_DEEPEST;
        ctx.beginPath();
        ctx.ellipse(0, 3.5 * s, 2 * s, 1 * s, 0, 0, Math.PI);
        ctx.fill();
    }

    // =====================================================================
    // BACK VIEW
    // =====================================================================
    private drawBack(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, t: number, hp: number) {
        const bounce = isMoving ? Math.abs(Math.sin(cycle * 0.5)) * 3 * s : 0;
        const pulse = 1 + Math.sin(t * 1.5) * 0.05;

        ctx.translate(0, -bounce);

        // Legs connected at waist level

        // Tentacles from back
        this.drawTentacles(ctx, -8 * s, -5 * s, s, t, false);
        this.drawTentacles(ctx, 8 * s, -5 * s, s, t, false);

        // Legs ‚Äî connected at waist
        this.drawLegFront(ctx, -5 * s, 8 * s, cycle, 0, s, false);
        this.drawLegFront(ctx, 5 * s, 8 * s, cycle, Math.PI, s, false);

        // Main body
        const backGrad = ctx.createRadialGradient(0, 0, 2 * s, 0, 0, 14 * s);
        backGrad.addColorStop(0, FleshUnitRenderer.FLESH_MID);
        backGrad.addColorStop(1, FleshUnitRenderer.FLESH_DEEPEST);

        ctx.fillStyle = backGrad;
        ctx.beginPath();
        ctx.ellipse(0, 0, 12 * s * pulse, 10 * s * pulse, 0, 0, Math.PI * 2);
        ctx.fill();

        // Spine bumps
        for (let i = 0; i < 5; i++) {
            const yPos = -8 * s + i * 3.5 * s;
            const bumpPulse = 1 + Math.sin(t * 3 + i) * 0.15;

            ctx.fillStyle = FleshUnitRenderer.FLESH_LIGHT;
            ctx.beginPath();
            ctx.ellipse(0, yPos, 2.5 * s * bumpPulse, 1.5 * s, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Cross stitches on back
        ctx.strokeStyle = FleshUnitRenderer.STITCH_DARK;
        ctx.lineWidth = 1.5 * s;
        ctx.beginPath();
        ctx.moveTo(-6 * s, -4 * s);
        ctx.lineTo(6 * s, 4 * s);
        ctx.moveTo(6 * s, -4 * s);
        ctx.lineTo(-6 * s, 4 * s);
        ctx.stroke();

        // Embedded chains
        ctx.strokeStyle = '#607d8b';
        ctx.lineWidth = 1.8 * s;
        ctx.beginPath();
        ctx.ellipse(-8 * s, 2 * s, 1.5 * s, 2.5 * s, 0.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(-9 * s, 4.5 * s, 1.5 * s, 2.5 * s, -0.3, 0, Math.PI * 2);
        ctx.stroke();

        // Back of head
        ctx.fillStyle = FleshUnitRenderer.FLESH_DARK;
        ctx.beginPath();
        ctx.ellipse(0, -10 * s, 4 * s, 3.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        this.drawDrippingGore(ctx, s, t, isMoving);
    }

    // =====================================================================
    // SHARED COMPONENTS
    // =====================================================================

    private drawLegSide(ctx: CanvasRenderingContext2D, x: number, y: number, cycle: number, phase: number, s: number, far: boolean) {
        const swing = Math.sin(cycle + phase) * 0.2;
        const squash = 1 + Math.abs(Math.sin(cycle + phase)) * 0.1;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(swing);

        // Thick, stumpy leg
        const legGrad = ctx.createLinearGradient(0, 0, 0, 7 * s);
        legGrad.addColorStop(0, far ? FleshUnitRenderer.FLESH_DARK : FleshUnitRenderer.FLESH_MID);
        legGrad.addColorStop(1, FleshUnitRenderer.FLESH_DEEPEST);

        ctx.fillStyle = legGrad;
        ctx.beginPath();
        ctx.moveTo(-3 * s, 0);
        ctx.bezierCurveTo(-3.5 * s * squash, 3 * s, -3 * s, 5 * s, -2 * s, 7 * s);
        ctx.lineTo(2 * s, 7 * s);
        ctx.bezierCurveTo(3 * s, 5 * s, 3.5 * s * squash, 3 * s, 3 * s, 0);
        ctx.fill();

        // Foot/hoof
        ctx.fillStyle = FleshUnitRenderer.FLESH_DARK;
        ctx.beginPath();
        ctx.ellipse(0, 7.5 * s, 3 * s, 1.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Fat roll on thigh
        if (!far) {
            ctx.fillStyle = FleshUnitRenderer.FLESH_LIGHT;
            ctx.beginPath();
            ctx.ellipse(0, 1 * s, 3.5 * s * squash, 1.5 * s, 0, 0, Math.PI);
            ctx.fill();
        }

        ctx.restore();
    }

    private drawLegFront(ctx: CanvasRenderingContext2D, x: number, y: number, cycle: number, phase: number, s: number, far: boolean) {
        const lift = Math.max(0, Math.sin(cycle + phase)) * 3 * s;
        const squash = 1 + Math.cos(cycle + phase) * 0.1;

        ctx.save();
        ctx.translate(x, y - lift);

        const legColor = far ? FleshUnitRenderer.FLESH_DARK : FleshUnitRenderer.FLESH_MID;
        ctx.fillStyle = legColor;
        ctx.beginPath();
        ctx.ellipse(0, 0, 3 * s * squash, 6 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Foot
        ctx.translate(0, 6 * s);
        ctx.fillStyle = FleshUnitRenderer.FLESH_DARK;
        ctx.beginPath();
        ctx.ellipse(0, 0, 3.5 * s, 1.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    drawEmissive(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        // Optional: Add sickly glow from belly maw or eyes
    }
}
</file>

<file path="src/renderers/units/GoblinUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import { CONFIG } from '../../Config';
import type { Enemy } from '../../Enemy';
import { Assets } from '../../Assets';

export class GoblinUnitRenderer implements UnitRenderer {
    // üé® Palette (Gritty & Detailed)
    private static readonly SKIN_BASE = '#689f38';  // Olive Green
    private static readonly SKIN_DARK = '#33691e';  // Shadow
    private static readonly CLOTH_RAGS = '#5d4037'; // Dark Leather/Rags
    private static readonly SACK_COLOR = '#8d6e63'; // Loot Sack
    private static readonly METAL_RUST = '#8d6e63'; // Rusty Dagger
    private static readonly METAL_EDGE = '#cfd8dc'; // Sharpened Edge
    private static readonly EYE_COLOR = '#ffeb3b';  // Yellow Eyes

    // BAKING SUPPORT
    public getBakeFacings(): ('SIDE' | 'UP' | 'DOWN')[] {
        return ['SIDE', 'UP', 'DOWN'];
    }

    public drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: 'SIDE' | 'UP' | 'DOWN') {
        const cycle = t * Math.PI * 2;
        const scale = 1.0;
        const isMoving = true;

        if (facing === 'UP') return this.drawBack(ctx, scale, cycle, isMoving);
        if (facing === 'DOWN') return this.drawFront(ctx, scale, cycle, isMoving);
        return this.drawSide(ctx, scale, cycle, isMoving);
    }

    drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void {
        this.drawFrameDirectional(ctx, enemy, t, 'SIDE');
    }

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.001;
        const walkCycle = time * (enemy.baseSpeed * 0.25);

        // 1. Try Cached Sprite
        const t = (walkCycle % (Math.PI * 2)) / (Math.PI * 2);
        const frameIdx = Math.floor(t * 32) % 32;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;

        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        const facingLeft = Math.cos(rotation) < 0;

        const frameKey = `unit_${enemy.typeId}_${facing.toLowerCase()}_walk_${frameIdx}`;

        const sprite = Assets.get(frameKey);
        if (sprite) {
            ctx.save();
            const size = 96 * scale;

            if (facing === 'SIDE') {
                if (facingLeft) ctx.scale(-1, 1);
            }

            ctx.drawImage(sprite, -size / 2, -size / 2, size, size);

            // Hit Flash (Source-Atop cheap method)
            if (enemy.hitFlashTimer > 0) {
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillRect(-size / 2, -size / 2, size, size);
            }

            ctx.restore();
            return;
        }

        // 2. Fallback
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        ctx.save();

        if (enemy.hitFlashTimer > 0) {
            ctx.globalAlpha = 0.7; // Simple visual feedback without expensive filter
        }

        if (facing === 'SIDE') {
            if (facingLeft) ctx.scale(-1, 1);
            this.drawSide(ctx, scale, walkCycle, isMoving);
        } else if (facing === 'UP') {
            this.drawBack(ctx, scale, walkCycle, isMoving);
        } else {
            this.drawFront(ctx, scale, walkCycle, isMoving);
        }

        ctx.restore();
    }

    // === FRONT VIEW ===
    private drawFront(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        // Sneaking Bob (Deep)
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;

        // Feet (Wide Stance, Knees out)
        const kneeOut = 3 * scale;
        const leftLift = isMoving ? Math.max(0, Math.sin(walkCycle)) * 5 * scale : 0;
        const rightLift = isMoving ? Math.max(0, Math.sin(walkCycle + Math.PI)) * 5 * scale : 0;

        ctx.translate(0, -bounce);

        // Legs (Thin & Spindly)
        this.drawLeg(ctx, -5 * scale, 10 * scale - leftLift, scale, -0.2);
        this.drawLeg(ctx, 5 * scale, 10 * scale - rightLift, scale, 0.2);

        // Loincloth / Rags
        ctx.fillStyle = GoblinUnitRenderer.CLOTH_RAGS;
        ctx.beginPath();
        ctx.moveTo(-5 * scale, 4 * scale);
        ctx.lineTo(5 * scale, 4 * scale);
        ctx.lineTo(3 * scale, 10 * scale); // Ragged bottom
        ctx.lineTo(0, 8 * scale);
        ctx.lineTo(-3 * scale, 10 * scale);
        ctx.fill();

        // Torso (Lean & Hunched)
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        // Narrow chest, wider belly (potbelly?)
        ctx.ellipse(0, 0, 4.5 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Ribs detail
        ctx.strokeStyle = GoblinUnitRenderer.SKIN_DARK;
        ctx.lineWidth = 1 * scale;
        ctx.beginPath(); ctx.moveTo(-2 * scale, -2 * scale); ctx.lineTo(2 * scale, -2 * scale); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-3 * scale, 0); ctx.lineTo(3 * scale, 0); ctx.stroke();

        // Arms (Long, dangling)
        const armSway = isMoving ? Math.sin(walkCycle) * 0.4 : 0;
        // Left Arm (Sack Strap?)
        this.drawArm(ctx, -6 * scale, 2 * scale + armSway * 4 * scale, scale, 0.2);
        // Right Arm (Dagger)
        this.drawArm(ctx, 6 * scale, 2 * scale - armSway * 4 * scale, scale, -0.2, true);

        // Head (Low on neck)
        ctx.translate(0, -5 * scale);
        this.drawHeadFront(ctx, scale);
    }

    // === BACK VIEW ===
    private drawBack(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;
        ctx.translate(0, -bounce);

        const leftLift = isMoving ? Math.max(0, Math.sin(walkCycle)) * 5 * scale : 0;
        const rightLift = isMoving ? Math.max(0, Math.sin(walkCycle + Math.PI)) * 5 * scale : 0;

        this.drawLeg(ctx, -5 * scale, 10 * scale - leftLift, scale, -0.2);
        this.drawLeg(ctx, 5 * scale, 10 * scale - rightLift, scale, 0.2);

        // Torso Back
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 4.5 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Giant Loot Sack (Defining Feature)
        ctx.save();
        const sackBounce = isMoving ? Math.sin(walkCycle * 2) * 1 * scale : 0;
        ctx.translate(0, -2 * scale + sackBounce);
        ctx.rotate(0.1); // Slightly askew

        ctx.fillStyle = GoblinUnitRenderer.SACK_COLOR;
        ctx.beginPath();
        ctx.ellipse(0, 0, 7 * scale, 8 * scale, 0, 0, Math.PI * 2); // Huge sack
        ctx.fill();
        // Patch
        ctx.fillStyle = '#6d4c41';
        ctx.fillRect(-3 * scale, 2 * scale, 3 * scale, 3 * scale);
        // Tie at top
        ctx.fillStyle = '#4e342e';
        ctx.fillRect(-2 * scale, -8 * scale, 4 * scale, 2 * scale);
        ctx.restore();

        // Arms visible at sides
        const armSway = isMoving ? Math.sin(walkCycle) * 0.4 : 0;
        this.drawArm(ctx, -7 * scale, 2 * scale - armSway * 4 * scale, scale, 0.3);
        this.drawArm(ctx, 7 * scale, 2 * scale + armSway * 4 * scale, scale, -0.3, true); // Weapon visible?

        // Head Back
        ctx.translate(0, -6 * scale); // Head is in front of sack? No, sack covers back. Head sits on top.
        this.drawHeadBack(ctx, scale);
    }

    // === SIDE VIEW ===
    private drawSide(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;
        ctx.translate(0, -bounce);

        // Sneaky Stride (Stay low)
        const stride = 6 * scale;
        const legX = isMoving ? Math.sin(walkCycle) * stride : 0;
        const liftFar = isMoving && legX > 0 ? Math.sin(walkCycle) * 4 * scale : 0;
        const liftNear = isMoving && legX < 0 ? -Math.sin(walkCycle) * 4 * scale : 0;

        // Crouch legs
        this.drawLeg(ctx, legX, 8 * scale - liftFar, scale, 0);  // Far
        this.drawLeg(ctx, -legX, 8 * scale - liftNear, scale, 0); // Near

        // Body (Hunched Forward Curve)
        ctx.save();
        ctx.rotate(0.4); // Deep lean forward (Sneaking)

        // Sack on back
        ctx.fillStyle = GoblinUnitRenderer.SACK_COLOR;
        ctx.beginPath();
        ctx.ellipse(-4 * scale, -2 * scale, 5 * scale, 7 * scale, -0.2, 0, Math.PI * 2);
        ctx.fill();

        // Torso
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 4 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Arms (Reaching)
        const armSway = isMoving ? Math.cos(walkCycle) * 0.5 : 0;
        this.drawArm(ctx, 4 * scale, 4 * scale + armSway * 5 * scale, scale, -0.4, true);

        // Head (Crane forward)
        ctx.translate(6 * scale, -4 * scale); // Way forward
        this.drawHeadSide(ctx, scale);
    }

    // --- PARTS ---

    private drawLeg(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number, ang: number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(ang);

        // Thigh
        ctx.fillStyle = GoblinUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.ellipse(0, -2 * scale, 2 * scale, 4 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Shin/Foot (Big foot)
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 3 * scale, 1.5 * scale, 3 * scale, 0.2, 0, Math.PI * 2); // Skinny shin
        ctx.fill();

        // Foot
        ctx.fillStyle = GoblinUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.ellipse(1 * scale, 5 * scale, 3 * scale, 1.5 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    private drawArm(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number, ang: number, hasWeapon: boolean = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(ang);

        // Long lanky arm
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 1.5 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        if (hasWeapon) {
            ctx.translate(0, 6 * scale); // Hand pos
            // Dagger
            ctx.rotate(0.5); // Point forward
            // Hilt
            ctx.fillStyle = '#4e342e';
            ctx.fillRect(-1 * scale, -1 * scale, 2 * scale, 3 * scale);
            // Guard
            ctx.fillStyle = GoblinUnitRenderer.METAL_RUST;
            ctx.fillRect(-2 * scale, 2 * scale, 4 * scale, 1 * scale);
            // Blade (Jagged)
            ctx.fillStyle = GoblinUnitRenderer.METAL_EDGE;
            ctx.beginPath();
            ctx.moveTo(-1.5 * scale, 3 * scale);
            ctx.lineTo(1.5 * scale, 3 * scale);
            ctx.lineTo(0, 9 * scale); // Long blade
            ctx.fill();
            // Rust spots
            ctx.fillStyle = GoblinUnitRenderer.METAL_RUST;
            ctx.beginPath(); ctx.arc(0, 5 * scale, 1 * scale, 0, Math.PI * 2); ctx.fill();
        }

        ctx.restore();
    }

    private drawHeadFront(ctx: CanvasRenderingContext2D, scale: number) {
        // Skull
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 4 * scale, 5 * scale, 0, 0, Math.PI * 2); // Tall head
        ctx.fill();

        // Huge Ears (Notched)
        ctx.fillStyle = GoblinUnitRenderer.SKIN_DARK;
        const drawEar = (mirror: number) => {
            ctx.beginPath();
            ctx.moveTo(mirror * 3 * scale, 0);
            ctx.bezierCurveTo(mirror * 10 * scale, -5 * scale, mirror * 12 * scale, 0, mirror * 4 * scale, 4 * scale);
            ctx.fill();
            // Notch
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath(); ctx.arc(mirror * 9 * scale, 0, 1 * scale, 0, Math.PI * 2); ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
        };
        drawEar(1);
        drawEar(-1);

        // Nose (Long & Crooked)
        ctx.fillStyle = '#558b2f';
        ctx.beginPath();
        ctx.moveTo(0, -1 * scale);
        ctx.lineTo(1.5 * scale, 3 * scale); // Pointy tip
        ctx.lineTo(-1 * scale, 2 * scale);
        ctx.fill();

        // Eyes (Yellow & Mean)
        ctx.fillStyle = GoblinUnitRenderer.EYE_COLOR;
        ctx.beginPath(); ctx.ellipse(-2 * scale, -1 * scale, 1.2 * scale, 0.8 * scale, 0.2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(2 * scale, -1 * scale, 1.2 * scale, 0.8 * scale, -0.2, 0, Math.PI * 2); ctx.fill();

        // Pupils
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(-2 * scale, -1 * scale, 0.3 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(2 * scale, -1 * scale, 0.3 * scale, 0, Math.PI * 2); ctx.fill();

        // Tooth (Snaggletooth)
        ctx.fillStyle = '#fff9c4';
        ctx.beginPath();
        ctx.moveTo(-1 * scale, 3 * scale); ctx.lineTo(-0.5 * scale, 5 * scale); ctx.lineTo(0, 3 * scale);
        ctx.fill();
    }

    private drawHeadSide(ctx: CanvasRenderingContext2D, scale: number) {
        // Ear (Back)
        ctx.fillStyle = GoblinUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(-6 * scale, -2 * scale); ctx.lineTo(-1 * scale, 3 * scale);
        ctx.fill();

        // Skull
        ctx.fillStyle = GoblinUnitRenderer.SKIN_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 4.5 * scale, 5 * scale, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Nose Profile
        ctx.fillStyle = '#558b2f';
        ctx.beginPath();
        ctx.moveTo(3 * scale, 0);
        ctx.bezierCurveTo(7 * scale, 1 * scale, 6 * scale, 4 * scale, 3 * scale, 3 * scale);
        ctx.fill();

        // Eye
        ctx.fillStyle = GoblinUnitRenderer.EYE_COLOR;
        ctx.beginPath(); ctx.arc(2 * scale, -1 * scale, 1 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(2.5 * scale, -1 * scale, 0.3 * scale, 0, Math.PI * 2); ctx.fill();
    }

    private drawHeadBack(ctx: CanvasRenderingContext2D, scale: number) {
        // Ears
        ctx.fillStyle = GoblinUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.moveTo(-3 * scale, 0); ctx.lineTo(-10 * scale, -4 * scale); ctx.lineTo(-4 * scale, 4 * scale); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(3 * scale, 0); ctx.lineTo(10 * scale, -4 * scale); ctx.lineTo(4 * scale, 4 * scale); ctx.fill();

        // Head
        ctx.fillStyle = '#33691e'; // Darker back hair/skin
        ctx.beginPath();
        ctx.ellipse(0, 0, 4 * scale, 5 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hair wisps?
        ctx.strokeStyle = '#212121';
        ctx.lineWidth = 1 * scale;
        ctx.beginPath(); ctx.moveTo(0, -5 * scale); ctx.lineTo(-1 * scale, -7 * scale); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -5 * scale); ctx.lineTo(2 * scale, -6 * scale); ctx.stroke();
    }
}
</file>

<file path="src/renderers/units/SkeletonCommanderUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import { CONFIG } from '../../Config';
import { Assets } from '../../Assets';
import type { Enemy } from '../../Enemy';

export class SkeletonCommanderUnitRenderer implements UnitRenderer {
    // üé® AAA PALETTE: Deep, Rich, Metallic
    private static readonly PALETTE = {
        BONE: '#cfd8dc',
        BONE_SHADOW: '#90a4ae',
        ARMOR_BASE: '#212121',     // Obsidian
        ARMOR_DARK: '#1a1a1a',      // Dark Obsidian
        ARMOR_HIGHLIGHT: '#424242', // Specular
        ARMOR_SHADOW: '#000000',    // Ambient Occlusion
        GOLD_LIGHT: '#ffecb3',      // Polished Gold
        GOLD_BASE: '#ffc107',       // Gold
        GOLD_DARK: '#ff6f00',       // Old Gold
        CAPE_BASE: '#b71c1c',       // Royal Crimson
        CAPE_DARK: '#7f0000',       // Fold shadow
        CAPE_HIGHLIGHT: '#e53935',  // Cloth sheen
        SWORD_STEEL: '#eceff1',
        SWORD_DARK: '#37474f',
        MAGIC_GLOW: '#ff3d00'       // Burning Ember Eyes/Runes
    };

    // BAKING SUPPORT
    public getBakeFacings(): ('SIDE' | 'UP' | 'DOWN')[] {
        return ['SIDE', 'UP', 'DOWN'];
    }

    public drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: 'SIDE' | 'UP' | 'DOWN') {
        const cycle = t * Math.PI * 2;
        const scale = 1.0;
        const s = scale * 1.35;
        const isMoving = true;

        // "Breathing" idle animation approximation for bake
        const breath = Math.sin(t * 10 * 2) * 0.03;
        const time = t * 10;

        // 1. Dynamic Aura (Ground Layer) - Baked or Procedural? 
        // Baking aura into the sprite might be okay if it handles transparency well.
        this.drawAura(ctx, s, time);

        if (facing === 'DOWN') {
            this.drawCapeBack(ctx, s, time, isMoving, facing);
            this.drawFront(ctx, s, cycle, isMoving, breath);
        } else if (facing === 'UP') {
            this.drawBack(ctx, s, cycle, isMoving, breath);
            this.drawCapeBack(ctx, s, time, isMoving, facing);
        } else {
            this.drawCapeBack(ctx, s, time, isMoving, facing);
            this.drawSide(ctx, s, cycle, isMoving, breath);
        }
    }

    drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void {
        this.drawFrameDirectional(ctx, enemy, t, 'SIDE');
    }

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.001;
        const walkCycle = time * (enemy.baseSpeed * 0.15);

        // 1. Try Cached Sprite
        const t = (walkCycle % (Math.PI * 2)) / (Math.PI * 2);
        const frameIdx = Math.floor(t * 32) % 32;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        const facingLeft = Math.cos(rotation) < 0;

        const frameKey = `unit_${enemy.typeId}_${facing.toLowerCase()}_walk_${frameIdx}`;
        const sprite = Assets.get(frameKey);

        if (sprite) {
            ctx.save();
            const size = 96 * scale * 1.5; // Commander is big

            if (facing === 'SIDE') {
                if (facingLeft) ctx.scale(-1, 1);
            }

            // Center sprite
            ctx.drawImage(sprite, -size / 2, -size / 2, size, size);

            // Hit Flash logic
            if (enemy.hitFlashTimer > 0) {
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fillRect(-size / 2, -size / 2, size, size);
            }
            ctx.restore();
            return;
        }

        // 2. Fallback Procedural
        const isMoving = !enemy.finished && enemy.currentHealth > 0;
        const breath = Math.sin(time * 2) * 0.03;
        const s = scale * 1.35;

        ctx.save();

        if (enemy.hitFlashTimer > 0) {
            ctx.globalAlpha = 0.6;
        }

        this.drawAura(ctx, s, time);

        if (facing === 'DOWN') {
            this.drawCapeBack(ctx, s, time, isMoving, facing);
            this.drawFront(ctx, s, walkCycle, isMoving, breath);
        }
        else if (facing === 'SIDE') {
            if (facingLeft) ctx.scale(-1, 1);
            this.drawCapeBack(ctx, s, time, isMoving, facing);
            this.drawSide(ctx, s, walkCycle, isMoving, breath);
        }
        else { // UP
            this.drawBack(ctx, s, walkCycle, isMoving, breath);
            this.drawCapeBack(ctx, s, time, isMoving, facing);
        }

        ctx.restore();
    }

    private drawAura(ctx: CanvasRenderingContext2D, s: number, t: number) {
        const auraImg = Assets.get('fx_boss_aura');
        if (auraImg) {
            ctx.save();
            ctx.scale(1, 0.5);
            const pulse = Math.sin(t * 3) * 0.2 + 0.8;
            const size = 32 * s * pulse;
            ctx.drawImage(auraImg, -size, -size, size * 2, size * 2);
            ctx.restore();
        } else {
            ctx.save();
            ctx.scale(1, 0.5); // Perspective squash
            const r = 18 * s;
            const pulse = Math.sin(t * 3) * 0.2 + 0.8;
            const grad = ctx.createRadialGradient(0, 0, r * 0.4, 0, 0, r);
            grad.addColorStop(0, 'rgba(255, 111, 0, 0.0)');
            grad.addColorStop(0.7, `rgba(255, 111, 0, ${0.3 * pulse})`);
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }
    }

    // === SOPHISTICATED CLOTH PHYSICS ===
    private drawCapeBack(ctx: CanvasRenderingContext2D, s: number, t: number, isMoving: boolean, facing: string) {
        const p = SkeletonCommanderUnitRenderer.PALETTE;
        const cycle = t * (isMoving ? 5 : 2); // Flutter speed
        const wind = Math.cos(t * 1.5) * 4 * s;
        const moveSway = isMoving ? Math.sin(cycle) * 6 * s : 0;

        ctx.save();
        ctx.translate(0, -12 * s); // Neck attachment

        if (facing === 'SIDE') {
            ctx.translate(-4 * s, 2 * s); // Attach to shoulder
            ctx.rotate(0.2 + (isMoving ? Math.sin(cycle * 0.5) * 0.1 : 0));
            // Multi-segment cape for fluid look
            ctx.beginPath();
            ctx.moveTo(0, 0);

            // Bezier Control points for "S" curve
            const tipX = -10 * s + moveSway + wind;
            const tipY = 28 * s;

            // Top curve (billow out)
            ctx.bezierCurveTo(-14 * s, 8 * s, -8 * s + moveSway, 18 * s, tipX, tipY);
            // Return edge (straighter)
            ctx.lineTo(4 * s, 4 * s);

            // Gradient Fill
            const grad = ctx.createLinearGradient(0, 0, 0, 30 * s);
            grad.addColorStop(0, p.CAPE_BASE);
            grad.addColorStop(1, p.CAPE_DARK);
            ctx.fillStyle = grad;
            ctx.fill();

        } else {
            // BACK / DOWN logic
            // Start narrow at neck, widen at bottom
            const neckW = 8 * s;
            const hemW = 22 * s;
            const h = 26 * s;
            const sway = moveSway + wind;

            ctx.beginPath();
            ctx.moveTo(-neckW / 2, 0);
            ctx.lineTo(neckW / 2, 0);

            // Complex Hem with folds
            const hemY = h + Math.sin(cycle * 2) * 1 * s;
            const hemX = sway;

            // Left curve
            ctx.bezierCurveTo(neckW + 4 * s, h * 0.4, hemW + hemX, h * 0.8, (hemW / 2) + hemX, hemY);
            // Bottom jagged edge (folds)
            ctx.lineTo(hemX, hemY + 2 * s);
            ctx.lineTo(-(hemW / 2) + hemX, hemY);
            // Right curve
            ctx.bezierCurveTo(-(hemW + hemX), h * 0.8, -(neckW + 4 * s), h * 0.4, -neckW / 2, 0);

            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, p.CAPE_BASE);
            grad.addColorStop(0.5, p.CAPE_BASE);
            grad.addColorStop(1, p.CAPE_DARK);
            ctx.fillStyle = grad;
            ctx.fill();

            // Highlight fold
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(hemX, hemY + 2 * s); ctx.lineTo(hemX + 2 * s, hemY + 2 * s); ctx.fill();
        }
        ctx.restore();
    }

    // === FRONT (AGGRESSIVE) ===
    private drawFront(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, breath: number, isBackLayer: boolean = false) {
        if (isBackLayer) return;

        const bounce = Math.abs(Math.sin(cycle)) * 1.5 * s;
        ctx.translate(0, -bounce);

        // -- LEGS (Dynamic Stance) --
        const ly = 12 * s;
        const legSep = 6 * s;
        this.drawLeg(ctx, -legSep, ly, s, 0);
        this.drawLeg(ctx, legSep, ly, s, 0);

        // -- TORSO (Heavy Plate) --
        ctx.save();
        ctx.scale(1 + breath, 1 + breath);

        // Waist
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_DARK;
        ctx.fillRect(-5 * s, 5 * s, 10 * s, 6 * s);
        this.drawGoldTrim(ctx, -5 * s, 5 * s, 10 * s, 2 * s);

        // Chest Plate 
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_BASE;
        ctx.beginPath();
        ctx.moveTo(-9 * s, -12 * s); ctx.lineTo(9 * s, -12 * s);
        ctx.lineTo(6 * s, 6 * s); ctx.lineTo(-6 * s, 6 * s);
        ctx.fill();

        // Chest Detail
        ctx.strokeStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT;
        ctx.lineWidth = 1 * s;
        ctx.beginPath();
        ctx.moveTo(-4 * s, -4 * s); ctx.lineTo(4 * s, -4 * s);
        ctx.moveTo(-3 * s, 0); ctx.lineTo(3 * s, 0);
        ctx.stroke();

        // Center Emblem
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE;
        ctx.beginPath(); ctx.arc(0, -5 * s, 2 * s, 0, Math.PI * 2); ctx.fill();

        // -- PAULDRONS --
        this.drawPauldron(ctx, -11 * s, -13 * s, s, 1);
        this.drawPauldron(ctx, 11 * s, -13 * s, s, -1);

        ctx.restore();

        // -- HEAD --
        ctx.translate(0, -14 * s + (breath * 5 * s));
        this.drawHelmet(ctx, s);
        ctx.translate(0, 14 * s - (breath * 5 * s));

        // -- ARMS & WEAPON --
        const sway = Math.sin(cycle * 0.5) * 0.1;

        ctx.save();
        ctx.translate(0, -2 * s);
        ctx.rotate(sway);

        ctx.translate(6 * s, 4 * s);

        // Draw Sword
        ctx.save();
        ctx.rotate(-2.2);
        this.drawGreatsword(ctx, 0, -8 * s, s);
        ctx.restore();

        // Right Arm 
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT;
        ctx.lineWidth = 3 * s;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-2 * s, -6 * s); ctx.stroke();

        // Left Arm 
        ctx.translate(-5 * s, 2 * s);
        ctx.restore();
    }

    // === SIDE (AGGRESSIVE) ===
    private drawSide(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, breath: number) {
        const bounce = Math.abs(Math.sin(cycle)) * 1.5 * s;
        ctx.translate(0, -bounce);

        // Legs
        const stride = 8 * s;
        const lx = isMoving ? Math.sin(cycle) * stride : -4 * s;
        const rx = isMoving ? -Math.sin(cycle) * stride : 4 * s;
        this.drawLeg(ctx, lx, 12 * s, s, 0);
        this.drawLeg(ctx, rx, 12 * s, s, 0);

        // Body Angle
        ctx.save();
        ctx.rotate(0.1);

        // Torso Side
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_BASE;
        ctx.beginPath();
        ctx.moveTo(-4 * s, -12 * s); ctx.lineTo(6 * s, -11 * s);
        ctx.lineTo(4 * s, 8 * s); ctx.lineTo(-4 * s, 7 * s);
        ctx.fill();

        // Pauldron
        this.drawPauldron(ctx, 0, -12 * s, s, 1);

        // Head
        ctx.translate(2 * s, -14 * s);
        this.drawHelmet(ctx, s);
        ctx.translate(-2 * s, 14 * s);

        // Arms & Weapon
        ctx.translate(4 * s, -2 * s);

        // Arm pointing forward
        const armAngle = -0.5 + Math.sin(cycle) * 0.1;
        ctx.rotate(armAngle);

        // Arm Plate
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT;
        ctx.fillRect(-2 * s, 0, 4 * s, 10 * s);

        // Forearm/Hand
        ctx.translate(0, 10 * s);
        ctx.rotate(-1.0);

        // Gauntlet
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(0, 2 * s, 3 * s, 0, Math.PI * 2); ctx.fill();

        // Sword
        ctx.rotate(-0.5);
        this.drawGreatsword(ctx, 0, -6 * s, s);

        ctx.restore();
    }

    // === BACK ===
    private drawBack(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, breath: number) {
        // Legs
        const ly = 12 * s;
        this.drawLeg(ctx, -5 * s, ly, s, 0);
        this.drawLeg(ctx, 5 * s, ly, s, 0);

        // Helmet Back
        ctx.translate(0, -14 * s);
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_BASE;
        ctx.beginPath(); ctx.arc(0, 0, 6 * s, 0, Math.PI * 2); ctx.fill();
        // Crown Back
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_DARK;
        ctx.beginPath();
        ctx.moveTo(-5 * s, 0); ctx.lineTo(-6 * s, -6 * s); ctx.lineTo(-3 * s, -3 * s);
        ctx.moveTo(5 * s, 0); ctx.lineTo(6 * s, -6 * s); ctx.lineTo(3 * s, -3 * s);
        ctx.fill();
    }

    // === COMPONENT LIBRARY ===

    private drawLeg(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, angle: number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        // Thigh / Knee
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT;
        ctx.beginPath();
        ctx.moveTo(-3 * s, -8 * s);
        ctx.lineTo(3 * s, -8 * s);
        ctx.lineTo(2 * s, 2 * s);
        ctx.lineTo(-2 * s, 2 * s);
        ctx.fill();

        // Knee Pad
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE;
        ctx.beginPath();
        ctx.moveTo(-3 * s, -4 * s); ctx.lineTo(0, -7 * s); ctx.lineTo(3 * s, -4 * s);
        ctx.lineTo(0, -1 * s);
        ctx.fill();

        // Boot
        ctx.fillStyle = '#0d0d0d';
        ctx.beginPath();
        ctx.ellipse(0, 2 * s, 3.5 * s, 2 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    private drawPauldron(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, dir: number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(dir, 1);

        // 3-Tiered Pauldron
        const colors = [
            SkeletonCommanderUnitRenderer.PALETTE.ARMOR_DARK,
            SkeletonCommanderUnitRenderer.PALETTE.ARMOR_BASE,
            SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT
        ];

        for (let i = 0; i < 3; i++) {
            ctx.fillStyle = colors[i];
            ctx.beginPath();
            const off = i * 2 * s;
            ctx.arc(0, 0 + off, 6 * s - (i * 1 * s), Math.PI, 0);
            ctx.fill();
        }

        // Gold Trim
        ctx.strokeStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE;
        ctx.lineWidth = 2 * s;
        ctx.beginPath(); ctx.arc(0, 4 * s, 4 * s, Math.PI, 0); ctx.stroke();

        // Spike
        ctx.fillStyle = '#eee';
        ctx.beginPath(); ctx.moveTo(-1 * s, -4 * s); ctx.lineTo(0, -10 * s); ctx.lineTo(1 * s, -4 * s); ctx.fill();

        ctx.restore();
    }

    private drawHelmet(ctx: CanvasRenderingContext2D, s: number) {
        // Base
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath(); ctx.arc(0, 0, 6 * s, 0, Math.PI * 2); ctx.fill();

        // Faceplate: T-Visor Design (Dark Knight)
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_HIGHLIGHT;
        ctx.beginPath();
        ctx.moveTo(-6 * s, -2 * s);
        ctx.quadraticCurveTo(0, 8 * s, 6 * s, -2 * s); // Jaw line
        ctx.lineTo(6 * s, -6 * s);
        ctx.quadraticCurveTo(0, -2 * s, -6 * s, -6 * s); // Brow
        ctx.fill();

        // Eye Slit (Glowing)
        const glowImg = Assets.get('fx_glow_red');
        if (glowImg) {
            ctx.drawImage(glowImg, -5 * s, -5 * s, 10 * s, 10 * s);
        } else {
            ctx.shadowBlur = 15;
            ctx.shadowColor = SkeletonCommanderUnitRenderer.PALETTE.MAGIC_GLOW;
        }

        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.MAGIC_GLOW;

        // Single horizontal slit or two eyes? 
        // Two aggressive angular eyes
        ctx.beginPath();
        // Left eye
        ctx.moveTo(-1 * s, 0); ctx.lineTo(-4 * s, -1 * s); ctx.lineTo(-3 * s, 1 * s); ctx.fill();
        // Right eye
        ctx.moveTo(1 * s, 0); ctx.lineTo(4 * s, -1 * s); ctx.lineTo(3 * s, 1 * s); ctx.fill();

        ctx.shadowBlur = 0;

        // Crown (Gold)
        this.drawGoldTrim(ctx, -6 * s, -6 * s, 12 * s, 2 * s); // Brow band
        // Spikes
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE;
        ctx.beginPath();
        ctx.moveTo(-5 * s, -6 * s); ctx.lineTo(-6 * s, -12 * s); ctx.lineTo(-3 * s, -6 * s);
        ctx.moveTo(5 * s, -6 * s); ctx.lineTo(6 * s, -12 * s); ctx.lineTo(3 * s, -6 * s);
        ctx.moveTo(0, -6 * s); ctx.lineTo(0, -14 * s); ctx.lineTo(2 * s, -6 * s); // Center tall
        ctx.fill();
    }

    private drawGreatsword(ctx: CanvasRenderingContext2D, x: number, y: number, s: number) {
        ctx.save();
        ctx.translate(x, y);

        // Blade with Glow
        // Optimization: Use cached glow instead of shadowBlur
        const glowImg = Assets.get('fx_glow_red');
        if (glowImg) {
            ctx.save();
            ctx.scale(0.5, 2.0); // Stretch vertically for blade
            ctx.globalAlpha = 0.4;
            ctx.drawImage(glowImg, -8 * s, -2 * s, 16 * s, 16 * s);
            ctx.restore();
        } else {
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'rgba(255, 61, 0, 0.4)';
        }

        // Metallic Gradient for Blade
        const grad = ctx.createLinearGradient(-3 * s, 0, 3 * s, 0);
        grad.addColorStop(0, '#cfd8dc');
        grad.addColorStop(0.5, '#ffffff'); // Ridge highlighted
        grad.addColorStop(1, '#b0bec5');

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(-3 * s, 0);
        ctx.lineTo(3 * s, 0);
        ctx.lineTo(0, 24 * s); // Wicked long
        ctx.fill();
        ctx.shadowBlur = 0;

        // Rune Inscription (Pulsing)
        ctx.strokeStyle = SkeletonCommanderUnitRenderer.PALETTE.MAGIC_GLOW;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, 2 * s); ctx.lineTo(0, 18 * s);
        ctx.stroke();

        // Crossguard (Bat wing style)
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.ARMOR_BASE;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-6 * s, -2 * s, -8 * s, 2 * s); // Wing tip
        ctx.lineTo(0, 4 * s);
        ctx.lineTo(8 * s, 2 * s);
        ctx.quadraticCurveTo(6 * s, -2 * s, 0, 0);
        ctx.fill();

        // Gem in guard
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.MAGIC_GLOW;
        ctx.beginPath(); ctx.arc(0, 1 * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();

        // Hilt
        ctx.fillStyle = '#3e2723';
        ctx.fillRect(-1 * s, -8 * s, 2 * s, 8 * s);

        // Pommel
        ctx.fillStyle = SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE;
        ctx.beginPath(); ctx.arc(0, -9 * s, 2.5 * s, 0, Math.PI * 2); ctx.fill();

        ctx.restore();
    }

    private drawGoldTrim(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number) {
        const grad = ctx.createLinearGradient(x, y, x, y + h);
        grad.addColorStop(0, SkeletonCommanderUnitRenderer.PALETTE.GOLD_LIGHT);
        grad.addColorStop(0.5, SkeletonCommanderUnitRenderer.PALETTE.GOLD_BASE);
        grad.addColorStop(1, SkeletonCommanderUnitRenderer.PALETTE.GOLD_DARK);
        ctx.fillStyle = grad;
        ctx.fillRect(x, y, w, h);
    }
}
</file>

<file path="src/renderers/units/SpiderUnitRenderer.ts">
import { CachedUnitRenderer } from './CachedUnitRenderer';
import { UnitRenderer } from './UnitRenderer';
import { CONFIG } from '../../Config';
import type { Enemy } from '../../Enemy';
import { Assets } from '../../Assets';

export class SpiderUnitRenderer extends CachedUnitRenderer {
    protected override orientationMode = 'DIR3' as const;
    // üé® Sinister Poison Palette
    private static readonly BODY_COLOR = '#051806'; // Nearly black green
    private static readonly ABDOMEN_COLOR = '#0f2910'; // Dark toxic green
    private static readonly LEG_COLOR = '#194d1b'; // Darker Leg
    private static readonly LEG_JOINT = '#4caf50'; // Glowing Joints
    private static readonly EYES_COLOR = '#d500f9'; // Sharp Purple
    private static readonly FANGS_COLOR = '#b388ff'; // Pale Purple
    private static readonly ACID_GLOW = '#76ff03';  // Bright Toxic Green
    private static readonly VEIN_COLOR = '#2e7d32'; // Subtle veins

    constructor() {
        super();
        this.walkCycleMultiplier = 0.4;
    }

    // BAKING SUPPORT
    public getBakeFacings(): ('SIDE' | 'UP' | 'DOWN')[] {
        return ['SIDE', 'UP', 'DOWN'];
    }

    public drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: 'SIDE' | 'UP' | 'DOWN') {
        const cycle = t * Math.PI * 2;
        const scale = 1.0;
        const spiderScale = scale * 1.1;
        const isMoving = true;
        const time = t * 10;
        const breathe = Math.sin(time * 8) * 0.3 * spiderScale;

        // CRITICAL: Draw legs first!
        this.drawLegs(ctx, facing, spiderScale, cycle, isMoving);

        if (facing === 'UP') {
            this.drawBack(ctx, spiderScale, breathe, time);
        } else if (facing === 'DOWN') {
            this.drawFront(ctx, spiderScale, breathe, time);
        } else {
            this.drawSide(ctx, spiderScale, breathe, time);
        }
    }

    drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void {
        this.drawFrameDirectional(ctx, enemy, t, 'SIDE');
    }

    // drawBody is inherited


    private drawLegs(ctx: CanvasRenderingContext2D, facing: string, s: number, cycle: number, isMoving: boolean) {
        const drawLeg = (sx: number, sy: number, ex: number, ey: number, kneeDir: number, phase: number, zIndex: number = 0) => {
            let tx = ex;
            let ty = ey;

            // Spider Movement: Legs lift HIGH and stab down
            if (isMoving) {
                const step = (cycle + phase) % (Math.PI * 2);
                if (step < Math.PI) {
                    // Lift phase (High arch)
                    const progress = Math.sin(step);
                    ty -= progress * 8 * s; // High steps
                    tx += Math.cos(step) * 2 * s;
                } else {
                    // Plant phase (Drag back)
                }
            }

            ctx.lineWidth = (zIndex === 0 ? 2 : 1.5) * s;
            ctx.strokeStyle = SpiderUnitRenderer.LEG_COLOR;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(sx, sy);

            // Knee Calculation (Sharp angles)
            const dx = tx - sx;
            const dy = ty - sy; // 3D Topdown perspective flattening
            const dist = Math.hypot(dx, dy);

            // Knee sticks UP in Z (negative Y in 2D)
            const midX = (sx + tx) / 2;
            const midY = (sy + ty) / 2;

            // Calculate a "knee" point that creates an arch
            const archHeight = 10 * s;
            const kx = midX + (dx * 0.1);
            // In top down, knees usually point OUT or UP. 
            // Let's bias Y negative for "Up"
            const ky = midY - archHeight * kneeDir;

            ctx.lineTo(kx, ky);
            ctx.lineTo(tx, ty);
            ctx.stroke();

            // Glowing Joint
            ctx.fillStyle = SpiderUnitRenderer.LEG_JOINT;
            ctx.beginPath(); ctx.arc(kx, ky, 1.2 * s, 0, Math.PI * 2); ctx.fill();
        };

        if (facing === 'SIDE') {
            // Side View Legs (Scuttling)
            // Far Left Legs
            drawLeg(0, -2 * s, -8 * s, 6 * s, 0.8, 0, 0);
            drawLeg(2 * s, -2 * s, 8 * s, 6 * s, 0.8, 1.5, 0);
            drawLeg(-2 * s, -2 * s, -10 * s, 4 * s, 0.9, 3.0, 0);
            drawLeg(4 * s, -2 * s, 12 * s, 4 * s, 0.9, 4.5, 0);
        } else {
            // Front/Back View Legs (Arched around body)
            // 4 Pairs
            const legSpread = [
                { dir: -1, phase: 0, ex: -12, ey: -8 }, // Front L
                { dir: 1, phase: Math.PI, ex: 12, ey: -8 }, // Front R
                { dir: -1, phase: 1.5, ex: -16, ey: 0 },  // Mid L
                { dir: 1, phase: Math.PI + 1.5, ex: 16, ey: 0 },  // Mid R
                { dir: -1, phase: 3, ex: -14, ey: 8 },    // Mid-Back L
                { dir: 1, phase: Math.PI + 3, ex: 14, ey: 8 },    // Mid-Back R
                { dir: -1, phase: 4.5, ex: -10, ey: 12 },   // Back L
                { dir: 1, phase: Math.PI + 4.5, ex: 10, ey: 12 },   // Back R
            ];

            const flipY = facing === 'UP' ? -1 : 1;

            legSpread.forEach(l => {
                const sx = l.dir * 3 * s; // Body attach width
                const sy = 0; // Center body

                // Front view: Legs arch DOWN
                // Back view: Legs arch DOWN
                // My knee logic (negative Y = UP) works for side view.
                // For top-downish front view:

                // Draw manual polylines for better shape
                this.drawLegArc(ctx, sx, sy, l.ex * s, l.ey * s * flipY, cycle + l.phase, s, isMoving);
            });
        }
    }

    private drawLegArc(ctx: CanvasRenderingContext2D, sx: number, sy: number, ex: number, ey: number, cycle: number, s: number, isMoving: boolean) {
        let finalEx = ex;
        let finalEy = ey;

        if (isMoving) {
            const lift = Math.sin(cycle);
            if (lift > 0) {
                finalEy -= lift * 6 * s; // Lift leg UP (negative Y)
            }
        }

        ctx.strokeStyle = SpiderUnitRenderer.LEG_COLOR;
        ctx.lineWidth = 1.8 * s;
        ctx.beginPath();
        ctx.moveTo(sx, sy);

        // Elbow point (High)
        const mx = (sx + finalEx) / 2;
        const my = (sy + finalEy) / 2 - 8 * s; // Arch UP

        ctx.quadraticCurveTo(mx, my, finalEx, finalEy);
        ctx.stroke();

        // Tip (claw)
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(finalEx, finalEy, 1 * s, 0, Math.PI * 2); ctx.fill();
    }

    // === VIEWS ===

    private drawFront(ctx: CanvasRenderingContext2D, s: number, breathe: number, t: number) {
        // Abdomen (Behind) - Darker
        ctx.fillStyle = SpiderUnitRenderer.ABDOMEN_COLOR;
        ctx.beginPath();
        ctx.ellipse(0, -3 * s, 6.5 * s, 5.5 * s + breathe, 0, 0, Math.PI * 2);
        ctx.fill();

        // Pulsing Veins
        this.drawVeins(ctx, 0, -3 * s, 6 * s, t);

        // Cephalothorax (Head)
        ctx.fillStyle = SpiderUnitRenderer.BODY_COLOR;
        ctx.beginPath();
        // Spiky shape
        ctx.moveTo(-3 * s, 0); ctx.lineTo(0, 4 * s); ctx.lineTo(3 * s, 0); ctx.lineTo(0, -3 * s);
        ctx.fill();

        // Eyes (Many)
        ctx.fillStyle = SpiderUnitRenderer.EYES_COLOR;
        // Cheap fake glow (Draw larger with alpha)
        [[-1, 1], [1, 1], [-2.5, 0.5], [2.5, 0.5]].forEach(p => {
            // Glow
            ctx.globalAlpha = 0.3;
            ctx.beginPath(); ctx.arc(p[0] * s, p[1] * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();
            // Core
            ctx.globalAlpha = 1.0;
            ctx.beginPath(); ctx.arc(p[0] * s, p[1] * s, 0.8 * s, 0, Math.PI * 2); ctx.fill();
        });

        // Fangs (Sharp)
        ctx.fillStyle = SpiderUnitRenderer.FANGS_COLOR;
        ctx.beginPath();
        ctx.moveTo(-1.5 * s, 3 * s); ctx.lineTo(-1 * s, 7 * s); ctx.lineTo(-0.5 * s, 3 * s);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(1.5 * s, 3 * s); ctx.lineTo(1 * s, 7 * s); ctx.lineTo(0.5 * s, 3 * s);
        ctx.fill();
    }

    private drawBack(ctx: CanvasRenderingContext2D, s: number, breathe: number, t: number) {
        // Cephalothorax (Front)
        ctx.fillStyle = SpiderUnitRenderer.BODY_COLOR;
        ctx.beginPath();
        ctx.arc(0, -2 * s, 3.5 * s, 0, Math.PI * 2);
        ctx.fill();

        // Abdomen (Huge, foreground)
        const abY = 3 * s;
        ctx.fillStyle = SpiderUnitRenderer.ABDOMEN_COLOR;
        ctx.beginPath();
        ctx.ellipse(0, abY, 7.5 * s, 6.5 * s + breathe, 0, 0, Math.PI * 2);
        ctx.fill();

        // Pulsing Veins
        this.drawVeins(ctx, 0, abY, 7 * s, t);

        // Hourglass (Glowing)
        this.drawHourglass(ctx, 0, abY, s, t);
    }

    private drawSide(ctx: CanvasRenderingContext2D, s: number, breathe: number, t: number) {
        // Abdomen (Back)
        ctx.fillStyle = SpiderUnitRenderer.ABDOMEN_COLOR;
        ctx.beginPath();
        ctx.ellipse(-5 * s, -1 * s, 6.5 * s, 5 * s + breathe, -0.2, 0, Math.PI * 2);
        ctx.fill();

        this.drawVeins(ctx, -5 * s, -1 * s, 6 * s, t);

        // Cephalothorax (Front)
        ctx.fillStyle = SpiderUnitRenderer.BODY_COLOR;
        ctx.beginPath();
        ctx.ellipse(3 * s, 1 * s, 3.5 * s, 3 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = SpiderUnitRenderer.EYES_COLOR;
        // Fake glow
        ctx.globalAlpha = 0.3;
        ctx.beginPath(); ctx.arc(5.5 * s, 0.5 * s, 1.5 * s, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1.0;
        ctx.beginPath(); ctx.arc(5.5 * s, 0.5 * s, 0.8 * s, 0, Math.PI * 2); ctx.fill();

        // Fangs
        ctx.fillStyle = SpiderUnitRenderer.FANGS_COLOR;
        ctx.beginPath();
        ctx.moveTo(4.5 * s, 2 * s); ctx.lineTo(4 * s, 6 * s); ctx.lineTo(5.5 * s, 2 * s);
        ctx.fill();
    }

    private drawHourglass(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, t: number) {
        const glow = Math.sin(t * 5) * 5;
        ctx.fillStyle = SpiderUnitRenderer.ACID_GLOW;

        ctx.save();
        ctx.translate(x, y);
        ctx.scale(1, 1.5);

        // Fake Halo Glow
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(0, 0, 4 * s, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1.0;
        ctx.beginPath();
        ctx.moveTo(-1.5 * s, -1.5 * s); ctx.lineTo(1.5 * s, 1.5 * s); ctx.lineTo(-1.5 * s, 1.5 * s); ctx.lineTo(1.5 * s, -1.5 * s);
        ctx.fill();
        ctx.restore();
    }

    private drawVeins(ctx: CanvasRenderingContext2D, x: number, y: number, r: number, t: number) {
        ctx.strokeStyle = SpiderUnitRenderer.VEIN_COLOR;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.3 + Math.sin(t * 3) * 0.2;
        ctx.beginPath();
        // Web pattern on back
        for (let i = 0; i < 8; i++) {
            const angle = i * (Math.PI / 4);
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(angle) * r, y + Math.sin(angle) * r);
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }

    private drawAcidDrip(ctx: CanvasRenderingContext2D, s: number) {
        ctx.fillStyle = SpiderUnitRenderer.ACID_GLOW;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(0, 5 * s, 1.5 * s, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}
</file>

<file path="src/renderers/units/TrollUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import type { Enemy } from '../../Enemy';
import { Assets } from '../../Assets';

export class TrollUnitRenderer implements UnitRenderer {
    // üé® Palette (Snow Troll)
    private static readonly FUR_BASE = '#eceff1';    // Snow White
    private static readonly FUR_SHADOW = '#cfd8dc';  // Blue-ish Grey Shadow
    private static readonly SKIN_DARK = '#b0bec5';   // Face/Hands
    private static readonly CLUB_WOOD = '#5d4037';   // Dark Wood
    private static readonly CLUB_LIGHT = '#8d6e63';  // Wood Highlight
    private static readonly EYE_COLOR = '#455a64';   // Dark Eyes (not glowing)

    // Config
    private static readonly CLUB_LENGTH = 24;
    private static readonly CLUB_WIDTH = 8;

    // BAKING SUPPORT
    public getBakeFacings(): ('SIDE' | 'UP' | 'DOWN')[] {
        return ['SIDE', 'UP', 'DOWN'];
    }

    public drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: 'SIDE' | 'UP' | 'DOWN') {
        const cycle = t * Math.PI * 2;
        const scale = 1.0;
        const isMoving = true;

        if (facing === 'UP') return this.drawBack(ctx, scale, cycle, isMoving);
        if (facing === 'DOWN') return this.drawFront(ctx, scale, cycle, isMoving);
        return this.drawSide(ctx, scale, cycle, isMoving);
    }

    drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void {
        this.drawFrameDirectional(ctx, enemy, t, 'SIDE');
    }

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.001;
        // Heavy, slow movement (baseSpeed is 42, ~0.7 tiles/sec)
        // Adjusted walk cycle speed for "heaviness"
        const walkCycle = time * (enemy.baseSpeed * 0.15);

        // 1. Try Cached Sprite
        const t = (walkCycle % (Math.PI * 2)) / (Math.PI * 2);
        const frameIdx = Math.floor(t * 32) % 32;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        // Angles: -PI..PI. 0 is Right. 
        // UP: -PI/2 approx (-1.57). range -2.35 to -0.78
        // DOWN: PI/2 approx (1.57). range 0.78 to 2.35
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        const facingLeft = Math.cos(rotation) < 0;

        const frameKey = `unit_${enemy.typeId}_${facing.toLowerCase()}_walk_${frameIdx}`;

        const sprite = Assets.get(frameKey);
        if (sprite) {
            ctx.save();
            const size = 96 * scale;

            if (facing === 'SIDE') {
                if (facingLeft) ctx.scale(-1, 1);
            }

            ctx.drawImage(sprite, -size / 2, -size / 2, size, size);

            // Hit Flash
            if (enemy.hitFlashTimer > 0) {
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillRect(-size / 2, -size / 2, size, size);
            }

            ctx.restore();
            return;
        }

        // 2. Fallback
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        ctx.save();

        if (enemy.hitFlashTimer > 0) ctx.globalAlpha = 0.7;

        if (facing === 'SIDE') {
            if (facingLeft) {
                ctx.scale(-1, 1); // Flip for Left
            }
            this.drawSide(ctx, scale, walkCycle, isMoving);
        } else if (facing === 'UP') {
            this.drawBack(ctx, scale, walkCycle, isMoving);
        } else {
            this.drawFront(ctx, scale, walkCycle, isMoving);
        }

        ctx.restore();
    }

    // === FRONT VIEW ===
    private drawFront(ctx: CanvasRenderingContext2D, s: number, wc: number, moving: boolean) {
        // Heavy plodding bounce
        const bounce = moving ? Math.abs(Math.sin(wc)) * 2 * s : 0;

        ctx.translate(0, -bounce);

        // 1. Back/Legs (Behind)
        this.drawLegsFront(ctx, s, wc, moving);

        // 2. Club (Dragging BEHIND to the side)
        // Hand is at (11, -4). Club should go down and back.
        // We simulate "dragging" by angling it.
        const dragAngle = -0.4; // Tilted back/out
        ctx.save();
        ctx.translate(11 * s, -4 * s); // Pivot at hand
        ctx.rotate(dragAngle);
        // Draw club extending down from hand
        this.drawClub(ctx, s, true);
        ctx.restore();

        // 3. Body (Hunchback Main Mass)
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        // Big round belly/chest
        ctx.ellipse(0, -2 * s, 10 * s, 11 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Fur Details (Chest)
        this.drawFurPatches(ctx, 0, -2 * s, 8 * s, s);

        // 4. Arms (Heavy, hanging low)
        const sway = moving ? Math.sin(wc) * 0.1 : 0;

        // Left Arm (Empty) - Thick muscles
        this.drawArmFront(ctx, -11 * s, -4 * s, s, 0.2 + sway);

        // Right Arm (Holding Club) - Firm grip on the pivoted club
        // We draw the arm on top of the club pivot
        this.drawArmFront(ctx, 11 * s, -4 * s, s, dragAngle);

        // 5. Head (Low, sunken)
        ctx.translate(0, -8 * s); // Neck is low
        this.drawHeadFront(ctx, s);
    }

    // === BACK VIEW ===
    private drawBack(ctx: CanvasRenderingContext2D, s: number, wc: number, moving: boolean) {
        const bounce = moving ? Math.abs(Math.sin(wc)) * 2 * s : 0;
        ctx.translate(0, -bounce);

        // 1. Legs
        this.drawLegsFront(ctx, s, wc, moving);

        // 2. Club (Dragging)
        // Hand is at Right (User's Right is Unit's Right) -> (12, -8)
        const dragAngle = 0.4;
        ctx.save();
        ctx.translate(12 * s, -8 * s); // Shoulder/Hand area
        ctx.rotate(dragAngle);
        // Club extends down
        this.drawClub(ctx, s, true);
        ctx.restore();

        // 3. Body (Massive Back)
        ctx.fillStyle = TrollUnitRenderer.FUR_SHADOW; // Darker back
        ctx.beginPath();
        ctx.ellipse(0, -4 * s, 11 * s, 12 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Fur Texture
        this.drawFurPatches(ctx, 0, -4 * s, 9 * s, s, true);

        // 4. Shoulders
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        ctx.arc(-11 * s, -8 * s, 5.5 * s, 0, Math.PI * 2); // Left Shoulder
        ctx.arc(11 * s, -8 * s, 5.5 * s, 0, Math.PI * 2);  // Right Shoulder
        ctx.fill();

        // 5. Head (Back)
        ctx.translate(0, -10 * s);
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        ctx.arc(0, 0, 6.5 * s, 0, Math.PI * 2);
        ctx.fill();
    }

    // === SIDE VIEW ===
    private drawSide(ctx: CanvasRenderingContext2D, s: number, wc: number, moving: boolean) {
        const bounce = moving ? Math.abs(Math.sin(wc)) * 2 * s : 0;

        // Stride
        const stride = 7 * s;
        const leftLegX = moving ? Math.sin(wc) * stride : 0; // Far leg
        const rightLegX = moving ? -Math.sin(wc) * stride : 0; // Near leg

        // 1. Far Leg (Left)
        this.drawFoot(ctx, leftLegX + 3 * s, 12 * s, s, true);

        ctx.translate(0, -bounce);

        // 2. Club (Dragging Behind)
        // Hand approx at (4, -4)
        // Club should drag way back
        const dragLift = moving ? Math.sin(wc) * 0.1 : 0; // Slight bump
        ctx.save();
        ctx.translate(4 * s, -4 * s); // Hand position
        ctx.rotate(-1.2 + dragLift); // Angled sharply back
        this.drawClub(ctx, s, true);
        ctx.restore();

        // 3. Far Arm (Holding Club)
        ctx.save();
        ctx.translate(4 * s, -6 * s); // Shoulder
        ctx.rotate(-0.8); // Reaching back/down to hold club
        this.drawArmShape(ctx, s, 13);
        ctx.restore();

        // 4. Body (Hunchback Profile)
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        // Hunch shape: ellipse rotated forward
        // More "bean" shaped for hunch
        ctx.moveTo(-6 * s, 8 * s);
        ctx.quadraticCurveTo(-12 * s, -6 * s, 0, -14 * s); // Back curve
        ctx.quadraticCurveTo(10 * s, -8 * s, 6 * s, 8 * s); // Front/Belly
        ctx.fill();

        // 5. Head (Forward/Low)
        ctx.save();
        ctx.translate(6 * s, -12 * s);
        this.drawHeadSide(ctx, s);
        ctx.restore();

        // 6. Near Leg (Right)
        ctx.save();
        ctx.translate(0, bounce); // Cancel bounce
        this.drawFoot(ctx, rightLegX, 12 * s, s, false);
        ctx.restore();

        // 7. Near Arm (Swinging free)
        const armSway = moving ? Math.cos(wc) * 0.4 : 0;
        ctx.save();
        ctx.translate(6 * s, -8 * s); // Shoulder fwd
        ctx.rotate(armSway + 0.3);
        this.drawArmShape(ctx, s, 13);
        ctx.restore();
    }

    // --- COMPONENTS ---

    private drawClub(ctx: CanvasRenderingContext2D, s: number, held: boolean = false) {
        // If held, (0,0) is handle top
        const len = TrollUnitRenderer.CLUB_LENGTH * s;
        const w = TrollUnitRenderer.CLUB_WIDTH * s;

        // Positioning: if held, draw DOWN from 0,0
        // Handle
        const handleLen = 6 * s;

        ctx.fillStyle = TrollUnitRenderer.CLUB_WOOD;

        ctx.beginPath();
        // Start thin at handle (0,0)
        ctx.moveTo(-1.5 * s, 0);
        ctx.lineTo(1.5 * s, 0);

        // Flare out
        ctx.lineTo(w / 2 + 2 * s, len); // Thick end
        ctx.lineTo(-w / 2 - 2 * s, len);
        ctx.fill();

        // Texture / Spikes?
        ctx.fillStyle = TrollUnitRenderer.CLUB_LIGHT;
        ctx.beginPath();
        ctx.arc(0, len * 0.8, 2.5 * s, 0, Math.PI * 2);
        ctx.fill();

        // Shadow on ground if dragging? (Simplified as dark tip)
        ctx.fillStyle = '#3e2723';
        ctx.beginPath();
        ctx.arc(0, len, w / 2, 0, Math.PI, false);
        ctx.fill();
    }

    private drawHeadFront(ctx: CanvasRenderingContext2D, s: number) {
        // Wide, flat head, deep set
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        ctx.ellipse(0, 0, 7.5 * s, 6.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Face Area (No fur)
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.ellipse(0, 1.5 * s, 4.5 * s, 3.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = TrollUnitRenderer.EYE_COLOR;
        ctx.beginPath(); ctx.arc(-2 * s, 0.5 * s, 0.9 * s, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(2 * s, 0.5 * s, 0.9 * s, 0, Math.PI * 2); ctx.fill();

        // Brow Ridge (Heavy)
        ctx.fillStyle = TrollUnitRenderer.FUR_SHADOW;
        ctx.beginPath();
        ctx.roundRect(-5 * s, -2.5 * s, 10 * s, 2 * s, 1 * s);
        ctx.fill();

        // Tusks (Protruding Up)
        ctx.fillStyle = '#fff9c4';
        ctx.beginPath();
        ctx.moveTo(-2.5 * s, 3.5 * s); ctx.lineTo(-3 * s, 6 * s); ctx.lineTo(-1.5 * s, 4 * s);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(2.5 * s, 3.5 * s); ctx.lineTo(3 * s, 6 * s); ctx.lineTo(1.5 * s, 4 * s);
        ctx.fill();
    }

    private drawHeadSide(ctx: CanvasRenderingContext2D, s: number) {
        // Snouty profile
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        // Furry back of head
        ctx.beginPath();
        ctx.arc(-2 * s, -1 * s, 5 * s, 0, Math.PI * 2);
        ctx.fill();

        // Face connection
        ctx.beginPath();
        ctx.ellipse(1 * s, 0, 4 * s, 4 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Snout
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.ellipse(4 * s, 1 * s, 3 * s, 2.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Ear (Pointy)
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.moveTo(-2 * s, 0);
        ctx.lineTo(-5 * s, -2 * s);
        ctx.lineTo(-3 * s, 2 * s);
        ctx.fill();

        // Eye (Deep)
        ctx.fillStyle = TrollUnitRenderer.EYE_COLOR;
        ctx.beginPath(); ctx.arc(2 * s, 0, 0.9 * s, 0, Math.PI * 2); ctx.fill();

        // Tusk Side
        ctx.fillStyle = '#fff9c4';
        ctx.beginPath();
        ctx.moveTo(5 * s, 2 * s); ctx.lineTo(6 * s, -1 * s); ctx.lineTo(4 * s, 1 * s);
        ctx.fill();
    }

    private drawArmFront(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, angle: number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        // Muscle shape
        ctx.ellipse(0, 6 * s, 3.5 * s, 7 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hand
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.arc(0, 13 * s, 4 * s, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    private drawArmShape(ctx: CanvasRenderingContext2D, s: number, length: number) {
        ctx.fillStyle = TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        ctx.ellipse(0, length * 0.4 * s, 3.5 * s, length * 0.5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hand
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        ctx.beginPath();
        ctx.arc(0, length * s, 4 * s, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawLegsFront(ctx: CanvasRenderingContext2D, s: number, wc: number, moving: boolean) {
        const strideY = moving ? Math.sin(wc) * 3 * s : 0;
        // Wide stance
        this.drawLeg(ctx, -7 * s, 6 * s + strideY, s, true);
        this.drawLeg(ctx, 7 * s, 6 * s - strideY, s, false);
    }

    private drawLeg(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, isLeft: boolean) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = TrollUnitRenderer.FUR_SHADOW;

        // Thigh
        ctx.beginPath();
        ctx.ellipse(0, 4 * s, 4 * s, 6 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Foot (Paw-like, 3 toes)
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;
        const toeY = 10 * s;

        // Main foot pad
        ctx.beginPath();
        ctx.ellipse(0, toeY - 1 * s, 4.5 * s, 3 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Toes
        const toes = [-2.5, 0, 2.5];
        toes.forEach(tx => {
            ctx.beginPath();
            ctx.arc(tx * s, toeY + 1.5 * s, 1.8 * s, 0, Math.PI * 2);
            ctx.fill();
        });

        ctx.restore();
    }

    private drawFoot(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, dark: boolean) {
        ctx.save();
        ctx.translate(x, y);

        // Leg stump
        ctx.fillStyle = dark ? TrollUnitRenderer.FUR_SHADOW : TrollUnitRenderer.FUR_BASE;
        ctx.beginPath();
        ctx.roundRect(-3.5 * s, -8 * s, 7 * s, 8 * s, 2 * s);
        ctx.fill();

        // Foot (Paw)
        ctx.fillStyle = TrollUnitRenderer.SKIN_DARK;

        // Pad
        ctx.beginPath();
        ctx.ellipse(1 * s, 0, 5 * s, 3 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Toes (Side view - stacked)
        ctx.beginPath(); ctx.arc(5 * s, 1 * s, 1.8 * s, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(3 * s, 1.5 * s, 1.8 * s, 0, Math.PI * 2); ctx.fill();

        ctx.restore();
    }

    private drawFurPatches(ctx: CanvasRenderingContext2D, x: number, y: number, r: number, s: number, dark: boolean = false) {
        ctx.fillStyle = dark ? '#b0bec5' : '#ffffff'; // Highlight patches
        // Random-ish patches to break up the circle
        const patches = [
            { dx: -0.5, dy: -0.5, sz: 0.4 },
            { dx: 0.5, dy: -0.4, sz: 0.5 },
            { dx: 0, dy: 0.2, sz: 0.6 },
        ];

        patches.forEach(p => {
            ctx.beginPath();
            ctx.arc(x + p.dx * r, y + p.dy * r, p.sz * r, 0, Math.PI * 2);
            ctx.fill();
        });
    }
}
</file>

<file path="src/renderers/units/UnitRenderer.ts">
import { Assets } from '../../Assets';
import { CONFIG } from '../../Config';
import type { Enemy } from '../../Enemy';

/**
 * Interface for specific unit renderers (Strategy Pattern).
 * Draws ONLY the body/components of the unit. 
 * Coordinate system is already transformed to unit center (0,0) 
 * and rotated by the parent EnemyRenderer.
 */
export interface UnitRenderer {
    /**
     * Draw the unit body.
     * @param ctx Canvas context (pre-translated to 0,0)
     * @param enemy The enemy instance
     * @param scale Visual scale factor
     * @param rotation Rotation in radians (direction of movement)
     */
    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void;

    /**
     * Optional: Draw glowing parts (eyes, runes) that should pierce through fog/darkness.
     * Drawn in a separate pass after lighting.
     */
    drawEmissive?(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void;

    /**
     * Optional: Draw a specific frame of animation for baking.
     * @param t Normalized time (0.0 to 1.0) representing the animation cycle.
     */
    drawFrame?(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void;

    /**
     * Optional: Return supported facings for baking (SIDE, UP, DOWN).
     * If undefined, defaults to ['SIDE'].
     */
    getBakeFacings?(): ('SIDE' | 'UP' | 'DOWN')[];

    /**
     * Optional: Draw a specific frame for a specific facing.
     * Used by SpriteBaker if getBakeFacings includes UP/DOWN.
     */
    drawFrameDirectional?(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: 'SIDE' | 'UP' | 'DOWN'): void;
}

/**
 * Default renderer for generic enemies (fallback).
 * Implements the classic "Sprite or Circle" logic.
 */
export class DefaultUnitRenderer implements UnitRenderer {

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        // Legacy behavior: rotate sprite to face movement
        ctx.save();
        ctx.rotate(rotation + Math.PI / 2);

        const safeType = enemy.typeId ? enemy.typeId.toLowerCase() : 'grunt';

        // Lookup config using typeId
        const typeConf = Object.values(CONFIG.ENEMY_TYPES).find(t => t.id === safeType);

        const archetype = typeConf?.archetype || 'GRUNT';
        // @ts-ignore - tint is optional in IEnemyTypeConfig but union type might confuse TS
        const tint = typeConf?.tint;

        const bodyImgName = `enemy_${archetype.toLowerCase()}`;
        const bodyImg = Assets.get(bodyImgName);

        if (bodyImg) {
            const size = 48 * scale;
            const half = size / 2;

            ctx.drawImage(bodyImg, -half, -half, size, size);

            if (tint) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = tint;
                ctx.globalAlpha = 0.5;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }

            // Hit Flash
            if (enemy.hitFlashTimer > 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.8;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }

            // Status Tints
            if (enemy.statuses.some(s => s.type === 'slow')) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = CONFIG.AMBIENT.LIGHTING.ICE || '#00e5ff';
                ctx.globalAlpha = 0.4;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }
            if (enemy.statuses.some(s => s.type === 'burn')) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = CONFIG.AMBIENT.LIGHTING.FIRE || '#ff3d00';
                ctx.globalAlpha = 0.4;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }
        } else {
            // Fallback (Circle)
            ctx.fillStyle = tint || '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 16 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }
}
</file>

<file path="src/SoundManager.ts">
export enum SoundPriority {
    LOW = 0,
    HIGH = 1
}

export class SoundManager {
    private static ctx: AudioContext;
    private static buffers: Record<string, AudioBuffer> = {};
    private static lastPlayed: Record<string, number> = {};
    private static lastPlayedType: Record<string, number> = {}; // Track last play time by TYPE
    private static lowPriorityCount: number = 0;
    private static lastFrameTime: number = 0;

    // Config
    private static CULL_MS = 50; // Minimum time between same sounds (Legacy logic)
    private static THROTTLE_MS = 60; // Global throttle for identical sounds
    public static MASTER_VOLUME = 0.3; // Made public for settings
    public static SFX_VOLUME = 1.0;
    public static MUSIC_VOLUME = 0.5;

    public static setVolume(master: number) {
        this.MASTER_VOLUME = Math.max(0, Math.min(1, master));
    }

    public static async init() {
        if (this.ctx) return;

        try {
            // @ts-ignore - Handle webkit prefix for older browsers if needed
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContextClass();
            console.log('SoundManager: AudioContext initialized');

            // Generate basic sounds
            this.generateSounds();
        } catch (e) {
            console.error('SoundManager: Failed to init AudioContext', e);
        }
    }

    public static resume() {
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    public static play(key: string, priority: SoundPriority = SoundPriority.LOW) {
        if (!this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();

        const now = Date.now();
        const last = this.lastPlayed[key] || 0;

        // 1. Culling / Ducking logic
        // Reset frame limits if new frame
        if (now !== this.lastFrameTime) {
            this.lowPriorityCount = 0;
            this.lastFrameTime = now;
        }

        // If High Priority, we always play
        // If Low Priority, apply strict limits
        if (priority === SoundPriority.LOW) {
            // A. Hard Limit: Max 3 low priority sounds per frame
            if (this.lowPriorityCount >= 3) return;

            // B. Time Throttling (Legacy cull)
            if (now - last < this.CULL_MS) return;

            // C. Global Type Throttling 
            const lastType = this.lastPlayedType[key] || 0;
            if (now - lastType < this.THROTTLE_MS) return;

            this.lowPriorityCount++;
        }

        this.lastPlayed[key] = now;
        this.lastPlayedType[key] = now;

        const buffer = this.buffers[key];
        if (!buffer) {
            // console.warn(`SoundManager: Sound '${key}' not found`);
            return;
        }

        // Create Source
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;

        // 2. Pitch Variance (Tech Trick)
        // +/- 10% (0.9 to 1.1)
        const detune = 0.9 + Math.random() * 0.2;
        source.playbackRate.value = detune;

        // Gain (Volume)
        const gainNode = this.ctx.createGain();
        let vol = this.MASTER_VOLUME * this.SFX_VOLUME;

        // Boost high priority sounds slightly
        if (priority === SoundPriority.HIGH) vol *= 1.5;

        // Randomize volume slightly too for "organic" feel
        vol *= (0.9 + Math.random() * 0.2);

        gainNode.gain.value = vol;

        // Connect
        source.connect(gainNode);
        gainNode.connect(this.ctx.destination);

        source.start();
    }

    private static generateSounds() {
        // We synthesize simple buffers
        // 1. Shoot (Sniper/Gun) - Sharp decay noise/square
        this.buffers['shoot_basic'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 20);
            return (Math.random() * 2 - 1) * decay;
        }, 0.2);

        this.buffers['shoot_sniper'] = this.createBuffer((t) => {
            // Longer, louder crack
            const decay = Math.exp(-t * 10);
            const noise = (Math.random() * 2 - 1);
            return noise * decay * 1.5; // Boost
        }, 0.5);

        // 2. Hit - High pitched tick
        this.buffers['hit'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 50);
            return Math.sin(t * 2000 * Math.PI * 2) * decay;
        }, 0.1);

        // 3. Enemy Death - Soft pop (pleasant, not annoying on repeat)
        this.buffers['death'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 25);
            // Soft bubble pop - high start, quick fade
            const freq = 400 * Math.exp(-t * 8);
            return Math.sin(t * freq * Math.PI * 2) * decay * 0.6;
        }, 0.15);

        // 4. Boss Spawn - Low droning sweep
        this.buffers['boss_spawn'] = this.createBuffer((t) => {
            const freq = 50 + Math.sin(t * 10) * 20;
            return Math.sin(t * freq * Math.PI * 2) * 0.8;
        }, 1.5);

        // 5. UI Click - Clean pip
        this.buffers['click'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 30);
            return Math.sin(t * 800 * Math.PI * 2) * decay;
        }, 0.1);

        // 6. UI Hover - Very short tick
        this.buffers['hover'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 50);
            return Math.sin(t * 1200 * Math.PI * 2) * decay * 0.2;
        }, 0.05);

        // 7. Explosion
        this.buffers['explosion'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 5);
            return (Math.random() * 2 - 1) * decay;
        }, 0.5);
    }

    private static createBuffer(fn: (t: number) => number, duration: number): AudioBuffer {
        const sampleRate = this.ctx.sampleRate;
        const frames = sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, frames, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < frames; i++) {
            data[i] = fn(i / sampleRate);
        }
        return buffer;
    }
}
</file>

<file path="src/cards/SniperCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Sniper Card Upgrades
 * 
 * Level 1: +80 range, +14 damage, -50% attack speed, 10% crit chance
 * Level 2: +160 range, +24 damage, -35% attack speed, 15% crit chance
 * Level 3: +240 range, +46 damage, -15% attack speed, 20% crit chance, pierce 2 enemies (15% damage loss each)
 */
export const SNIPER_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damage: 14,
            range: 80,
            attackSpeedMultiplier: 0.30, // -70% attack speed (slower)
            critChance: 0.15, // 15% crit chance
        },
        effects: [],
        visualOverrides: {
            projectileType: 'sniper',
            projectileColor: '#4caf50',
            projectileSpeed: 900, // 15 * 60
        }
    },
    2: {
        level: 2,
        modifiers: {
            damage: 24,
            range: 160,
            attackSpeedMultiplier: 0.45, // -55% attack speed
            critChance: 0.15,
        },
        effects: []
    },
    3: {
        level: 3,
        modifiers: {
            damage: 46,
            range: 240,
            attackSpeedMultiplier: 0.60, // -40% attack speed (improved from level 2)
            critChance: 0.20,
        },
        effects: [
            {
                type: 'pierce',
                pierceCount: 2, // Pierce through 2 enemies
                pierceDamageLoss: 0.15, // Lose 15% damage per pierce
            }
        ]
    }
};
</file>

<file path="src/renderers/units/MagmaUnitRenderer.ts">
import { CachedUnitRenderer } from './CachedUnitRenderer';
import { UnitRenderer } from './UnitRenderer';
import type { Enemy } from '../../Enemy';
import { Assets } from '../../Assets';
import { AssetCache } from '../../utils/AssetCache';

interface MagmaParticle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    size: number;
    life: number;
    maxLife: number;
    type: 'EMBER' | 'ASH' | 'SMOKE' | 'SPARK';
    active: boolean; // For pooling
}

export class MagmaUnitRenderer extends CachedUnitRenderer {
    // --- PALETTE: MOLTEN CORE ---
    protected override orientationMode = 'FLIP' as const;

    // Core is blindingly bright, cooling as it goes out
    private static readonly C_CORE = '#ffffff';       // White-hot core
    private static readonly C_CORE_BRIGHT = '#fff9e6'; // Slightly yellow glow
    private static readonly C_LAVA_LIGHT = '#ff9800'; // Liquid Magma
    private static readonly C_LAVA_DARK = '#bf360c';  // Cooling Magma
    private static readonly C_CRUST = '#212121';      // Obsidian/Slag
    private static readonly C_ASH = '#757575';        // Grey Ash

    // --- DECOY PALETTE: DEAD STONE ---
    private static readonly C_STONE_BASE = '#0d0d0d';
    private static readonly C_STONE_DARK = '#1a1a1a';
    private static readonly C_STONE_HIGHLIGHT = '#424242';
    private static readonly C_EMBER_FAINT = '#3e1c14'; // Dying embers in cracks

    // Particle System (WeakMap for instance isolation)
    private particleSystems = new WeakMap<Enemy, MagmaParticle[]>();

    // OPTIMIZATION: Max particles per enemy to prevent infinite scaling
    private static readonly MAX_PARTICLES_PER_ENEMY = 15;

    // Object Pool for Particles to avoid GC
    private static particlePool: MagmaParticle[] = [];
    // OPTIMIZATION: Free list for O(1) allocation
    private static freeParticles: MagmaParticle[] = [];

    constructor() {
        super();
        this.walkCycleMultiplier = 0.1; // 55 * 0.1 = 5.5 rad/s -> ~1.1s per cycle (Heavy Walk)
    }

    // --- POOLING UTILS ---
    private static getParticle(): MagmaParticle {
        // OPTIMIZATION: O(1) pop from free list
        const p = this.freeParticles.pop();
        if (p) {
            p.active = true;
            return p;
        }
        // Create new if pool empty
        const newP: MagmaParticle = {
            x: 0, y: 0, vx: 0, vy: 0, size: 0, life: 0, maxLife: 0, type: 'SMOKE', active: true
        };
        this.particlePool.push(newP);
        return newP;
    }

    private static releaseParticle(p: MagmaParticle) {
        p.active = false;
        this.freeParticles.push(p);
    }

    // BAKING SUPPORT
    drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void {
        // Fix: Normalize time to 1 cycle (2 PI)
        // t is 0..1 representing one full walk cycle
        const phase = t * Math.PI * 2;
        const scale = 1.0;
        // Check local override or passed enemy type for boss status
        const isBoss = (enemy.typeId === 'magma_king');

        if (isBoss) {
            this.drawDemonBoss(ctx, enemy, scale, phase);
        } else {
            this.drawObsidianStatue(ctx, scale, phase);
        }
    }

    // --- HYBRID RENDERING ---
    // Body is cached (via super.drawBody), Effects are dynamic on top.

    protected drawEffects(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number): void {
        const isBoss = enemy.typeId === 'magma_king';

        ctx.save(); // OPTIMIZATION: Safety wrap

        // Draw particles on top of the cached sprite
        this.updateParticles(ctx, enemy, scale, isBoss);

        // Draw emissive glow
        this.drawEmissive(ctx, enemy, scale, 0);

        ctx.restore();
    }

    // NOTE: We do NOT override drawBody anymore. 
    // CachedUnitRenderer.drawBody handles the sprite + hit flash + calls drawEffects.


    // =========================================================================
    // 1. THE MOLTEN ARCHDEMON
    // =========================================================================
    // ... (rest of drawDemonBoss and drawObsidianStatue methods remain unchanged) ...
    // Note: Since I cannot verify line numbers for unchanged code in the middle without reading again, 
    // and replace_file_content is for contiguous blocks...
    // I will target the Particle System section specifically in a separate call if I can't encompass everything.
    // But since the user asked to optimize, I will focus on the particle update/draw logic which is at the end.

    // ... Skipping drawDemonBoss ...

    // ... Skipping drawObsidianStatue ...

    // =========================================================================
    // 1. THE MOLTEN ARCHDEMON
    // =========================================================================
    private drawDemonBoss(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, phase: number) {
        // NOTE: For baking, we assume the unit is moving to generate the walk cycle.
        // If we want an idle frame, we'd need separate logic, but here we bake "walk".
        const hpPercent = enemy.currentHealth / enemy.maxHealth;

        // Instability: As HP drops, the crust fragments more (jitter)
        const instability = (1 - hpPercent) * 3;

        // Breathing (Independent slow pulse? No, syncing with walk makes it feel heavier)
        const breathe = Math.sin(phase) * 0.02 * scale; // Reduced from 0.05

        // Movement Flow (Normalized to phase)
        // Lean: Left/Right sway (1 cycle per loop)
        const lean = Math.sin(phase) * 3 * scale; // Reduced from 8 to 3 (No more violent shake)

        // Heavy Step: Up/Down bob (2 steps per loop -> 2 cycles)
        // sin(phase) goes 0->1->0->-1->0. abs(sin) goes 0->1->0->1->0. Perfect 2 steps.
        const heavyStep = Math.abs(Math.sin(phase)) * 2 * scale; // Reduced from 6 to 2

        // Low HP Jitter (Random noise is OK, but keeping amplitude low)
        const jitterX = hpPercent < 0.3 ? (Math.random() - 0.5) * 0.5 * scale : 0; // Reduced from 1.5
        const jitterY = hpPercent < 0.3 ? (Math.random() - 0.5) * 0.5 * scale : 0;

        ctx.translate(lean + jitterX, -heavyStep + jitterY);
        ctx.scale(scale + breathe, scale + breathe);

        // A. MAGMA BODY (The Glow)
        this.drawLavaCore(ctx, phase, instability, hpPercent);

        // B. OBSIDIAN ARMOR (Floating Plates)
        this.drawCrustPlates(ctx, phase, instability);

        // C. HEAD (The Crown)
        this.drawDemonHead(ctx, phase, lean);

        // D. ARMS (Heavy Flow with DRIPPING LAVA)
        this.drawLavaArms(ctx, phase);
    }

    private drawLavaCore(ctx: CanvasRenderingContext2D, phase: number, instability: number, hpPercent: number) {
        // More WHITE the lower HP gets (desperation)
        const coreIntensity = 1 - (hpPercent * 0.5);

        // Complex Gradient: Core -> Lava -> Cooling Edge
        const grad = ctx.createRadialGradient(0, -15, 3, 0, -12, 35);
        grad.addColorStop(0, MagmaUnitRenderer.C_CORE);
        grad.addColorStop(0.15, MagmaUnitRenderer.C_CORE_BRIGHT);
        grad.addColorStop(0.4, MagmaUnitRenderer.C_LAVA_LIGHT);
        grad.addColorStop(0.75, MagmaUnitRenderer.C_LAVA_DARK);
        grad.addColorStop(1, MagmaUnitRenderer.C_CRUST);

        ctx.fillStyle = grad;

        // Shape: Bulky, muscular upper body, tapering to a flow
        ctx.beginPath();
        ctx.moveTo(-15, -25); // Shoulder L
        ctx.quadraticCurveTo(0, -30, 15, -25); // Shoulder R
        ctx.bezierCurveTo(25, -10, 10, 5 + instability, 0, 10); // Torso R
        ctx.bezierCurveTo(-10, 5 + instability, -25, -10, -15, -25); // Torso L
        ctx.fill();

        ctx.fillStyle = MagmaUnitRenderer.C_CORE;
        const coreSize = 6 + coreIntensity * 3;

        // Fake Glow (Optimized)
        ctx.globalAlpha = 0.5;
        ctx.beginPath(); ctx.arc(0, -15, coreSize * 1.5, 0, Math.PI * 2); ctx.fill();

        ctx.globalAlpha = 1.0;
        ctx.beginPath();
        ctx.arc(0, -15, coreSize, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawCrustPlates(ctx: CanvasRenderingContext2D, phase: number, instability: number) {
        // Large polygonal plates that float on the magma
        // Move with the breath/sway
        ctx.fillStyle = MagmaUnitRenderer.C_CRUST;

        // Chest Plate (Broken) - Move opposite to sway slightly
        const shiftX = Math.sin(phase) * (3 + instability * 2);
        const shiftY = Math.cos(phase * 2) * (1 + instability); // 2x freq for bounce

        // Left Plate
        ctx.beginPath();
        ctx.moveTo(-2 + shiftX, -18 + shiftY);
        ctx.lineTo(-12, -22);
        ctx.lineTo(-10, -8);
        ctx.closePath();
        ctx.fill();

        // Right Plate
        ctx.beginPath();
        ctx.moveTo(2 - shiftX, -18 - shiftY);
        ctx.lineTo(12, -22);
        ctx.lineTo(10, -8);
        ctx.closePath();
        ctx.fill();

        // Abdominal Plates with rotation
        ctx.save();
        ctx.translate(0, -5);
        ctx.rotate(shiftX * 0.05);
        ctx.fillRect(-6, 0, 12, 4);
        ctx.restore();
    }

    private drawDemonHead(ctx: CanvasRenderingContext2D, phase: number, lean: number) {
        ctx.save();
        ctx.translate(0, -28);

        // Horns (Floating Obsidian Shards)
        ctx.fillStyle = MagmaUnitRenderer.C_CRUST;
        const hornFloat = Math.sin(phase * 0.5) * 2; // Slow float

        // Left Horn
        ctx.beginPath();
        ctx.moveTo(-8, 0); ctx.lineTo(-20, -12 + hornFloat); ctx.lineTo(-10, -2);
        ctx.fill();

        // Right Horn
        ctx.beginPath();
        ctx.moveTo(8, 0); ctx.lineTo(20, -12 - hornFloat); ctx.lineTo(10, -2);
        ctx.fill();

        // Face (Skull-like magma)
        ctx.fillStyle = MagmaUnitRenderer.C_LAVA_LIGHT;
        ctx.beginPath();
        ctx.ellipse(0, 0, 8, 10, lean * 0.05, 0, Math.PI * 2);
        ctx.fill();

        // Obsidian Mask
        ctx.fillStyle = MagmaUnitRenderer.C_CRUST;
        ctx.beginPath();
        ctx.moveTo(-6, -6);
        ctx.lineTo(6, -6);
        ctx.lineTo(0, 8); // Jaw
        ctx.fill();

        // Eyes (INTENSIFIED - Brighter)
        // Replaced shadowBlur with manual glow
        ctx.fillStyle = MagmaUnitRenderer.C_CORE;

        // Fake Glow
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(-3, -2, 3.5, 0, Math.PI * 2);
        ctx.arc(3, -2, 3.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 1.0;
        ctx.beginPath();
        ctx.arc(-3, -2, 2, 0, Math.PI * 2);
        ctx.arc(3, -2, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    private drawLavaArms(ctx: CanvasRenderingContext2D, phase: number) {
        // Arms Sway opposite to body? Or lag behind?
        const sway = Math.sin(phase - 0.5) * 0.3; // Slight lag

        // Arms are heavy, dripping magma
        this.drawHeavyArm(ctx, -16, -22, -0.3 + sway, false, phase);
        this.drawHeavyArm(ctx, 16, -22, 0.3 - sway, true, phase);
    }

    private drawHeavyArm(ctx: CanvasRenderingContext2D, x: number, y: number, angle: number, flip: boolean, phase: number) {
        ctx.save();
        ctx.translate(x, y);
        if (flip) ctx.scale(-1, 1);
        ctx.rotate(angle);

        // Magma Flow Gradient
        const grad = ctx.createLinearGradient(0, 0, 0, 35);
        grad.addColorStop(0, MagmaUnitRenderer.C_CRUST); // Shoulder is hard
        grad.addColorStop(0.4, MagmaUnitRenderer.C_LAVA_LIGHT);
        grad.addColorStop(0.8, MagmaUnitRenderer.C_LAVA_DARK);
        grad.addColorStop(1, MagmaUnitRenderer.C_LAVA_LIGHT); // Dripping tip

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(-10, 10, -5, 25, 0, 35); // Heavy dripping hand
        ctx.bezierCurveTo(5, 25, 10, 10, 0, 0);
        ctx.fill();

        // Floating crust bits + DRIPPING EFFECT
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        const drift = Math.sin(phase * 2) * 2; // Slower drift
        ctx.fillRect(-2, 10 + drift, 4, 4);

        // LAVA DRIP (animated)
        const dripY = 35 + Math.abs(Math.sin(phase * 1.5)) * 8;
        ctx.fillStyle = MagmaUnitRenderer.C_LAVA_LIGHT;
        ctx.beginPath();
        ctx.ellipse(0, dripY, 1.5, 3, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }


    // =========================================================================
    // 2. THE OBSIDIAN STATUE (DECOY) - ENHANCED
    // =========================================================================
    private drawObsidianStatue(ctx: CanvasRenderingContext2D, scale: number, time: number) {
        ctx.scale(scale, scale);

        // Statue Body (Crystalline, Angular)
        ctx.fillStyle = MagmaUnitRenderer.C_STONE_BASE;
        ctx.strokeStyle = MagmaUnitRenderer.C_STONE_HIGHLIGHT;
        ctx.lineWidth = 1.5;

        ctx.beginPath();
        // HEROIC POSE: Arms raised
        ctx.moveTo(-14, -28);
        ctx.lineTo(-8, -20);
        ctx.lineTo(-12, -10);
        ctx.lineTo(-8, 0);
        ctx.lineTo(-12, 10);
        ctx.lineTo(12, 10);
        ctx.lineTo(8, 0);
        ctx.lineTo(12, -10);
        ctx.lineTo(8, -20);
        ctx.lineTo(14, -28);
        ctx.lineTo(0, -25);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // CRACK NETWORK
        ctx.strokeStyle = MagmaUnitRenderer.C_STONE_DARK;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -20); ctx.lineTo(-5, -10); ctx.lineTo(2, -5); ctx.lineTo(-3, 2);
        ctx.stroke();

        // Secondary cracks
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-5, -10); ctx.lineTo(-8, -8);
        ctx.moveTo(2, -5); ctx.lineTo(5, -3);
        ctx.moveTo(-3, 2); ctx.lineTo(-6, 5);
        ctx.stroke();

        // DYING EMBERS in Cracks (Red glow)
        // REPLACED shadowBlur with stroke + alpha overlap
        ctx.fillStyle = 'rgba(0,0,0,0)'; // No fill
        ctx.strokeStyle = 'rgba(255, 61, 0, 0.5)'; // Orange faint glow
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, -20); ctx.lineTo(-5, -10); ctx.lineTo(2, -5);
        ctx.stroke();

        ctx.lineWidth = 1.5;
        ctx.strokeStyle = MagmaUnitRenderer.C_EMBER_FAINT;
        ctx.stroke();

        // Head (Frozen Scream)
        ctx.translate(0, -30);
        ctx.fillStyle = MagmaUnitRenderer.C_STONE_BASE;
        ctx.strokeStyle = MagmaUnitRenderer.C_STONE_HIGHLIGHT;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Eyes (Dead, but faint ember)
        ctx.fillStyle = MagmaUnitRenderer.C_EMBER_FAINT;
        ctx.beginPath();
        ctx.arc(-3, -1, 1, 0, Math.PI * 2);
        ctx.arc(3, -1, 1, 0, Math.PI * 2);
        ctx.fill();
    }

    // =========================================================================
    // 3. PARTICLE SYSTEM (AAA EFFECT) - OPTIMIZED (Pooled)
    // =========================================================================
    private updateParticles(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, isBoss: boolean) {
        let particles = this.particleSystems.get(enemy);
        if (!particles) {
            particles = [];
            this.particleSystems.set(enemy, particles);
        }

        // OPTIMIZATION: Hard limit check
        if (particles.length < MagmaUnitRenderer.MAX_PARTICLES_PER_ENEMY) {
            // SPAWN - OPTIMIZATION: Reduced rates
            const spawnRate = isBoss ? 0.18 : 0.12;

            if (Math.random() < spawnRate) {
                let type: 'EMBER' | 'ASH' | 'SMOKE' | 'SPARK' = 'SMOKE';

                if (isBoss) {
                    const rand = Math.random();
                    if (rand > 0.7) type = 'SPARK';
                    else if (rand > 0.4) type = 'EMBER';
                    else type = 'SMOKE';
                } else {
                    type = Math.random() > 0.5 ? 'ASH' : 'SMOKE';
                }

                // USE POOL (O(1))
                const p = MagmaUnitRenderer.getParticle();
                p.x = (Math.random() * 30 - 15) * scale;
                p.y = -(Math.random() * 30 + 10) * scale;
                p.vx = (Math.random() - 0.5) * 0.8;
                p.vy = type === 'SPARK' ? -(Math.random() * 3 + 2) :
                    type === 'EMBER' ? -(Math.random() * 2 + 1) :
                        -(Math.random() + 0.5);
                p.size = (Math.random() * 3 + 1) * scale;
                p.life = 1.0;
                p.maxLife = 1.0;
                p.type = type;

                particles.push(p);
            }
        }

        // UPDATE & DRAW
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];

            // OPTIMIZATION: Simplify update math
            p.life -= p.type === 'SPARK' ? 0.03 : 0.015;
            p.x += p.vx; // Removed complex sin calculation per particle
            p.y += p.vy;

            if (p.life <= 0) {
                // Return to pool (O(1))
                MagmaUnitRenderer.releaseParticle(p);
                // Swap & Pop (O(1))
                particles[i] = particles[particles.length - 1];
                particles.pop();
                continue;
            }

            // Draw
            ctx.globalAlpha = p.life;
            if (p.type === 'SPARK') {
                ctx.fillStyle = MagmaUnitRenderer.C_CORE;
            } else if (p.type === 'EMBER') {
                ctx.fillStyle = MagmaUnitRenderer.C_LAVA_LIGHT;
            } else if (p.type === 'ASH') {
                ctx.fillStyle = MagmaUnitRenderer.C_ASH;
            } else {
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; // Smoke
            }

            // OPTIMIZATION: Use fillRect instead of arc
            const renderSize = p.size * (p.type === 'SPARK' ? 0.3 : p.type === 'EMBER' ? 0.5 : 1.0);

            // Draw as square (much faster than arc)
            ctx.fillRect(p.x - renderSize, p.y - renderSize, renderSize * 2, renderSize * 2);
        }
        ctx.globalAlpha = 1.0;
    }

    drawEmissive(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.002;
        if (enemy.typeId === 'magma_king') {
            // INTENSIFIED Heat Haze / Glow with PULSING
            const pulse = (Math.sin(time * 3) + 1) * 0.5; // 0..1

            // Replaced shadowBlur with AssetCache.getGlow (Radial Gradient)
            // Color #ff5722 = Orange-Red
            const glow1 = AssetCache.getGlow('rgba(255, 87, 34, 0.4)', 64);
            const size1 = (40 + pulse * 10) * scale;

            ctx.globalCompositeOperation = 'screen';
            ctx.drawImage(glow1, -size1, -size1, size1 * 2, size1 * 2);

            // Layer 2: Wide soft glow
            const glow2 = AssetCache.getGlow('rgba(255, 152, 0, 0.2)', 100);
            const size2 = (60 + pulse * 15) * scale;
            ctx.drawImage(glow2, -size2, -size2, size2 * 2, size2 * 2);

            ctx.globalCompositeOperation = 'source-over';

        } else {
            // Statue: Faint residual heat
            const glow = AssetCache.getGlow('rgba(255, 61, 0, 0.3)', 32);
            const size = 20 * scale;
            ctx.globalCompositeOperation = 'screen';
            ctx.drawImage(glow, -size, -size, size * 2, size * 2);
            ctx.globalCompositeOperation = 'source-over';
        }
    }
}
</file>

<file path="src/renderers/units/OrcUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import type { Enemy } from '../../Enemy';
import { Assets } from '../../Assets';

export class OrcUnitRenderer implements UnitRenderer {
    // –ü–∞–ª–∏—Ç—Ä–∞: –¢–µ–º–Ω–∞—è, —Ç—è–∂–µ–ª–∞—è, —Ä–∂–∞–≤–∞—è
    private static readonly ARMOR_DARK = '#212121'; // –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–∞–ª–ª
    private static readonly ARMOR_RUST = '#4e342e'; // –†–∂–∞–≤—á–∏–Ω–∞/–ö–æ–∂–∞
    private static readonly SKIN_COLOR = '#33691e'; // –¢–µ–º–Ω–æ-–∑–µ–ª–µ–Ω—ã–π (–ø–æ—á—Ç–∏ –Ω–µ –≤–∏–¥–µ–Ω)
    private static readonly METAL_LIGHT = '#757575'; // –ö–ª–µ–ø–∫–∏/–õ–µ–∑–≤–∏—è
    private static readonly ARMOR_MAIN = '#616161'; // –ß—É—Ç—å —Å–≤–µ—Ç–ª–µ–µ

    // BAKING SUPPORT
    public getBakeFacings(): ('SIDE' | 'UP' | 'DOWN')[] {
        return ['SIDE', 'UP', 'DOWN'];
    }

    public drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: 'SIDE' | 'UP' | 'DOWN') {
        const cycle = t * Math.PI * 2;
        const s = 1.0;
        const moving = true;

        if (facing === 'UP') return this.drawBack(ctx, s, cycle, moving);
        if (facing === 'DOWN') return this.drawFront(ctx, s, cycle, moving);
        return this.drawSide(ctx, s, cycle, moving);
    }

    drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void {
        this.drawFrameDirectional(ctx, enemy, t, 'SIDE');
    }

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now();
        const walkCycle = (time * 0.0015) * (enemy.baseSpeed / 10);

        // 1. Try Cached Sprite
        const t = (walkCycle % (Math.PI * 2)) / (Math.PI * 2);
        const frameIdx = Math.floor(t * 32) % 32;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';
        const r = rotation;
        // Standard angle logic
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        // Helper to check if facing left for SIDE view
        const facingLeft = Math.cos(rotation) < 0;

        // Key generation: 'walk' for SIDE (legacy compatibility if needed, but we used getBakeFacings so we likely have specific keys now)
        // However, SpriteBaker logic: 
        // if facings == ['SIDE'] -> unit_${type}_walk_${i}
        // else -> unit_${type}_${facing.toLowerCase()}_walk_${i}
        // Since we explicitly return SIDE, UP, DOWN, we expect:
        // unit_orc_side_walk_i, unit_orc_up_walk_i, unit_orc_down_walk_i

        // CAUTION: The user plan says:
        // "–µ—Å–ª–∏ facings == ['SIDE'] -> unit_${type}_walk_${i} (—Å—Ç–∞—Ä—ã–π)"
        // "–∏–Ω–∞—á–µ -> unit_${type}_${facing.toLowerCase()}_walk_${i}"

        const frameKey = `unit_${enemy.typeId}_${facing.toLowerCase()}_walk_${frameIdx}`;

        const sprite = Assets.get(frameKey);
        if (sprite) {
            ctx.save();
            const size = 96 * scale;

            // Orientation logic for DIR3
            if (facing === 'SIDE') {
                if (facingLeft) ctx.scale(-1, 1);
            }
            // UP/DOWN: No rotation/flip needed as they are baked specifically

            ctx.drawImage(sprite, -size / 2, -size / 2, size, size);

            // Hit Flash (Manual)
            if (enemy.hitFlashTimer > 0) {
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillRect(-size / 2, -size / 2, size, size);
            }

            ctx.restore();
            return;
        }

        // 2. Fallback
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        ctx.save();

        if (enemy.hitFlashTimer > 0) ctx.globalAlpha = 0.7;

        if (facing === 'SIDE') {
            if (facingLeft) ctx.scale(-1, 1);
            this.drawSide(ctx, scale, walkCycle, isMoving);
        } else if (facing === 'UP') {
            this.drawBack(ctx, scale, walkCycle, isMoving);
        } else {
            this.drawFront(ctx, scale, walkCycle, isMoving);
        }

        ctx.restore();
    }

    // === FRONT (–í–∏–¥ –°–ø–µ—Ä–µ–¥–∏) ===
    private drawFront(ctx: CanvasRenderingContext2D, scale: number, cycle: number, isMoving: boolean) {
        // –¢—è–∂–µ–ª—ã–π —Ç–æ–ø–æ—Ç: –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –±–∞—É–Ω—Å + –Ω–∞–∫–ª–æ–Ω
        const bounce = isMoving ? Math.abs(Math.sin(cycle)) * 1.5 * scale : 0;
        // –õ–µ–≥–∫–æ–µ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ
        const sway = isMoving ? Math.sin(cycle / 2) * 2 * scale : 0;

        ctx.translate(sway, -bounce);

        // 1. –ù–æ–≥–∏ (–ö–æ—Ä–æ—Ç–∫–∏–µ —Å—Ç–æ–ª–±—ã)
        // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥—ä–µ–º –∫–æ–ª–µ–Ω–µ–π
        const liftL = isMoving ? Math.max(0, Math.sin(cycle)) * 4 * scale : 0;
        const liftR = isMoving ? Math.max(0, Math.sin(cycle + Math.PI)) * 4 * scale : 0;

        this.drawLeg(ctx, -8 * scale, 8 * scale - liftL, scale);
        this.drawLeg(ctx, 8 * scale, 8 * scale - liftR, scale);

        // 2. –¢–µ–ª–æ (–ú–∞—Å—Å–∏–≤–Ω–∞—è –ø–ª–∏—Ç–∞)
        ctx.fillStyle = OrcUnitRenderer.ARMOR_DARK;
        // –†–∏—Å—É–µ–º "–ë–æ—á–∫—É"
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(-12 * scale, -10 * scale, 24 * scale, 18 * scale, 3 * scale);
        } else {
            ctx.rect(-12 * scale, -10 * scale, 24 * scale, 18 * scale);
        }
        ctx.fill();

        // –î–µ—Ç–∞–ª—å: –†–∂–∞–≤—ã–π –Ω–∞–≥—Ä—É–¥–Ω–∏–∫
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.fillRect(-8 * scale, -9 * scale, 16 * scale, 12 * scale);

        // –ó–∞–∫–ª–µ–ø–∫–∏
        ctx.fillStyle = OrcUnitRenderer.METAL_LIGHT;
        ctx.beginPath();
        ctx.arc(-6 * scale, -7 * scale, 1 * scale, 0, Math.PI * 2);
        ctx.arc(6 * scale, -7 * scale, 1 * scale, 0, Math.PI * 2);
        ctx.arc(-6 * scale, 1 * scale, 1 * scale, 0, Math.PI * 2);
        ctx.arc(6 * scale, 1 * scale, 1 * scale, 0, Math.PI * 2);
        ctx.fill();

        // 3. –ì–æ–ª–æ–≤–∞ (–®–ª–µ–º-–≤–µ–¥—Ä–æ, —Å–∏–¥–∏—Ç –Ω–∏–∑–∫–æ, "–≤—Ç—è–Ω—É—Ç")
        ctx.translate(0, -9 * scale);
        this.drawHelmet(ctx, scale);
        ctx.translate(0, 9 * scale);

        // 4. –û—Ä—É–∂–∏–µ –∏ –©–∏—Ç (–ü–æ –±–æ–∫–∞–º)
        // –©–∏—Ç (–°–ª–µ–≤–∞ –æ—Ç –Ω–∞—Å, –¥–µ—Ä–∂–∏—Ç –≤ –ø—Ä–∞–≤–æ–π —Ä—É–∫–µ –≤—Ä–∞–≥–∞)
        ctx.translate(14 * scale, 2 * scale);
        this.drawShieldFront(ctx, scale); // –ß—É—Ç—å –Ω–∏–∂–µ
        ctx.translate(-28 * scale, 0); // –ù–∞ –¥—Ä—É–≥—É—é —Ä—É–∫—É
        this.drawMace(ctx, scale);
    }

    // === SIDE (–í–∏–¥ –°–±–æ–∫—É) ===
    private drawSide(ctx: CanvasRenderingContext2D, scale: number, cycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(cycle)) * 1.5 * scale : 0;
        ctx.translate(0, -bounce);

        // 1. –ù–æ–≥–∏ (–®–∞–≥ —Å —à–∏—Ä–æ–∫–æ–π –ø–æ—Å—Ç–∞–Ω–æ–≤–∫–æ–π)
        // –°–¥–µ–ª–∞–µ–º –±–æ–ª–µ–µ "–≤–±–∏–≤–∞—é—â–∏–π" —à–∞–≥ - –∫–æ—Ä–æ—Ç–∫–∏–π –Ω–æ –º–æ—â–Ω—ã–π
        const step = isMoving ? Math.cos(cycle) * 6 * scale : 0;
        const liftFar = isMoving && step > 0 ? Math.sin(cycle) * 3 * scale : 0;
        const liftNear = isMoving && step < 0 ? -Math.sin(cycle) * 3 * scale : 0;

        this.drawLeg(ctx, step, 8 * scale - liftFar, scale);       // –î–∞–ª—å–Ω—è—è
        this.drawLeg(ctx, -step, 8 * scale - liftNear, scale);      // –ë–ª–∏–∂–Ω—è—è

        // 2. –¢–µ–ª–æ (–ö–æ—Ä–æ–±–∫–∞, –∞ –Ω–µ –æ–≤–∞–ª)
        // –¢–µ–ª–æ –≤ –ø—Ä–æ—Ñ–∏–ª—å —Ç–æ–∂–µ —à–∏—Ä–æ–∫–æ–µ –∏–∑-–∑–∞ –±—Ä–æ–Ω–∏
        ctx.fillStyle = OrcUnitRenderer.ARMOR_DARK;
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(-8 * scale, -9 * scale, 16 * scale, 16 * scale, 4 * scale);
        } else {
            ctx.rect(-8 * scale, -9 * scale, 16 * scale, 16 * scale);
        }
        ctx.fill();

        // –ì–æ—Ä–±/–ü–ª–∞—Å—Ç–∏–Ω—ã —Å–∑–∞–¥–∏
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.fillRect(-9 * scale, -6 * scale, 4 * scale, 10 * scale);

        // 3. –ì–æ–ª–æ–≤–∞ (–°–¥–≤–∏–Ω—É—Ç–∞ –≤–ø–µ—Ä–µ–¥)
        ctx.translate(4 * scale, -8 * scale); // –ß—É—Ç—å –≤—ã—à–µ –∏ –≤–ø–µ—Ä–µ–¥
        this.drawHelmet(ctx, scale);
        ctx.translate(-4 * scale, 8 * scale);

        // 4. –©–ò–¢ (TOWER SHIELD)
        // –ó–∞–∫—Ä—ã–≤–∞–µ—Ç –ø–µ—Ä–µ–¥–Ω—é—é —á–∞—Å—Ç—å
        ctx.translate(9 * scale, 2 * scale); // –°–¥–≤–∏–Ω—É—Ç –≤–ø–µ—Ä–µ–¥ —Å–∏–ª—å–Ω–µ–µ
        this.drawShieldSide(ctx, scale);

        // –†—É–∫–∞/–ü–ª–µ—á–æ –¥–µ—Ä–∂–∞—â–µ–µ —â–∏—Ç
        ctx.fillStyle = OrcUnitRenderer.ARMOR_MAIN;
        ctx.beginPath();
        ctx.arc(0, -6 * scale, 4 * scale, 0, Math.PI * 2);
        ctx.fill();
    }

    // === BACK (–í–∏–¥ –°–∑–∞–¥–∏) ===
    private drawBack(ctx: CanvasRenderingContext2D, scale: number, cycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(cycle)) * 1.5 * scale : 0;
        const sway = isMoving ? Math.sin(cycle / 2) * 2 * scale : 0;
        ctx.translate(sway, -bounce);

        const liftL = isMoving ? Math.max(0, Math.sin(cycle)) * 4 * scale : 0;
        const liftR = isMoving ? Math.max(0, Math.sin(cycle + Math.PI)) * 4 * scale : 0;

        this.drawLeg(ctx, -8 * scale, 8 * scale - liftL, scale);
        this.drawLeg(ctx, 8 * scale, 8 * scale - liftR, scale);

        // –°–ø–∏–Ω–∞ (–°–ø–ª–æ—à–Ω–∞—è –ø–ª–∏—Ç–∞)
        ctx.fillStyle = OrcUnitRenderer.ARMOR_DARK;
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(-12 * scale, -10 * scale, 24 * scale, 18 * scale, 3 * scale);
        } else {
            ctx.rect(-12 * scale, -10 * scale, 24 * scale, 18 * scale);
        }
        ctx.fill();

        // "–ü–æ–∑–≤–æ–Ω–æ—á–Ω–∏–∫" –±—Ä–æ–Ω–∏
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.fillRect(-3 * scale, -10 * scale, 6 * scale, 18 * scale);

        // –ì–æ–ª–æ–≤–∞ (–ó–∞—Ç—ã–ª–æ–∫ —à–ª–µ–º–∞)
        ctx.translate(0, -9 * scale);
        ctx.fillStyle = OrcUnitRenderer.ARMOR_MAIN;
        ctx.beginPath();
        ctx.arc(0, 0, 6 * scale, Math.PI, 0); // –ß—É—Ç—å —à–∏—Ä–µ
        ctx.fill();
        ctx.translate(0, 9 * scale);

        // –©–∏—Ç (–í–∏–¥–µ–Ω —Å —Ç–æ—Ä—Ü–∞ —Å–±–æ–∫—É)
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.fillRect(14 * scale, -5 * scale, 3 * scale, 15 * scale); // –¢–æ—Ä–µ—Ü —â–∏—Ç–∞

        // –î—É–±–∏–Ω–∞ (–í–∏–¥–Ω–∞ —Å –¥—Ä—É–≥–æ–≥–æ –±–æ–∫—É)
        ctx.translate(-14 * scale, 0);
        this.drawMace(ctx, scale);
    }

    // --- –ö–û–ú–ü–û–ù–ï–ù–¢–´ ---

    private drawHelmet(ctx: CanvasRenderingContext2D, scale: number) {
        // –®–ª–µ–º-–í–µ–¥—Ä–æ (Bucket Helm) - –µ—â–µ –±–æ–ª–µ–µ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–π
        ctx.fillStyle = OrcUnitRenderer.ARMOR_MAIN; // –°–µ—Ä—ã–π –º–µ—Ç–∞–ª–ª
        ctx.beginPath();
        // –û—Å–Ω–æ–≤–∞
        if (ctx.roundRect) {
            ctx.roundRect(-6 * scale, -7 * scale, 12 * scale, 11 * scale, 2 * scale);
        } else {
            ctx.rect(-6 * scale, -7 * scale, 12 * scale, 11 * scale);
        }
        ctx.fill();

        // –£—Å–∏–ª–µ–Ω–∏–µ (–∫—Ä–µ—Å—Ç –∏–ª–∏ –ø–æ–ª–æ—Å–∞)
        ctx.fillStyle = '#424242';
        ctx.fillRect(-6 * scale, -3 * scale, 12 * scale, 2 * scale); // –ì–æ—Ä–∏–∑
        ctx.fillRect(-1 * scale, -7 * scale, 2 * scale, 11 * scale); // –í–µ—Ä—Ç

        // –°–º–æ—Ç—Ä–æ–≤–∞—è —â–µ–ª—å (—É–∑–∫–∞—è, –∑–ª–∞—è)
        ctx.fillStyle = '#000';
        ctx.fillRect(-5 * scale, -3 * scale, 10 * scale, 1.5 * scale);

        // –†–æ–≥–∞/–®–∏–ø—ã (—á—É—Ç—å –º–µ–Ω—å—à–µ, —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å —Å–∏–ª—É—ç—Ç –≤–µ–¥—Ä–∞)
        ctx.fillStyle = '#212121';
        ctx.beginPath();
        ctx.moveTo(-5 * scale, -7 * scale); ctx.lineTo(-7 * scale, -10 * scale); ctx.lineTo(-3 * scale, -7 * scale);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(5 * scale, -7 * scale); ctx.lineTo(7 * scale, -10 * scale); ctx.lineTo(3 * scale, -7 * scale);
        ctx.fill();
    }

    private drawLeg(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number) {
        ctx.translate(x, y);
        // –¢—è–∂–µ–ª—ã–π –ª–∞—Ç–Ω—ã–π —Å–∞–ø–æ–≥ - —à–∏—Ä–µ
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(-4 * scale, -5 * scale, 8 * scale, 10 * scale, 2 * scale);
        } else {
            ctx.rect(-4 * scale, -5 * scale, 8 * scale, 10 * scale);
        }
        ctx.fill();
        // –ú–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–π –Ω–æ—Å–æ–∫
        ctx.fillStyle = OrcUnitRenderer.ARMOR_MAIN;
        ctx.fillRect(-4 * scale, 2 * scale, 8 * scale, 3 * scale);
        ctx.translate(-x, -y);
    }

    private drawShieldFront(ctx: CanvasRenderingContext2D, scale: number) {
        // –û–≥—Ä–æ–º–Ω–∞—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∞—è –¥–≤–µ—Ä—å
        ctx.fillStyle = '#3e2723'; // –î–µ—Ä–µ–≤–æ —Å–∑–∞–¥–∏
        ctx.fillRect(-2 * scale, -8 * scale, 4 * scale, 18 * scale);

        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(-7 * scale, -11 * scale, 14 * scale, 22 * scale, 2 * scale);
        } else {
            ctx.rect(-7 * scale, -11 * scale, 14 * scale, 22 * scale);
        }
        ctx.fill();

        // –£–∑–æ—Ä
        ctx.strokeStyle = OrcUnitRenderer.METAL_LIGHT;
        ctx.lineWidth = 3 * scale;
        ctx.strokeRect(-6 * scale, -10 * scale, 12 * scale, 20 * scale);

        // –£–º–±–æ–Ω (—Ü–µ–Ω—Ç—Ä)
        ctx.fillStyle = OrcUnitRenderer.METAL_LIGHT;
        ctx.beginPath();
        ctx.arc(0, 0, 3 * scale, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawShieldSide(ctx: CanvasRenderingContext2D, scale: number) {
        // –í–∏–¥ —â–∏—Ç–∞ —Å–±–æ–∫—É - –ú–∞—Å—Å–∏–≤–Ω—ã–π
        ctx.fillStyle = OrcUnitRenderer.ARMOR_RUST;
        ctx.beginPath();
        // –ë–æ–ª–µ–µ –ø—Ä—è–º–æ–π, —Ç—è–∂–µ–ª—ã–π
        ctx.moveTo(0, -13 * scale);
        ctx.lineTo(2 * scale, 0);
        ctx.lineTo(0, 13 * scale);
        ctx.lineTo(-5 * scale, 13 * scale); // –¢–æ–ª—â–∏–Ω–∞
        ctx.lineTo(-3 * scale, 0); // –í–Ω—É—Ç—Ä –∏–∑–≥–∏–±
        ctx.lineTo(-5 * scale, -13 * scale);
        ctx.fill();

        // –®–∏–ø—ã —Ç–æ—Ä—á–∞—Ç –≤–ø–µ—Ä–µ–¥
        ctx.fillStyle = OrcUnitRenderer.METAL_LIGHT;
        ctx.beginPath(); ctx.moveTo(2 * scale, -6 * scale); ctx.lineTo(5 * scale, -6 * scale); ctx.lineTo(2 * scale, -4 * scale); ctx.fill();
        ctx.beginPath(); ctx.moveTo(2 * scale, 6 * scale); ctx.lineTo(5 * scale, 6 * scale); ctx.lineTo(2 * scale, 8 * scale); ctx.fill();
    }

    private drawMace(ctx: CanvasRenderingContext2D, scale: number) {
        // –†—É–∫–æ—è—Ç—å
        ctx.fillStyle = '#3e2723';
        ctx.fillRect(-1.5 * scale, -6 * scale, 3 * scale, 16 * scale);

        // –ì–æ–ª–æ–≤–∞
        ctx.fillStyle = '#212121';
        ctx.beginPath();
        ctx.arc(0, -8 * scale, 4.5 * scale, 0, Math.PI * 2);
        ctx.fill();

        // –®–∏–ø—ã –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
        ctx.fillStyle = '#bdbdbd';
        const spikes = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
        spikes.forEach(angle => {
            const sx = Math.cos(angle);
            const sy = Math.sin(angle);
            ctx.beginPath();
            ctx.moveTo(sx * 4 * scale, -8 * scale + sy * 4 * scale);
            ctx.lineTo(sx * 8 * scale, -8 * scale + sy * 8 * scale);
            ctx.lineTo(sx * 4 * scale + sy * 2 * scale, -8 * scale + sy * 4 * scale - sx * 2 * scale);
            ctx.fill();
        });
    }
}
</file>

<file path="src/renderers/units/RatUnitRenderer.ts">
import { CachedUnitRenderer } from './CachedUnitRenderer';
import { UnitRenderer } from './UnitRenderer';
import type { Enemy } from '../../Enemy';
import { Assets } from '../../Assets';
import { AssetCache } from '../../utils/AssetCache';

export class RatUnitRenderer extends CachedUnitRenderer {
    // üé® Darker Alchemical Palette
    private static readonly FUR_COLOR = '#3e2723';       // Dark Chocolate
    private static readonly FUR_LIGHT = '#5d4037';       // Muddy Brown
    private static readonly SKIN_COLOR = '#bcaaa4';      // Pale, Sickly Skin
    private static readonly POISON_GLOW = '#64dd17';     // Toxic Neon Green (Darker shade)
    private static readonly POISON_LIQUID = '#76ff03';   // Bright Core
    private static readonly BARREL_WOOD = '#261b18';     // Burnt Wood
    private static readonly BARREL_RIM = '#4e342e';      // Rusted Iron

    protected override orientationMode = 'DIR3' as const;

    constructor() {
        super();
        this.walkCycleMultiplier = 12.5; // High speed scurry
    }

    // BAKING SUPPORT
    public getBakeFacings(): ('SIDE' | 'UP' | 'DOWN')[] {
        return ['SIDE', 'UP', 'DOWN'];
    }

    public drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: 'SIDE' | 'UP' | 'DOWN') {
        const cycle = t * Math.PI * 2;
        const scale = 1.0;
        const isMoving = true;
        const time = t * 10;

        ctx.save();
        if (facing === 'UP') {
            this.drawBack(ctx, scale, cycle, isMoving, time);
        } else if (facing === 'DOWN') {
            this.drawFront(ctx, scale, cycle, isMoving, time);
        } else {
            this.drawSide(ctx, scale, cycle, isMoving, time);
        }
        ctx.restore();
    }

    drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void {
        this.drawFrameDirectional(ctx, enemy, t, 'SIDE');
    }

    // drawBody is inherited

    // === FRONT ===
    private drawFront(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean, time: number) {
        // Feet
        const footOff = Math.sin(walkCycle) * 3 * scale;
        this.drawPaw(ctx, -5 * scale, 6 * scale + footOff, scale);
        this.drawPaw(ctx, 5 * scale, 6 * scale - footOff, scale);

        // Body
        ctx.fillStyle = RatUnitRenderer.FUR_COLOR;
        ctx.beginPath(); ctx.ellipse(0, 0, 7 * scale, 6 * scale, 0, 0, Math.PI * 2); ctx.fill();

        // Barrel (Unstable!)
        ctx.save();
        ctx.translate(0, -7 * scale);
        // Liquid Slosh Animation
        const slosh = Math.sin(time * 8) * 0.2;
        ctx.rotate(slosh);

        this.drawBarrel(ctx, scale, true, time);
        ctx.restore();

        // Head
        ctx.save();
        ctx.translate(0, 1 * scale); // Lower head (hunchback)
        this.drawHeadFront(ctx, scale);
        ctx.restore();
    }

    // === BACK ===
    private drawBack(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean, time: number) {
        // Feet
        const footOff = Math.sin(walkCycle) * 3 * scale;
        this.drawPaw(ctx, -5 * scale, 6 * scale + footOff, scale);
        this.drawPaw(ctx, 5 * scale, 6 * scale - footOff, scale);

        // Tail (Wagging wildly)
        // More complex wave for "rat-like" feel
        const tailWag = Math.sin(time * 10) * 0.4;
        this.drawTail(ctx, 0, 4 * scale, scale, tailWag, true, time);

        // Body
        ctx.fillStyle = RatUnitRenderer.FUR_COLOR;
        ctx.beginPath(); ctx.ellipse(0, 0, 8 * scale, 7 * scale, 0, 0, Math.PI * 2); ctx.fill();

        // Barrel (Strapped)
        ctx.save();
        ctx.translate(0, -3 * scale);
        const slosh = Math.sin(time * 8) * 0.1;
        ctx.rotate(slosh);
        this.drawBarrel(ctx, scale, false, time);
        ctx.restore();

        // Ears
        ctx.fillStyle = RatUnitRenderer.SKIN_COLOR;
        ctx.beginPath(); ctx.arc(-6 * scale, -2 * scale, 2.5 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(6 * scale, -2 * scale, 2.5 * scale, 0, Math.PI * 2); ctx.fill();
    }

    // === SIDE ===
    private drawSide(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean, time: number) {
        const frontLegA = Math.sin(walkCycle) * 4 * scale;
        const backLegA = Math.sin(walkCycle + Math.PI / 2) * 4 * scale;

        // Back Legs
        this.drawPaw(ctx, -7 * scale + backLegA, 6 * scale, scale);

        // Tail (Trailing with wave)
        // Uses sine wave logic inside drawTail for side view
        this.drawTail(ctx, -9 * scale, 1 * scale, scale, 0, false, time);

        // Body (Hunched)
        ctx.fillStyle = RatUnitRenderer.FUR_COLOR;
        ctx.beginPath();
        ctx.ellipse(0, 1 * scale, 10 * scale, 6 * scale, 0, 0, Math.PI * 2); // Fatter
        ctx.fill();

        // Barrel (Heavy Load)
        ctx.save();
        ctx.translate(-1 * scale, -6 * scale);
        ctx.rotate(-0.2 + Math.sin(time * 10) * 0.05); // Heavy wobble
        this.drawBarrel(ctx, scale, false, time);
        ctx.restore();

        // Front Legs
        this.drawPaw(ctx, 7 * scale + frontLegA, 6 * scale, scale);

        // Head
        ctx.save();
        ctx.translate(10 * scale, 2 * scale); // Low head
        this.drawHeadSide(ctx, scale);
        ctx.restore();
    }

    // --- PARTS ---

    private drawHeadFront(ctx: CanvasRenderingContext2D, scale: number) {
        // Face
        ctx.fillStyle = RatUnitRenderer.FUR_LIGHT;
        ctx.beginPath();
        ctx.moveTo(-4 * scale, -2 * scale);
        ctx.lineTo(4 * scale, -2 * scale);
        ctx.lineTo(0, 6 * scale);
        ctx.fill();

        // Nose
        ctx.fillStyle = RatUnitRenderer.SKIN_COLOR;
        ctx.beginPath(); ctx.arc(0, 6 * scale, 1.5 * scale, 0, Math.PI * 2); ctx.fill();

        // Ears (Ragged)
        ctx.fillStyle = RatUnitRenderer.SKIN_COLOR;
        ctx.beginPath(); ctx.arc(-6 * scale, -3 * scale, 3 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(6 * scale, -3 * scale, 3 * scale, 0, Math.PI * 2); ctx.fill();

        // Glowing Toxic Eyes (Optimized)
        const glow = AssetCache.getGlow('rgba(100, 221, 23, 0.6)', 16);
        const gSize = 8 * scale;

        ctx.drawImage(glow, -2.5 * scale - gSize / 2, -0.5 * scale - gSize / 2, gSize, gSize);
        ctx.drawImage(glow, 2.5 * scale - gSize / 2, -0.5 * scale - gSize / 2, gSize, gSize);

        ctx.fillStyle = RatUnitRenderer.POISON_GLOW;
        ctx.beginPath(); ctx.arc(-2.5 * scale, -0.5 * scale, 1.2 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(2.5 * scale, -0.5 * scale, 1.2 * scale, 0, Math.PI * 2); ctx.fill();
    }

    private drawHeadSide(ctx: CanvasRenderingContext2D, scale: number) {
        ctx.fillStyle = RatUnitRenderer.FUR_LIGHT;
        ctx.beginPath();
        ctx.ellipse(0, 0, 5 * scale, 3.5 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Long Snout
        ctx.fillStyle = RatUnitRenderer.FUR_LIGHT; // Same color to blend
        ctx.beginPath(); ctx.ellipse(3 * scale, 1 * scale, 3 * scale, 2 * scale, 0, 0, Math.PI * 2); ctx.fill();

        ctx.fillStyle = RatUnitRenderer.SKIN_COLOR;
        ctx.beginPath(); ctx.arc(6 * scale, 1.5 * scale, 1.5 * scale, 0, Math.PI * 2); ctx.fill(); // Nose

        ctx.beginPath(); ctx.arc(-2 * scale, -3 * scale, 3 * scale, 0, Math.PI * 2); ctx.fill(); // Ear

        // Eye (Optimized)
        const glow = AssetCache.getGlow('rgba(100, 221, 23, 0.6)', 16);
        const gSize = 8 * scale;
        ctx.drawImage(glow, 2 * scale - gSize / 2, -1 * scale - gSize / 2, gSize, gSize);

        ctx.fillStyle = RatUnitRenderer.POISON_GLOW;
        ctx.beginPath(); ctx.arc(2 * scale, -1 * scale, 1.3 * scale, 0, Math.PI * 2); ctx.fill();
    }

    private drawPaw(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number) {
        // –ë–æ–ª–µ–µ –∑–∞–º–µ—Ç–Ω—ã–µ –ª–∞–ø–∫–∏
        ctx.fillStyle = '#d7ccc8'; // Lighter than SKIN_COLOR for visibility
        ctx.strokeStyle = RatUnitRenderer.SKIN_COLOR;
        ctx.lineWidth = 1;
        ctx.beginPath();
        // Larger claws with visible toes
        ctx.moveTo(x - 3 * scale, y + 3 * scale);
        ctx.lineTo(x - 1 * scale, y - 1 * scale);
        ctx.lineTo(x, y + 1 * scale);
        ctx.lineTo(x + 1 * scale, y - 1 * scale);
        ctx.lineTo(x + 3 * scale, y + 3 * scale);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    private drawTail(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number, angleObs: number, isBack: boolean, time: number = 0) {
        // –ë–æ–ª–µ–µ —Ç–æ–ª—Å—Ç—ã–π –∏ –∑–∞–º–µ—Ç–Ω—ã–π —Ö–≤–æ—Å—Ç
        ctx.strokeStyle = '#d7ccc8'; // Lighter for visibility
        ctx.lineWidth = 3.5 * scale; // Thicker
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x, y);

        if (isBack) {
            // Wagging tail from back view - more pronounced
            ctx.quadraticCurveTo(
                x + Math.sin(angleObs) * 12 * scale,
                y + 6 * scale,
                x + Math.sin(angleObs) * 18 * scale,
                y - 3 * scale
            );
        } else {
            // Side view trailing Sine Wave - more visible
            const wave = Math.sin(time * 15) * 4 * scale;
            ctx.quadraticCurveTo(
                x - 6 * scale,
                y + wave,
                x - 15 * scale,
                y + 3 * scale
            );
        }
        ctx.stroke();

        // Tip of tail
        ctx.fillStyle = RatUnitRenderer.SKIN_COLOR;
        const tipX = isBack ? (x + Math.sin(angleObs) * 18 * scale) : (x - 15 * scale);
        const tipY = isBack ? (y - 3 * scale) : (y + 3 * scale);
        ctx.beginPath();
        ctx.arc(tipX, tipY, 1.5 * scale, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawBarrel(ctx: CanvasRenderingContext2D, scale: number, glow: boolean, time: number) {
        const w = 10 * scale; // Bulky
        const h = 8 * scale;

        // Wood Body
        ctx.fillStyle = RatUnitRenderer.BARREL_WOOD;
        ctx.beginPath();
        ctx.rect(-w / 2, -h / 2, w, h);
        ctx.fill();

        // Metal Bands
        ctx.fillStyle = RatUnitRenderer.BARREL_RIM;
        ctx.fillRect(-w / 2, -h / 2 + 1 * scale, w, 1 * scale);
        ctx.fillRect(-w / 2, h / 2 - 2 * scale, w, 1 * scale);

        // Leak / Liquid
        if (glow) {
            // Optimized glow using AssetCache
            const g = AssetCache.getGlow('rgba(100, 221, 23, 0.4)', 32);
            ctx.drawImage(g, -16 * scale, -16 * scale, 32 * scale, 32 * scale);
        }
        ctx.fillStyle = RatUnitRenderer.POISON_LIQUID;
        ctx.beginPath(); ctx.arc(0, 0, 2.5 * scale, 0, Math.PI * 2); ctx.fill(); // Core

        // Drip (Deterministic)
        // Use time to simulate random drip frequency
        const dripTime = time * 2;
        const dripCycle = dripTime % 5; // 5 second cycle roughly
        if (dripCycle > 4.5) { // Drip at end of cycle
            const fall = (dripCycle - 4.5) * 20 * scale;
            ctx.fillStyle = RatUnitRenderer.POISON_LIQUID;
            ctx.beginPath(); ctx.arc(w / 2, h / 2 + fall, 1.5 * scale, 0, Math.PI * 2); ctx.fill();
        }

        // Fuse Spark (Deterministic flicker)
        if (Math.sin(time * 50) > 0) {
            ctx.fillStyle = '#fff176';
            ctx.beginPath();
            ctx.arc(2 * scale, -h / 2 - 2 * scale, 2 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ff3d00';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(2 * scale, -h / 2); ctx.lineTo(2 * scale, -h / 2 - 2 * scale); ctx.stroke();
        }
    }
}
</file>

<file path="src/scenes/GameState.ts">
import { CONFIG } from '../Config';
import { Enemy } from '../Enemy';
import { Tower } from '../Tower';
import { Projectile } from '../Projectile';
import { ObjectPool } from '../Utils';
import { EventBus, Events } from '../EventBus';

/**
 * Manages game state (money, lives, wave, pause) and provides state mutation methods.
 * Emits events when state changes occur.
 */
export class GameState {
    // Core state
    public wave: number = 0;
    public lives: number = CONFIG.PLAYER.START_LIVES;
    public readonly startingLives: number = CONFIG.PLAYER.START_LIVES;
    public money: number = CONFIG.PLAYER.START_MONEY;
    public paused: boolean = false;
    public isRunning: boolean = true;
    public timeScale: number = 1.0;

    // Entity collections
    public enemies: Enemy[] = [];
    public towers: Tower[] = [];
    // public projectiles: Projectile[] = []; // MOVED to ProjectileSystem

    // Object pools
    // public projectilePool: ObjectPool<Projectile>; // MOVED to ProjectileSystem
    public enemyPool: ObjectPool<Enemy>;

    // Selection state
    public selectedTower: Tower | null = null;

    // Animation state
    public frames: number = 0;
    public shakeTimer: number = 0;
    public shakeIntensity: number = 0;

    private eventBus: EventBus = EventBus.getInstance();

    constructor() {
        // this.projectilePool = new ObjectPool(() => new Projectile());
        this.enemyPool = new ObjectPool(() => new Enemy());
    }



    // === Reset (for restart) ===
    public reset(): void {
        this.wave = 0;
        this.lives = CONFIG.PLAYER.START_LIVES;
        this.money = CONFIG.PLAYER.START_MONEY;
        this.paused = false;
        this.isRunning = true;
        this.timeScale = 1.0;
        this.frames = 0;
        this.shakeTimer = 0;
        this.shakeIntensity = 0;
        this.selectedTower = null;

        // Clear entities in-place to preserve references
        this.enemies.length = 0;
        this.towers.length = 0;
        // this.projectiles = []; // MOVED
    }

    // === Money Management ===
    public addMoney(amount: number): void {
        this.money += amount;
        this.eventBus.emit(Events.MONEY_CHANGED, this.money);
    }

    public spendMoney(amount: number): boolean {
        if (this.money >= amount) {
            this.money -= amount;
            this.eventBus.emit(Events.MONEY_CHANGED, this.money);
            return true;
        }
        return false;
    }

    // === Lives Management ===
    public loseLife(amount: number = 1, effects?: any): void {
        this.lives -= amount;
        this.eventBus.emit(Events.LIVES_CHANGED, this.lives);

        // Red screen flash on damage
        if (effects) {
            effects.add({
                type: 'screen_flash',
                x: 0,
                y: 0,
                life: 15,
                flashColor: 'rgba(255, 0, 0, ',
            });
        }

        if (this.lives <= 0) {
            this.eventBus.emit(Events.GAME_OVER, this.wave);
            this.isRunning = false;
        }
    }

    // === Wave Management ===
    public incrementWave(): void {
        this.wave++;
    }

    // === Pause Management ===
    public togglePause(): void {
        this.paused = !this.paused;
        this.eventBus.emit(Events.TOGGLE_PAUSE, this.paused);
    }

    // === Screen Shake ===
    public triggerShake(duration: number, intensity: number): void {
        this.shakeTimer = duration;
        this.shakeIntensity = intensity;
    }

    public updateShake(): void {
        if (this.shakeTimer > 0) {
            this.shakeTimer--;
        }
    }

    // === Tower Selection ===
    public selectTower(tower: Tower | null): void {
        this.selectedTower = tower;
    }

    // === Time Scale ===
    public setTimeScale(scale: number): void {
        this.timeScale = Math.max(1.0, Math.min(scale, 2.0)); // Clamp between 1x and 2x
    }

    public toggleTimeScale(): void {
        this.timeScale = (this.timeScale === 1.0) ? 2.0 : 1.0;
    }

    // === Game Over ===
    public endGame(): void {
        this.isRunning = false;
    }
}
</file>

<file path="src/systems/LightingSystem.ts">
import { CONFIG } from '../Config';

export interface ILight {
    x: number;
    y: number;
    radius: number;
    color: string; // Hex or rgba
    intensity: number; // 0 to 1
}

export class LightingSystem {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private width: number;
    private height: number;
    private scale: number; // Phase 6: Performance optimization

    private lights: ILight[] = [];
    public ambientLight: number = 0.9; // 0 = Pitch Black, 1 = Full Brightness

    constructor(width: number, height: number, optimization: boolean = false) {
        this.width = width;
        this.height = height;

        // Phase 6: 2x scale optimization for performance
        this.scale = optimization ? 2 : 1;

        // Create offscreen canvas for light map (at reduced resolution if optimized)
        this.canvas = document.createElement('canvas');
        this.canvas.width = Math.floor(width / this.scale);
        this.canvas.height = Math.floor(height / this.scale);
        this.ctx = this.canvas.getContext('2d', { alpha: true })!;
    }

    public resize(width: number, height: number) {
        this.width = width;
        this.height = height;
        this.canvas.width = Math.floor(width / this.scale);
        this.canvas.height = Math.floor(height / this.scale);
    }

    public clear() {
        this.lights = [];
    }

    public addLight(x: number, y: number, radius: number, color: string, intensity: number = 1.0) {
        // Standard system
        this.lights.push({
            x: x / this.scale,
            y: y / this.scale,
            radius: radius / this.scale,
            color,
            intensity
        });
    }

    /**
     * Phase 6: Enable global darkness (nighttime mode)
     */
    public enableGlobalDarkness(darknessLevel: number = 0.7) {
        this.ambientLight = 1 - darknessLevel; // e.g., 0.7 darkness = 0.3 ambient
    }

    /**
     * Phase 6: Add light from a tower
     */
    public addTowerLight(x: number, y: number, tileSize: number) {
        this.addLight(x + tileSize / 2, y + tileSize / 2, tileSize * 2.5, '#ffaa00', 0.8);
    }

    public render(targetCtx: CanvasRenderingContext2D) {
        // Logic for SPRITE style (Original)
        const w = this.canvas.width;
        const h = this.canvas.height;

        // 0. Clear previous frame
        this.ctx.clearRect(0, 0, w, h);

        // 1. Fill light map with "Darkness"
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.fillStyle = `rgba(0, 0, 0, ${1 - this.ambientLight})`;
        this.ctx.fillRect(0, 0, w, h);

        // 2. Punch holes / Add lights (Visibility)
        this.ctx.globalCompositeOperation = 'destination-out';

        // Optimized: for loop instead of forEach
        for (let i = 0; i < this.lights.length; i++) {
            const light = this.lights[i];
            const g = this.ctx.createRadialGradient(light.x, light.y, 0, light.x, light.y, light.radius);
            g.addColorStop(0, `rgba(0, 0, 0, ${light.intensity})`); // Full erase
            g.addColorStop(1, 'rgba(0, 0, 0, 0)'); // No erase

            this.ctx.fillStyle = g;
            this.ctx.beginPath();
            this.ctx.arc(light.x, light.y, light.radius, 0, Math.PI * 2);
            this.ctx.fill();
        }

        // 3. Draw colored glows (Additive Pass)
        // Draw the darkness overlay first (scaled up if using optimization)
        targetCtx.save();
        targetCtx.drawImage(this.canvas, 0, 0, this.width, this.height);

        // Now draw colored lights on TOP using 'lighter' (or 'screen')
        targetCtx.globalCompositeOperation = 'lighter'; // Additive blending

        // Optimized: for loop instead of forEach
        for (let i = 0; i < this.lights.length; i++) {
            const light = this.lights[i];
            if (light.color === '#000000') continue; // Skip black lights

            // Scale back to target resolution
            const x = light.x * this.scale;
            const y = light.y * this.scale;
            const r = light.radius * this.scale;

            const g = targetCtx.createRadialGradient(x, y, 0, x, y, r);
            g.addColorStop(0, light.color); // Color at center
            g.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade to transparent

            targetCtx.fillStyle = g;
            targetCtx.globalAlpha = light.intensity * 0.6; // Scale down glow intensity
            targetCtx.beginPath();
            targetCtx.arc(light.x, light.y, light.radius, 0, Math.PI * 2);
            targetCtx.fill();
        }

        targetCtx.restore();
    }
}
</file>

<file path="src/utils/SpriteBaker.ts">
import { AssetCache } from './AssetCache';
import { UnitRenderer } from '../renderers/units/UnitRenderer';
import { Enemy } from '../Enemy';

export class SpriteBaker {
    private static readonly WALK_FRAMES = 32; // Higher framerate for smoothness (32 frames)
    private static readonly IDLE_FRAMES = 12; // Lower framerate for breathing/idle (12 frames)
    private static readonly SIZE = 96;   // 1.5x Tile Size (64) -> 96 for extra detail/weapons

    /**
     * Bakes the animations for a specific renderer.
     * Generates individual frames in cache for both 'walk' and 'idle' states.
     * Output keys: 'unit_orc_walk_0', 'unit_orc_idle_0'...
     */
    public static bakeWalkCycle(typeId: string, renderer: UnitRenderer) {
        console.log(`[SpriteBaker] Baking ${this.WALK_FRAMES} walk and ${this.IDLE_FRAMES} idle frames for "${typeId}"...`);

        const mockEnemyWalk = {
            typeId: typeId,
            x: 0,
            y: 0,
            currentHealth: 100,
            maxHealth: 100,
            speed: 1,
            baseSpeed: 1,
            finished: false,
            hitFlashTimer: 0,
            isMoving: true // Signal to renderer
        } as any;

        const mockEnemyIdle = {
            ...mockEnemyWalk,
            isMoving: false // Signal for idle breathing/pulsing
        } as any;

        const facings = renderer.getBakeFacings ? renderer.getBakeFacings() : ['SIDE'] as const;

        for (const facing of facings) {
            // 1. Bake Walk Cycle
            this.bakeSet(typeId, facing, renderer, mockEnemyWalk, 'walk', this.WALK_FRAMES);

            // 2. Bake Idle Cycle
            this.bakeSet(typeId, facing, renderer, mockEnemyIdle, 'idle', this.IDLE_FRAMES);
        }
    }

    private static bakeSet(
        typeId: string,
        facing: 'SIDE' | 'UP' | 'DOWN',
        renderer: UnitRenderer,
        mockEnemy: any,
        animSet: 'walk' | 'idle',
        frameCount: number
    ) {
        // Compatibility check: if only SIDE is supported and we bake WALK, use legacy key format.
        // Otherwise, use explicit DIR3 + AnimSet format.
        const facingsCount = renderer.getBakeFacings ? renderer.getBakeFacings().length : 1;
        const useLegacyKey = (facingsCount === 1 && facing === 'SIDE' && animSet === 'walk');

        for (let i = 0; i < frameCount; i++) {
            let frameKey: string;
            if (useLegacyKey) {
                frameKey = `unit_${typeId}_walk_${i}`;
            } else {
                frameKey = `unit_${typeId}_${facing.toLowerCase()}_${animSet}_${i}`;
            }

            // Normalized time (0.0 -> 1.0)
            const t = i / frameCount;

            AssetCache.get(frameKey, (ctx, w, h) => {
                ctx.translate(w / 2, h / 2);

                if (renderer.drawFrameDirectional) {
                    renderer.drawFrameDirectional(ctx, mockEnemy, t, facing);
                } else if (renderer.drawFrame) {
                    renderer.drawFrame(ctx, mockEnemy, t);
                }
            }, this.SIZE, this.SIZE);

            // Generate White Silhouette for Hit Flash (Pre-baked)
            const sprite = AssetCache.peek(frameKey);
            if (sprite) {
                const silhouetteKey = frameKey + '_white';
                AssetCache.get(silhouetteKey, (ctxS, w, h) => {
                    ctxS.drawImage(sprite, 0, 0);
                    ctxS.globalCompositeOperation = 'source-in';
                    ctxS.fillStyle = '#ffffff';
                    ctxS.fillRect(0, 0, w, h);
                }, this.SIZE, this.SIZE);
            }
        }
    }

    /**
     * Retrieves a specific frame from the cache based on game time and state.
     */
    public static getFrame(
        typeId: string,
        gameTime: number,
        cycleDuration: number,
        animSet: 'walk' | 'idle' = 'walk',
        facing: 'SIDE' | 'UP' | 'DOWN' = 'SIDE'
    ): HTMLCanvasElement | undefined {

        const frameCount = animSet === 'walk' ? this.WALK_FRAMES : this.IDLE_FRAMES;
        const t = (gameTime % cycleDuration) / cycleDuration;
        const frameIndex = Math.floor(t * frameCount);

        // Legacy fallback check: if asking for SIDE walk without specific renderer knowledge,
        // we assume the key might be in legacy format 'unit_orc_walk_0'.
        // To be safe, try new format first, then fallback.
        const explicitKey = `unit_${typeId.toLowerCase()}_${facing.toLowerCase()}_${animSet}_${frameIndex}`;
        let sprite = AssetCache.peek(explicitKey);

        if (!sprite && animSet === 'walk' && facing === 'SIDE') {
            const legacyKey = `unit_${typeId.toLowerCase()}_walk_${frameIndex}`;
            sprite = AssetCache.peek(legacyKey);
        }

        return sprite;
    }
}
</file>

<file path="src/VisualConfig.ts">
/**
 * Centralized Visual Configuration
 * Stores colors, sizes, and other visual constants for procedural generation and rendering.
 */

import { UI } from './design';

export const VISUALS = {
    ENVIRONMENT: {
        GRASS: {
            // –ñ–∏–≤–∞—è —Ç—Ä–∞–≤–∞ (—Å—Ä–µ–¥–Ω—è—è –∑–µ–ª–µ–Ω—å) - –§–ê–ó–ê 2: –û–±–Ω–æ–≤–ª–µ–Ω–æ
            BASE: '#6b9e4a',         // –°—Ä–µ–¥–Ω–µ-–∑–µ–ª—ë–Ω—ã–π (–æ—Å–Ω–æ–≤–∞)
            LIGHT: '#7ab55a',        // –°–≤–µ—Ç–ª–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è
            DARK: '#5a8839',         // –¢—ë–º–Ω–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è (—Ç–µ–Ω–∏)
            BLADE: '#8bc34a',        // –¢—Ä–∞–≤–∏–Ω–∫–∏ (—è—Ä–∫–∏–µ)
            DETAIL: '#757575',       // –ö–∞–º–µ—à–∫–∏
            FLOWER: '#ffeb3b',       // –ú–µ–ª–∫–∏–µ —Ü–≤–µ—Ç–æ—á–∫–∏

            // –ë–∏–æ–ª—é–º–∏–Ω–µ—Å—Ü–µ–Ω—Ü–∏—è (–ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô - –¥–ª—è –§–∞–∑—ã 4)
            BIOLUM: '#4dd0e1',       // Cyan bioluminescence

            // LEGACY - –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º
            MAIN: '#6b9e4a',         // = BASE (fallback)
            VAR_1: '#7ab55a',        // = LIGHT (fallback)
            VAR_2: '#5a8839',        // = DARK (fallback)
        },
        PATH: {
            // –ö–∞–º–µ–Ω–Ω–∞—è –¥–æ—Ä–æ–≥–∞ (–§–ê–ó–ê 1: –û–±–Ω–æ–≤–ª–µ–Ω–æ)
            STONE_BASE: '#c5b8a1',       // –°–≤–µ—Ç–ª—ã–π –±–µ–∂–µ–≤—ã–π –∫–∞–º–µ–Ω—å
            STONE_LIGHT: '#d4c5a9',      // –°–≤–µ—Ç–ª–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è
            STONE_DARK: '#b6a890',       // –¢—ë–º–Ω–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è
            CRACK: '#8b7e6a',            // –¢—Ä–µ—â–∏–Ω—ã (—Ç—ë–º–Ω–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ã–π)
            EDGE: '#9a8d7a',             // –ö—Ä–∞—è –º–µ–∂–¥—É –ø–ª–∏—Ç–∞–º–∏
            MOSS: '#7a8f63',             // –ú–æ—Ö (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

            // LEGACY - –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º
            MAIN: '#c5b8a1',             // = STONE_BASE (fallback)
            DETAIL: '#8b7e6a',           // = CRACK (fallback)
            GRID: '#9a8d7a',             // = EDGE (fallback)
            BORDER: '#9a8d7a',           // = EDGE (fallback)
        },
        DECOR: {
            TREE: {
                BASE: '#3a4a2f', // Match –Ω–æ–≤—É—é grass
                FOLIAGE_LIGHT: '#2e4d32',
                FOLIAGE_DARK: '#1b3e20',
            },
            ROCK: {
                BASE: '#3a4a2f',
                STONE: '#5a606c', // –¢–µ–º–Ω–µ–µ –¥–ª—è Dark —Å—Ç–∏–ª—è
            }
        },
        FOG: {
            BASE: '#263238',
        }
    },
    // –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–µ—Ç–∞ (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –§–∞–∑—ã 5!)
    LIGHTING: {
        GLOBAL_LIGHT_ANGLE: Math.PI * 0.75,  // 135¬∞ (—Å–µ–≤–µ—Ä–æ-–∑–∞–ø–∞–¥ ‚Üí —é–≥–æ-–≤–æ—Å—Ç–æ–∫)
        SHADOW_OFFSET_X: 3,   // px —Å–º–µ—â–µ–Ω–∏—è —Ç–µ–Ω–∏
        SHADOW_OFFSET_Y: 3,
        HIGHLIGHT_OFFSET_X: -2,  // px –±–ª–∏–∫–∞ (–ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ —Ç–µ–Ω–∏)
        HIGHLIGHT_OFFSET_Y: -2,
    },
    TOWER: {
        BASE: {
            PLATFORM: '#9e9e9e', // Grey 500
            RIM: '#616161',      // Grey 700
            RIVETS: '#424242',
        },
        TURRET: {
            STANDARD: {
                MAIN: '#616161',
                STROKE: '#212121',
                BARREL: '#616161',
            },
            FIRE: {
                MAIN: '#f4511e', // Deep Orange 600
                STROKE: '#ffccbc',
                BARREL: '#ff7043',
                TIP: '#bf360c',
                RUNE: '#ffcc80', // Light Orange
                CORE: '#bf360c', // Dark Red Glow
                BAND: '#3e2723', // Dark band
            },
            ICE: {
                MAIN: '#00acc1', // Cyan 600
                STROKE: '#e0f7fa',
                SPIKE: '#4dd0e1', // Cyan 300
                FACET: 'rgba(255, 255, 255, 0.3)',
                COATING: 'rgba(255, 255, 255, 0.5)',
            },
            SNIPER: {
                MAIN: '#2e7d32', // Green 800
                BARREL: '#1b5e20', // Green 900
                MUZZLE: '#4caf50',
                DETAIL: '#1b5e20', // Darker detail
                ENERGY: '#69f0ae', // Neon Green
            },
            SPLIT: {
                MAIN: '#f57f17', // Yellow 900
                BARREL: '#fbc02d', // Yellow 700
                BAND: '#ff6f00', // Amber
                PLATE: '#ffca28', // Gold-ish
            },
            MINIGUN: {
                BARREL: '#7b1fa2', // Purple 700
                HOUSING: '#9c27b0', // Purple 500
                COIL: '#e1bee7', // Purple 100
                FLASH: '#4a148c', // Darker
                VENT: '#ce93d8', // Light Purple
                CORE: '#e1bee7', // Almost white purple
                GLOW: '#d500f9', // Neon Purple
            }
        },
        MUZZLE_FLASH: {
            STANDARD: 'rgba(255, 200, 100, 0.9)', // Yellow
            FIRE: 'rgba(255, 87, 34, 0.9)',    // Orange/Red
            ICE: 'rgba(77, 208, 225, 0.9)',    // Cyan
            SNIPER: 'rgba(105, 240, 174, 0.9)', // Green
            SPLIT: 'rgba(255, 235, 59, 0.9)',  // Bright Yellow
            MINIGUN: 'rgba(179, 136, 255, 0.9)' // Purple
        },
        MODULES: {
            ICE: {
                BODY: '#0277bd',
                LIQUID: '#4fc3f7',
                CAP: '#eceff1',
            },
            FIRE: {
                BODY: '#c62828',
                SYMBOL: '#ffeb3b',
            },
            SNIPER: {
                BODY: '#212121',
                LENS: '#00e5ff',
            },
            SPLIT: {
                BODY: '#ff6f00',
                ACCENT: '#ffd54f',
            }
        },
        BUILDING: {
            BASE: 'rgba(158, 158, 158, 0.5)',
            BAR_BG: 'rgba(0,0,0,0.5)',
            BAR_FILL: 'gold',
        },
        LASER: 'rgba(255, 0, 0, 0.6)',  // Sniper laser sight
        HEIGHT: 0.6,
        BASE_COLOR: '#9e9e9e', // Fallback color for tower base (migrated from CONFIG.COLORS.TOWER_BASE)
        RANGE_CIRCLE: {
            FILL: 'rgba(0, 255, 255, 0.1)',
            STROKE: 'rgba(0, 255, 255, 0.4)',
        }
    },
    ENEMY: {
        SKELETON: {
            BONE: '#e0e0e0',
            EYES: '#212121',
        },
        WOLF: {
            BODY: '#5d4037',
            EYES: '#ff1744',
        },
        TROLL: {
            SKIN: '#558b2f',
            FEATURE: '#33691e',
        },
        SPIDER: {
            BODY: '#311b92',
            HEAD: '#4527a0',
            EYES: '#d50000',
        },
        PROPS: {
            SHIELD: { WOOD: '#8d6e63', METAL: '#bdbdbd' },
            HELMET: { GOLD: '#ffd700', HORN: '#e0e0e0' },
            BARRIER: { FILL: 'rgba(100, 255, 218, 0.4)', STROKE: 'rgba(255, 255, 255, 0.8)' },
            WEAPON: { HANDLE: '#5d4037', GUARD: '#ffd700', BLADE: '#cfd8dc' },
        }
    },
    PROJECTILES: {
        STANDARD: '#fff',
        ICE: '#00bcd4',
        FIRE: '#f44336',
        SNIPER: '#4caf50',
        SPLIT: '#ff9800',
    },

    // UI Design System (imported from modular design tokens)
    UI: UI
};

// Re-export helper functions from design system
export { getSpacing, getTransition } from './design';
</file>

<file path="src/cards/FireCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Fire Card Upgrades (BALANCED)
 * 
 * Role: AoE damage dealer, good against groups
 * Trade-off: Lower single-target DPS for splash
 * 
 * Level 1: +12 damage, splash 45px, -15% speed
 * Level 2: +22 damage, splash 70px, -10% speed
 * Level 3: +25 damage, splash 80px, explode on death
 */
export const FIRE_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damage: 12,               // Nerfed from 15
            attackSpeedMultiplier: 0.85,
        },
        effects: [
            {
                type: 'splash',
                splashRadius: 45,     // Nerfed from 50
            },
            {
                type: 'burn',
                burnDuration: 3,
                burnDps: 5
            }
        ],
        visualOverrides: {
            projectileType: 'fire',
            projectileColor: '#f44336',
            projectileSpeed: 360,
        }
    },
    2: {
        level: 2,
        modifiers: {
            damage: 22,               // Nerfed from 30
            attackSpeedMultiplier: 0.90,
        },
        effects: [
            {
                type: 'splash',
                splashRadius: 70,     // Nerfed from 85
            },
            {
                type: 'burn',
                burnDuration: 4,
                burnDps: 8
            }
        ]
    },
    3: {
        level: 3,
        modifiers: {
            damage: 25,               // Nerfed from 30
            attackSpeedMultiplier: 0.90,
        },
        effects: [
            {
                type: 'splash',
                splashRadius: 80,     // Nerfed from 90
            },
            {
                type: 'burn',
                burnDuration: 5,
                burnDps: 12
            },
            {
                type: 'explodeOnDeath',
                explosionDamagePercent: 0.5,
                explosionRadius: 40,
            }
        ]
    }
};
</file>

<file path="src/cards/IceCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Ice Card Upgrades
 * 
 * Level 1: 30% slow, -10% range, +1 damage
 * Level 2: 45% slow, -20% range, +3 damage, +20% damage to slowed enemies
 * Level 3: 75% slow, -25% range, +6 damage, +40% damage to slowed, chain slow on death
 */
export const ICE_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damage: 1,
            rangeMultiplier: 0.90, // -10% range
        },
        effects: [
            {
                type: 'slow',
                slowPower: 0.30, // 30% slow
                slowDuration: 3, // 180 / 60
            }
        ],
        visualOverrides: {
            projectileType: 'ice',
            projectileColor: '#00bcd4',
            projectileSpeed: 600, // 10 * 60
        }
    },
    2: {
        level: 2,
        modifiers: {
            damage: 3,
            rangeMultiplier: 0.80, // -20% range
        },
        effects: [
            {
                type: 'slow',
                slowPower: 0.45, // 45% slow
                slowDuration: 4.5, // 270 / 60
                damageToSlowed: 1.20, // +20% damage to slowed enemies
            }
        ]
    },
    3: {
        level: 3,
        modifiers: {
            damage: 6,
            rangeMultiplier: 0.75, // -25% range
        },
        effects: [
            {
                type: 'slow',
                slowPower: 0.75, // 75% slow
                slowDuration: 6, // 360 / 60
                damageToSlowed: 1.40, // +40% damage to slowed enemies
            },
            {
                type: 'chainSlowOnDeath',
                chainRadius: 80,
            }
        ]
    }
};
</file>

<file path="src/FogSystem.ts">
import { IMapData } from './MapData';
import { FogRenderer } from './FogRenderer';
import { FogStructure, buildFogStructures } from './FogStructure';
import { CONFIG } from './Config';

/**
 * Fog System - manages layered fog with density and structure-based animation
 * @description
 * Supports 6 density levels:
 * - 0: No fog (visible)
 * - 1: 20% density
 * - 2: 40% density
 * - 3: 60% density
 * - 4: 80% density
 * - 5: 100% density
 */
export class FogSystem {
    private mapData: IMapData;
    private renderer: FogRenderer;
    private structures: FogStructure[] = [];
    private time: number = 0;
    private dirty: boolean = true;

    constructor(mapData: IMapData) {
        this.mapData = mapData;

        // Initialize fog data if missing
        if (!this.mapData.fogData) {
            this.mapData.fogData = Array(mapData.width * mapData.height).fill(0);
        } else if (this.mapData.fogData.length !== mapData.width * mapData.height) {
            const newData = Array(mapData.width * mapData.height).fill(0);
            this.mapData.fogData = newData;
        }

        // Create standard renderer
        this.renderer = new FogRenderer(
            mapData.width * 64, // Assuming TILE_SIZE = 64
            mapData.height * 64
        );

        this.buildStructures();
    }

    /**
     * Build fog structures from current fog data
     */
    private buildStructures(): void {
        this.structures = buildFogStructures(
            this.mapData.fogData!,
            this.mapData.width,
            this.mapData.height
        );
        this.dirty = false;

        console.log(`FogSystem: Found ${this.structures.length} fog structures`);
    }

    /**
     * Update fog animation
     */
    /**
     * Update fog animation
     */
    public update(dt: number = 0.016, lights: { x: number, y: number, radius: number }[] = []): void {
        // Rebuild structures if data changed
        if (this.dirty) {
            this.buildStructures();
        }

        const t = (dt > 0) ? (this.time += dt * 60) : 0;

        // Render Sprite logic
        if (dt > 0 || this.time === 0) {
            this.renderer.render(this.structures, this.time, lights);
        }
    }

    /**
     * Draw fog to main canvas
     */
    public draw(ctx: CanvasRenderingContext2D): void {
        ctx.save();
        ctx.drawImage(this.renderer.getCanvas(), 0, 0);
        ctx.restore();
    }

    /**
     * Set fog density at specific tile
     * @param x Column
     * @param y Row
     * @param density 0-5 (0 = no fog, 5 = max density)
     */
    public setFog(x: number, y: number, density: number): void {
        if (x < 0 || x >= this.mapData.width || y < 0 || y >= this.mapData.height) return;
        if (density < 0 || density > 5) return;

        const index = y * this.mapData.width + x;
        if (this.mapData.fogData![index] !== density) {
            this.mapData.fogData![index] = density;
            this.dirty = true;
        }
    }

    /**
     * Get fog density at specific tile
     */
    public getFog(x: number, y: number): number {
        if (x < 0 || x >= this.mapData.width || y < 0 || y >= this.mapData.height) return 0;
        const index = y * this.mapData.width + x;
        return this.mapData.fogData![index] || 0;
    }

    /**
     * Cycle fog density (1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 1)
     * For editor use - each click increases density
     */
    public cycleFogDensity(x: number, y: number): void {
        const current = this.getFog(x, y);
        let next: number;

        if (current === 0) {
            // First click on empty tile -> density 1
            next = 1;
        } else if (current >= 5) {
            // Max density -> back to 1
            next = 1;
        } else {
            // Increment density
            next = current + 1;
        }

        this.setFog(x, y, next);
    }

    /**
     * Get fog data array
     */
    public getFogData(): number[] {
        return this.mapData.fogData || [];
    }

    /**
     * Legacy method for compatibility
     * @deprecated Use setFog or cycleFogDensity instead
     */
    public toggleFog(col: number, row: number): void {
        this.cycleFogDensity(col, row);
    }
}
</file>

<file path="src/Pathfinder.ts">
import { Cell } from './MapData';
import { PerformanceMonitor } from './utils/PerformanceMonitor';

export class Pathfinder {
    // Path cache - avoids recalculating path on every spawn
    private static cachedPath: { x: number; y: number }[] = [];
    private static cacheKey: string = '';

    // Grid version to ensure cache invalidation on map edits
    private static gridVersion: number = 0;

    // Engine-Grade Buffers (Static, shared across all pathfind calls)
    private static queue: Int32Array | null = null;
    private static visited: Uint16Array | null = null;
    private static parent: Int32Array | null = null; // Stores index of parent node
    private static searchId: number = 0;
    private static bufferSize: number = 0;


    /**
     * Invalidate cache when map changes (call this after map edits)
     */
    public static invalidateCache(): void {
        this.cachedPath = [];
        this.cacheKey = '';
        this.gridVersion++;
    }

    /**
     * Ensure buffers are large enough for the current grid
     */
    private static ensureBuffers(cols: number, rows: number) {
        const size = cols * rows;
        if (!this.queue || this.bufferSize < size) {
            this.bufferSize = size;
            this.queue = new Int32Array(size);
            this.visited = new Uint16Array(size);
            this.parent = new Int32Array(size);
            this.searchId = 0;
        }
    }

    /**
     * Generate a hash of start/end/grid for cache key
     */
    private static getCacheKey(
        start: { x: number; y: number },
        end: { x: number; y: number },
        gridRows: number,
        gridCols: number
    ): string {
        return `${start.x},${start.y}-${end.x},${end.y}-${gridRows}x${gridCols}-v${this.gridVersion}`;
    }

    /**
     * Finds path using Zero-Allocation BFS logic (internally).
     * Returns a fresh array of points (allocates result only).
     */
    public static findPath(
        grid: Cell[][],
        start: { x: number; y: number },
        end: { x: number; y: number },
    ): { x: number; y: number }[] {
        PerformanceMonitor.startTimer('Pathfinding');
        PerformanceMonitor.addCount('PathCalls', 1);

        const rows = grid.length;
        const cols = grid[0].length;

        // Check cache first
        const key = this.getCacheKey(start, end, rows, cols);
        if (key === this.cacheKey && this.cachedPath.length > 0) {
            PerformanceMonitor.endTimer('Pathfinding');
            return [...this.cachedPath]; // Return copy to prevent mutation
        }

        // Initialize buffers
        this.ensureBuffers(cols, rows);
        const queue = this.queue!;
        const visited = this.visited!;
        const parent = this.parent!;

        // Increment Search ID
        this.searchId++;
        if (this.searchId >= 65000) {
            this.searchId = 1;
            visited.fill(0);
        }
        const sid = this.searchId;

        const startIdx = start.y * cols + start.x;
        const endIdx = end.y * cols + end.x;

        // BFS Init
        let head = 0;
        let tail = 0;

        queue[tail++] = startIdx;
        visited[startIdx] = sid;
        parent[startIdx] = -1; // Start has no parent

        const offsets = [-cols, 1, cols, -1]; // Up, Right, Down, Left (Deterministic)

        let found = false;

        // Search Loop
        while (head < tail) {
            const currentIdx = queue[head++];

            if (currentIdx === endIdx) {
                found = true;
                break;
            }

            // Neighbors
            for (let i = 0; i < 4; i++) {
                const neighborIdx = currentIdx + offsets[i];

                // Bounds Check (1D)
                if (neighborIdx < 0 || neighborIdx >= visited.length) continue;
                // Wrap Check
                if (i === 1 && (neighborIdx % cols) === 0) continue; // Right wrap
                if (i === 3 && ((neighborIdx + 1) % cols) === 0) continue; // Left wrap

                // Valid check
                const ny = (neighborIdx / cols) | 0;
                const nx = neighborIdx % cols; // Optim: could avoid mod?

                const cell = grid[ny][nx];
                if (cell.type === 1) { // STRICT: Path only
                    if (visited[neighborIdx] !== sid) {
                        visited[neighborIdx] = sid;
                        parent[neighborIdx] = currentIdx;
                        queue[tail++] = neighborIdx;
                    }
                }
            }
        }

        if (found) {
            // Reconstruct path
            const path: { x: number; y: number }[] = [];
            let curr = endIdx;
            while (curr !== -1) {
                const cx = curr % cols;
                const cy = (curr / cols) | 0;
                path.push({ x: cx, y: cy });
                curr = parent[curr];
            }
            // Reverse to get Start -> End
            path.reverse();

            // Cache result
            this.cachedPath = path;
            this.cacheKey = key;

            PerformanceMonitor.endTimer('Pathfinding');
            return [...path];
        }

        PerformanceMonitor.endTimer('Pathfinding');
        return [];
    }
}
</file>

<file path="src/renderers/units/CachedUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import { Assets } from '../../Assets';
import { AssetCache } from '../../utils/AssetCache';
import type { Enemy } from '../../Enemy';

export type SpriteOrientationMode = 'ROTATE' | 'FLIP' | 'DIR3';
export type SpriteFacing = 'SIDE' | 'UP' | 'DOWN';

/**
 * Base class for UnitRenderers that supports Sprite Baking.
 * Automatically handles sprite lookup, rotation, and basic hit flash.
 * Falls back to abstract `drawFrame` (procedural) if sprite is missing.
 */
export abstract class CachedUnitRenderer implements UnitRenderer {

    // Multiplier for walk cycle speed.
    // Orc: 0.1, Goblin: 0.25, etc.
    // Default: 0.15
    protected walkCycleMultiplier: number = 0.15;

    // Sprite size (default 96 for baked sprites)
    protected spriteSize: number = 96;

    // Orientation of baked sprites
    // Default: 'ROTATE' for backward compatibility (Top-Down units, Projectiles)
    protected orientationMode: SpriteOrientationMode = 'ROTATE';

    /**
     * If your sprite is authored ‚Äúfacing up‚Äù instead of ‚Äúfacing right‚Äù etc.
     * Only used in ROTATE mode.
     */
    protected baseRotationOffset: number = 0;

    /**
     * Facing thresholds (radians). You can tweak per-project.
     */
    protected facingUpMin = -2.35;
    protected facingUpMax = -0.78;
    protected facingDownMin = 0.78;
    protected facingDownMax = 2.35;

    /**
     * Draws a single frame for baking or fallback.
     * @param t Normalized time (0..1)
     */
    abstract drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void;

    /**
     * Standard draw method called by EnemyRenderer.
     */
    public drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.001;
        const facing = this.getFacing(rotation);

        // Determine animation set ('walk' or 'idle')
        // We cast to any because isMoving might not be explicitly typed on Enemy yet
        const enemyAny = enemy as any;
        const isMoving = enemyAny.isMoving !== undefined ? enemyAny.isMoving : true; // Fallback to walk if unknown
        const animSet: 'walk' | 'idle' = isMoving ? 'walk' : 'idle';

        let sprite;
        let t = 0;

        if (animSet === 'walk') {
            const walkCycle = time * (enemy.baseSpeed * this.walkCycleMultiplier);
            t = (walkCycle % (Math.PI * 2)) / (Math.PI * 2);
            const frameIdx = Math.floor(t * 32) % 32;
            const frameKey = this.getSpriteKey(enemy.typeId, frameIdx, facing, 'walk');
            sprite = AssetCache.peek(frameKey);
        } else {
            // Idle breathing (slower cycle)
            const idleCycle = time * 0.5; // Fixed idle speed
            t = (idleCycle % (Math.PI * 2)) / (Math.PI * 2);
            const frameIdx = Math.floor(t * 12) % 12; // 12 frames for idle
            const frameKey = this.getSpriteKey(enemy.typeId, frameIdx, facing, 'idle');
            sprite = AssetCache.peek(frameKey);
        }

        if (sprite) {
            ctx.save();
            const size = this.spriteSize * scale;

            // --- ORIENTATION LOGIC ---
            if (this.orientationMode === 'ROTATE') {
                // Classic Top-Down: Rotate the context match direction
                ctx.rotate(rotation + this.baseRotationOffset);
            } else if (this.orientationMode === 'FLIP') {
                // Side-View: Flip horizontally if moving left. NEVER rotate.
                if (this.isFacingLeft(enemy, rotation)) {
                    ctx.scale(-1, 1);
                }
            } else {
                // DIR3: 3-Directional (SIDE / UP / DOWN)
                // SIDE: Flip if left
                // UP/DOWN: No flip, no rotate
                if (facing === 'SIDE' && this.isFacingLeft(enemy, rotation)) {
                    ctx.scale(-1, 1);
                }
            }

            // Draw Centered
            ctx.drawImage(sprite, -size / 2, -size / 2, size, size);

            // Optimized Hit Flash (Source-Atop - extremely fast)
            if (enemy.hitFlashTimer > 0) {
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fillRect(-size / 2, -size / 2, size, size);
            }
            ctx.restore();

            // Draw extra effects if implemented by subclass (e.g. Magma particles)
            this.drawEffects(ctx, enemy, scale);
        } else {
            // Fallback: Procedural Draw
            ctx.save();

            if (this.orientationMode === 'ROTATE') {
                ctx.rotate(rotation + this.baseRotationOffset);
                this.drawFrame(ctx, enemy, t);
            } else if (this.orientationMode === 'FLIP') {
                if (this.isFacingLeft(enemy, rotation)) ctx.scale(-1, 1);
                this.drawFrame(ctx, enemy, t);
            } else {
                // DIR3 Fallback
                if (facing === 'SIDE' && this.isFacingLeft(enemy, rotation)) ctx.scale(-1, 1);
                this.drawFrameDirectional(ctx, enemy, t, facing);
            }

            ctx.restore();

            // Draw effects for fallback too
            this.drawEffects(ctx, enemy, scale);
        }
    }

    protected getFacing(rotation: number): SpriteFacing {
        // Normalize rotation to -PI..PI if needed, but usually it is.
        // Canvas angles: 0=Right, PI/2=Down, -PI/2=Up
        if (rotation > -Math.PI / 4 * 3 && rotation < -Math.PI / 4) return 'UP'; // Approx -135 to -45 deg
        if (rotation > Math.PI / 4 && rotation < Math.PI / 4 * 3) return 'DOWN'; // Approx 45 to 135 deg
        return 'SIDE';
    }

    protected isFacingLeft(enemy: Enemy, rotation: number): boolean {
        // PREFERRED: Use persistent state to avoid jitter (walking backwards)
        return enemy.lastFacingLeft;
    }

    protected getSpriteKey(enemyTypeId: string, frameIdx: number, facing: SpriteFacing, animSet: 'walk' | 'idle' = 'walk'): string {
        const id = enemyTypeId.toLowerCase();
        // Compatibility: ROTATE and FLIP modes use the legacy "walk_N" keys (side view baked)
        if (this.orientationMode !== 'DIR3') return `unit_${id}_${animSet}_${frameIdx}`;
        // DIR3 uses directional keys
        return `unit_${id}_${facing.toLowerCase()}_${animSet}_${frameIdx}`;
    }

    /**
     * Directional draw hook for baking/fallback in DIR3 mode.
     * Default: just call drawFrame (side).
     */
    public drawFrameDirectional(
        ctx: CanvasRenderingContext2D,
        enemy: Enemy,
        t: number,
        facing: SpriteFacing
    ): void {
        this.drawFrame(ctx, enemy, t);
    }

    /**
     * Optional hook for drawing effects (particles, etc.) on top of the body.
     * These are NOT baked into the sprite.
     */
    protected drawEffects(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number): void {
        // Override in subclasses
    }
}
</file>

<file path="src/renderers/units/HellhoundUnitRenderer.ts">
import { CachedUnitRenderer } from './CachedUnitRenderer';
import { UnitRenderer } from './UnitRenderer';
import { CONFIG } from '../../Config';
import type { Enemy } from '../../Enemy';
import { Assets } from '../../Assets';
import { AssetCache } from '../../utils/AssetCache';

/**
 * HellhoundUnitRenderer v2.0 ‚Äî Complete Visual Redesign
 * 
 * Key changes from v1:
 * - Lower, predatory stance (head below shoulders)
 * - Prominent shoulder blades and visible ribs
 * - Enhanced magma effects with spine glow
 * - Fangs and inner mouth fire
 * - Larger embers with trails
 */
export class HellhoundUnitRenderer extends CachedUnitRenderer {
    // üî• Demonic Palette ‚Äî Enhanced
    protected override orientationMode = 'DIR3' as const;
    private static readonly OBSIDIAN = '#0a0303';         // Deepest black-red
    private static readonly OBSIDIAN_LIGHT = '#1f0f0f';   // Slightly lighter
    private static readonly OBSIDIAN_MUSCLE = '#2a1515';  // Muscle tone
    private static readonly MAGMA_CORE = '#ff3d00';       // Bright lava
    private static readonly MAGMA_HOT = '#ffab00';        // White-hot
    private static readonly MAGMA_CRUST = '#bf360c';      // Cooling lava
    private static readonly EYE_FIRE = '#ffff00';         // Intense yellow
    private static readonly EYE_INNER = '#ffffff';        // White-hot center
    private static readonly CLAW_BONE = '#4e342e';        // Charred bone
    private static readonly FANG_WHITE = '#fff8e1';       // Ivory fangs
    private static readonly TONGUE_RED = '#c62828';       // Dark red tongue

    constructor() {
        super();
        this.walkCycleMultiplier = 0.2;
    }

    // BAKING SUPPORT
    public getBakeFacings(): ('SIDE' | 'UP' | 'DOWN')[] {
        return ['SIDE', 'UP', 'DOWN'];
    }

    public drawFrameDirectional(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number, facing: 'SIDE' | 'UP' | 'DOWN') {
        const cycle = t * Math.PI * 2;
        const scale = 1.0;
        const beastScale = scale * 1.25;
        const isMoving = true;
        const time = t * 10;

        if (facing === 'UP') return this.drawBack(ctx, beastScale, cycle, isMoving, time);
        if (facing === 'DOWN') return this.drawFront(ctx, beastScale, cycle, isMoving, time);
        return this.drawSide(ctx, beastScale, cycle, isMoving, time);
    }

    drawFrame(ctx: CanvasRenderingContext2D, enemy: Enemy, t: number): void {
        this.drawFrameDirectional(ctx, enemy, t, 'SIDE');
    }

    // drawBody is inherited from CachedUnitRenderer


    // =====================================================================
    // SIDE VIEW ‚Äî Predatory Hunting Stance
    // =====================================================================
    private drawSide(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, t: number) {
        const tilt = isMoving ? Math.sin(cycle) * 0.03 : 0;
        const vertical = isMoving ? Math.abs(Math.sin(cycle)) * 1.5 * s : 0;
        const breathe = Math.sin(t * 2) * 0.3 * s;

        ctx.translate(0, -vertical);
        ctx.rotate(tilt);

        // 1. FAR LEGS ‚Äî Behind body
        const legPhase = Math.PI * 0.3;
        this.drawLegSide(ctx, 6 * s, 5 * s, cycle, legPhase, s, true);      // Front far
        this.drawLegSide(ctx, -7 * s, 4 * s, cycle, Math.PI + legPhase, s, true); // Back far

        // 2. EMBER TRAIL ‚Äî Behind creature
        if (isMoving) this.drawEmberTrail(ctx, -8 * s, 2 * s, s, t);

        // 3. BODY ‚Äî Low, muscular, with prominent shoulders
        this.drawBodySide(ctx, s, t, breathe);

        // 4. SPINE GLOW ‚Äî Magma running along back
        this.drawSpineGlow(ctx, s, t);

        // 5. NEAR LEGS ‚Äî In front
        this.drawLegSide(ctx, 6 * s, 5 * s, cycle, 0, s, false);           // Front near
        this.drawLegSide(ctx, -7 * s, 4 * s, cycle, Math.PI, s, false);    // Back near

        // 6. HEAD ‚Äî Lower than shoulders (hunting pose)
        ctx.save();
        ctx.translate(10 * s, 2 * s); // Head FORWARD and DOWN
        ctx.rotate(-0.15 - tilt * 0.5); // Slight downward angle
        this.drawHeadSide(ctx, s, isMoving, t);
        ctx.restore();

        // 7. TAIL ‚Äî Raised, with fire tip
        this.drawTailSide(ctx, -9 * s, -3 * s, cycle, s, t);
    }

    private drawBodySide(ctx: CanvasRenderingContext2D, s: number, t: number, breathe: number) {
        // Main body ‚Äî angular, predatory
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();

        // Start from chest (right side)
        ctx.moveTo(8 * s, 2 * s);           // Neck base

        // SHOULDER BLADE ‚Äî prominent hump
        ctx.bezierCurveTo(5 * s, -6 * s, 2 * s, -7 * s, -1 * s, -5 * s); // Rise to shoulder

        // BACK ‚Äî slight dip then rise to haunches
        ctx.bezierCurveTo(-4 * s, -3 * s, -6 * s, -4 * s, -8 * s, -5 * s); // Haunches

        // REAR ‚Äî curves down
        ctx.bezierCurveTo(-10 * s, -4 * s, -10 * s, 2 * s, -8 * s, 5 * s); // Rear leg joint

        // BELLY ‚Äî sucked in (visible ribs)
        ctx.bezierCurveTo(-4 * s, 6 * s + breathe, 2 * s, 5 * s + breathe, 6 * s, 4 * s);

        // CHEST ‚Äî powerful
        ctx.bezierCurveTo(9 * s, 3 * s, 10 * s, 1 * s, 8 * s, 2 * s);
        ctx.fill();

        // Shoulder blade highlight
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN_MUSCLE;
        ctx.beginPath();
        ctx.ellipse(0, -4 * s, 3 * s, 2 * s, -0.3, 0, Math.PI * 2);
        ctx.fill();

        // Visible ribs
        ctx.strokeStyle = HellhoundUnitRenderer.OBSIDIAN_LIGHT;
        ctx.lineWidth = 0.8 * s;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(-2 * s + i * 3 * s, 2 * s, 3 * s, 0.5, Math.PI - 0.5);
            ctx.stroke();
        }

        // Magma cracks on body
        this.drawMagmaCracksSide(ctx, s, t);
    }

    private drawHeadSide(ctx: CanvasRenderingContext2D, s: number, mouthOpen: boolean, t: number) {
        const jawAngle = mouthOpen ? Math.sin(t * 8) * 0.15 + 0.2 : 0.1;

        // Skull ‚Äî more angular, elongated
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.moveTo(-3 * s, -4 * s);          // Back of skull
        ctx.lineTo(0, -5 * s);                // Top of skull
        ctx.lineTo(6 * s, -3 * s);            // Brow
        ctx.lineTo(8 * s, 0);                 // Snout tip
        ctx.lineTo(6 * s, 2 * s);             // Upper jaw
        ctx.lineTo(0, 3 * s);                 // Jaw hinge
        ctx.lineTo(-4 * s, 1 * s);            // Throat
        ctx.closePath();
        ctx.fill();

        // Lower jaw ‚Äî animated
        ctx.save();
        ctx.translate(0, 2 * s);
        ctx.rotate(jawAngle);
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN_LIGHT;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(6 * s, 1 * s);
        ctx.lineTo(0, 2 * s);
        ctx.closePath();
        ctx.fill();

        // FANGS ‚Äî Lower
        ctx.fillStyle = HellhoundUnitRenderer.FANG_WHITE;
        ctx.beginPath();
        ctx.moveTo(2 * s, 0); ctx.lineTo(2.5 * s, -2 * s); ctx.lineTo(3 * s, 0);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(4 * s, 0.5 * s); ctx.lineTo(4.5 * s, -1.5 * s); ctx.lineTo(5 * s, 0.5 * s);
        ctx.fill();

        // Tongue ‚Äî flickers when running
        if (mouthOpen && jawAngle > 0.15) {
            ctx.fillStyle = HellhoundUnitRenderer.TONGUE_RED;
            ctx.beginPath();
            ctx.ellipse(3 * s, 1.5 * s, 2 * s, 0.8 * s, 0.2, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();

        // Upper fangs
        ctx.fillStyle = HellhoundUnitRenderer.FANG_WHITE;
        ctx.beginPath();
        ctx.moveTo(5 * s, 1 * s); ctx.lineTo(5.3 * s, 3.5 * s); ctx.lineTo(5.8 * s, 1 * s);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(6.5 * s, 0.5 * s); ctx.lineTo(6.8 * s, 2.5 * s); ctx.lineTo(7.2 * s, 0.5 * s);
        ctx.fill();

        // Inner mouth glow
        const glowIntensity = 0.4 + Math.sin(t * 6) * 0.2;
        ctx.fillStyle = `rgba(255, 100, 0, ${glowIntensity})`;
        ctx.beginPath();
        ctx.ellipse(3 * s, 1.5 * s, 3 * s, 1.5 * s, 0, 0, Math.PI);
        ctx.fill();

        // EYE ‚Äî Intense glow (Optimized: No shadowBlur)
        const eyePulse = 0.9 + Math.sin(t * 10) * 0.1;

        // Glow
        const glow = AssetCache.getGlow('rgba(255, 255, 0, 0.5)', 32);
        const glowSize = 6 * s * eyePulse;
        ctx.drawImage(glow, 3 * s - glowSize / 2, -2 * s - glowSize / 2, glowSize, glowSize);

        ctx.fillStyle = HellhoundUnitRenderer.EYE_INNER;
        ctx.beginPath();
        ctx.ellipse(3 * s, -2 * s, 1.2 * s * eyePulse, 0.9 * s * eyePulse, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Pupil slit
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(3 * s, -2 * s, 0.3 * s, 0.7 * s, 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Ear ‚Äî torn, battle-scarred
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.moveTo(-2 * s, -3 * s);
        ctx.lineTo(-5 * s, -7 * s);
        ctx.lineTo(-4 * s, -6 * s); // Torn notch
        ctx.lineTo(-6 * s, -8 * s);
        ctx.lineTo(-3 * s, -4 * s);
        ctx.fill();
    }

    // =====================================================================
    // FRONT VIEW ‚Äî Aggressive Stance
    // =====================================================================
    private drawFront(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, t: number) {
        const vertical = isMoving ? Math.abs(Math.sin(cycle)) * 2 * s : 0;
        const breathe = Math.sin(t * 2) * 0.5 * s;
        ctx.translate(0, -vertical);

        // Back legs (visible between front)
        this.drawLegFront(ctx, -6 * s, 5 * s, cycle, Math.PI, s, true);
        this.drawLegFront(ctx, 6 * s, 5 * s, cycle, 0, s, true);

        // BODY ‚Äî V-shaped chest, power stance
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        // Wide shoulders
        ctx.moveTo(-8 * s, -6 * s);
        ctx.lineTo(8 * s, -6 * s);
        // V-chest narrowing 
        ctx.lineTo(4 * s, 6 * s + breathe);
        ctx.lineTo(-4 * s, 6 * s + breathe);
        ctx.closePath();
        ctx.fill();

        // Chest magma core (Optimized: No shadowBlur)
        const corePulse = 1 + Math.sin(t * 4) * 0.2;

        ctx.save();
        ctx.translate(0, 1 * s);
        const glow = AssetCache.getGlow('rgba(255, 171, 0, 0.6)', 64);
        const gSize = 25 * s * corePulse;
        ctx.drawImage(glow, -gSize / 2, -gSize / 2, gSize, gSize);
        ctx.restore();

        ctx.fillStyle = HellhoundUnitRenderer.MAGMA_CORE;
        ctx.beginPath();
        // Inverted triangle ‚Äî hellfire heart
        ctx.moveTo(-2 * s * corePulse, -2 * s);
        ctx.lineTo(2 * s * corePulse, -2 * s);
        ctx.lineTo(0, 4 * s * corePulse);
        ctx.closePath();
        ctx.fill();

        // Magma cracks from core (Optimized: Thick stroke + alpha)
        ctx.strokeStyle = HellhoundUnitRenderer.MAGMA_CORE;
        ctx.lineWidth = 1.5 * s;

        // Fake Glow
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 61, 0, 0.4)';
        ctx.lineWidth = 3.5 * s;
        ctx.beginPath();
        ctx.moveTo(-2 * s, -1 * s); ctx.lineTo(-5 * s, -4 * s);
        ctx.moveTo(2 * s, -1 * s); ctx.lineTo(5 * s, -4 * s);
        ctx.moveTo(0, 3 * s); ctx.lineTo(0, 6 * s);
        ctx.stroke();
        ctx.restore();

        ctx.beginPath();
        ctx.moveTo(-2 * s, -1 * s); ctx.lineTo(-5 * s, -4 * s);
        ctx.moveTo(2 * s, -1 * s); ctx.lineTo(5 * s, -4 * s);
        ctx.moveTo(0, 3 * s); ctx.lineTo(0, 6 * s);
        ctx.stroke();

        // Front legs (wide aggressive stance)
        this.drawLegFront(ctx, -5 * s, 7 * s, cycle, 0, s, false);
        this.drawLegFront(ctx, 5 * s, 7 * s, cycle, Math.PI, s, false);

        // Mane flames
        this.drawManeFront(ctx, 0, -8 * s, s, t);

        // HEAD
        ctx.save();
        ctx.translate(0, -6 * s);
        this.drawHeadFront(ctx, s, t, isMoving);
        ctx.restore();

        // Embers
        if (isMoving) this.drawEmberTrail(ctx, 0, 8 * s, s, t);
    }

    private drawHeadFront(ctx: CanvasRenderingContext2D, s: number, t: number, snarling: boolean) {
        // Angular skull
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.moveTo(-5 * s, -5 * s);  // Left temple
        ctx.lineTo(5 * s, -5 * s);   // Right temple
        ctx.lineTo(6 * s, 0);        // Right cheek
        ctx.lineTo(3 * s, 5 * s);    // Right jaw
        ctx.lineTo(-3 * s, 5 * s);   // Left jaw
        ctx.lineTo(-6 * s, 0);       // Left cheek
        ctx.closePath();
        ctx.fill();

        // EYES ‚Äî Burning (Optimized)
        const eyePulse = 0.9 + Math.sin(t * 12) * 0.1;
        const drawEye = (xOff: number) => {
            // Glow
            const glow = AssetCache.getGlow('rgba(255, 255, 0, 0.6)', 32);
            const gSize = 8 * s;
            ctx.drawImage(glow, xOff - gSize / 2, -1 * s - gSize / 2, gSize, gSize);

            // Shape
            ctx.fillStyle = HellhoundUnitRenderer.EYE_FIRE;
            ctx.beginPath();
            ctx.moveTo(xOff - 2.5 * s, -1 * s);
            ctx.lineTo(xOff + 1.5 * s, -2.5 * s);
            ctx.lineTo(xOff + 1.5 * s, 0.5 * s);
            ctx.closePath();
            ctx.fill();

            // White hot center
            ctx.fillStyle = HellhoundUnitRenderer.EYE_INNER;
            ctx.beginPath();
            ctx.arc(xOff, -1 * s, 0.6 * s * eyePulse, 0, Math.PI * 2);
            ctx.fill();
        };
        drawEye(-2.5 * s);
        drawEye(2.5 * s);

        // Snout
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN_LIGHT;
        ctx.beginPath();
        ctx.rect(-2 * s, 1 * s, 4 * s, 3 * s);
        ctx.fill();

        // Nostrils ‚Äî glowing
        ctx.fillStyle = HellhoundUnitRenderer.MAGMA_CRUST;
        ctx.beginPath();
        ctx.ellipse(-1 * s, 2 * s, 0.5 * s, 0.3 * s, 0, 0, Math.PI * 2);
        ctx.ellipse(1 * s, 2 * s, 0.5 * s, 0.3 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // FANGS
        ctx.fillStyle = HellhoundUnitRenderer.FANG_WHITE;
        // Upper fangs
        ctx.beginPath();
        ctx.moveTo(-2 * s, 4 * s); ctx.lineTo(-1.7 * s, 7 * s); ctx.lineTo(-1.4 * s, 4 * s);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(2 * s, 4 * s); ctx.lineTo(1.7 * s, 7 * s); ctx.lineTo(1.4 * s, 4 * s);
        ctx.fill();

        // Lower fangs (smaller)
        ctx.beginPath();
        ctx.moveTo(-1 * s, 5 * s); ctx.lineTo(-0.8 * s, 3 * s); ctx.lineTo(-0.6 * s, 5 * s);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(1 * s, 5 * s); ctx.lineTo(0.8 * s, 3 * s); ctx.lineTo(0.6 * s, 5 * s);
        ctx.fill();

        // Inner mouth glow
        if (snarling) {
            const glowPulse = 0.5 + Math.sin(t * 8) * 0.3;
            const grad = ctx.createRadialGradient(0, 4 * s, 0, 0, 4 * s, 3 * s);
            grad.addColorStop(0, `rgba(255, 150, 0, ${glowPulse})`);
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.rect(-2 * s, 3 * s, 4 * s, 3 * s);
            ctx.fill();
        }

        // Ears
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.moveTo(-4 * s, -5 * s); ctx.lineTo(-7 * s, -10 * s); ctx.lineTo(-3 * s, -6 * s);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(4 * s, -5 * s); ctx.lineTo(7 * s, -10 * s); ctx.lineTo(3 * s, -6 * s);
        ctx.fill();
    }

    // =====================================================================
    // BACK VIEW ‚Äî Retreating/Chasing
    // =====================================================================
    private drawBack(ctx: CanvasRenderingContext2D, s: number, cycle: number, isMoving: boolean, t: number) {
        const vertical = isMoving ? Math.abs(Math.sin(cycle)) * 2 * s : 0;
        ctx.translate(0, -vertical);

        // Front legs visible through gap
        this.drawLegFront(ctx, -3 * s, 4 * s, cycle, 0, s, true);
        this.drawLegFront(ctx, 3 * s, 4 * s, cycle, Math.PI, s, true);

        // Haunches/Hips ‚Äî powerful
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.ellipse(0, 0, 7 * s, 5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // SPINE with magma between vertebrae
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN_MUSCLE;
        ctx.beginPath();
        ctx.rect(-1.5 * s, -7 * s, 3 * s, 7 * s);
        ctx.fill();

        // Vertebrae bumps
        for (let i = 0; i < 4; i++) {
            const yPos = -6 * s + i * 2 * s;
            // Bone
            ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN_LIGHT;
            ctx.beginPath();
            ctx.ellipse(0, yPos, 2 * s, 0.8 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            // Magma glow between (Optimized)
            if (i < 3) {
                const glowInt = 0.6 + Math.sin(t * 5 + i) * 0.4;
                ctx.fillStyle = `rgba(255, 61, 0, ${glowInt})`;

                // Fake Glow
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.ellipse(0, yPos + 1 * s, 1.5 * s, 0.6 * s, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;

                ctx.beginPath();
                ctx.ellipse(0, yPos + 1 * s, 1 * s, 0.4 * s, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Back legs ‚Äî muscular haunches
        this.drawLegFront(ctx, -5 * s, 6 * s, cycle, Math.PI, s, false);
        this.drawLegFront(ctx, 5 * s, 6 * s, cycle, 0, s, false);

        // Tail ‚Äî raised dominantly
        this.drawTailBack(ctx, 0, -5 * s, cycle, s, t);

        // Back of head/ears silhouette
        ctx.translate(0, -7 * s);
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN_LIGHT;
        // Ear silhouettes
        ctx.beginPath();
        ctx.moveTo(-3 * s, -2 * s); ctx.lineTo(-6 * s, -7 * s); ctx.lineTo(-2 * s, -3 * s);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(3 * s, -2 * s); ctx.lineTo(6 * s, -7 * s); ctx.lineTo(2 * s, -3 * s);
        ctx.fill();

        // Top of skull
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.ellipse(0, 0, 4 * s, 3 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.translate(0, 7 * s);
        if (isMoving) this.drawEmberTrail(ctx, 0, 8 * s, s, t);
    }

    // =====================================================================
    // COMPONENTS
    // =====================================================================

    private drawLegSide(ctx: CanvasRenderingContext2D, x: number, y: number, cycle: number, phase: number, s: number, far: boolean) {
        const angle = Math.cos(cycle + phase) * 0.45; // Reduced swing
        const kneeBend = Math.max(0, Math.sin(cycle + phase)) * 1.0; // Gentler knee

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        // Thigh ‚Äî more muscular
        ctx.fillStyle = far ? HellhoundUnitRenderer.OBSIDIAN_LIGHT : HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.ellipse(0, 0, 3 * s, 5 * s, 0.15, 0, Math.PI * 2);
        ctx.fill();

        // Calf
        ctx.translate(0, 4 * s);
        ctx.rotate(kneeBend - 0.4);
        ctx.fillStyle = far ? HellhoundUnitRenderer.OBSIDIAN_MUSCLE : HellhoundUnitRenderer.OBSIDIAN_LIGHT;
        ctx.beginPath();
        ctx.moveTo(-1.2 * s, 0);
        ctx.lineTo(1.2 * s, 0);
        ctx.lineTo(0.6 * s, 6 * s);
        ctx.lineTo(-0.6 * s, 6 * s);
        ctx.fill();

        // Paw with claws
        ctx.translate(0, 6 * s);
        ctx.rotate(-kneeBend + 0.4);
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.ellipse(0, 0, 2 * s, 1.2 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // Claws
        if (!far) {
            ctx.fillStyle = HellhoundUnitRenderer.CLAW_BONE;
            ctx.beginPath();
            ctx.moveTo(1 * s, 0); ctx.lineTo(2.5 * s, 0.5 * s); ctx.lineTo(1 * s, 0.5 * s);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(0, 0.5 * s); ctx.lineTo(0.5 * s, 1.5 * s); ctx.lineTo(-0.5 * s, 1.5 * s);
            ctx.fill();
        }

        ctx.restore();
    }

    private drawLegFront(ctx: CanvasRenderingContext2D, x: number, y: number, cycle: number, phase: number, s: number, back: boolean) {
        const lift = Math.max(0, Math.sin(cycle + phase)) * 4 * s;
        ctx.save();
        ctx.translate(x, y - lift);

        ctx.fillStyle = back ? HellhoundUnitRenderer.OBSIDIAN_LIGHT : HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.2 * s, 5 * s, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.translate(0, 5 * s);
        ctx.fillStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.beginPath();
        ctx.arc(0, 0, 2.2 * s, 0, Math.PI * 2);
        ctx.fill();

        // Claws
        if (!back) {
            ctx.fillStyle = HellhoundUnitRenderer.CLAW_BONE;
            ctx.beginPath();
            ctx.rect(-1.5 * s, 1.5 * s, 0.8 * s, 1.5 * s);
            ctx.rect(0.7 * s, 1.5 * s, 0.8 * s, 1.5 * s);
            ctx.fill();
        }

        ctx.restore();
    }

    private drawTailSide(ctx: CanvasRenderingContext2D, x: number, y: number, cycle: number, s: number, t: number) {
        const whip = Math.sin(cycle * 2.5) * 0.4;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(whip - 0.8); // Raised tail

        // Tail body
        ctx.strokeStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.lineWidth = 2 * s;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-4 * s, -3 * s, -7 * s, -5 * s);
        ctx.stroke();

        // Fire tip (Optimized: No shadowBlur)
        const firePulse = 1 + Math.sin(t * 10) * 0.3;

        const glow = AssetCache.getGlow('rgba(255, 61, 0, 0.5)', 32);
        const gSize = 12 * s * firePulse;
        ctx.drawImage(glow, -7 * s - gSize / 2, -5 * s - gSize / 2, gSize, gSize);

        ctx.fillStyle = HellhoundUnitRenderer.MAGMA_CORE;
        ctx.beginPath();
        ctx.arc(-7 * s, -5 * s, 2 * s * firePulse, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    private drawTailBack(ctx: CanvasRenderingContext2D, x: number, y: number, cycle: number, s: number, t: number) {
        const sway = Math.sin(cycle * 2) * 0.3;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(sway);

        // Tail going up
        ctx.strokeStyle = HellhoundUnitRenderer.OBSIDIAN;
        ctx.lineWidth = 2.5 * s;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(0, -5 * s, 0, -8 * s);
        ctx.stroke();

        // Fire tip (Optimized)
        const firePulse = 1 + Math.sin(t * 10) * 0.3;

        const glow = AssetCache.getGlow('rgba(255, 61, 0, 0.5)', 32);
        const gSize = 15 * s * firePulse;
        ctx.drawImage(glow, -gSize / 2, -8 * s - gSize / 2, gSize, gSize);

        ctx.fillStyle = HellhoundUnitRenderer.MAGMA_CORE;
        ctx.beginPath();
        ctx.arc(0, -8 * s, 2.5 * s * firePulse, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    private drawSpineGlow(ctx: CanvasRenderingContext2D, s: number, t: number) {
        const pulseBase = 0.5 + Math.sin(t * 4) * 0.3;

        ctx.strokeStyle = HellhoundUnitRenderer.MAGMA_CORE;
        ctx.lineWidth = 2 * s;

        // Fake Glow (stroke)
        ctx.globalAlpha = pulseBase * 0.5;
        ctx.lineWidth = 4 * s;
        ctx.beginPath();
        ctx.moveTo(5 * s, -5 * s);
        ctx.bezierCurveTo(2 * s, -6 * s, -3 * s, -4 * s, -7 * s, -4 * s);
        ctx.stroke();

        ctx.globalAlpha = pulseBase;
        ctx.lineWidth = 2 * s;
        ctx.beginPath();
        ctx.moveTo(5 * s, -5 * s);
        ctx.bezierCurveTo(2 * s, -6 * s, -3 * s, -4 * s, -7 * s, -4 * s);
        ctx.stroke();

        ctx.globalAlpha = 1.0;
    }

    private drawMagmaCracksSide(ctx: CanvasRenderingContext2D, s: number, t: number) {
        const alpha = 0.6 + Math.sin(t * 6) * 0.4;
        ctx.strokeStyle = HellhoundUnitRenderer.MAGMA_CORE;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = 1.8 * s;

        // Fake Glow (Double stroke)
        ctx.save();
        ctx.lineWidth = 4 * s;
        ctx.globalAlpha = alpha * 0.3;
        ctx.beginPath();
        ctx.moveTo(4 * s, -4 * s); ctx.lineTo(2 * s, 0);
        ctx.moveTo(-1 * s, -2 * s); ctx.lineTo(-3 * s, 2 * s);
        ctx.moveTo(-5 * s, -3 * s); ctx.lineTo(-6 * s, 0);
        ctx.moveTo(-7 * s, -2 * s); ctx.lineTo(-8 * s, 1 * s);
        ctx.stroke();
        ctx.restore();

        ctx.beginPath();
        // Shoulder crack
        ctx.moveTo(4 * s, -4 * s); ctx.lineTo(2 * s, 0);
        // Flank cracks
        ctx.moveTo(-1 * s, -2 * s); ctx.lineTo(-3 * s, 2 * s);
        ctx.moveTo(-5 * s, -3 * s); ctx.lineTo(-6 * s, 0);
        // Haunch
        ctx.moveTo(-7 * s, -2 * s); ctx.lineTo(-8 * s, 1 * s);
        ctx.stroke();

        ctx.globalAlpha = 1.0;
    }

    private drawManeFront(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, t: number) {
        ctx.save();
        ctx.translate(x, y);

        // Multiple flame tendrils
        const flames = 7;
        for (let i = 0; i < flames; i++) {
            const ang = -Math.PI * 0.4 + (i / (flames - 1)) * Math.PI * 0.8;
            const flicker = Math.sin(t * 15 + i * 2) * 0.2;
            const len = 6 * s + Math.sin(t * 10 + i * 3) * 2 * s;

            const grad = ctx.createLinearGradient(0, 0, Math.cos(ang) * len, Math.sin(ang) * len);
            grad.addColorStop(0, HellhoundUnitRenderer.MAGMA_HOT);
            grad.addColorStop(0.4, HellhoundUnitRenderer.MAGMA_CORE);
            grad.addColorStop(1, 'rgba(191, 54, 12, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(ang - 0.15 + flicker) * len, Math.sin(ang - 0.15 + flicker) * len);
            ctx.lineTo(Math.cos(ang + 0.15 + flicker) * (len * 0.6), Math.sin(ang + 0.15 + flicker) * (len * 0.6));
            ctx.fill();
        }

        ctx.restore();
    }

    private drawEmberTrail(ctx: CanvasRenderingContext2D, x: number, y: number, s: number, t: number) {
        // DETERMINISTIC EMBERS (No Math.random inside frame draw)
        // We use sine waves based on time and index to simulate randomness
        const count = 4;
        for (let i = 0; i < count; i++) {
            // Emulate "if (Math.random() > 0.7) continue" deterministically
            // Use a complex sine wave to decide visibility
            const visibilityFactor = Math.sin(t * 5 + i * 132.1);
            if (visibilityFactor > 0.4) continue; // Skip roughly 30-40% of time

            const offset = Math.sin(t * 3 + i * 4) * 4 * s;
            const px = x + offset;
            const py = y + Math.cos(t * 4 + i * 2) * 2 * s;

            const size = (0.8 + Math.abs(Math.sin(t * 2 + i))) * s;
            const alpha = 0.6 + Math.sin(t * 7 + i) * 0.4;

            ctx.fillStyle = (i % 2 === 0) ? HellhoundUnitRenderer.MAGMA_CORE : HellhoundUnitRenderer.MAGMA_HOT;

            // Optimized: No shadowBlur
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(px, py, size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1.0;
    }

    drawEmissive(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        // Emissive handled in main draw for consistency
    }
}
</file>

<file path="src/scenes/IGameScene.ts">
import { Game } from '../Game';
import { IMapData } from '../MapData';
import { WaveManager } from '../WaveManager';
import { CardSystem, ICard } from '../CardSystem';
import { UIManager } from '../UIManager';
import { ForgeSystem } from '../ForgeSystem';
import { InspectorSystem } from '../InspectorSystem';
import { MetricsSystem } from '../MetricsSystem';
import { Enemy } from '../Enemy';
import { Tower } from '../Tower';
import { Projectile } from '../Projectile';
import { EffectSystem } from '../EffectSystem';
import { ProjectileSystem } from '../systems/ProjectileSystem';
import { CollisionSystem } from '../CollisionSystem';
import { EventEmitter } from '../Events';
import { GameController } from './GameController';
import { GameState } from './GameState';

// Define the interface for the GameScene
export interface IGameScene {
    // Core references
    game: Game;
    mapData: IMapData;

    // Controller
    gameController: GameController;

    // Systems
    waveManager: WaveManager;
    cardSys: CardSystem;
    ui: UIManager;
    forge: ForgeSystem;
    inspector: InspectorSystem;
    metrics: MetricsSystem;
    effects: EffectSystem;
    projectileSystem: ProjectileSystem;
    collision: CollisionSystem;
    events: EventEmitter;

    // State
    gameState: GameState;
    wave: number;
    readonly money: number;
    readonly lives: number;
    readonly startingLives: number; // For perfect wave bonus detection
    enemies: Enemy[];
    towers: Tower[];
    projectiles: Projectile[];

    // Methods
    spawnEnemy(type: string): void;
    showFloatingText(text: string, x: number, y: number, color?: string): void;
    handleCardDrop(card: ICard, x: number, y: number): boolean;
    giveRandomCard(): void;
    sellTower(tower: Tower): void;
    sellCardFromTower(tower: Tower, cardIndex: number): void;
    restart(): void;
    togglePause(): void;

    // Helper Methods
    addMoney(amount: number): void;
    spendMoney(amount: number): boolean;
    loseLife(amount?: number): void;

    // Need these for some systems (e.g. UIManager accessing shop)
    // shop is in UIManager, but UIManager might access scene's other props
}
</file>

<file path="src/scenes/StressTestScene.ts">
import { BaseScene } from '../BaseScene';
import { Game } from '../Game';
import { MapManager } from '../Map';
import { UIManager } from '../UIManager';
import { EntityManager } from './EntityManager';
import { PerformanceProfiler } from '../utils/PerformanceProfiler';
import { StressLogger } from '../utils/StressLogger';
import { SeededRandom } from '../utils/SeededRandom';
import { GameState } from './GameState';
import { EffectSystem } from '../EffectSystem';
import { ProjectileSystem } from '../systems/ProjectileSystem';
import { CollisionSystem } from '../CollisionSystem';
import { MetricsSystem } from '../MetricsSystem';
import { IMapData } from '../MapData';
import { IGameScene } from './IGameScene';
import { Tower } from '../Tower';
import { Enemy } from '../Enemy';
import { Projectile } from '../Projectile';
import { ICard } from '../CardSystem';
import { EventEmitter } from '../Events';
import { CONFIG } from '../Config';
import { GameSession } from '../GameSession';
import { GameController } from './GameController';

enum TestPhase {
    IDLE,
    WARMUP,
    CPU_NAV_REBUILD,
    CPU_AGENT_UPDATE,
    PHYSICS_CLUSTERED,
    PHYSICS_UNIFORM,
    RENDER_BASELINE,
    RENDER_REALISTIC,
    RENDER_WORST_CACHED,
    RENDER_WORST_NOCACHE,
    RAMP_UP,
    FINISHED
}

type BenchMode = 'logicOnly' | 'renderOnly' | 'mixed';

export class StressTestScene extends BaseScene implements IGameScene {
    public game: Game;
    public mapData: IMapData;
    public session: GameSession;
    private _map: MapManager;

    // IGameScene proxies
    public get gameState() { return this.session.gameState; }
    public get entityManager() { return this.session.entityManager; }
    public get waveManager() { return this.session.waveManager; }
    public get projectileSystem() { return this.session.projectileSystem; }
    public get collision() { return this.session.collision; }
    public get metrics() { return this.session.metrics; }
    public get weaponSystem() { return this.session.weaponSystem; }
    public get cardSys() { return this.session.cardSys; }
    public get forge() { return this.session.forge; }
    public get inspector() { return this.session.inspector; }
    public get bestiary() { return this.session.bestiary; }
    public get notifications() { return this.session.notifications; }
    public get acidSystem() { return this.session.acidSystem; }
    public get commanderSystem() { return this.session.commanderSystem; }
    public get effects() { return this._effects; }

    public ui: UIManager;
    public events: EventEmitter;
    public gameController: GameController;

    private _effects: EffectSystem;

    // Test State
    private phase: TestPhase = TestPhase.IDLE;
    private benchMode: BenchMode = 'mixed';
    private timer: number = 0;
    private phaseTimer: number = 0;
    private rng: SeededRandom;
    private uiOverlay: HTMLElement | null = null;

    private lastDt: number = 0.016;
    private lastFps: number = 60;
    private lastTotalEntities: number = 0;
    public stableMaxEntities: number = 0;

    private profiledCtx: CanvasRenderingContext2D | null = null;
    private prevCtx: CanvasRenderingContext2D | null = null;

    private getProfiledCtx(ctx: CanvasRenderingContext2D): CanvasRenderingContext2D {
        if (this.prevCtx !== ctx) {
            this.prevCtx = ctx;
            this.profiledCtx = new Proxy(ctx, {
                get(target, prop) {
                    const val = (target as any)[prop];
                    if (typeof val === 'function') {
                        // Categories based on TL feedback
                        if (prop === 'drawImage') {
                            return (...args: any[]) => { PerformanceProfiler.count('drawImage'); return val.apply(target, args); };
                        }
                        if (prop === 'fillRect' || prop === 'strokeRect' || prop === 'clearRect') {
                            return (...args: any[]) => { PerformanceProfiler.count('fillRect'); return val.apply(target, args); };
                        }
                        if (['beginPath', 'moveTo', 'lineTo', 'arc', 'fill', 'stroke', 'bezierCurveTo', 'quadraticCurveTo'].includes(prop as string)) {
                            return (...args: any[]) => { PerformanceProfiler.count('pathOps'); return val.apply(target, args); };
                        }
                        if (prop === 'fillText' || prop === 'strokeText' || prop === 'measureText') {
                            return (...args: any[]) => { PerformanceProfiler.count('textOps'); return val.apply(target, args); };
                        }
                        if (prop === 'save' || prop === 'restore') {
                            return (...args: any[]) => { PerformanceProfiler.count('saveRestore'); return val.apply(target, args); };
                        }
                        if (['translate', 'scale', 'rotate', 'transform', 'setTransform', 'resetTransform'].includes(prop as string)) {
                            return (...args: any[]) => { PerformanceProfiler.count('transform'); return val.apply(target, args); };
                        }
                        if (prop === 'createRadialGradient' || prop === 'createLinearGradient' || prop === 'createPattern') {
                            return (...args: any[]) => { PerformanceProfiler.count('gradientOps'); return val.apply(target, args); };
                        }

                        // For any other function
                        return val.bind(target);
                    }
                    return val;
                },
                set(target, prop, value) {
                    if (prop === 'globalAlpha' || prop === 'globalCompositeOperation') {
                        PerformanceProfiler.count('stateChanges');
                    }
                    if (prop === 'fillStyle' || prop === 'strokeStyle' || prop === 'lineWidth' || prop === 'font') {
                        PerformanceProfiler.count('stateChanges');
                    }
                    (target as any)[prop] = value;
                    return true;
                }
            });
        }
        return this.profiledCtx!;
    }

    // Config parameters
    private static readonly PHASE_DURATION = 5.0; // 5 seconds per phase hold

    // IGameScene Stubs
    public get wave() { return 0; }
    public set wave(v: number) { }
    public get money() { return 0; }
    public get lives() { return 20; }
    public get startingLives() { return 20; }
    public get enemies() { return this.gameState.enemies; }
    public get towers() { return this.gameState.towers; }
    public get projectiles() { return this.projectileSystem.projectiles; }

    public spawnEnemy(type: string) { }
    public showFloatingText(text: string, x: number, y: number, color?: string) { }
    public handleCardDrop(card: ICard, x: number, y: number): boolean { return false; }
    public giveRandomCard() { }
    public sellTower(tower: Tower) { }
    public sellCardFromTower(tower: Tower, cardIndex: number) { }
    public restart() { }
    public togglePause() { }
    public addMoney(amount: number) { }
    public spendMoney(amount: number): boolean { return true; }
    public loseLife(amount?: number) { }
    public startBuildingTower(col: number, row: number) { }
    public handleGridClick(col: number, row: number) { }
    public gameOver() { }
    public triggerShake(duration: number, intensity: number) { }

    constructor(game: Game) {
        super();
        this.game = game;
        this.rng = new SeededRandom(42); // Fixed seed for reproducible tests

        this.mapData = {
            width: 20,
            height: 20,
            tiles: Array(20).fill(0).map(() => Array(20).fill(0)),
            waypoints: [{ x: 0, y: 10 }, { x: 19, y: 10 }],
            objects: []
        };

        this._effects = new EffectSystem(game.ctx);
        this._map = new MapManager(this.mapData);
        this._map.waypoints = this.mapData.waypoints;
        this.events = new EventEmitter();

        this.session = new GameSession(game, this, this._map, this.mapData, this._effects, []);
        this.ui = new UIManager(this);
        this.gameController = {} as GameController;
    }

    public get map() { return this._map; }

    protected onEnterImpl() {
        this.createOverlay();
        this.setPhase(TestPhase.WARMUP);
        StressLogger.reset();
        PerformanceProfiler.enable();
        console.log("Stress Test V2 Started");
    }

    protected onExitImpl() {
        if (this.uiOverlay) {
            this.uiOverlay.remove();
            this.uiOverlay = null;
        }
        PerformanceProfiler.disable();
    }

    private setPhase(newPhase: TestPhase) {
        this.phase = newPhase;
        this.phaseTimer = 0;
        this.clearEntities();
        this.resetMapWalls();

        switch (newPhase) {
            case TestPhase.WARMUP:
                this.benchMode = 'mixed';
                StressLogger.startPhase('WARMUP');
                this.spawnTestEnemies('ORC_TANK', 50, 'uniform');
                break;
            case TestPhase.CPU_NAV_REBUILD:
                this.benchMode = 'logicOnly';
                StressLogger.startPhase('CPU_NAV_REBUILD');
                this.spawnTestEnemies('SCOUT', 300, 'uniform');
                break;
            case TestPhase.CPU_AGENT_UPDATE:
                this.benchMode = 'logicOnly';
                StressLogger.startPhase('CPU_AGENT_UPDATE');
                this.spawnTestEnemies('SCOUT', 1000, 'uniform'); // High logic load
                break;
            case TestPhase.PHYSICS_CLUSTERED:
                this.benchMode = 'logicOnly';
                StressLogger.startPhase('PHYSICS_CLUSTERED');
                this.spawnTestEnemies('ORC_WARRIOR', 500, 'clustered');
                this.setupPhysicsProjectiles(1000, 'clustered');
                break;
            case TestPhase.PHYSICS_UNIFORM:
                this.benchMode = 'logicOnly';
                StressLogger.startPhase('PHYSICS_UNIFORM');
                this.spawnTestEnemies('ORC_WARRIOR', 500, 'uniform');
                this.setupPhysicsProjectiles(1000, 'uniform');
                break;
            case TestPhase.RENDER_BASELINE:
                this.benchMode = 'renderOnly';
                StressLogger.startPhase('RENDER_BASELINE');
                this.spawnTestEnemies('SCOUT', 500, 'uniform');
                break;
            case TestPhase.RENDER_REALISTIC:
                this.benchMode = 'renderOnly';
                StressLogger.startPhase('RENDER_REALISTIC');
                this.spawnTestEnemies('SCOUT', 500, 'uniform'); // Normal drawing
                break;
            case TestPhase.RENDER_WORST_CACHED:
                this.benchMode = 'renderOnly';
                StressLogger.startPhase('RENDER_WORST_CACHED');
                break;
            case TestPhase.RENDER_WORST_NOCACHE:
                this.benchMode = 'renderOnly';
                StressLogger.startPhase('RENDER_WORST_NOCACHE');
                break;
            case TestPhase.RAMP_UP:
                this.benchMode = 'mixed';
                this.rampUpStep = 1;
                StressLogger.startPhase(`RAMP_UP_STEP_${this.rampUpStep}`);
                break;
            case TestPhase.FINISHED:
                StressLogger.finishPhase();
                this.showReport();
                break;
        }
    }

    private clearEntities() {
        this.gameState.enemies = [];
        this.gameState.towers = [];
        this.projectileSystem.clear();
        this.effects.clear();
        this.map.requestFlowFieldUpdate();
        this.map.update(0);
    }

    public update(dt: number) {
        if (document.hidden) return;

        const currentFps = dt > 0 ? 1 / dt : 60;
        this.lastDt = dt;
        this.lastFps = currentFps;

        PerformanceProfiler.beginFrame();
        PerformanceProfiler.start('Total');

        this.timer += dt;
        this.phaseTimer += dt;

        PerformanceProfiler.start('Logic');
        this.updatePhaseLogic(dt, currentFps);

        if (this.benchMode !== 'renderOnly') {
            // Entities Update
            PerformanceProfiler.start('Entities');
            this.entityManager.updateEnemies(dt, this.map.flowField);

            // Towers & Weapons
            for (const t of this.gameState.towers) {
                t.update(dt, this.collision.getValidGrid(this.gameState.enemies), this.map.flowField);
            }
            this.weaponSystem.update(
                this.gameState.towers,
                this.gameState.enemies,
                this.projectileSystem,
                dt,
                this.effects
            );
            PerformanceProfiler.count('entitiesUpdated', this.gameState.enemies.length);
            PerformanceProfiler.end('Entities');
        }
        PerformanceProfiler.end('Logic');

        if (this.benchMode !== 'renderOnly') {
            PerformanceProfiler.start('Collision');            // 2. Invalidate Grid Check
            this.collision.invalidateGrid();
            this.collision.update(this.projectileSystem.projectiles, this.gameState.enemies);
            PerformanceProfiler.end('Collision');

            PerformanceProfiler.start('Logic');
            this.projectileSystem.update(dt, this.effects);
            PerformanceProfiler.end('Logic');
        }

        if (this.benchMode !== 'logicOnly') {
            this.effects.update(dt);
        }

        PerformanceProfiler.end('Total');

        this.lastTotalEntities = this.gameState.enemies.length + this.projectileSystem.projectiles.length + this.effects.activeEffects.length;
        this.updateOverlay(currentFps);
    }

    private updatePhaseLogic(dt: number, currentFps: number) {
        switch (this.phase) {
            case TestPhase.WARMUP:
                if (this.phaseTimer > StressTestScene.PHASE_DURATION) this.setPhase(TestPhase.CPU_NAV_REBUILD);
                break;
            case TestPhase.CPU_NAV_REBUILD:
                // Rebuild heavy map every 0.5s
                if (Math.floor(this.phaseTimer * 2) > Math.floor((this.phaseTimer - dt) * 2)) {
                    PerformanceProfiler.start('Pathfinding');
                    this.randomizeWalls();
                    this.map.requestFlowFieldUpdate();
                    this.map.update(0);
                    PerformanceProfiler.end('Pathfinding');
                }
                // Force path update by updating flow field (already done above)
                if (this.phaseTimer > StressTestScene.PHASE_DURATION) this.setPhase(TestPhase.CPU_AGENT_UPDATE);
                break;
            case TestPhase.CPU_AGENT_UPDATE:
                // Just let them run
                if (this.phaseTimer > StressTestScene.PHASE_DURATION) this.setPhase(TestPhase.PHYSICS_CLUSTERED);
                break;
            case TestPhase.PHYSICS_CLUSTERED:
            case TestPhase.PHYSICS_UNIFORM:
                // Static bullets testing collision grid densely
                if (this.phaseTimer > StressTestScene.PHASE_DURATION) {
                    if (this.phase === TestPhase.PHYSICS_CLUSTERED) this.setPhase(TestPhase.PHYSICS_UNIFORM);
                    else this.setPhase(TestPhase.RENDER_BASELINE);
                }
                break;
            case TestPhase.RENDER_BASELINE:
                if (this.phaseTimer > StressTestScene.PHASE_DURATION) this.setPhase(TestPhase.RENDER_REALISTIC);
                break;
            case TestPhase.RENDER_REALISTIC:
                if (this.phaseTimer > StressTestScene.PHASE_DURATION) this.setPhase(TestPhase.RENDER_WORST_CACHED);
                break;
            case TestPhase.RENDER_WORST_CACHED:
            case TestPhase.RENDER_WORST_NOCACHE:
                // Spawn heavy particles each frame
                for (let i = 0; i < 50; i++) {
                    this.effects.add({
                        type: 'explosion',
                        x: this.rng.rangeFloat(0, this.game.width),
                        y: this.rng.rangeFloat(0, this.game.height),
                        life: 0.5,
                        color: '#ff4400',
                        size: 30
                    });
                }
                if (this.phaseTimer > StressTestScene.PHASE_DURATION) {
                    if (this.phase === TestPhase.RENDER_WORST_CACHED) this.setPhase(TestPhase.RENDER_WORST_NOCACHE);
                    else this.setPhase(TestPhase.RAMP_UP);
                }
                break;
            case TestPhase.RAMP_UP:
                this.updateRampUp(currentFps);
                break;
        }
    }

    private rampUpStep: number = 0;
    private medianBuffer: number[] = [];

    private updateRampUp(currentFps: number) {
        this.medianBuffer.push(currentFps);

        // Every 3 seconds, evaluate step
        if (this.phaseTimer > 3.0) {
            this.medianBuffer.sort((a, b) => a - b);
            const median = this.medianBuffer[Math.floor(this.medianBuffer.length / 2)];
            const p99 = this.medianBuffer[0]; // worst frame roughly

            if (median < 20 || p99 < 12 || this.rampUpStep > 15) {
                // FAILED CRITERIA OR MAX STEPS REACHED
                this.stableMaxEntities = this.gameState.enemies.length + this.gameState.towers.length + this.projectileSystem.projectiles.length;
                this.setPhase(TestPhase.FINISHED);
                return;
            }

            // SUCCESS -> Ramp up harder
            let addCount = 20;
            if (median > 55) addCount = 100;
            else if (median > 35) addCount = 50;

            this.spawnTestEnemies('SCOUT', addCount, 'uniform');

            this.phaseTimer = 0;
            this.medianBuffer = [];
            this.rampUpStep++;
            StressLogger.startPhase(`RAMP_UP_STEP_${this.rampUpStep}`);
        }
    }

    // --- Helpers ---

    private spawnTestEnemies(type: string, count: number, layout: 'uniform' | 'clustered') {
        for (let i = 0; i < count; i++) {
            const e = new Enemy();
            e.init({ health: 100000, speed: 50, path: this.map.waypoints }); // Invulnerable
            e.setType(type);

            if (layout === 'uniform') {
                e.x = this.rng.rangeFloat(0, this.game.width);
                e.y = this.rng.rangeFloat(0, this.game.height);
            } else {
                // Clustered in middle
                e.x = this.game.width / 2 + this.rng.rangeFloat(-20, 20);
                e.y = this.game.height / 2 + this.rng.rangeFloat(-20, 20);
            }
            this.gameState.enemies.push(e);
        }
    }

    private setupPhysicsProjectiles(count: number, layout: 'uniform' | 'clustered') {
        for (let i = 0; i < count; i++) {
            const p = new Projectile();
            const config = { speed: 0, damage: 0, effects: [{ type: 'splash', splashRadius: 100 }] };
            const px = layout === 'uniform' ? this.rng.rangeFloat(0, this.game.width) : this.game.width / 2;
            const py = layout === 'uniform' ? this.rng.rangeFloat(0, this.game.height) : this.game.height / 2;

            p.init(px, py, { x: px, y: py }, config as any);
            // Patch logic: it won't move, it will just constantly search for collision
            this.projectileSystem.projectiles.push(p);
        }
    }

    private randomizeWalls() {
        for (let y = 0; y < 20; y++) {
            for (let x = 0; x < 20; x++) {
                this.mapData.tiles[y][x] = this.rng.chance(0.2) ? 2 : 0; // 20% walls
                if (this.map.grid[y] && this.map.grid[y][x]) {
                    this.map.grid[y][x].type = this.mapData.tiles[y][x];
                }
            }
        }
    }

    private resetMapWalls() {
        for (let y = 0; y < 20; y++) {
            for (let x = 0; x < 20; x++) {
                this.mapData.tiles[y][x] = 0;
                if (this.map.grid[y] && this.map.grid[y][x]) this.map.grid[y][x].type = 0;
            }
        }
    }

    public draw(ctx: CanvasRenderingContext2D) {
        PerformanceProfiler.start('Render');

        const pCtx = this.getProfiledCtx(ctx);

        if (this.benchMode === 'logicOnly') {
            // Strictly NO canvas state churn
            pCtx.fillStyle = '#111';
            pCtx.fillRect(0, 0, this.game.width, this.game.height);

            pCtx.fillStyle = '#0f0';
            pCtx.font = '24px monospace';
            pCtx.textAlign = 'center';
            pCtx.fillText(`LOGIC ONLY MODE (${TestPhase[this.phase]})`, this.game.width / 2, this.game.height / 2);
            pCtx.fillText('Rendering disabled to measure purely CPU limits', this.game.width / 2, this.game.height / 2 + 30);

            PerformanceProfiler.end('Render');
            StressLogger.logFrame(this.lastDt, this.lastFps, this.lastTotalEntities);
            return;
        }

        pCtx.fillStyle = '#222';
        pCtx.fillRect(0, 0, this.game.width, this.game.height);

        if (this.phase === TestPhase.RENDER_BASELINE) {
            // Primitive drawing
            pCtx.fillStyle = '#ff0000';
            for (const e of this.gameState.enemies) {
                pCtx.fillRect(e.x - 10, e.y - 10, 20, 20);
            }
        } else {
            // Realistic or Heavy
            for (const e of this.gameState.enemies) {
                e.draw(pCtx);
            }
            this.projectileSystem.draw(pCtx);
        }

        PerformanceProfiler.start('DrawParticles');
        if (this.phase === TestPhase.RENDER_WORST_NOCACHE) {
            // Heavy logic
            for (const p of this.effects.activeEffects) {
                if (p.type === 'explosion') {
                    pCtx.save();
                    pCtx.globalCompositeOperation = 'lighter';
                    const grad = pCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                    grad.addColorStop(0, 'rgba(255,100,0,1)');
                    grad.addColorStop(1, 'rgba(255,0,0,0)');
                    pCtx.fillStyle = grad;
                    pCtx.beginPath();
                    pCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    pCtx.fill();
                    pCtx.restore();
                }
            }
        } else {
            this.effects.draw(); // Default realistic rendering
        }
        PerformanceProfiler.end('DrawParticles');

        PerformanceProfiler.end('Render');
        StressLogger.logFrame(this.lastDt, this.lastFps, this.lastTotalEntities);
    }

    private createOverlay() {
        this.uiOverlay = document.createElement('div');
        Object.assign(this.uiOverlay.style, {
            position: 'absolute', top: '10px', right: '10px',
            backgroundColor: 'rgba(0,0,0,0.85)', color: '#0f0',
            padding: '15px', fontFamily: 'monospace', whiteSpace: 'pre',
            border: '2px solid #0f0', borderRadius: '8px', zIndex: '9999'
        });
        document.body.appendChild(this.uiOverlay);
    }

    private updateOverlay(fps: number) {
        if (!this.uiOverlay || this.phase === TestPhase.FINISHED) return;
        const phaseName = TestPhase[this.phase];
        const entities = this.gameState.enemies.length;
        this.uiOverlay.innerText = `[STRESS V2] Phase: ${phaseName}\nTime: ${this.phaseTimer.toFixed(1)}s\nFPS: ${fps.toFixed(0)}\nEntities: ${entities}`;
    }

    private showReport() {
        if (!this.uiOverlay) return;
        const report = StressLogger.generateReport();
        const json = StressLogger.generateJson();

        this.uiOverlay.innerHTML = '';
        Object.assign(this.uiOverlay.style, { right: 'calc(50% - 250px)', top: '50px', width: '500px', textAlign: 'center' });

        const title = document.createElement('h2');
        title.innerText = "BENCHMARK COMPLETE";
        title.style.color = '#fff';
        this.uiOverlay.appendChild(title);

        const btnStyle = "background:#444; color:#fff; border:1px solid #888; padding:10px; margin:5px; cursor:pointer;";

        const createBtn = (text: string, action: () => void) => {
            const b = document.createElement('button');
            b.innerText = text; b.style.cssText = btnStyle; b.onclick = action; return b;
        };

        this.uiOverlay.appendChild(createBtn("COPY MARKDOWN", () => navigator.clipboard.writeText(report)));
        this.uiOverlay.appendChild(createBtn("COPY JSON", () => navigator.clipboard.writeText(json)));
        this.uiOverlay.appendChild(createBtn("EXIT", () => this.game.toMenu()));
    }
}
</file>

<file path="src/cards/CardType.ts">
/**
 * Base interfaces and types for the upgrade card system
 */

export interface ICardModifiers {
    damage?: number;              // Flat damage bonus
    damageMultiplier?: number;    // Multiplier for base damage (e.g., 0.30 = 30% of base)
    attackSpeedMultiplier?: number; // Multiplier for attack speed (0.85 = -15% speed, 1.0 = no change)
    range?: number;               // Flat range bonus
    rangeMultiplier?: number;     // Multiplier for range
    critChance?: number;          // Critical hit chance (0-1)
}

export interface ICardEffect {
    type: 'splash' | 'slow' | 'pierce' | 'explodeOnDeath' | 'chainSlowOnDeath' | 'spinup' | 'burn';

    // Splash effect properties
    splashRadius?: number;

    // Burn effect properties (Napalm evolution)
    burnDps?: number;           // Damage per second
    burnDuration?: number;      // Duration in seconds

    // Slow effect properties
    slowPower?: number;           // 0-1, where 0.2 = 20% slow
    slowDuration?: number;        // Frames
    damageToSlowed?: number;      // Damage multiplier for slowed enemies (1.2 = +20% damage)

    // Pierce properties
    pierceCount?: number;         // Number of enemies to pierce through
    pierceDamageLoss?: number;    // Damage loss per pierce (0.15 = 15% loss)

    // Explosion on death properties
    explosionDamagePercent?: number; // Percent of tower damage (0.5 = 50%)
    explosionRadius?: number;

    // Chain slow properties
    chainRadius?: number;

    // Spinup properties (Minigun mechanic)
    spinupDamagePerSecond?: number;   // Flat damage bonus per second of continuous fire
    spinupCritPerSecond?: number;     // Crit chance bonus per second (0.02 = 2%)
    spinupSpeedBonus?: number;        // NEW: Max speed bonus at full spinup (e.g. 1.5 = +150%)
    spinupSteps?: Array<{ threshold: number; damage: number }>; // For stepped damage (level 3)
    maxSpinupSeconds?: number;        // Maximum spinup time (7 seconds)
    overheatDuration?: number;        // Overheat lockout duration in frames (90 or 180)
    overheatExtensionWithIce?: number; // Bonus time before overheat when combined with Ice card (180 frames = 3 sec)

    // Legacy/Generic properties (fixing TS errors)
    radius?: number;
    dur?: number;
    power?: number;
}

export interface ICardVisualOverrides {
    projectileType?: string;    // Visual type: 'standard', 'fire', 'ice', 'sniper', 'minigun', 'split'
    projectileColor?: string;   // Hex color for projectile
    projectileSpeed?: number;   // Projectile travel speed
}

export interface IUpgradeCard {
    level: number;
    modifiers: ICardModifiers;
    effects: ICardEffect[];
    visualOverrides?: ICardVisualOverrides; // NEW: Data-driven visuals
}

/**
 * Merge multiple card modifiers into one
 */
export function mergeModifiers(modifiers: ICardModifiers[]): ICardModifiers {
    const result: ICardModifiers = {
        damage: 0,
        attackSpeedMultiplier: 1.0,
        range: 0,
        rangeMultiplier: 1.0,
        critChance: 0,
    };

    modifiers.forEach(mod => {
        result.damage! += mod.damage || 0;
        result.attackSpeedMultiplier! *= mod.attackSpeedMultiplier || 1.0;
        result.range! += mod.range || 0;
        result.rangeMultiplier! *= mod.rangeMultiplier || 1.0;
        result.critChance! = Math.max(result.critChance!, mod.critChance || 0);
    });

    return result;
}

/**
 * Merge multiple card effects into one array
 */
export function mergeEffects(effectArrays: ICardEffect[][]): ICardEffect[] {
    const result: ICardEffect[] = [];
    effectArrays.forEach(effects => {
        result.push(...effects);
    });
    return result;
}
</file>

<file path="src/cards/MinigunCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Minigun Card Upgrades (BUFFED)
 * 
 * Role: Sustained DPS monster, rewards commitment
 * Trade-off: Needs ramp-up time, vulnerable to overheat
 * 
 * Level 1: 55% base, x2.65 speed, +4 DPS/s, 5s to overheat
 * Level 2: 65% base, x2.75 speed, +5 DPS/s, +2% crit/s, 6s overheat
 * Level 3: 80% base, stepped damage up to +40, extended overheat
 */
export const MINIGUN_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damageMultiplier: 0.55,       // Buffed from 0.50
            attackSpeedMultiplier: 2.65,
        },
        effects: [
            {
                type: 'spinup',
                spinupDamagePerSecond: 4,  // Buffed from 3
                spinupSpeedBonus: 1.5,     // NEW: Ramps up speed by +1.5x
                maxSpinupSeconds: 5,
                overheatDuration: 1.2,     // Slightly reduced from 1.5
                overheatExtensionWithIce: 2.5,
            }
        ],
        visualOverrides: {
            projectileType: 'minigun',
            projectileColor: '#fff',
            projectileSpeed: 720,
        }
    },
    2: {
        level: 2,
        modifiers: {
            damageMultiplier: 0.65,       // Buffed from 0.60
            attackSpeedMultiplier: 2.80,  // Buffed from 2.75
        },
        effects: [
            {
                type: 'spinup',
                spinupDamagePerSecond: 5,  // Buffed from 3
                spinupCritPerSecond: 0.025, // Buffed from 0.02
                spinupSpeedBonus: 1.8,      // NEW: +1.8x speed at max
                maxSpinupSeconds: 6,       // Extended from 5
                overheatDuration: 1.0,     // Reduced from 1.5
                overheatExtensionWithIce: 2.5,
            }
        ]
    },
    3: {
        level: 3,
        modifiers: {
            damageMultiplier: 0.80,       // Buffed from 0.75
            attackSpeedMultiplier: 2.75,  // Buffed from 2.65
        },
        effects: [
            {
                type: 'spinup',
                spinupSteps: [
                    { threshold: 1, damage: 6 },   // Buffed
                    { threshold: 2, damage: 14 },  // Buffed
                    { threshold: 3, damage: 22 },  // Buffed
                    { threshold: 4, damage: 32 },  // Buffed
                    { threshold: 5, damage: 45 },  // Buffed from 30
                ],
                spinupCritPerSecond: 0.03,
                spinupSpeedBonus: 2.0,     // NEW: +2.0x speed at max
                maxSpinupSeconds: 6,       // Extended
                overheatDuration: 1.2,     // Reduced
                overheatExtensionWithIce: 3,
            }
        ]
    }
};
</file>

<file path="src/EventBus.ts">
/**
 * Event Bus Module
 * Decouples game systems using the Observer pattern.
 */

export interface EventPayloadMap {
    // Economy
    MONEY_CHANGED: number;
    LIVES_CHANGED: number;

    // Wave
    WAVE_STARTED: { wave: number; name?: string };
    WAVE_COMPLETED: number;

    // Game State
    GAME_OVER: number;
    GAME_RESTART: void;
    TOGGLE_PAUSE: boolean;

    // Entities
    ENEMY_IMMUNE: { x: number; y: number };
    ENEMY_DIED: { enemy: any }; // Using any to avoid circular dependency with Enemy for now, or use interface
    ENEMY_SPAWNED: string;
    SPAWN_PUDDLE: { x: number; y: number };
    PROJECTILE_SPAWNED: { x: number; y: number; target: any; stats: any };

    // Boss Mechanics
    ENEMY_SPLIT: { enemy: any; threshold: number };
    ENEMY_DEATH_SPAWN: { enemy: any; spawns: string[] };

    // Cards (Phase 6.C)
    CARD_DROPPED: { card: any; x: number; y: number; actionId?: string }; // card is ICard
}

export type EventCallback<T> = (data: T) => void;

interface IEventSubscription {
    id: number;
    event: string;
    callback: EventCallback<any>;
}

export class EventBus {
    private static instance: EventBus;
    private subscribers: Map<string, IEventSubscription[]> = new Map();
    private nextId: number = 0;

    private constructor() { }

    public static getInstance(): EventBus {
        if (!EventBus.instance) {
            EventBus.instance = new EventBus();
        }
        return EventBus.instance;
    }

    /**
     * Subscribe to an event
     * @returns Unsubscribe function
     */
    public on<K extends keyof EventPayloadMap>(event: K, callback: EventCallback<EventPayloadMap[K]>): () => void {
        const id = this.nextId++;
        if (!this.subscribers.has(event)) {
            this.subscribers.set(event, []);
        }
        this.subscribers.get(event)!.push({ id, event, callback });

        // Return unsubscribe function
        return () => this.off(id);
    }

    /**
     * Unsubscribe using the ID (Deprecated, use returned function from on())
     */
    public off(id: number): void {
        // Optimized: iterate with for loop instead of forEach
        const events = this.subscribers.keys();
        for (const event of events) {
            const subs = this.subscribers.get(event)!;
            for (let i = 0; i < subs.length; i++) {
                if (subs[i].id === id) {
                    subs.splice(i, 1);
                    return; // Found and removed, exit early
                }
            }
        }
    }

    /**
     * Emit an event with data
     */
    public emit<K extends keyof EventPayloadMap>(event: K, data: EventPayloadMap[K]): void {
        const subs = this.subscribers.get(event);
        if (!subs) return;
        // Use for loop instead of forEach for hot path
        // Clone array to avoid issues if subscribers remove themselves during emit
        const safeSubs = [...subs];
        for (let i = 0; i < safeSubs.length; i++) {
            safeSubs[i].callback(data);
        }
    }

    /**
     * Clear all subscribers (useful for scene transitions)
     */
    public clear(): void {
        this.subscribers.clear();
    }
}

// Define Event Constants for type safety type feeling
// Legacy Events object kept for reference if needed, but prefer string literals with types
export const Events = {
    MONEY_CHANGED: 'MONEY_CHANGED',
    LIVES_CHANGED: 'LIVES_CHANGED',
    WAVE_STARTED: 'WAVE_STARTED',
    WAVE_COMPLETED: 'WAVE_COMPLETED',
    GAME_OVER: 'GAME_OVER',
    GAME_RESTART: 'GAME_RESTART',
    TOGGLE_PAUSE: 'TOGGLE_PAUSE',
    ENEMY_IMMUNE: 'ENEMY_IMMUNE',
    ENEMY_DIED: 'ENEMY_DIED',
    ENEMY_SPAWNED: 'ENEMY_SPAWNED',
    SPAWN_PUDDLE: 'SPAWN_PUDDLE',
    PROJECTILE_SPAWNED: 'PROJECTILE_SPAWNED',
    ENEMY_SPLIT: 'ENEMY_SPLIT',
    ENEMY_DEATH_SPAWN: 'ENEMY_DEATH_SPAWN',
    CARD_DROPPED: 'CARD_DROPPED'
} as const;
</file>

<file path="src/ForgeSystem.ts">
import { IGameScene } from './scenes/IGameScene';
import { CardSystem, ICard } from './CardSystem';
import { CONFIG } from './Config';
import { getEvolutionChoice, IEvolutionChoice, IEvolutionPath } from './cards';

export class ForgeSystem {
    private scene: IGameScene;
    private slotEls: HTMLElement[];

    public forgeSlots: (ICard | null)[] = [null, null];
    public isForging: boolean = false;

    // Evolution modal elements
    private evolutionModal: HTMLElement | null = null;
    private pendingForgeCallback: ((evolutionPath: string) => void) | null = null;

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.slotEls = [document.getElementById('forge-slot-0')!, document.getElementById('forge-slot-1')!];
        this.initEvolutionModal();
    }

    /**
     * Initialize the evolution choice modal
     */
    private initEvolutionModal() {
        this.evolutionModal = document.getElementById('evolution-modal');
        if (!this.evolutionModal) {
            // Create modal if it doesn't exist yet
            this.createEvolutionModal();
        }
    }

    private createEvolutionModal() {
        const modal = document.createElement('div');
        modal.id = 'evolution-modal';
        modal.innerHTML = `
            <div class="evo-container">
                <div class="evo-title">‚öîÔ∏è –≠–í–û–õ–Æ–¶–ò–Ø ‚öîÔ∏è</div>
                <div class="evo-subtitle">–í—ã–±–µ—Ä–∏—Ç–µ –ø—É—Ç—å —Ä–∞–∑–≤–∏—Ç–∏—è</div>
                <div class="evo-paths">
                    <div class="evo-path" data-path="A">
                        <div class="evo-path-icon" id="evo-icon-a"></div>
                        <div class="evo-path-name" id="evo-name-a"></div>
                        <div class="evo-path-desc" id="evo-desc-a"></div>
                    </div>
                    <div class="evo-path" data-path="B">
                        <div class="evo-path-icon" id="evo-icon-b"></div>
                        <div class="evo-path-name" id="evo-name-b"></div>
                        <div class="evo-path-desc" id="evo-desc-b"></div>
                    </div>
                </div>
                <button class="evo-cancel-btn">–û—Ç–º–µ–Ω–∞</button>
            </div>
        `;
        document.body.appendChild(modal);
        this.evolutionModal = modal;

        // Event listeners
        const pathA = modal.querySelector('[data-path="A"]') as HTMLElement;
        const pathB = modal.querySelector('[data-path="B"]') as HTMLElement;
        const cancelBtn = modal.querySelector('.evo-cancel-btn') as HTMLElement;

        pathA?.addEventListener('click', () => this.selectEvolutionPath('A'));
        pathB?.addEventListener('click', () => this.selectEvolutionPath('B'));
        cancelBtn?.addEventListener('click', () => this.cancelEvolution());

        // Close on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.evolutionModal?.classList.contains('show')) {
                this.cancelEvolution();
            }
        });
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –æ—Ç–ø—É—Å—Ç–∏–ª–∏ –ª–∏ –º—ã—à—å –Ω–∞–¥ —Å–ª–æ—Ç–æ–º –∫—É–∑–Ω–∏—Ü—ã.
     */
    public tryDropCard(mouseX: number, mouseY: number, card: ICard): boolean {
        if (this.isForging) return false;

        for (let i = 0; i < this.slotEls.length; i++) {
            const rect = this.slotEls[i].getBoundingClientRect();

            if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) {
                if (this.forgeSlots[i] !== null) {
                    return false;
                }
                this.putInForgeSlot(i, card);
                return true;
            }
        }
        return false;
    }

    /**
     * Check if forge is possible
     * Now also checks evolutionPath compatibility
     */
    public canForge(): boolean {
        const c1 = this.forgeSlots[0];
        const c2 = this.forgeSlots[1];

        if (!c1 || !c2) return false;
        if (c1.type.id !== c2.type.id) return false;
        if (c1.level !== c2.level) return false;
        if (c1.level >= 3) return false;

        // Check evolution path compatibility (cross-breeding prevention)
        const evo1 = c1.evolutionPath || 'classic';
        const evo2 = c2.evolutionPath || 'classic';
        if (evo1 !== evo2) {
            return false;
        }

        return true;
    }

    /**
     * Get reason why forging is not possible (for UI feedback)
     */
    public getForgeBlockReason(): string | null {
        const c1 = this.forgeSlots[0];
        const c2 = this.forgeSlots[1];

        if (!c1 || !c2) return null;
        if (c1.type.id !== c2.type.id) return '–†–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –∫–∞—Ä—Ç';
        if (c1.level !== c2.level) return '–†–∞–∑–Ω—ã–µ —É—Ä–æ–≤–Ω–∏';
        if (c1.level >= 3) return '–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å';

        const evo1 = c1.evolutionPath || 'classic';
        const evo2 = c2.evolutionPath || 'classic';
        if (evo1 !== evo2) {
            return '‚ö†Ô∏è –ù–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ —ç—Å—Å–µ–Ω—Ü–∏–∏!';
        }

        return null;
    }

    public putInForgeSlot(slotIdx: number, card: ICard) {
        this.scene.cardSys.removeCardFromHand(card);
        this.forgeSlots[slotIdx] = card;
        this.render();
        this.scene.ui.update();
    }

    public returnFromForge(slotIdx: number) {
        const card = this.forgeSlots[slotIdx];
        if (card) {
            this.forgeSlots[slotIdx] = null;
            this.scene.cardSys.hand.push(card);
            this.scene.cardSys.render();
            this.render();
            this.scene.ui.update();
        }
    }

    /**
     * Try to start forging - may show evolution choice
     */
    public tryForge() {
        if (!this.canForge()) {
            const reason = this.getForgeBlockReason();
            if (reason) {
                this.scene.showFloatingText(reason, 300, 500, 'red');
            }
            return;
        }

        const card = this.forgeSlots[0]!;
        const cost = card.level === 1
            ? CONFIG.ECONOMY.FORGE_COST_LVL1
            : CONFIG.ECONOMY.FORGE_COST_LVL2;

        if (this.scene.money < cost) {
            this.scene.showFloatingText('–ù—É–∂–Ω–æ –±–æ–ª—å—à–µ –∑–æ–ª–æ—Ç–∞!', 500, 500, 'red');
            return;
        }

        // Check if evolution choice is available
        const evolutionChoice = getEvolutionChoice(
            card.type.id,
            card.level,
            card.evolutionPath
        );

        if (evolutionChoice) {
            // Show evolution choice modal
            this.showEvolutionChoice(evolutionChoice, (chosenPath) => {
                this.performForge(chosenPath, cost);
            });
        } else {
            // Classic forge (Lv1 cards without evolution system configured)
            this.performForge(card.evolutionPath || 'classic', cost);
        }
    }

    /**
     * Show the evolution choice modal
     */
    private showEvolutionChoice(choice: IEvolutionChoice, callback: (path: string) => void) {
        if (!this.evolutionModal) return;

        // Store callback and choice data
        this.pendingForgeCallback = callback;
        this.evolutionModal.dataset.pathA = choice.pathA.id;
        this.evolutionModal.dataset.pathB = choice.pathB.id;

        // Update UI
        const iconA = document.getElementById('evo-icon-a');
        const nameA = document.getElementById('evo-name-a');
        const descA = document.getElementById('evo-desc-a');
        const iconB = document.getElementById('evo-icon-b');
        const nameB = document.getElementById('evo-name-b');
        const descB = document.getElementById('evo-desc-b');

        if (iconA) iconA.textContent = choice.pathA.icon;
        if (nameA) nameA.textContent = choice.pathA.name;
        if (descA) descA.textContent = choice.pathA.description;
        if (iconB) iconB.textContent = choice.pathB.icon;
        if (nameB) nameB.textContent = choice.pathB.name;
        if (descB) descB.textContent = choice.pathB.description;

        // Show modal
        this.evolutionModal.classList.add('show');
    }

    /**
     * Handle evolution path selection
     */
    private selectEvolutionPath(pathKey: 'A' | 'B') {
        if (!this.evolutionModal || !this.pendingForgeCallback) return;

        const pathId = pathKey === 'A'
            ? this.evolutionModal.dataset.pathA
            : this.evolutionModal.dataset.pathB;

        // Hide modal
        this.evolutionModal.classList.remove('show');

        // Execute callback with chosen path
        if (pathId) {
            this.pendingForgeCallback(pathId);
        }
        this.pendingForgeCallback = null;
    }

    /**
     * Cancel evolution choice
     */
    private cancelEvolution() {
        if (!this.evolutionModal) return;
        this.evolutionModal.classList.remove('show');
        this.pendingForgeCallback = null;
    }

    /**
     * Actually perform the forge with chosen evolution path
     */
    private performForge(evolutionPath: string, cost: number) {
        if (!this.scene.spendMoney(cost)) {
            return;
        }
        this.isForging = true;

        const forgeSlot0 = this.slotEls[0];
        const forgeSlot1 = this.slotEls[1];
        const canvas = this.scene.game.canvas;
        const canvasRect = canvas.getBoundingClientRect();

        if (forgeSlot0) forgeSlot0.classList.add('forging');
        if (forgeSlot1) forgeSlot1.classList.add('forging');

        let effectX = 200;
        let effectY = canvas.height - 300;

        if (forgeSlot0 && forgeSlot1) {
            const rect0 = forgeSlot0.getBoundingClientRect();
            const rect1 = forgeSlot1.getBoundingClientRect();
            const centerX = (rect0.left + rect1.right) / 2;
            const centerY = (rect0.top + rect0.bottom) / 2;
            effectX = (centerX - canvasRect.left) * (canvas.width / canvasRect.width);
            effectY = (centerY - canvasRect.top) * (canvas.height / canvasRect.height);
        }

        // Spawn particles during forge animation
        const particleInterval = setInterval(() => {
            for (let i = 0; i < 5; i++) {
                this.scene.effects.add({
                    type: 'particle',
                    x: effectX + (Math.random() - 0.5) * 80,
                    y: effectY + (Math.random() - 0.5) * 50,
                    vx: (Math.random() - 0.5) * 360,
                    vy: -(Math.random() * 240 + 60),
                    life: 0.5 + Math.random() * 0.3,
                    radius: Math.random() * 4 + 2,
                    color: Math.random() > 0.5 ? '#ff9800' : '#ffeb3b',
                });
            }
        }, 50);

        // Forging complete
        setTimeout(() => {
            clearInterval(particleInterval);

            if (forgeSlot0) forgeSlot0.classList.remove('forging');
            if (forgeSlot1) forgeSlot1.classList.remove('forging');

            const c1 = this.forgeSlots[0]!;
            const newLevel = c1.level + 1;

            // Find card type key
            let typeKey = 'FIRE';
            for (const k in CONFIG.CARD_TYPES) {
                if (CONFIG.CARD_TYPES[k].id === c1.type.id) {
                    typeKey = k;
                    break;
                }
            }

            this.forgeSlots = [null, null];
            this.isForging = false;

            // Add upgraded card with evolution path
            this.scene.cardSys.addCardWithEvolution(typeKey, newLevel, evolutionPath);

            // Enhanced completion effects
            this.scene.effects.add({
                type: 'explosion',
                x: effectX,
                y: effectY,
                radius: 60,
                life: 0.6,
                color: '#ffd700',
            });

            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                this.scene.effects.add({
                    type: 'particle',
                    x: effectX,
                    y: effectY,
                    vx: Math.cos(angle) * 300,
                    vy: Math.sin(angle) * 300,
                    life: 0.65,
                    radius: 4,
                    color: '#ffd700',
                });
            }

            this.scene.showFloatingText('‚öíÔ∏è FORGED!', effectX, effectY - 30, 'gold');

            this.render();
            this.scene.ui.update();

        }, 800);
    }

    public render() {
        this.slotEls.forEach((el, idx) => {
            el.innerHTML = '';
            const slotCard = this.forgeSlots[idx];
            if (slotCard) {
                el.classList.remove('slot-empty');
                const cardEl = CardSystem.createCardElement(slotCard);
                cardEl.onclick = () => this.returnFromForge(idx);
                el.appendChild(cardEl);
            } else {
                el.classList.add('slot-empty');
            }
        });
    }

    public update() {
        // No per-frame update needed for now
    }
}
</file>

<file path="src/SpatialGrid.ts">
/**
 * Spatial Grid for efficient proximity queries
 * Reduces collision detection from O(P √ó E) to O(P √ó avgCandidates)
 * 
 * PERF V4.0: Refactored to use Flat 1D Array instead of Map<string, T[]>
 * - Eliminates string key allocation ("x,y") every frame
 * - Uses pre-allocated cell arrays that are cleared but not recreated
 * - Zero GC pressure during gameplay
 */

export interface IGridEntity {
    x: number;
    y: number;
}

import { PerformanceProfiler } from './utils/PerformanceProfiler';

export class SpatialGrid<T extends IGridEntity> {
    public readonly cellSize: number;
    private cols: number;
    private rows: number;
    // PERF: Flat 1D array instead of Map<string, T[]>
    private cells: T[][];

    public size: number = 0;

    constructor(worldWidth: number, worldHeight: number, cellSize: number = 128) {
        this.cellSize = cellSize;
        this.cols = Math.ceil(worldWidth / cellSize);
        this.rows = Math.ceil(worldHeight / cellSize);

        // Pre-allocate ALL cells at construction time (ZERO allocation in runtime)
        const totalCells = this.cols * this.rows;
        this.cells = new Array(totalCells);
        for (let i = 0; i < totalCells; i++) {
            this.cells[i] = [];
        }
    }

    /**
     * Clear all entities from the grid
     * PERF: Does NOT deallocate arrays - just resets length to 0
     */
    public clear(): void {
        this.size = 0;
        for (let i = 0; i < this.cells.length; i++) {
            this.cells[i].length = 0;
        }
    }

    /**
     * Get flat index from column and row
     * PERF: No string allocation
     */
    private getIndex(col: number, row: number): number {
        return col + row * this.cols;
    }

    /**
     * Get cell index for a world position
     * PERF: Returns -1 for out-of-bounds (no crash, no string)
     */
    private getCellIndex(x: number, y: number): number {
        const col = Math.floor(x / this.cellSize);
        const row = Math.floor(y / this.cellSize);
        if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) {
            return -1;
        }
        return this.getIndex(col, row);
    }

    /**
     * Register an entity in the grid based on its position
     */
    public register(entity: T): void {
        const idx = this.getCellIndex(entity.x, entity.y);
        if (idx >= 0) {
            this.cells[idx].push(entity);
            this.size++;
        }
    }

    /**
     * Get all entities within radius of the given position
     * Only checks cells that could contain entities within the radius
     */
    // PERF: Shared buffer for queries to avoid allocation
    private queryBuffer: T[] = [];

    /**
     * Get all entities within radius of the given position
     * Uses a shared buffer to avoid GC. CAUTION: Result is valid only until next call.
     */
    public getNearby(x: number, y: number, radius: number): T[] {
        PerformanceProfiler.count('gridQueries', 1);
        this.queryBuffer.length = 0; // Clear without allocation

        // Calculate which cells to check
        const minCol = Math.max(0, Math.floor((x - radius) / this.cellSize));
        const maxCol = Math.min(this.cols - 1, Math.floor((x + radius) / this.cellSize));
        const minRow = Math.max(0, Math.floor((y - radius) / this.cellSize));
        const maxRow = Math.min(this.rows - 1, Math.floor((y + radius) / this.cellSize));

        // Check all relevant cells
        for (let col = minCol; col <= maxCol; col++) {
            for (let row = minRow; row <= maxRow; row++) {
                const cell = this.cells[this.getIndex(col, row)];
                for (let i = 0; i < cell.length; i++) {
                    this.queryBuffer.push(cell[i]);
                }
            }
        }

        return this.queryBuffer;
    }

    /**
     * Iterator pattern - NO ARRAY ALLOCATION
     * PERF: Use this when you don't need to store the results
     */
    public forEachNearby(x: number, y: number, radius: number, callback: (entity: T) => void): void {
        const minCol = Math.max(0, Math.floor((x - radius) / this.cellSize));
        const maxCol = Math.min(this.cols - 1, Math.floor((x + radius) / this.cellSize));
        const minRow = Math.max(0, Math.floor((y - radius) / this.cellSize));
        const maxRow = Math.min(this.rows - 1, Math.floor((y + radius) / this.cellSize));

        for (let col = minCol; col <= maxCol; col++) {
            for (let row = minRow; row <= maxRow; row++) {
                const cell = this.cells[this.getIndex(col, row)];
                for (let i = 0; i < cell.length; i++) {
                    callback(cell[i]);
                }
            }
        }
    }

    /**
     * Get all entities within radius of the given position
     * Fills the provided buffer to avoid allocation.
     * ZERO GC method.
     * @param x Center X
     * @param y Center Y
     * @param radius Search radius
     * @param outBuffer Buffer to fill (will be cleared)
     * @returns Number of entities found
     */
    public queryInRadius(x: number, y: number, radius: number, outBuffer: T[]): number {
        PerformanceProfiler.count('gridQueries', 1);
        outBuffer.length = 0;

        // PADDING: Add extra range to catch large units (e.g. Bosses) whose center
        // might be in a neighbor cell but whose body overlaps into range.
        const PADDING = 64;
        const searchRadius = radius + PADDING;

        const minCol = Math.max(0, Math.floor((x - searchRadius) / this.cellSize));
        const maxCol = Math.min(this.cols - 1, Math.floor((x + searchRadius) / this.cellSize));
        const minRow = Math.max(0, Math.floor((y - searchRadius) / this.cellSize));
        const maxRow = Math.min(this.rows - 1, Math.floor((y + searchRadius) / this.cellSize));

        for (let col = minCol; col <= maxCol; col++) {
            for (let row = minRow; row <= maxRow; row++) {
                const cell = this.cells[this.getIndex(col, row)];
                // Standard for loop for performance
                for (let i = 0; i < cell.length; i++) {
                    outBuffer.push(cell[i]);
                }
            }
        }

        return outBuffer.length;
    }

    /**
     * Debug: Get grid statistics
     */
    public getStats(): { totalCells: number; occupiedCells: number; totalEntities: number } {
        let totalEntities = 0;
        let occupiedCells = 0;

        for (let i = 0; i < this.cells.length; i++) {
            if (this.cells[i].length > 0) {
                occupiedCells++;
                totalEntities += this.cells[i].length;
            }
        }

        return {
            totalCells: this.cols * this.rows,
            occupiedCells,
            totalEntities,
        };
    }
}
</file>

<file path="src/systems/NotificationSystem.ts">
import { Game } from '../Game';
import { EffectSystem } from '../EffectSystem';
import { EventBus, Events } from '../EventBus';
import { SoundManager, SoundPriority } from '../SoundManager';

/**
 * NotificationSystem - Visual notifications for game events
 * Wave start, wave clear, boss spawn, etc.
 */
export class NotificationSystem {
    private effects: EffectSystem;
    private game: Game;

    // Active notifications queue
    private notifications: INotification[] = [];

    private unsubs: (() => void)[] = [];

    constructor(effects: EffectSystem, game: Game) {
        this.effects = effects;
        this.game = game;

        this.initSubscriptions();
    }

    private initSubscriptions() {
        const bus = EventBus.getInstance();

        this.unsubs.push(bus.on(Events.WAVE_STARTED, (data: { wave: number; name?: string }) => {
            this.showWaveStart(data.wave, data.name);
        }));

        this.unsubs.push(bus.on(Events.WAVE_COMPLETED, (wave: number) => {
            this.showWaveClear(wave);
        }));

        this.unsubs.push(bus.on(Events.ENEMY_IMMUNE, (data: { x: number; y: number }) => {
            this.showImmune(data.x, data.y);
        }));
    }

    public destroy() {
        this.unsubs.forEach(u => u());
        this.unsubs = [];
    }

    /**
     * Wave Start notification - big zoom-in text
     */
    public showWaveStart(waveNum: number, waveName?: string) {
        const cx = this.game.width / 2;
        const cy = this.game.height / 2;

        // Main wave text with zoom effect
        this.effects.add({
            type: 'text',
            text: `WAVE ${waveNum}`,
            x: cx,
            y: cy,
            life: 1.5, // 90 frames
            color: '#fff',
            fontSize: 48,
            vy: 0
        });

        // Subtitle
        this.effects.add({
            type: 'text',
            text: waveName || 'INCOMING',
            x: cx,
            y: cy + 50,
            life: 1.1, // 70 frames
            color: '#ff5722',
            fontSize: 24,
            vy: 0
        });

        // Screen flash (red tint)
        this.effects.add({
            type: 'screen_flash',
            x: 0,
            y: 0,
            life: 25,
            flashColor: 'rgba(255, 50, 50, '
        });

        // Sound
        SoundManager.play('boss_spawn', SoundPriority.HIGH);
    }

    /**
     * Wave Clear notification - gold flash + confetti
     */
    public showWaveClear(waveNum: number) {
        const cx = this.game.width / 2;
        const cy = this.game.height / 2;

        // Victory text
        this.effects.add({
            type: 'text',
            text: 'WAVE CLEARED!',
            x: cx,
            y: cy - 30,
            life: 1.3, // 80 frames
            color: '#ffd700',
            fontSize: 36,
            vy: -30 // -0.5 * 60
        });

        // Gold screen flash
        this.effects.add({
            type: 'screen_flash',
            x: 0,
            y: 0,
            life: 20,
            flashColor: 'rgba(255, 215, 0, '
        });

        // Confetti particles
        this.spawnConfetti(cx, cy);

        // Sound
        SoundManager.play('click', SoundPriority.HIGH);
    }

    /**
     * Boss Spawn notification - dramatic darkening + spotlight
     */
    public showBossSpawn(bossName: string, x: number, y: number) {
        const cx = this.game.width / 2;
        const cy = this.game.height / 2;

        // Warning text
        this.effects.add({
            type: 'text',
            text: '‚ö†Ô∏è BOSS ‚ö†Ô∏è',
            x: cx,
            y: cy - 100,
            life: 2.0, // 120
            color: '#ff0000',
            fontSize: 42,
            vy: 0
        });

        // Boss name
        this.effects.add({
            type: 'text',
            text: bossName.toUpperCase(),
            x: cx,
            y: cy - 50,
            life: 1.6, // 100
            color: '#fff',
            fontSize: 28,
            vy: 0
        });

        // Dark flash
        this.effects.add({
            type: 'screen_flash',
            x: 0,
            y: 0,
            life: 40,
            flashColor: 'rgba(0, 0, 0, '
        });

        // Sound
        SoundManager.play('boss_spawn', SoundPriority.HIGH);
    }

    /**
     * Spawn confetti particles
     */
    private spawnConfetti(cx: number, cy: number) {
        const colors = ['#ffd700', '#ff5722', '#4caf50', '#2196f3', '#e91e63'];

        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = (2 + Math.random() * 4) * 60; // Convert to px/sec
            const color = colors[Math.floor(Math.random() * colors.length)];

            this.effects.add({
                type: 'particle',
                x: cx + (Math.random() - 0.5) * 100,
                y: cy,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 120, // Bias upward (2 * 60)
                life: 0.6 + Math.random() * 0.5, // 40-70 frames
                color: color,
                radius: 3 + Math.random() * 3
            });
        }
    }

    /**
     * Custom notification (for special events)
     */
    public showCustom(text: string, color: string = '#fff', duration: number = 60) {
        const cx = this.game.width / 2;
        const cy = this.game.height / 2;

        this.effects.add({
            type: 'text',
            text: text,
            x: cx,
            y: cy,
            life: duration,
            color: color,
            fontSize: 32,
            vy: -0.5
        });
    }

    public showImmune(x: number, y: number) {
        this.effects.add({
            type: 'text',
            text: 'IMMUNE',
            x: x,
            y: y - 20, // Slight offset up
            life: 0.6,
            color: '#ffd700', // Gold
            fontSize: 16, // Smaller than boss text
            vy: -50 // Float up fast
        });
    }
}

interface INotification {
    type: 'wave_start' | 'wave_clear' | 'boss_spawn' | 'custom';
    text: string;
    life: number;
    maxLife: number;
}
</file>

<file path="src/systems/ProjectileSystem.ts">
import { Projectile } from '../Projectile';
import { EffectSystem } from '../EffectSystem';

export class ProjectileSystem {
    // Stack-based pooling
    // 'pool' contains inactive projectiles ready for reuse
    // 'active' contains currently live projectiles
    private pool: Projectile[] = [];
    private active: Projectile[] = [];

    // Getter for other systems (Collision, etc)
    public get projectiles(): Projectile[] {
        return this.active;
    }

    public spawn(x: number, y: number, target: { x: number, y: number }, stats: any): Projectile {
        // 1. Pop from pool or create new (O(1))
        const p = this.pool.pop() || new Projectile();

        // 2. Init
        p.init(x, y, target, stats);

        // 3. Add to active list
        this.active.push(p);

        return p;
    }

    public createExplosion(x: number, y: number, radius: number, damage: number, friendlyFire: boolean = false) {
        // DEPRECATED/LEGACY: 
        // Logic usually handled by CollisionSystem triggers. 
        // If this is still used for direct spawning (e.g. from debug or abilities), 
        // we spawn a projectile that dies instantly.

        const p = this.spawn(x, y, { x, y }, {
            dmg: damage,
            speed: 0,
            color: '#76ff03',
            effects: [],
            pierce: 999,
            projectileType: 'explosion',
            explosionRadius: radius,
            explosionDamage: damage,
            explodeOnDeath: true
        });

        p.life = 0;
        (p as any).friendlyFire = friendlyFire;
        return p;
    }

    public update(dt: number, effects: EffectSystem) {
        // Iterate active projectiles
        for (let i = 0; i < this.active.length; i++) {
            const p = this.active[i];

            p.update(dt); // Update logic (physics only)

            if (p.alive) {
                // --- TRAIL EFFECTS (Decoupled from Projectile) ---
                // Spawn trail particles approx every ~0.06s (15 fps density)
                if (Math.random() < dt * 15) {
                    this.spawnTrail(p, effects);
                }
            } else {
                // Remove from active (Swap & Pop)
                this.remove(i);

                // Decrement i because we swapped a new element into this slot
                i--;
            }
        }
    }

    private spawnTrail(p: Projectile, effects: EffectSystem) {
        const type = p.projectileType || 'standard';

        // Fire Trail (Smoke/Embers)
        if (type === 'fire') {
            effects.add({
                type: 'particle',
                x: p.x + (Math.random() - 0.5) * 4,
                y: p.y + (Math.random() - 0.5) * 4,
                vx: -p.vx * 0.2 + (Math.random() - 0.5) * 60,
                vy: -p.vy * 0.2 + (Math.random() - 0.5) * 60,
                life: 0.25 + Math.random() * 0.15, // ~15-25 frames
                radius: 2 + Math.random() * 2,
                color: Math.random() > 0.5 ? 'rgba(255, 100, 0, 0.5)' : 'rgba(100, 100, 100, 0.3)'
            });
        }
        // Ice Trail (Snow/Sparkle)
        else if (type === 'ice') {
            effects.add({
                type: 'particle',
                x: p.x,
                y: p.y,
                vx: (Math.random() - 0.5) * 30,
                vy: (Math.random() - 0.5) * 30,
                life: 0.35, // 20 frames
                radius: 1.5,
                color: '#e1f5fe'
            });
        }
        // Level 3 Trail (Glow) - Generic for all high levels
        if (p.towerLevel >= 3) {
            effects.add({
                type: 'particle',
                x: p.x,
                y: p.y,
                vx: 0,
                vy: 0,
                life: 0.16, // 10 frames
                radius: 2,
                color: p.color
            });
        }
    }

    private remove(index: number) {
        const p = this.active[index];

        // 1. Reset state completely
        p.reset();

        // 2. Return to pool
        this.pool.push(p);

        // 3. Swap Remove from active (Safe swap & pop)
        const last = this.active[this.active.length - 1];
        this.active[index] = last;
        this.active.pop();
    }

    public draw(ctx: CanvasRenderingContext2D) {
        // Draw all active
        for (let i = 0; i < this.active.length; i++) {
            this.active[i].draw(ctx);
        }
    }

    public clear() {
        // Move all active to pool
        while (this.active.length > 0) {
            const p = this.active.pop();
            if (p) {
                p.reset(); // Crucial: Reset before pooling
                p.alive = false;
                this.pool.push(p);
            }
        }
    }
}
</file>

<file path="src/BestiarySystem.ts">
import { IGameScene } from './scenes/IGameScene';
import { BestiaryUI } from './ui/bestiary/BestiaryUI';
import { UIUtils } from './UIUtils';
import { EventBus, Events } from './EventBus';

export class BestiarySystem {
    private scene: IGameScene;
    private unlockedEnemies: Set<string> = new Set();
    private ui: BestiaryUI | null = null;
    private btn!: HTMLElement;

    private unsubSpawned: () => void = () => { };

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.loadProgress(); // Load saved unlocks
        this.createButton();

        // Start with basic enemy unlocked (if not already loaded)
        this.unlock('grunt');

        // Listen for enemy spawns to unlock them
        this.unsubSpawned = EventBus.getInstance().on(Events.ENEMY_SPAWNED, (enemyType: string) => {
            this.unlock(enemyType);
        });
    }

    public destroy() {
        this.unsubSpawned();
        if (this.btn && this.btn.parentNode) {
            this.btn.parentNode.removeChild(this.btn);
        }
        if (this.ui) {
            this.ui.hide();
            // BestiaryUI doesn't strictly need destroy if it just removes DOM, 
            // but we could add it if needed. For now, removing the button is key.
        }
    }

    private loadProgress() {
        try {
            const saved = localStorage.getItem('nt_bestiary_unlocks');
            if (saved) {
                const ids = JSON.parse(saved);
                if (Array.isArray(ids)) {
                    ids.forEach(id => this.unlockedEnemies.add(id));
                }
            }
        } catch (e) {
            console.error('Failed to load bestiary progress', e);
        }
    }

    private saveProgress() {
        try {
            const data = JSON.stringify(Array.from(this.unlockedEnemies));
            localStorage.setItem('nt_bestiary_unlocks', data);
        } catch (e) {
            console.error('Failed to save bestiary progress', e);
        }
    }

    public unlock(typeId: string) {
        const id = typeId.toLowerCase();
        if (!this.unlockedEnemies.has(id)) {
            this.unlockedEnemies.add(id);
            this.saveProgress();
            if (this.ui) this.ui.unlockEnemy(id);
        }
    }

    private getUI(): BestiaryUI {
        if (!this.ui) {
            this.ui = new BestiaryUI(this.scene, this.unlockedEnemies);
        }
        return this.ui;
    }

    private toggle() {
        this.getUI().toggle();
    }

    private createButton() {
        this.btn = UIUtils.createButton(document.body, 'üìñ', () => this.toggle(), {
            position: 'absolute',
            top: '20px',
            left: '20px',
            width: '40px',
            height: '40px',
            borderRadius: '50%',
            fontSize: '24px',
            padding: '0',
            background: 'rgba(0,0,0,0.6)',
            color: '#fff',
            border: '2px solid #aaa',
            zIndex: '100',
            title: 'Bestiary'
        });

        // Hover effect for button
        this.btn.onmousedown = () => (this.btn.style.transform = 'scale(0.9)');
        this.btn.onmouseup = () => (this.btn.style.transform = 'scale(1)');
    }
}
</file>

<file path="src/config/Enemies.ts">
import { IEnemyTypeConfig } from '../types';

export const ENEMY_CONFIG = {
    BASE_HP: 25,
    HP_GROWTH: 1.2
};

export const ENEMY_TYPES: Record<string, IEnemyTypeConfig> = {
    GRUNT: {
        id: 'grunt',
        name: '–°–∫–µ–ª–µ—Ç',
        symbol: 'üíÄ',
        hpMod: 1.2,
        speed: 90, // 1.5 * 60 = 90
        reward: 4,
        color: '#e0e0e0',
        desc: '–û–±—ã—á–Ω—ã–π —Å–∫–µ–ª–µ—Ç',
        archetype: 'SKELETON',
        scale: 1.0,
    },
    SCOUT: {
        id: 'scout',
        name: '–ê–¥—Å–∫–∞—è –ì–æ–Ω—á–∞—è',
        symbol: 'üêï',
        hpMod: 0.85,
        speed: 168, // 2.8 * 60 = 168
        reward: 2,
        color: '#212121', // Dark fur color
        desc: '–ë—ã—Å—Ç—Ä—ã–π —Ö–∏—â–Ω–∏–∫ –∏–∑ –ø—Ä–µ–∏—Å–ø–æ–¥–Ω–µ–π',
        archetype: 'HELLHOUND',
        scale: 0.9,
    },
    TANK: {
        id: 'tank',
        name: '–í–æ–µ–≤–æ–¥–∞ –û—Ä–∫–æ–≤',
        symbol: 'üëπ', // Or maybe üõ°Ô∏è? Sticking with ogre/oni usually works for Orcs, or use custom unicode if preferred.
        hpMod: 3.65,
        speed: 68, // Decreased by ~20% from 48
        reward: 10,
        color: '#558b2f',
        desc: '–ñ–∏–≤–æ–π —Ç–∞—Ä–∞–Ω –≤ —Ç—è–∂–µ–ª–æ–π –±—Ä–æ–Ω–µ',
        archetype: 'ORC',
        scale: 1.3,
    },
    BOSS: {
        id: 'boss',
        name: '–ü—Ä–∏–∑—Ä–∞–∫ –ü—É—Å—Ç–æ—Ç—ã',
        symbol: 'üëª',
        hpMod: 30.0,
        speed: 40,
        reward: 300,
        color: '#1a0b2e',
        desc: '–ù–µ—É—è–∑–≤–∏–º–∞—è —Å—É—â–Ω–æ—Å—Ç—å',
        archetype: 'WRAITH',
        scale: 1.2,
    },
    // --- NEW VARIANTS ---
    SKELETON_MINER: {
        id: 'skeleton_miner',
        name: '–°–∫–µ–ª–µ—Ç-–®–∞—Ö—Ç—ë—Ä',
        symbol: '‚õèÔ∏è',
        hpMod: 1.44, // 20% more than basic skeleton (1.2)
        speed: 85, // Slightly slower than basic skeleton
        reward: 5,
        color: '#d7ccc8', // Dirty bone color
        desc: '–ö—Ä–µ–ø–∫–∏–π —Ä–∞–±–æ—Ç—è–≥–∞ —Å –∫–∏—Ä–∫–æ–π –∏ –º–µ—à–∫–æ–º —É–≥–ª—è.',
        archetype: 'SKELETON_MINER',
        scale: 1.05, // Slightly bigger presence
    },
    SKELETON_BERSERKER: {
        id: 'skeleton_berserker',
        name: '–°–∫–µ–ª–µ—Ç-–ë–µ—Ä—Å–µ—Ä–∫',
        symbol: 'ü™ì',
        hpMod: 2.0, // High health pool
        speed: 65, // Slow base speed, becomes 130 when enraged
        reward: 8,
        color: '#c62828', // Enrage red color
        desc: '–û–≥—Ä–æ–º–Ω—ã–π —Å–∫–µ–ª–µ—Ç —Å –¥–≤—É—Ä—É—á–Ω—ã–º —Ç–æ–ø–æ—Ä–æ–º. –ü—Ä–∏ HP < 50% –≤–ø–∞–¥–∞–µ—Ç –≤ —è—Ä–æ—Å—Ç—å, —É–¥–≤–∞–∏–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å.',
        archetype: 'SKELETON_BERSERKER',
        scale: 1.25, // Visually larger and more intimidating
    },
    SKELETON_COMMANDER: {
        id: 'skeleton_commander',
        name: '–ö–æ–º–∞–Ω–¥–∏—Ä –°–∫–µ–ª–µ—Ç–æ–≤',
        symbol: 'üëë',
        hpMod: 3.0,
        speed: 72, // Heavy (1.2 * 60)
        reward: 12,
        color: '#ffd700',
        desc: '–°—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Å–∏–ª—å–Ω–µ–µ –æ—Ç —Å–º–µ—Ä—Ç–µ–π —Å–æ—é–∑–Ω–∏–∫–æ–≤',
        archetype: 'SKELETON_COMMANDER',
        scale: 1.3,
        tint: '#ffd700'
    },
    SPIDER_POISON: {
        id: 'spider_poison',
        name: '–Ø–¥–æ–≤–∏—Ç—ã–π',
        symbol: 'üß™',
        hpMod: 1.4,
        speed: 132, // 2.2 * 60 = 132
        reward: 6,
        color: '#76ff03',
        desc: '–û—Å—Ç–∞–≤–ª—è–µ—Ç –ª–µ—á–∞—â—É—é –ª—É–∂—É –ø–æ—Å–ª–µ —Å–º–µ—Ä—Ç–∏',
        archetype: 'SPIDER',
        scale: 1.15,
        tint: '#76ff03'
    },
    TROLL_ARMORED: {
        id: 'troll_armored',
        name: '–õ–∞—Ç–Ω–∏–∫',
        symbol: 'üõ°Ô∏è',
        hpMod: 7.0,
        speed: 42, // 0.7 * 60 = 42
        reward: 15,
        color: '#eceff1', // Snow White
        desc: '–°–Ω–µ–∂–Ω—ã–π —Ç—Ä–æ–ª–ª—å —Å —Ç—è–∂–µ–ª–æ–π –¥—É–±–∏–Ω–æ–π',
        archetype: 'TROLL',
        scale: 1.3,
        tint: '#cfd8dc'
    },
    GOBLIN: {
        id: 'goblin',
        name: '–ì–æ–±–ª–∏–Ω',
        symbol: 'üë∫',
        hpMod: 0.8,
        speed: 76,
        reward: 3,
        color: '#689f38',
        desc: '–ñ–∞–¥–Ω—ã–π –º–∞—Ä–æ–¥–µ—Ä —Å –º–µ—à–∫–æ–º',
        archetype: 'GOBLIN',
        scale: 1.35,
    },
    SAPPER_RAT: {
        id: 'sapper_rat',
        name: '–ê–ª—Ö–∏–º–∏—á–µ—Å–∫–∞—è –ö—Ä—ã—Å–∞',
        symbol: 'üêÄ',
        hpMod: 1.8, // Durable carrier
        speed: 130, // Slightly slower to compensate for HP
        reward: 12,
        color: '#3e2723', // Darker brown
        desc: '–í–∑—Ä—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —Å–º–µ—Ä—Ç–∏, –Ω–∞–Ω–æ—Å—è —É—Ä–æ–Ω –í–°–ï–ú',
        archetype: 'RAT',
        scale: 1.15,
    },
    MAGMA_KING: {
        id: 'magma_king',
        name: '–ö–æ—Ä–æ–ª—å –ú–∞–≥–º—ã',
        symbol: 'üåã',
        hpMod: 15.0,
        speed: 55,
        reward: 100,
        color: '#ff3d00', // Magma Orange
        desc: '–î—Ä–µ–≤–Ω–∏–π –∞—Ä—Ö–∏–¥–µ–º–æ–Ω –∏–∑ —Ä–∞—Å–ø–ª–∞–≤–ª–µ–Ω–Ω–æ–π –º–∞–≥–º—ã. –°–±—Ä–∞—Å—ã–≤–∞–µ—Ç –æ—Å—Ç—ã–≤—à—É—é –æ–±–æ–ª–æ—á–∫—É –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —É—Ä–æ–Ω–∞.',
        archetype: 'MAGMA',
        scale: 1.4,
    },
    MAGMA_STATUE: {
        id: 'magma_statue',
        name: '–û–±—Å–∏–¥–∏–∞–Ω–æ–≤–∞—è –°—Ç–∞—Ç—É—è',
        symbol: 'üóø',
        hpMod: 8.0,
        speed: 1,
        reward: 0,
        color: '#212121', // Obsidian
        desc: '–û—Å—Ç—ã–≤—à–∞—è –ª–∞–≤–æ–≤–∞—è –æ–±–æ–ª–æ—á–∫–∞ –±–æ—Å—Å–∞. –¢–≤–µ—Ä–¥–∞—è –∫–∞–∫ –∫–∞–º–µ–Ω—å.',
        archetype: 'MAGMA',
        scale: 1.0,
        armor: 15,
        isHidden: true,
    },
    FLESH_COLOSSUS: {
        id: 'flesh_colossus',
        name: '–ú—è—Å–Ω–æ–π –ö–æ–ª–æ—Å—Å',
        symbol: 'üßü',
        hpMod: 8.0,
        speed: 45,
        reward: 0, // No direct reward ‚Äî reward comes from spawns
        armor: 5,
        color: '#8d4545',
        desc: '–¢—Ä–æ—è–Ω—Å–∫–∏–π –∫–æ–Ω—å. –ü—Ä–∏ —Å–º–µ—Ä—Ç–∏ –∏–∑ –Ω–µ–≥–æ –≤—ã—Ä—ã–≤–∞—é—Ç—Å—è 2 —Å–∫–µ–ª–µ—Ç–∞ –∏ –∞–¥—Å–∫–∞—è –≥–æ–Ω—á–∞—è.',
        archetype: 'FLESH',
        scale: 1.5,
        deathSpawns: ['GRUNT', 'GRUNT', 'SCOUT']
    }
};
</file>

<file path="src/EntityFactory.ts">
import { Enemy } from './Enemy';
import { Tower } from './Tower';
import { CONFIG, getEnemyType } from './Config';
// import { generateUUID } from './Utils'; // No longer needed

export class EntityFactory {
    // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–±—Ä–∞–ª–∏ –ª–∏—à–Ω–∏–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã, —Ç–µ–ø–µ—Ä—å —Ä–æ–≤–Ω–æ 3
    public static createEnemy(typeKey: string, wave: number, path: { x: number; y: number }[]): Enemy {
        const enemy = new Enemy();
        this.setupEnemy(enemy, typeKey, wave, path);
        return enemy;
    }

    public static setupEnemy(enemy: Enemy, typeKey: string, wave: number, path: { x: number; y: number }[]) {
        const safeKey = typeKey || 'GRUNT';

        const typeConf = getEnemyType(safeKey) || getEnemyType('GRUNT')!;
        if (!getEnemyType(safeKey)) {
            console.warn(`Unknown enemy type: ${typeKey}, falling back to GRUNT`);
        }

        const hp = CONFIG.ENEMY.BASE_HP * typeConf.hpMod * Math.pow(CONFIG.ENEMY.HP_GROWTH, wave - 1);

        // Spawn enemy at the first waypoint
        const startX = path.length > 0 ? path[0].x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 : 0;
        const startY = path.length > 0 ? path[0].y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 : 0;

        enemy.init({
            // id removed - generated internally
            health: hp,
            speed: typeConf.speed,
            path: path,
            x: startX,
            y: startY,
        });

        enemy.setType(typeConf.id || safeKey.toLowerCase());
        enemy.reward = typeConf.reward || 5;
    }

    public static createTower(col: number, row: number): Tower {
        return new Tower(col, row);
    }
}
</file>

<file path="src/InspectorSystem.ts">
import { IGameScene } from './scenes/IGameScene';
import { Tower } from './Tower';
import { CONFIG } from './Config';

export class InspectorSystem {
    private scene: IGameScene;
    private elInspector: HTMLElement;
    private elName: HTMLElement;
    private elStats: HTMLElement;
    private elCardsContainer: HTMLElement;
    private elSellBtn: HTMLButtonElement;

    private currentTower: Tower | null = null;

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.elInspector = document.createElement('div');

        // Create inspector panel
        this.elInspector.id = 'inspector-panel';
        this.elInspector.className = 'ui-panel'; // Use existing panel style
        Object.assign(this.elInspector.style, {
            background: 'rgba(20, 20, 30, 0.95)',
            border: '2px solid #555',
            borderRadius: '8px',
            padding: '15px',
            color: '#fff',
            display: 'none',
            pointerEvents: 'auto',
            marginBottom: '15px', // Space above shop panel
        });

        this.elName = document.createElement('h3');
        this.elName.style.margin = '0 0 10px 0';
        this.elName.style.textAlign = 'center';

        this.elStats = document.createElement('div');
        this.elStats.style.fontSize = '13px';
        this.elStats.style.marginBottom = '10px';

        this.elCardsContainer = document.createElement('div');
        Object.assign(this.elCardsContainer.style, {
            borderTop: '1px solid #555',
            paddingTop: '10px',
            marginTop: '10px',
        });

        this.elSellBtn = document.createElement('button');
        this.elSellBtn.innerText = 'üóëÔ∏è –ü–†–û–î–ê–¢–¨ –ë–ê–®–ù–Æ';
        Object.assign(this.elSellBtn.style, {
            marginTop: '10px',
            padding: '12px',
            background: '#d32f2f',
            color: '#fff',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            fontWeight: 'bold',
            width: '100%',
            fontSize: '14px',
        });

        // CRITICAL: Use addEventListener for better event handling
        this.elSellBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event from bubbling to canvas
            e.preventDefault();
            console.log('Sell button clicked! Tower:', this.currentTower);
            if (this.currentTower) {
                this.scene.sellTower(this.currentTower);
            }
        });

        this.elInspector.appendChild(this.elName);
        this.elInspector.appendChild(this.elStats);
        this.elInspector.appendChild(this.elCardsContainer);
        this.elInspector.appendChild(this.elSellBtn);

        // CRITICAL: Attach to #ui-right container, NOT document.body
        // This ensures proper event handling within the UI layer
        const uiRight = document.getElementById('ui-right');
        if (uiRight) {
            // Insert at the beginning so it appears above shop
            uiRight.insertBefore(this.elInspector, uiRight.firstChild);
        } else {
            // Fallback to body if ui-right not found
            document.body.appendChild(this.elInspector);
        }
    }

    public selectTower(tower: Tower) {
        this.currentTower = tower;
        this.elInspector.style.display = 'block';
        this.updateInfo();
    }

    public hide() {
        this.currentTower = null;
        this.elInspector.style.display = 'none';
    }

    private updateInfo() {
        if (!this.currentTower) return;

        this.elName.innerText = 'üè∞ –ë–∞—à–Ω—è';

        // Get tower stats
        const stats = this.currentTower.getStats();

        // Build stats display
        let statsHTML = '';
        statsHTML += `<div>‚öîÔ∏è –£—Ä–æ–Ω: ${stats.dmg.toFixed(1)}</div>`;
        statsHTML += `<div>üìè –†–∞–¥–∏—É—Å: ${stats.range.toFixed(0)}</div>`;
        statsHTML += `<div>‚è±Ô∏è –°–∫–æ—Ä–æ—Å—Ç—å: ${(1 / stats.cd).toFixed(1)}/—Å</div>`;
        if (stats.pierce > 0) {
            statsHTML += `<div>üéØ –ü—Ä–æ–±–∏–≤–∞–Ω–∏–µ: ${stats.pierce}</div>`;
        }
        this.elStats.innerHTML = statsHTML;

        // Clear and rebuild cards container
        this.elCardsContainer.innerHTML = '';

        // === TARGETING MODE SELECTOR ===
        const targetingSection = document.createElement('div');
        Object.assign(targetingSection.style, {
            borderBottom: '1px solid #555',
            paddingBottom: '10px',
            marginBottom: '10px',
        });

        const targetingLabel = document.createElement('div');
        targetingLabel.innerText = '–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Ü–µ–ª–∏:';
        Object.assign(targetingLabel.style, {
            fontSize: '12px',
            color: '#aaa',
            marginBottom: '5px',
            textAlign: 'center',
        });
        targetingSection.appendChild(targetingLabel);

        const targetingRow = document.createElement('div');
        Object.assign(targetingRow.style, {
            display: 'flex',
            gap: '5px',
            justifyContent: 'center',
        });

        // Create buttons for each targeting mode
        Object.values(CONFIG.TARGETING_MODES).forEach((mode: any) => {
            const btn = document.createElement('button');
            btn.innerText = mode.icon;
            btn.title = `${mode.name}: ${mode.desc}`;

            const isActive = this.currentTower!.targetingMode === mode.id;
            Object.assign(btn.style, {
                width: '36px',
                height: '36px',
                fontSize: '18px',
                background: isActive ? '#4caf50' : '#444',
                border: `2px solid ${isActive ? '#fff' : '#666'}`,
                borderRadius: '6px',
                cursor: 'pointer',
                transition: 'all 0.15s',
            });

            btn.addEventListener('mouseenter', () => {
                if (!isActive) btn.style.background = '#555';
            });
            btn.addEventListener('mouseleave', () => {
                if (!isActive) btn.style.background = '#444';
            });

            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                if (this.currentTower) {
                    this.currentTower.targetingMode = mode.id;
                    console.log('Targeting mode changed to:', mode.id);
                    this.updateInfo(); // Refresh to show new selection
                }
            });

            targetingRow.appendChild(btn);
        });

        targetingSection.appendChild(targetingRow);
        this.elCardsContainer.appendChild(targetingSection);
        // === END TARGETING MODE SELECTOR ===

        const label = document.createElement('div');
        label.style.fontSize = '12px';
        label.style.color = '#aaa';
        label.style.marginBottom = '5px';
        label.style.textAlign = 'center';
        label.innerText = '–°–ª–æ—Ç—ã:';
        this.elCardsContainer.appendChild(label);

        const cardsRow = document.createElement('div');
        Object.assign(cardsRow.style, {
            display: 'flex',
            gap: '5px',
            justifyContent: 'center',
        });

        // Create slots for all 3 positions
        this.currentTower.slots.forEach((slot, index) => {
            const slotEl = document.createElement('div');

            if (slot.isLocked) {
                // === LOCKED SLOT ===
                const unlockCost = CONFIG.ECONOMY.SLOT_UNLOCK_COST[index];
                const canAfford = this.scene.money >= unlockCost;


                Object.assign(slotEl.style, {
                    width: '50px',
                    height: '70px',
                    background: '#222',
                    borderRadius: '4px',
                    border: '1px solid #444',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: canAfford ? '#ffd700' : '#888',
                    cursor: 'pointer',
                    position: 'relative',
                    transition: 'all 0.1s',
                });

                slotEl.innerHTML = `
                    <div style="font-size: 20px;">üîí</div>
                    <div style="font-size: 10px; margin-top: 5px;">${unlockCost}üí∞</div>
                `;

                // Unlock Click
                slotEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.currentTower) {
                        // Call GameController or do logic here? 
                        // Better to call scene -> controller
                        this.scene.gameController.handleMenuAction({ type: 'UNLOCK', slotId: slot.id }, this.currentTower);
                        this.updateInfo(); // Refresh UI immediately
                    }
                });

                // Hover
                slotEl.onmouseenter = () => { slotEl.style.borderColor = canAfford ? '#ffd700' : '#f00'; };
                slotEl.onmouseleave = () => { slotEl.style.borderColor = '#444'; };

            } else if (slot.card) {
                // === CARD ===
                const card = slot.card;
                const stars = '‚òÖ'.repeat(card.level);
                // Return to hand logic instead of sell? User asked for behavior similar to radial menu?
                // Radial menu had: Click card -> Return to hand.
                // Inspector sell button is global.
                // Let's keep "Click to return to hand" for consistency with radial menu logic requested
                // OR "Click to sell" as previous inspector?
                // User said: "remove radial menu... logic of locking/unlocking moves to inspector".
                // I will stick to "Return to Hand" on click, because "Sell" is a separate big button.

                Object.assign(slotEl.style, {
                    width: '50px',
                    height: '70px',
                    background: card.type.color,
                    borderRadius: '4px',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    border: '2px solid rgba(255,255,255,0.3)',
                    position: 'relative',
                    cursor: 'pointer',
                    transition: 'transform 0.1s, box-shadow 0.1s',
                });

                slotEl.innerHTML = `
                    <div style="position: absolute; top: 2px; left: 2px; font-size: 8px; color: #fff;">${stars}</div>
                    <div style="font-size: 24px;">${card.type.icon}</div>
                    <div style="font-size: 9px; color: #fff; margin-top: 2px;">Lvl ${card.level}</div>
                `;

                // Hover effect
                slotEl.onmouseenter = () => {
                    slotEl.style.transform = 'scale(1.1)';
                    slotEl.style.boxShadow = '0 0 10px gold';
                };
                slotEl.onmouseleave = () => {
                    slotEl.style.transform = 'scale(1)';
                    slotEl.style.boxShadow = 'none';
                };

                // Click to REMOVE (Return to hand)
                slotEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.currentTower) {
                        // Use IMMEDIATE removal for Inspector clicks
                        this.scene.gameController.handleMenuAction({ type: 'REMOVE_CARD', slotId: slot.id }, this.currentTower);
                        // Update UI handles the rest
                    }
                });

            } else {
                // === EMPTY SLOT ===
                Object.assign(slotEl.style, {
                    width: '50px',
                    height: '70px',
                    background: '#333',
                    borderRadius: '4px',
                    border: '1px dashed #555',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: '#555',
                    cursor: 'default',
                    fontSize: '18px',
                });
                slotEl.innerText = '+';

                // Maybe allow clicking to select this slot for something? 
                // For now just visual.
            }

            cardsRow.appendChild(slotEl);
        });

        this.elCardsContainer.appendChild(cardsRow);

        // Update sell button with refund amount
        const refund = Math.floor(CONFIG.ECONOMY.TOWER_COST * CONFIG.ECONOMY.SELL_REFUND);
        this.elSellBtn.innerText = `üóëÔ∏è –ü–†–û–î–ê–¢–¨ (+${refund}üí∞)`;
    }
}
</file>

<file path="src/renderers/units/SkeletonUnitRenderer.ts">
import { BaseSkeletonRenderer, SkeletonPose } from './BaseSkeletonRenderer';

/**
 * Standard Sword and Shield Skeleton.
 * Implements the layered hooks provided by BaseSkeletonRenderer.
 */
export class SkeletonUnitRenderer extends BaseSkeletonRenderer {
    // Palette
    private static readonly ARMOR_DARK = '#2d2d2d'; // Original dark
    private static readonly ARMOR_LIGHT = '#546e7a'; // Original plate metallic
    private static readonly SHIELD_WOOD = '#5d4037'; // Original wood
    private static readonly SHIELD_RIM = '#8d6e63'; // Original rim

    // Eye glow and head radius are inherited from BaseSkeletonRenderer

    // We don't need to override getBakeFacings, as BaseSkeletonRenderer provides ['SIDE', 'UP', 'DOWN']
    // We don't need to override drawFrameDirectional either, the base handles Z-ordering

    // ============================================================================
    // LAYERED RENDERING HOOKS
    // ============================================================================

    protected override drawHeadDecoration(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        ctx.save();
        ctx.translate(pose.anchors.head.x, pose.anchors.head.y);
        ctx.rotate(pose.anchors.head.angle);

        const s = pose.scale;

        // Draw Skull base (shared from BaseSkeletonRenderer)
        this.drawSkull(ctx, s, pose.facing);

        ctx.restore();
    }

    protected override drawBodyArmor(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {

        ctx.save();
        ctx.translate(pose.anchors.torso.x, pose.anchors.torso.y);
        const s = pose.scale;

        ctx.fillStyle = SkeletonUnitRenderer.ARMOR_DARK;
        ctx.beginPath();

        if (pose.facing === 'SIDE') {
            // Chestplate side view
            ctx.ellipse(0, -1 * s, 4 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Chestplate front/back
            ctx.moveTo(-7 * s, -7 * s);
            ctx.lineTo(7 * s, -7 * s);
            ctx.lineTo(5 * s, 5 * s);
            ctx.lineTo(-5 * s, 5 * s);
            ctx.fill();

            // Plate details
            ctx.strokeStyle = SkeletonUnitRenderer.ARMOR_LIGHT;
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            if (pose.facing === 'DOWN') {
                ctx.moveTo(-4 * s, -2 * s); ctx.lineTo(4 * s, -2 * s);
                ctx.moveTo(-3 * s, 1 * s); ctx.lineTo(3 * s, 1 * s);
            } else {
                ctx.moveTo(0, -6 * s); ctx.lineTo(0, 4 * s);
            }
            ctx.stroke();
        }
        ctx.restore();
    }

    protected override drawLeftHandItem(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        // Shield
        ctx.save();
        ctx.translate(pose.anchors.leftHand.x, pose.anchors.leftHand.y);
        const s = pose.scale;

        if (pose.facing === 'SIDE') {
            // Shield Side (edge profile)
            ctx.translate(0, 3 * s);
            ctx.fillStyle = SkeletonUnitRenderer.SHIELD_WOOD;
            ctx.beginPath();
            ctx.ellipse(0, 0, 1.5 * s, 6 * s, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = SkeletonUnitRenderer.SHIELD_RIM;
            ctx.lineWidth = 1 * s;
            ctx.stroke();
        } else if (pose.facing === 'DOWN') {
            // Shield Front
            ctx.translate(0, 3 * s);
            ctx.fillStyle = SkeletonUnitRenderer.SHIELD_WOOD;
            ctx.beginPath(); ctx.arc(0, 0, 6 * s, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = SkeletonUnitRenderer.SHIELD_RIM;
            ctx.lineWidth = 2 * s;
            ctx.stroke();
        } else {
            // Shield Back
            ctx.translate(0, 3 * s);
            ctx.fillStyle = '#3e2723';
            ctx.beginPath(); ctx.arc(0, 0, 6 * s, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#111';
            ctx.fillRect(-2 * s, -1 * s, 4 * s, 2 * s); // Strap
        }

        ctx.restore();
    }

    protected override drawRightHandItem(ctx: CanvasRenderingContext2D, pose: SkeletonPose): void {
        // Sword
        ctx.save();
        ctx.translate(pose.anchors.rightHand.x, pose.anchors.rightHand.y);
        const s = pose.scale;

        if (pose.facing === 'SIDE') {
            ctx.rotate(0.5); // Angle forward
            ctx.fillStyle = '#cfd8dc';
            ctx.fillRect(0, -1 * s, 14 * s, 2 * s); // Blade
            ctx.fillStyle = SkeletonUnitRenderer.ARMOR_LIGHT;
            ctx.fillRect(0, -3 * s, 2 * s, 6 * s); // Guard
        } else {
            // Front/Back
            ctx.rotate(Math.PI / 2); // Pointing down
            ctx.fillStyle = '#cfd8dc';
            ctx.beginPath();
            ctx.moveTo(-1 * s, 0); ctx.lineTo(1 * s, 0);
            ctx.lineTo(0, 14 * s);
            ctx.fill();
            ctx.fillStyle = SkeletonUnitRenderer.ARMOR_LIGHT;
            ctx.fillRect(-3 * s, -1 * s, 6 * s, 1 * s);
        }

        ctx.restore();
    }
}
</file>

<file path="src/types.ts">
/**
 * Central type definitions for the Tower Defense game
 */

// ============================================
// Card System Types
// ============================================

export interface ICardTypeConfig {
    id: string;
    name: string;
    icon: string;
    color: string;
    desc: string;
    // Turret rendering (optional for backward compatibility)
    turretAsset?: string;  // e.g. 'turret_fire'
    moduleAsset?: string;  // e.g. 'mod_fire'
}

// ============================================
// Enemy System Types
// ============================================

export interface IEnemyTypeConfig {
    id: string;
    name: string;
    symbol: string;
    hpMod: number;
    speed: number;
    reward: number;
    armor?: number; // Optional armor value
    color: string;
    desc: string;
    // Modular Visuals
    archetype?: 'SKELETON' | 'WOLF' | 'TROLL' | 'SPIDER' | 'HELLHOUND' | 'ORC' | 'WRAITH' | 'GOBLIN' | 'SKELETON_COMMANDER' | 'RAT' | 'MAGMA' | 'FLESH' | 'SKELETON_MINER' | 'SKELETON_BERSERKER';
    scale?: number;
    props?: string[]; // IDs of props
    tint?: string;    // Hex color override
    isHidden?: boolean; // If true, hidden from Editor/Bestiary lists
    deathSpawns?: string[]; // Enemy types to spawn on death (Flesh Colossus)
}

// ============================================
// Configuration Types
// ============================================

export type CardTypeKey = 'FIRE' | 'ICE' | 'SNIPER' | 'MULTISHOT';
export type EnemyTypeKey = 'GRUNT' | 'SCOUT' | 'TANK' | 'BOSS';

// ============================================
// Utility Types
// ============================================

/**
 * Type-safe accessor for card types
 */
export function getCardTypeConfig(key: string): ICardTypeConfig | undefined {
    return undefined; // Implementation will be in Config.ts
}

/**
 * Type-safe accessor for enemy types
 */
export function getEnemyTypeConfig(key: string): IEnemyTypeConfig | undefined {
    return undefined; // Implementation will be in Config.ts
}
</file>

<file path="src/ui/DevConsole.ts">
import { IGameScene } from '../scenes/IGameScene';
import { Logger, LogLevel, LogChannel, LogEntry } from '../utils/Logger';
import { SafeJson } from '../utils/SafeJson';
import { PerformanceMonitor } from '../utils/PerformanceMonitor';

/**
 * DevConsole v2.0 - –†—É—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –≥—Ä–∞—Ñ–∏–∫–æ–º FPS
 * –í–∫–ª–∞–¥–∫–∏: –õ–û–ì | –ì–†–ê–§–ò–ö | –ß–ò–¢–´ | –¢–ï–°–¢–´
 */
export class DevConsole {
    private scene: IGameScene;
    private container!: HTMLElement;
    private toggleBtn!: HTMLElement;

    // Tab content areas
    private contentLog!: HTMLElement;
    private contentGraph!: HTMLElement;
    private contentCheats!: HTMLElement;
    private contentTests!: HTMLElement;
    // Graph canvas
    private graphCanvas!: HTMLCanvasElement;
    private graphCtx!: CanvasRenderingContext2D;
    private fpsHistory: number[] = [];
    private eventMarkers: { frame: number; label: string; color: string }[] = [];
    private graphUpdateInterval: ReturnType<typeof setInterval> | null = null;

    // Frame Snapshots - capture game state during FPS drops
    private frameSnapshots: {
        time: string;
        fps: number;
        enemies: number;
        projectiles: number;
        effects: number;
        towers: number;
    }[] = [];

    // State
    private isVisible: boolean = false;
    private activeTab: 'log' | 'graph' | 'cheats' | 'tests' = 'log';
    private autoScroll: boolean = true;
    private stateUpdateInterval: ReturnType<typeof setInterval> | null = null;

    // Filters
    private showInfo: boolean = true;
    private showWarn: boolean = true;
    private showError: boolean = true;
    private showVerbose: boolean = false;

    // Cleanup
    private keyDownHandler: ((e: KeyboardEvent) => void) | null = null;

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.createUI();
        this.setupLogger();
        Logger.info(LogChannel.SYSTEM, 'DevConsole v2.0 –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
    }

    private setupLogger() {
        Logger.subscribe((entry) => {
            this.appendLog(entry);
            // Add event marker for graph
            if (entry.level === LogLevel.WARN || entry.level === LogLevel.ERROR) {
                this.eventMarkers.push({
                    frame: this.fpsHistory.length,
                    label: entry.message.slice(0, 20),
                    color: entry.level === LogLevel.ERROR ? '#f44' : '#fc0'
                });
                if (this.eventMarkers.length > 50) this.eventMarkers.shift();
            }
            if (!this.isVisible && entry.level === LogLevel.ERROR) {
                this.flashButton();
            }
        });
    }

    private flashButton() {
        if (this.toggleBtn) {
            this.toggleBtn.style.background = '#ff0000';
            setTimeout(() => {
                if (!this.isVisible) this.toggleBtn.style.background = 'rgba(0,0,0,0.8)';
            }, 500);
        }
    }

    private createUI() {
        // Toggle Button
        this.toggleBtn = document.createElement('div');
        this.toggleBtn.innerText = 'üêû';
        this.toggleBtn.title = 'Dev Console (~)';
        Object.assign(this.toggleBtn.style, {
            position: 'absolute', top: '10px', right: '10px',
            width: '32px', height: '32px', background: 'rgba(0,0,0,0.8)',
            border: '1px solid #444', borderRadius: '50%',
            display: 'flex', alignItems: 'center', justifyContent: 'center',
            cursor: 'pointer', zIndex: '20000', userSelect: 'none', fontSize: '16px'
        });
        this.toggleBtn.onclick = () => this.toggle();
        document.body.appendChild(this.toggleBtn);

        // Main Container
        this.container = document.createElement('div');
        Object.assign(this.container.style, {
            position: 'absolute', top: '50px', right: '10px',
            width: '420px', height: '520px', background: 'rgba(10, 10, 10, 0.95)',
            border: '1px solid #444', borderRadius: '4px', display: 'none',
            flexDirection: 'column', zIndex: '20000', fontFamily: 'Consolas, monospace',
            fontSize: '12px', color: '#ccc', boxShadow: '0 4px 12px rgba(0,0,0,0.5)'
        });
        document.body.appendChild(this.container);

        // Header (Tabs) - RUSSIAN
        const header = document.createElement('div');
        Object.assign(header.style, {
            display: 'flex', borderBottom: '1px solid #333',
            background: '#1a1a1a', padding: '0 5px'
        });

        const tabs = [
            { id: 'log', label: '–õ–û–ì' },
            { id: 'graph', label: '–ì–†–ê–§–ò–ö' },
            { id: 'cheats', label: '–ß–ò–¢–´' },
            { id: 'tests', label: '–¢–ï–°–¢–´' }
        ];

        tabs.forEach(tab => {
            const btn = document.createElement('button');
            btn.innerText = tab.label;
            btn.dataset.tab = tab.id;
            Object.assign(btn.style, {
                background: 'transparent', border: 'none', color: '#888',
                padding: '8px 10px', cursor: 'pointer', fontWeight: 'bold', fontSize: '11px'
            });
            btn.onclick = () => this.switchTab(tab.id as any);
            header.appendChild(btn);
        });

        // Close Btn
        const closeBtn = document.createElement('button');
        closeBtn.innerText = '‚úï';
        Object.assign(closeBtn.style, {
            marginLeft: 'auto', background: 'transparent', border: 'none',
            color: '#666', cursor: 'pointer', padding: '0 10px'
        });
        closeBtn.onclick = () => this.toggle();
        header.appendChild(closeBtn);
        this.container.appendChild(header);

        // === LOG TAB ===
        const logWrapper = document.createElement('div');
        Object.assign(logWrapper.style, { flex: '1', display: 'flex', flexDirection: 'column' });

        const filters = document.createElement('div');
        Object.assign(filters.style, { padding: '5px', background: '#111', borderBottom: '1px solid #222', display: 'flex', gap: '8px', fontSize: '10px' });
        filters.innerHTML = `
            <label><input type="checkbox" id="chk-info" checked> –ò–Ω—Ñ–æ</label>
            <label><input type="checkbox" id="chk-warn" checked> –í–Ω–∏–º–∞–Ω–∏–µ</label>
            <label><input type="checkbox" id="chk-err" checked> –û—à–∏–±–∫–∏</label>
            <button id="btn-clear" style="margin-left:auto; font-size:10px;">–û–ß–ò–°–¢–ò–¢–¨</button>
        `;
        logWrapper.appendChild(filters);

        this.contentLog = document.createElement('div');
        Object.assign(this.contentLog.style, { flex: '1', overflowY: 'auto', padding: '5px' });
        logWrapper.appendChild(this.contentLog);
        this.container.appendChild(logWrapper);

        // === GRAPH TAB ===
        this.contentGraph = document.createElement('div');
        Object.assign(this.contentGraph.style, { flex: '1', display: 'none', flexDirection: 'column', padding: '10px' });
        this.createGraphContent();
        this.container.appendChild(this.contentGraph);

        // === CHEATS TAB ===
        this.contentCheats = document.createElement('div');
        Object.assign(this.contentCheats.style, { flex: '1', overflowY: 'auto', padding: '10px', display: 'none' });
        this.createCheatsContent();
        this.container.appendChild(this.contentCheats);

        // === TESTS TAB ===
        this.contentTests = document.createElement('div');
        Object.assign(this.contentTests.style, { flex: '1', overflowY: 'auto', padding: '10px', display: 'none' });
        this.createTestsContent();
        this.container.appendChild(this.contentTests);

        // Filter Logic
        this.container.querySelector('#chk-info')!.addEventListener('change', (e: any) => { this.showInfo = e.target.checked; this.refreshLogs(); });
        this.container.querySelector('#chk-warn')!.addEventListener('change', (e: any) => { this.showWarn = e.target.checked; this.refreshLogs(); });
        this.container.querySelector('#chk-err')!.addEventListener('change', (e: any) => { this.showError = e.target.checked; this.refreshLogs(); });
        this.container.querySelector('#btn-clear')!.addEventListener('click', () => { this.contentLog.innerHTML = ''; });

        // Global Key
        this.keyDownHandler = (e: KeyboardEvent) => {
            if (e.code === 'Backquote') { e.preventDefault(); this.toggle(); }
        };
        window.addEventListener('keydown', this.keyDownHandler);
    }

    // === GRAPH TAB CONTENT ===
    private createGraphContent() {
        // Canvas for FPS Graph
        this.graphCanvas = document.createElement('canvas');
        this.graphCanvas.width = 380;
        this.graphCanvas.height = 180;
        Object.assign(this.graphCanvas.style, { background: '#111', borderRadius: '4px', marginBottom: '10px' });
        this.graphCtx = this.graphCanvas.getContext('2d')!;
        this.contentGraph.appendChild(this.graphCanvas);

        // Stats line
        const statsLine = document.createElement('div');
        statsLine.id = 'graph-stats';
        Object.assign(statsLine.style, { color: '#8f8', fontSize: '11px', marginBottom: '10px' });
        statsLine.innerText = 'FPS: -- | –ú–∏–Ω: -- | –ú–∞–∫—Å: -- | –°–ø–∞–π–∫–∏: --';
        this.contentGraph.appendChild(statsLine);

        // Event Log (collapsible)
        const spoiler = document.createElement('details');
        spoiler.innerHTML = `<summary style="cursor:pointer; color:#888; margin-bottom:5px;">üìã –õ–æ–≥ —Å–æ–±—ã—Ç–∏–π</summary>`;
        const eventLog = document.createElement('div');
        eventLog.id = 'event-log';
        Object.assign(eventLog.style, { maxHeight: '150px', overflowY: 'auto', fontSize: '10px', color: '#aaa', background: '#0a0a0a', padding: '5px', borderRadius: '3px' });
        spoiler.appendChild(eventLog);
        this.contentGraph.appendChild(spoiler);

        // Full Report Button
        const reportBtn = document.createElement('button');
        reportBtn.innerText = 'üìã –ü–æ–ª–Ω—ã–π –æ—Ç—á—ë—Ç –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞';
        Object.assign(reportBtn.style, {
            display: 'block', width: '100%', padding: '10px', marginTop: '10px',
            background: '#2a4a2a', color: '#8f8', border: '1px solid #4a7a4a',
            borderRadius: '4px', cursor: 'pointer', fontWeight: 'bold'
        });
        reportBtn.onclick = () => this.generateFullReport();
        this.contentGraph.appendChild(reportBtn);
    }

    // === CHEATS TAB CONTENT ===
    private createCheatsContent() {
        const addBtn = (label: string, icon: string, action: () => void, color: string = '#2a2a2a') => {
            const btn = document.createElement('button');
            btn.innerText = `${icon} ${label}`;
            Object.assign(btn.style, {
                display: 'block', width: '100%', padding: '10px 12px', marginBottom: '4px',
                background: color, color: '#ddd', border: '1px solid #444', borderRadius: '4px',
                cursor: 'pointer', textAlign: 'left', fontSize: '12px'
            });
            btn.onclick = action;
            this.contentCheats.appendChild(btn);
        };

        const addHeader = (text: string) => {
            const h = document.createElement('div');
            h.innerText = text;
            Object.assign(h.style, { color: '#888', fontSize: '10px', fontWeight: 'bold', margin: '10px 0 5px', borderBottom: '1px solid #333', paddingBottom: '3px' });
            this.contentCheats.appendChild(h);
        };

        addHeader('üí∞ –†–ï–°–£–†–°–´');
        addBtn('+1000 –ó–æ–ª–æ—Ç–∞', 'üí∞', () => { this.scene.addMoney(1000); Logger.info(LogChannel.GAME, '+1000 –∑–æ–ª–æ—Ç–∞'); }, '#1a4a1a');
        addBtn('+10000 –ó–æ–ª–æ—Ç–∞', 'üí∞', () => { this.scene.addMoney(10000); Logger.info(LogChannel.GAME, '+10000 –∑–æ–ª–æ—Ç–∞'); }, '#1a4a1a');
        addBtn('–ü–æ–ª–Ω—ã–µ –∂–∏–∑–Ω–∏ (100)', '‚ù§Ô∏è', () => { this.scene.gameState.lives = 100; Logger.info(LogChannel.GAME, '–ñ–∏–∑–Ω–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã'); }, '#1a4a1a');

        addHeader('‚öîÔ∏è –í–û–õ–ù–´');
        addBtn('–°–ª–µ–¥—É—é—â–∞—è –≤–æ–ª–Ω–∞', '‚è©', () => { this.scene.wave++; Logger.info(LogChannel.GAME, `–í–æ–ª–Ω–∞ ${this.scene.wave}`); }, '#4a3a1a');
        addBtn('–£–±–∏—Ç—å –≤—Å–µ—Ö –≤—Ä–∞–≥–æ–≤', 'üíÄ', () => {
            for (let i = 0; i < this.scene.enemies.length; i++) {
                this.scene.enemies[i].takeDamage(999999);
            }
            Logger.info(LogChannel.GAME, '–í—Å–µ –≤—Ä–∞–≥–∏ —É–±–∏—Ç—ã');
        }, '#4a1a1a');

        addHeader('‚è∏Ô∏è –£–ü–†–ê–í–õ–ï–ù–ò–ï');
        addBtn('–ü–∞—É–∑–∞ / –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å', '‚è∏Ô∏è', () => {
            this.scene.gameState.paused = !this.scene.gameState.paused;
            Logger.info(LogChannel.GAME, this.scene.gameState.paused ? '–ü–ê–£–ó–ê' : '–ü–†–û–î–û–õ–ñ–ï–ù–ò–ï');
        });
    }

    // === TESTS TAB CONTENT ===
    private createTestsContent() {
        const addBtn = (label: string, icon: string, action: () => void, color: string = '#2a2a2a') => {
            const btn = document.createElement('button');
            btn.innerText = `${icon} ${label}`;
            Object.assign(btn.style, {
                display: 'block', width: '100%', padding: '8px 12px', marginBottom: '4px',
                background: color, color: '#ddd', border: '1px solid #444', borderRadius: '4px',
                cursor: 'pointer', textAlign: 'left', fontSize: '11px'
            });
            btn.onclick = action;
            this.contentTests.appendChild(btn);
        };

        const addHeader = (text: string) => {
            const h = document.createElement('div');
            h.innerText = text;
            Object.assign(h.style, { color: '#888', fontSize: '10px', fontWeight: 'bold', margin: '10px 0 5px', borderBottom: '1px solid #333', paddingBottom: '3px' });
            this.contentTests.appendChild(h);
        };

        addHeader('üìä –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨');
        addBtn('–í–∫–ª—é—á–∏—Ç—å FPS –æ–≤–µ—Ä–ª–µ–π', 'üìä', () => {
            PerformanceMonitor.toggle();
            Logger.info(LogChannel.SYSTEM, `FPS Overlay: ${PerformanceMonitor.isEnabled() ? '–í–ö–õ' : '–í–´–ö–õ'}`);
        });
        addBtn('–°–±—Ä–æ—Å–∏—Ç—å —Å—á—ë—Ç—á–∏–∫–∏', 'üîÑ', () => {
            PerformanceMonitor.resetSpikes();
            Logger.info(LogChannel.SYSTEM, '–°—á—ë—Ç—á–∏–∫–∏ —Å–±—Ä–æ—à–µ–Ω—ã');
        });
        addBtn('–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏', 'üìà', () => {
            const s = PerformanceMonitor.getAdvancedStats();
            Logger.info(LogChannel.SYSTEM, `FPS: ${s.fps} | 1%Low: ${s.onePercentLow} | –°–ø–∞–π–∫–∏: ${s.spikeCount} | –ú–∞–∫—Å –∫–∞–¥—Ä: ${s.worstFrameTime.toFixed(0)}ms`);
        });

        addHeader('üß™ –°–¢–†–ï–°–°-–¢–ï–°–¢–´');
        addBtn('+50 –≤—Ä–∞–≥–æ–≤ (—Å–º–µ—à–∞–Ω–Ω—ã–µ)', 'üëæ', () => {
            const types = ['GRUNT', 'SCOUT', 'TANK'];
            for (let i = 0; i < 50; i++) {
                this.scene.spawnEnemy?.(types[Math.floor(Math.random() * types.length)]);
            }
            Logger.warn(LogChannel.SYSTEM, '–°–ø–∞–≤–Ω 50 –≤—Ä–∞–≥–æ–≤');
        }, '#4a3a1a');
        addBtn('+200 —Å–∫–µ–ª–µ—Ç–æ–≤ (GRUNT)', 'üíÄ', () => {
            for (let i = 0; i < 200; i++) { this.scene.spawnEnemy?.('GRUNT'); }
            Logger.warn(LogChannel.SYSTEM, '–°–ø–∞–≤–Ω 200 GRUNT');
        }, '#4a1a1a');
        addBtn('–û—á–∏—Å—Ç–∏—Ç—å –ø—É–ª—ã', 'üßπ', () => {
            this.scene.effects?.clear?.();
            this.scene.projectileSystem?.clear?.();
            Logger.info(LogChannel.SYSTEM, '–ü—É–ª—ã –æ—á–∏—â–µ–Ω—ã');
        });

        addHeader('üêõ –û–¢–õ–ê–î–ö–ê');
        addBtn('–•–∏—Ç–±–æ–∫—Å—ã –í–ö–õ/–í–´–ö–õ', 'üéØ', () => {
            (window as any).__DEBUG_HITBOXES = !(window as any).__DEBUG_HITBOXES;
            Logger.info(LogChannel.SYSTEM, `–•–∏—Ç–±–æ–∫—Å—ã: ${(window as any).__DEBUG_HITBOXES ? '–í–ö–õ' : '–í–´–ö–õ'}`);
        });
        addBtn('–ü—É—Ç–∏ –≤—Ä–∞–≥–æ–≤ –í–ö–õ/–í–´–ö–õ', 'üìç', () => {
            (window as any).__DEBUG_PATHS = !(window as any).__DEBUG_PATHS;
            Logger.info(LogChannel.SYSTEM, `–ü—É—Ç–∏: ${(window as any).__DEBUG_PATHS ? '–í–ö–õ' : '–í–´–ö–õ'}`);
        });
        addBtn('–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Ç–∫–∏ (SpatialGrid)', 'üìê', () => {
            const collision = this.scene.collision;
            // Provide empty array to getValidGrid to just get the grid state safely for dev console stats. 
            // Better yet, we can pass scene.enemies but in DevConsole we want minimal interference.
            const grid = collision?.getValidGrid(this.scene.enemies || []);
            if (grid?.getStats) {
                const stats = grid.getStats();
                Logger.info(LogChannel.SYSTEM, `SpatialGrid: ${stats.occupiedCells}/${stats.totalCells} —è—á–µ–µ–∫, ${stats.totalEntities} —Å—É—â–Ω–æ—Å—Ç–µ–π`);
            } else {
                Logger.warn(LogChannel.SYSTEM, 'SpatialGrid –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
            }
        });

        addHeader('üëæ –°–ü–ê–í–ù –í–†–ê–ì–û–í');
        ['GRUNT', 'SCOUT', 'TANK', 'BOSS', 'SKELETON_COMMANDER', 'TROLL_ARMORED', 'SKELETON_MINER'].forEach(type => {
            addBtn(`+ ${type}`, 'üëæ', () => {
                this.scene.spawnEnemy?.(type);
                Logger.info(LogChannel.GAME, `–°–ø–∞–≤–Ω ${type}`);
            });
        });
    }

    // === GRAPH DRAWING ===
    private updateGraph() {
        if (this.activeTab !== 'graph' || !this.isVisible) return;

        const stats = PerformanceMonitor.getAdvancedStats();
        this.fpsHistory.push(stats.fps);
        if (this.fpsHistory.length > 200) this.fpsHistory.shift();

        // Capture snapshot during FPS drops
        if (stats.fps < 30 && stats.fps > 0) {
            const lastSnapshot = this.frameSnapshots[this.frameSnapshots.length - 1];
            const now = new Date().toISOString().split('T')[1].slice(0, 12);
            // Only add if different from last (avoid spam)
            if (!lastSnapshot || lastSnapshot.fps !== stats.fps ||
                lastSnapshot.enemies !== (this.scene.enemies?.length || 0)) {
                this.frameSnapshots.push({
                    time: now,
                    fps: stats.fps,
                    enemies: this.scene.enemies?.length || 0,
                    projectiles: this.scene.projectiles?.length || 0,
                    effects: this.scene.effects?.getCount?.() || 0,
                    towers: this.scene.towers?.length || 0
                });
                if (this.frameSnapshots.length > 100) this.frameSnapshots.shift();
            }
        }

        // Update stats line
        const statsEl = document.getElementById('graph-stats');
        if (statsEl) {
            statsEl.innerText = `FPS: ${stats.fps} | –ú–∏–Ω: ${stats.minFps} | –ú–∞–∫—Å: ${stats.peakFps} | –°–ø–∞–π–∫–∏: ${stats.spikeCount} | –ü–∞–º—è—Ç—å: ${stats.memoryMB?.toFixed(1) || 'N/A'}MB`;
        }

        // Draw graph
        const ctx = this.graphCtx;
        const w = this.graphCanvas.width;
        const h = this.graphCanvas.height;

        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, w, h);

        // Grid lines
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        for (let y = 0; y <= 60; y += 15) {
            const py = h - (y / 60) * h;
            ctx.beginPath();
            ctx.moveTo(0, py);
            ctx.lineTo(w, py);
            ctx.stroke();
            ctx.fillStyle = '#444';
            ctx.font = '9px monospace';
            ctx.fillText(`${y}`, 2, py - 2);
        }

        // FPS line
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < this.fpsHistory.length; i++) {
            const x = (i / 200) * w;
            const y = h - Math.min(this.fpsHistory[i] / 60, 1) * h;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // 30 FPS warning line
        ctx.strokeStyle = '#f44';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(0, h - (30 / 60) * h);
        ctx.lineTo(w, h - (30 / 60) * h);
        ctx.stroke();
        ctx.setLineDash([]);

        // Event markers
        ctx.fillStyle = '#fc0';
        for (const marker of this.eventMarkers) {
            const x = (marker.frame / 200) * w;
            if (x >= 0 && x <= w) {
                ctx.beginPath();
                ctx.arc(x, 10, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Update event log
        const eventLog = document.getElementById('event-log');
        if (eventLog) {
            const recentLogs = Logger.getHistory().slice(-20);
            eventLog.innerHTML = recentLogs.map(e => {
                const time = new Date(e.timestamp).toISOString().split('T')[1].slice(0, 8);
                const color = e.level === LogLevel.ERROR ? '#f44' : e.level === LogLevel.WARN ? '#fc0' : '#888';
                return `<div style="color:${color}">[${time}] ${e.message.slice(0, 50)}</div>`;
            }).join('');
        }
    }

    // === FULL REPORT ===
    private generateFullReport() {
        const perf = PerformanceMonitor.getAdvancedStats();
        const now = Date.now();

        // Build timeline: FPS samples + events merged chronologically
        const timeline: { time: string; type: 'fps' | 'event'; fps?: number; msg?: string; level?: string }[] = [];

        // Add FPS history (approximate timestamps - 100ms intervals)
        for (let i = 0; i < this.fpsHistory.length; i++) {
            const msAgo = (this.fpsHistory.length - i) * 100;
            const time = new Date(now - msAgo).toISOString().split('T')[1].slice(0, 12);
            const fps = this.fpsHistory[i];
            // Only add significant FPS changes or drops
            if (i === 0 || Math.abs(fps - this.fpsHistory[i - 1]) > 5 || fps < 30) {
                timeline.push({ time, type: 'fps', fps });
            }
        }

        // Add events with timestamps
        const logs = Logger.getHistory().slice(-50);
        for (const log of logs) {
            const time = new Date(log.timestamp).toISOString().split('T')[1].slice(0, 12);
            timeline.push({
                time,
                type: 'event',
                msg: log.message.slice(0, 60),
                level: LogLevel[log.level]
            });
        }

        // Sort timeline chronologically
        timeline.sort((a, b) => a.time.localeCompare(b.time));

        // Create readable timeline string
        const timelineStr = timeline.slice(-40).map(t => {
            if (t.type === 'fps') {
                const bar = t.fps! < 30 ? 'üî¥' : t.fps! < 45 ? 'üü°' : 'üü¢';
                return `[${t.time}] ${bar} FPS: ${t.fps}`;
            } else {
                const icon = t.level === 'ERROR' ? '‚ùå' : t.level === 'WARN' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
                return `[${t.time}] ${icon} ${t.msg}`;
            }
        }).join('\n');

        // Summary stats
        const avgFps = this.fpsHistory.length > 0
            ? Math.round(this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length)
            : 0;
        const minFpsHistory = this.fpsHistory.length > 0 ? Math.min(...this.fpsHistory) : 0;
        const maxFpsHistory = this.fpsHistory.length > 0 ? Math.max(...this.fpsHistory) : 0;

        const report = `=== –û–¢–ß–Å–¢ –û –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò ===
–í—Ä–µ–º—è: ${new Date().toISOString()}
–í–µ—Ä—Å–∏—è: 1.4-alfa

üìä –°–í–û–î–ö–ê:
  –¢–µ–∫—É—â–∏–π FPS: ${perf.fps}
  1% Low: ${perf.onePercentLow}
  –°—Ä–µ–¥–Ω–∏–π FPS (–∏—Å—Ç–æ—Ä–∏—è): ${avgFps}
  –î–∏–∞–ø–∞–∑–æ–Ω FPS: ${minFpsHistory}-${maxFpsHistory}
  –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –∫–∞–¥—Ä–∞: ${perf.avgFrameTime.toFixed(2)}ms
  –•—É–¥—à–∏–π –∫–∞–¥—Ä: ${perf.worstFrameTime.toFixed(0)}ms
  –°–ø–∞–π–∫–∏ (<30 FPS): ${perf.spikeCount}
  –ü–∞–º—è—Ç—å: ${perf.memoryMB?.toFixed(1) || 'N/A'}MB

üéÆ –°–û–°–¢–û–Ø–ù–ò–ï –ò–ì–†–´:
  –í–æ–ª–Ω–∞: ${this.scene.wave}
  –î–µ–Ω—å–≥–∏: ${this.scene.money}
  –ñ–∏–∑–Ω–∏: ${this.scene.gameState?.lives}
  –í—Ä–∞–≥–æ–≤: ${this.scene.enemies?.length || 0}
  –ë–∞—à–µ–Ω: ${this.scene.towers?.length || 0}
  –°–Ω–∞—Ä—è–¥–æ–≤: ${this.scene.projectiles?.length || 0}
  –≠—Ñ—Ñ–µ–∫—Ç–æ–≤: ${this.scene.effects?.getCount?.() || 0}

üî¥ –°–ù–ê–ü–®–û–¢–´ –ü–†–ò –ü–ê–î–ï–ù–ò–ò FPS (<30):
${this.frameSnapshots.slice(-20).map(s =>
            `[${s.time}] FPS:${s.fps} | üëæ${s.enemies} –≤—Ä–∞–≥–æ–≤ | üí•${s.projectiles} —Å–Ω–∞—Ä—è–¥–æ–≤ | ‚ú®${s.effects} —ç—Ñ—Ñ–µ–∫—Ç–æ–≤`
        ).join('\n') || '(–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö - –Ω–µ –±—ã–ª–æ –ø–∞–¥–µ–Ω–∏–π FPS)'}

üìà TIMELINE (FPS + –°–æ–±—ã—Ç–∏—è):
${timelineStr}

=== –ö–û–ù–ï–¶ –û–¢–ß–Å–¢–ê ===`;

        navigator.clipboard.writeText(report);
        Logger.info(LogChannel.SYSTEM, `üìã –û—Ç—á—ë—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω (${report.length} —Å–∏–º–≤–æ–ª–æ–≤)`);
        console.log(report);
    }

    // === TAB SWITCHING ===
    private switchTab(tab: 'log' | 'graph' | 'cheats' | 'tests') {
        this.activeTab = tab;

        // Hide all
        (this.contentLog.parentElement as HTMLElement).style.display = 'none';
        this.contentGraph.style.display = 'none';
        this.contentCheats.style.display = 'none';
        this.contentTests.style.display = 'none';

        // Show selected
        if (tab === 'log') (this.contentLog.parentElement as HTMLElement).style.display = 'flex';
        if (tab === 'graph') this.contentGraph.style.display = 'flex';
        if (tab === 'cheats') this.contentCheats.style.display = 'block';
        if (tab === 'tests') this.contentTests.style.display = 'block';

        // Update tab button styles
        const buttons = this.container.querySelectorAll('button[data-tab]');
        buttons.forEach((btn: any) => {
            btn.style.color = btn.dataset.tab === tab ? '#fff' : '#888';
            btn.style.borderBottom = btn.dataset.tab === tab ? '2px solid #4caf50' : 'none';
        });
    }

    public toggle() {
        this.isVisible = !this.isVisible;
        this.container.style.display = this.isVisible ? 'flex' : 'none';

        if (this.isVisible) {
            this.refreshLogs();
            this.toggleBtn.style.background = 'rgba(0,0,0,0.8)';
            // Start graph updates
            if (!this.graphUpdateInterval) {
                this.graphUpdateInterval = setInterval(() => this.updateGraph(), 100);
            }
        } else {
            if (this.graphUpdateInterval) {
                clearInterval(this.graphUpdateInterval);
                this.graphUpdateInterval = null;
            }
        }
    }

    public destroy(): void {
        if (this.keyDownHandler) {
            window.removeEventListener('keydown', this.keyDownHandler);
        }
        if (this.graphUpdateInterval) {
            clearInterval(this.graphUpdateInterval);
        }
        if (this.stateUpdateInterval) {
            clearInterval(this.stateUpdateInterval);
        }
        this.container.remove();
        this.toggleBtn.remove();
    }

    private refreshLogs() {
        this.contentLog.innerHTML = '';
        Logger.getHistory().forEach(entry => this.appendLog(entry));
    }

    private appendLog(entry: LogEntry) {
        if (!this.isVisible) return;
        if (entry.level === LogLevel.INFO && !this.showInfo) return;
        if (entry.level === LogLevel.WARN && !this.showWarn) return;
        if (entry.level === LogLevel.ERROR && !this.showError) return;
        if (entry.level === LogLevel.VERBOSE && !this.showVerbose) return;

        const row = document.createElement('div');
        const time = new Date(entry.timestamp).toISOString().split('T')[1].slice(0, 8);
        let color = '#ccc';
        if (entry.level === LogLevel.WARN) color = '#fc0';
        if (entry.level === LogLevel.ERROR) color = '#f44';

        row.style.color = color;
        row.style.fontFamily = 'monospace';
        row.style.fontSize = '10px';
        row.style.padding = '2px 0';
        row.style.borderBottom = '1px solid #222';

        const countStr = entry.count > 1 ? ` <span style="background:#555; color:#fff; padding:0 4px; border-radius:4px;">x${entry.count}</span>` : '';
        row.innerHTML = `<span style="color:#666">[${time}]</span> ${entry.message}${countStr}`;

        this.contentLog.appendChild(row);
        if (this.autoScroll) this.contentLog.scrollTop = this.contentLog.scrollHeight;
    }
}
</file>

<file path="src/WaveEditor.ts">
import { IWaveConfig } from './MapData';
import { WaveModel } from './editor/WaveModel';
import { WaveList } from './editor/components/WaveList';
import { WavePresetPanel } from './editor/components/WavePresetPanel';
import { ValidationPanel } from './editor/components/ValidationPanel';
import './editor/editor.css';

export class WaveEditor {
    private container!: HTMLElement;
    private model: WaveModel;
    private waveList!: WaveList;
    private presetPanel!: WavePresetPanel;
    private validationPanel!: ValidationPanel;
    private onSave: (waves: IWaveConfig[]) => void;
    private onClose: () => void;

    // Toolbar elements (for updating disabled state)
    private undoBtn!: HTMLButtonElement;
    private redoBtn!: HTMLButtonElement;
    private statusBar!: HTMLElement;

    // Keyboard handler reference for cleanup
    private boundKeyHandler: (e: KeyboardEvent) => void;

    /**
     * @param initialWaves - The initial configuration of waves (will be copied)
     * @param onSave - Callback when user clicks Save
     * @param onClose - Callback when user clicks Cancel
     */
    constructor(initialWaves: IWaveConfig[], onSave: (waves: IWaveConfig[]) => void, onClose: () => void) {
        this.onSave = onSave;
        this.onClose = onClose;

        // Initialize Model with draft data
        this.model = new WaveModel(initialWaves);

        // Keyboard shortcuts
        this.boundKeyHandler = (e: KeyboardEvent) => {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                this.model.undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                this.model.redo();
            } else if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                this.save();
            }
        };
        document.addEventListener('keydown', this.boundKeyHandler);

        this.createUI();

        // Subscribe to model changes to re-render the list and update toolbar
        this.model.subscribe(() => {
            if (this.waveList) {
                this.waveList.render();
            }
            if (this.validationPanel) {
                this.validationPanel.updateResult(this.model.validateExtended());
            }
            this.updateToolbar();
        });
    }

    private createUI() {
        // 1. Overlay
        const overlay = document.createElement('div');
        overlay.className = 'wave-editor-overlay';

        // 2. Main Container (wider)
        this.container = document.createElement('div');
        this.container.className = 'wave-editor-container';

        // 3. Header
        const header = document.createElement('div');
        header.className = 'we-header';

        const headerLeft = document.createElement('div');
        headerLeft.innerHTML = `<h2>–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –í–æ–ª–Ω</h2>`;
        header.appendChild(headerLeft);

        // Toolbar: Undo / Redo
        const toolbar = document.createElement('div');
        toolbar.className = 'we-toolbar';

        this.undoBtn = document.createElement('button');
        this.undoBtn.className = 'we-btn we-btn-icon';
        this.undoBtn.textContent = '‚Ü©Ô∏è';
        this.undoBtn.title = '–û—Ç–º–µ–Ω–∏—Ç—å (Ctrl+Z)';
        this.undoBtn.disabled = true;
        this.undoBtn.onclick = () => this.model.undo();
        toolbar.appendChild(this.undoBtn);

        this.redoBtn = document.createElement('button');
        this.redoBtn.className = 'we-btn we-btn-icon';
        this.redoBtn.textContent = '‚Ü™Ô∏è';
        this.redoBtn.title = '–ü–æ–≤—Ç–æ—Ä–∏—Ç—å (Ctrl+Y)';
        this.redoBtn.disabled = true;
        this.redoBtn.onclick = () => this.model.redo();
        toolbar.appendChild(this.redoBtn);

        header.appendChild(toolbar);
        this.container.appendChild(header);

        // Add WavePresetPanel here
        this.presetPanel = new WavePresetPanel(this.model);
        this.presetPanel.mount(this.container);

        // Status Bar
        this.statusBar = document.createElement('div');
        this.statusBar.className = 'we-status-bar';
        this.container.appendChild(this.statusBar);
        this.updateToolbar(); // Initial status

        // 4. Content (The Wave List)
        const content = document.createElement('div');
        content.className = 'we-content';

        this.waveList = new WaveList(this.model);
        this.waveList.mount(content);

        this.container.appendChild(content);

        // Add Validation Panel here
        this.validationPanel = new ValidationPanel(this.model.validateExtended());
        this.validationPanel.mount(this.container);

        // 5. Footer (Buttons)
        const footer = document.createElement('div');
        footer.className = 'we-footer';

        const saveBtn = document.createElement('button');
        saveBtn.className = 'we-btn we-btn-primary';
        saveBtn.style.flex = '1';
        saveBtn.textContent = 'üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å';
        saveBtn.onclick = () => this.save();

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'we-btn we-btn-danger';
        cancelBtn.style.flex = '1';
        cancelBtn.textContent = '–û—Ç–º–µ–Ω–∞';
        cancelBtn.onclick = () => this.close();

        footer.appendChild(saveBtn);
        footer.appendChild(cancelBtn);
        this.container.appendChild(footer);

        // Mount Overlay to Body
        overlay.appendChild(this.container);
        document.body.appendChild(overlay);

        // Update reference to point to overlay for destruction
        this.container = overlay;
    }

    private updateToolbar() {
        // Undo/Redo button state
        if (this.undoBtn) this.undoBtn.disabled = !this.model.canUndo();
        if (this.redoBtn) this.redoBtn.disabled = !this.model.canRedo();

        // Status bar
        if (this.statusBar) {
            const waves = this.model.getWaves();
            const waveCount = waves.length;
            const totalEnemies = waves.reduce((sum, w) => sum + w.enemies.reduce((s, g) => s + g.count, 0), 0);
            let totalDuration = 0;
            for (let i = 0; i < waveCount; i++) {
                totalDuration += this.model.getEstimatedDuration(i);
            }
            this.statusBar.textContent = `–ß–µ—Ä–Ω–æ–≤–∏–∫ ‚Ä¢ ${waveCount} –≤–æ–ª–Ω ‚Ä¢ ${totalEnemies} –≤—Ä–∞–≥–æ–≤ ‚Ä¢ ~${totalDuration.toFixed(1)}—Å`;
        }
    }

    private save() {
        const result = this.model.validateExtended();
        if (!result.isValid) {
            this.validationPanel.updateResult(result);
            return;
        }
        this.onSave(this.model.getWaves());
        this.destroy();
    }

    private close() {
        this.onClose();
        this.destroy();
    }

    public destroy() {
        // Keyboard listener cleanup
        document.removeEventListener('keydown', this.boundKeyHandler);

        // Component Cleanup
        if (this.waveList) {
            this.waveList.destroy();
        }
        if (this.presetPanel) {
            this.presetPanel.destroy();
        }
        if (this.validationPanel) {
            this.validationPanel.destroy();
        }

        // Model Cleanup
        if (this.model) {
            this.model.destroy();
        }

        // DOM Cleanup
        if (this.container && this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
    }
}
</file>

<file path="src/index.ts">
import { Game } from './Game';
import { MapStorage } from './MapStorage';
import { CONFIG } from './Config';
import { CrashHandler } from './CrashHandler';

// Expose MapStorage to window for debugging
(window as any).MapStorage = MapStorage;

window.addEventListener('DOMContentLoaded', () => {
    new CrashHandler();

    const canvas = document.getElementById('game-canvas');
    if (!canvas) {
        console.error('‚ùå –û–®–ò–ë–ö–ê: Canvas –Ω–µ –Ω–∞–π–¥–µ–Ω!');
        return;
    }

    try {
        const game = new Game('game-canvas');
        game.start();

        // Theme Switcher Logic Removed (Ink Mode deprecated)
        const themeBtn = document.getElementById('theme-btn');
        if (themeBtn) {
            themeBtn.style.display = 'none'; // Hide the button
        }

        console.log('‚úÖ –ò–≥—Ä–∞ –≥–æ—Ç–æ–≤–∞. –ù–∞–∂–º–∏—Ç–µ ‚öîÔ∏è, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –≤–æ–ª–Ω—É.');
    } catch (e) {
        console.error('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞:', e);
    }
});
</file>

<file path="src/MapData.ts">
// –†–µ–∂–∏–º—ã –ø–æ—è–≤–ª–µ–Ω–∏—è –≤—Ä–∞–≥–æ–≤ –∏–∑ –ø–æ—Ä—Ç–∞–ª–∞
export type SpawnPattern = 'normal' | 'random' | 'swarm';

// Input format (from JSON/Editor/Config)
// This is lenient to allow legacy data and editor drafts
export interface IWaveGroupRaw {
    type: string;
    count: number;

    // Optional / Legacy fields
    baseInterval?: number;
    pattern?: SpawnPattern;
    spawnRate?: 'fast' | 'medium' | 'slow';
    spawnPattern?: SpawnPattern; // Alias for pattern, seen in some legacy data
    speed?: number; // Legacy multiplier, rarely used but present in old saves
    delayBefore?: number;   // Pause before this group spawns (seconds), default: 0
}

// Runtime format (Strictly normalized)
// Logic should ONLY use this interface
export interface IWaveGroup {
    type: string;
    count: number;
    baseInterval: number; // Always in seconds (e.g. 0.5)
    pattern: SpawnPattern;
}

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ–¥–Ω–æ–π –≤–æ–ª–Ω—ã
export interface IWaveConfig {
    // Configs can be raw, we normalize them at runtime
    enemies: IWaveGroupRaw[];
    name?: string;                              // Display name ("Boss Wave!")
    startDelay?: number;                        // Delay before wave starts (seconds)
    waitForClear?: boolean;                     // Block next wave until all enemies dead
    bonusReward?: number;                       // Extra gold for clearing this wave
    shuffleMode?: 'none' | 'within_group' | 'all'; // Spawn order control
}

// –ü–æ–ª–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
export interface IMapObject {
    type: string; // 'stone' | 'rock' | 'tree' | 'wheat' | 'flowers'
    x: number;
    y: number;
    properties?: Record<string, any>;
    size?: number; // –†–∞–∑–º–µ—Ä –æ–±—ä–µ–∫—Ç–∞ –≤ —Ç–∞–π–ª–∞—Ö (–¥–ª—è —Å–∫–∞–ª: 2 –∏–ª–∏ 3)
}

export interface Cell {
    type: number; // 0=Grass, 1=Path, 2=Decor
    x: number;
    y: number;
    decor?: string | null;
}

// –ü–æ–ª–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
export interface IMapData {
    width: number;
    height: number;
    tiles: number[][]; // 0=Grass, 1=Path, 2=Decor
    waypoints: { x: number; y: number }[];
    objects: IMapObject[];

    // –ù–æ–≤—ã–µ –ø–æ–ª—è (—Å—Ü–µ–Ω–∞—Ä–∏–π)
    waves?: IWaveConfig[];
    startingMoney?: number;
    startingLives?: number;
    manualPath?: boolean; // @deprecated use waypointsMode
    waypointsMode?: WaypointsMode; // Defines the source of truth for navigation
    fogData?: number[]; // ARRAY: fog density per tile (0=Visible, 1-5=Fog density 20%-100%)
    schemaVersion?: number;
}

export type WaypointsMode = 'ENDPOINTS' | 'FULLPATH';

// –ó–∞–≥–ª—É—à–∫–∞ (—á—Ç–æ–±—ã —Å—Ç–∞—Ä—ã–π –∫–æ–¥ –Ω–µ –ª–æ–º–∞–ª—Å—è, –µ—Å–ª–∏ –≥–¥–µ-—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)
export const DEMO_MAP: IMapData = {
    width: 10,
    height: 10,
    tiles: Array(10)
        .fill(0)
        .map(() => Array(10).fill(0)), // 10x10 Grass
    waypoints: [],
    objects: [],
    waves: [],
    startingMoney: 100,
    startingLives: 20,
    fogData: [],
};

export const MAP_SCHEMA_VERSION = 1;

/**
 * Validates and migrates raw map data from any source (localStorage, JSON import, etc.)
 * to the current IMapData format, filling in missing fields with safe defaults.
 * 
 * @throws Error if data is fundamentally broken (no tiles, wrong shape)
 */
export function migrateMapData(raw: unknown): IMapData {
    if (!raw || typeof raw !== 'object') {
        throw new Error('Map data is not an object');
    }

    const data = raw as Record<string, unknown>;

    // Required: tiles must be 2D number array
    if (!Array.isArray(data.tiles) || data.tiles.length === 0) {
        throw new Error('Map data missing tiles array');
    }

    const tiles = data.tiles as number[][];
    const height = tiles.length;
    const width = tiles[0]?.length ?? 0;
    if (width === 0) {
        throw new Error('Map data has empty tile rows');
    }

    const result: IMapData = {
        width: typeof data.width === 'number' ? data.width : width,
        height: typeof data.height === 'number' ? data.height : height,
        tiles,
        waypoints: Array.isArray(data.waypoints) ? data.waypoints : [],
        objects: Array.isArray(data.objects) ? (data.objects as IMapObject[]) : [],
        waves: Array.isArray(data.waves) ? (data.waves as IWaveConfig[]) : [],
        startingMoney: typeof data.startingMoney === 'number' ? data.startingMoney : 100,
        startingLives: typeof data.startingLives === 'number' ? data.startingLives : 20,
        waypointsMode: (data.waypointsMode === 'FULLPATH' || (data.waypointsMode === undefined && data.manualPath === true))
            ? 'FULLPATH'
            : 'ENDPOINTS',
        fogData: Array.isArray(data.fogData) ? (data.fogData as number[]) : [],
        schemaVersion: MAP_SCHEMA_VERSION,
    };

    // Sanitize new wave fields
    if (result.waves) {
        result.waves.forEach(w => {
            if (w.startDelay != null) w.startDelay = Math.max(0, w.startDelay);
            if (w.bonusReward != null) w.bonusReward = Math.max(0, w.bonusReward);
            if (w.enemies) {
                w.enemies.forEach(g => {
                    if (g.delayBefore != null) g.delayBefore = Math.max(0, g.delayBefore);
                    if (g.baseInterval != null) g.baseInterval = Math.max(0.05, g.baseInterval);
                });
            }
        });
    }

    return result;
}
</file>

<file path="src/ui/GameHUD.ts">
import { IGameScene } from '../scenes/IGameScene';
import { CONFIG } from '../Config';
import { UIUtils } from '../UIUtils';
import { EventBus, Events } from '../EventBus';
import { VISUALS } from '../VisualConfig';

export class GameHUD {
    private scene: IGameScene;

    private elMoney: HTMLElement;
    private elWave: HTMLElement;
    private elLives: HTMLElement;
    private elEnemyCounter: HTMLElement;
    private elForgeBtn: HTMLButtonElement;
    private elStartBtn: HTMLButtonElement;
    // private elPauseBtn: HTMLButtonElement; // REMOVED

    private boundStartWave: () => void;
    private boundForge: () => void;

    // Subscription Unsubscribers
    private unsubMoney: () => void = () => { };
    private unsubLives: () => void = () => { };
    private unsubWaveStart: () => void = () => { };
    private unsubWaveEnd: () => void = () => { };

    constructor(scene: IGameScene) {
        this.scene = scene;

        this.elMoney = document.getElementById('money')!;
        this.elWave = document.getElementById('wave')!;
        this.elLives = document.getElementById('lives')!;
        this.elEnemyCounter = document.getElementById('enemy-counter')!;
        this.elForgeBtn = document.getElementById('forge-btn') as HTMLButtonElement;
        this.elStartBtn = document.getElementById('start-wave-btn') as HTMLButtonElement;
        // Pause button removed

        // Bind callbacks
        this.boundStartWave = () => this.scene.waveManager.startWave();
        this.boundForge = () => this.handleForgeClick();

        this.initListeners();
        this.initSubscriptions();

        // Initial values
        this.updateMoney(this.scene.money);
        this.updateLives(this.scene.lives);
        this.updateWaveText(this.scene.wave);
    }

    private initListeners() {
        if (this.elStartBtn) this.elStartBtn.addEventListener('click', this.boundStartWave);
        if (this.elForgeBtn) this.elForgeBtn.addEventListener('click', this.boundForge);
    }

    private handleForgeClick() {
        // FIX: Use forge system
        if (!this.scene.forge || !this.scene.forge.canForge()) return;

        // Determine cost based on card level
        const card = this.scene.forge.forgeSlots[0];
        const forgeCost = card && card.level >= 2
            ? CONFIG.ECONOMY.FORGE_COST_LVL2
            : CONFIG.ECONOMY.FORGE_COST_LVL1;

        if (this.scene.money >= forgeCost) {
            this.scene.forge.tryForge();
            // Button state will update on next tick or via event if we add more events
        }
    }

    private initSubscriptions() {
        const bus = EventBus.getInstance();
        this.unsubMoney = bus.on(Events.MONEY_CHANGED, (money: number) => this.updateMoney(money));
        this.unsubLives = bus.on(Events.LIVES_CHANGED, (lives: number) => this.updateLives(lives));
        this.unsubWaveStart = bus.on(Events.WAVE_STARTED, (data: { wave: number; name?: string }) => {
            this.updateWaveText(data.wave);
            this.updateStartBtn(true);
        });
        this.unsubWaveEnd = bus.on(Events.WAVE_COMPLETED, () => this.updateStartBtn(false));
    }

    public destroy() {
        if (this.elStartBtn) this.elStartBtn.removeEventListener('click', this.boundStartWave);
        if (this.elForgeBtn) this.elForgeBtn.removeEventListener('click', this.boundForge);

        this.unsubMoney();
        this.unsubLives();
        this.unsubWaveStart();
        this.unsubWaveEnd();
    }

    private updateMoney(newMoney: number) {
        const current = parseInt(this.elMoney.innerText) || 0;

        // Gold Glow Animation
        if (newMoney > current) {
            const el = this.elMoney.parentElement || this.elMoney;
            el.classList.remove('hud-glow-gold');
            void el.offsetWidth; // Reflow to restart animation
            el.classList.add('hud-glow-gold');
            el.addEventListener('animationend', () => el.classList.remove('hud-glow-gold'), { once: true });

            // Keep legacy flash if needed, or remove. Let's keep for color tint.
            UIUtils.flashElement(el, VISUALS.UI.COLORS.success);
        } else if (newMoney < current) {
            UIUtils.flashElement(this.elMoney.parentElement || this.elMoney, VISUALS.UI.COLORS.danger);
        }

        this.elMoney.innerText = newMoney.toString();
        this.updateForgeBtn(newMoney);
    }

    private updateLives(newLives: number) {
        const current = parseInt(this.elLives.innerText) || 0;

        // Danger Pulse Animation
        if (newLives < current) {
            const el = this.elLives.parentElement || this.elLives;
            el.classList.remove('hud-pulse-danger');
            void el.offsetWidth;
            el.classList.add('hud-pulse-danger');
            el.addEventListener('animationend', () => el.classList.remove('hud-pulse-danger'), { once: true });

            UIUtils.flashElement(el, VISUALS.UI.COLORS.danger);
        }

        this.elLives.innerText = newLives.toString();
    }

    private updateWaveText(wave: number) {
        this.elWave.innerText = wave.toString();
    }

    public updateEnemyCounter(currentCount: number) {
        this.elEnemyCounter.innerText = currentCount.toString();
    }

    private updateStartBtn(isWaveActive: boolean) {
        if (isWaveActive) {
            this.elStartBtn.innerText = '>>'; // Fast forward / Next wave
            this.elStartBtn.disabled = false;
            this.elStartBtn.style.opacity = '1';
            this.elStartBtn.title = 'Start next wave early for bonus!';
        } else {
            this.elStartBtn.innerText = '‚öîÔ∏è';
            this.elStartBtn.disabled = false;
            this.elStartBtn.style.opacity = '1';
            this.elStartBtn.title = 'Start Wave';
        }
    }

    private updateForgeBtn(money: number) {
        const forgeSys = this.scene.forge;

        // Determine cost based on slot
        let forgeCost: number = CONFIG.ECONOMY.FORGE_COST_LVL1;
        if (forgeSys && forgeSys.forgeSlots[0] && forgeSys.forgeSlots[0].level >= 2) {
            forgeCost = CONFIG.ECONOMY.FORGE_COST_LVL2;
        }

        const canForge = forgeSys && forgeSys.canForge();
        const hasMoney = money >= forgeCost;

        if (canForge && hasMoney) {
            this.elForgeBtn.disabled = false;
            this.elForgeBtn.innerHTML = `<span>‚öíÔ∏è</span> ${forgeCost}üí∞`;
            this.elForgeBtn.style.opacity = '1';
        } else {
            this.elForgeBtn.disabled = true;
            if (!canForge) this.elForgeBtn.innerHTML = `<span>‚öíÔ∏è</span> –ö–æ–≤–∫–∞`;
            else if (!hasMoney) this.elForgeBtn.innerHTML = `<span>‚öíÔ∏è</span> ${forgeCost}üí∞`;
        }
    }

    // updatePauseBtn removed

    public update() {
        // Polling kept only for complex checks if needed, but currently mostly event driven.
        // Forge button might need polling if HAND changes without event.
        // Let's keep a light update for safety or refactor fully later.
        // For now, let's update ForgeBtn here to be safe as CardSystem doesn't emit events yet.
        if (!this.scene) return;
        this.updateForgeBtn(this.scene.money);

        // Also update start btn state just in case? Or rely on events.
        // Events should be enough for Start Btn.
        this.updateStartBtn(this.scene.waveManager.isWaveActive);
    }
}
</file>

<file path="src/ui/ShopUI.ts">
import { IGameScene } from '../scenes/IGameScene';
import { CONFIG } from '../Config';
import { EventBus, Events } from '../EventBus';
import { VISUALS } from '../VisualConfig';

export class ShopUI {
    private scene: IGameScene;

    private elShopBtn: HTMLButtonElement;
    private elRefreshBtn: HTMLButtonElement; // [NEW]
    private elSlotsContainer: HTMLElement;

    private shopCards: string[] = [];
    private selectedSlot: number = -1;

    public readonly cost: number = 100;
    public readonly refreshCost: number = CONFIG.ECONOMY.SHOP_REROLL_COST; // [NEW]

    private boundBuy: () => void;
    private boundRefresh: () => void;
    private boundMoneyChanged: (money: number) => void;
    private unsubMoney: () => void = () => { };

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.elShopBtn = document.getElementById('shop-btn') as HTMLButtonElement;
        this.elRefreshBtn = document.getElementById('shop-refresh-btn') as HTMLButtonElement; // [NEW]
        this.elSlotsContainer = document.getElementById('shop-slots')!;

        // Bind callbacks
        this.boundBuy = () => this.buySelectedCard();
        this.boundRefresh = () => this.rerollWithCost();
        this.boundMoneyChanged = () => this.update();

        this.initListeners();
        this.rerollShop();
    }

    private initListeners() {
        if (this.elShopBtn) this.elShopBtn.addEventListener('click', this.boundBuy);
        if (this.elRefreshBtn) this.elRefreshBtn.addEventListener('click', this.boundRefresh);

        this.unsubMoney = EventBus.getInstance().on(Events.MONEY_CHANGED, this.boundMoneyChanged);
    }

    public destroy() {
        if (this.elShopBtn) this.elShopBtn.removeEventListener('click', this.boundBuy);
        if (this.elRefreshBtn) this.elRefreshBtn.removeEventListener('click', this.boundRefresh);

        this.unsubMoney();
    }

    public rerollWithCost() {
        if (this.scene.money < this.refreshCost) {
            this.scene.showFloatingText('Not enough gold!', 800, 800, 'red');
            return;
        }

        if (this.scene.spendMoney(this.refreshCost)) {
            this.scene.metrics.trackMoneySpent(this.refreshCost);
            this.scene.showFloatingText(`- ${this.refreshCost}üí∞`, 800, 800, 'gold');
            this.rerollShop();

            // Anim refresh
            this.elRefreshBtn.classList.add('shaking');
            setTimeout(() => this.elRefreshBtn.classList.remove('shaking'), 500);
        }
    }

    public rerollShop() {
        this.shopCards = [];
        const allKeys = Object.keys(CONFIG.CARD_TYPES);

        // IMPROVED: Ensure diversity - no duplicates if possible
        const shuffled = [...allKeys].sort(() => Math.random() - 0.5);
        for (let i = 0; i < 3; i++) {
            this.shopCards.push(shuffled[i % shuffled.length]);
        }

        this.selectedSlot = -1;
        this.render();
    }

    private getRandomCardKey(): string {
        const keys = Object.keys(CONFIG.CARD_TYPES);
        return keys[Math.floor(Math.random() * keys.length)];
    }

    public selectSlot(index: number) {
        if (index < 0 || index >= this.shopCards.length) return;

        if (this.selectedSlot === index) {
            this.selectedSlot = -1;
        } else {
            this.selectedSlot = index;
        }
        this.render();
        this.update();
    }

    public buySelectedCard() {
        if (this.selectedSlot === -1) return;

        if (this.scene.money < this.cost) {
            this.scene.showFloatingText('–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –∑–æ–ª–æ—Ç–∞!', 800, 800, 'red');
            return;
        }

        if (this.scene.cardSys.hand.length >= CONFIG.PLAYER.HAND_LIMIT) {
            this.scene.showFloatingText('–†—É–∫–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∞!', 800, 800, 'orange');
            return;
        }

        if (!this.scene.spendMoney(this.cost)) {
            this.scene.showFloatingText('Error: Transaction Failed', 800, 800, 'red');
            return;
        }
        this.scene.metrics.trackMoneySpent(this.cost);

        const cardKey = this.shopCards[this.selectedSlot];
        this.scene.cardSys.addCard(cardKey, 1);

        this.scene.effects.add({
            type: 'text',
            text: `- ${this.cost}üí∞`,
            x: this.scene.game.width - 200,
            y: this.scene.game.height - 100,
            life: 60,
            color: 'gold',
            vy: -1,
        });

        this.shopCards[this.selectedSlot] = this.getRandomCardKey();
        this.selectedSlot = -1;

        this.render();
        this.update();
    }

    public update() {
        this.elShopBtn.innerHTML = `<span>üõí</span> ${this.cost}üí∞`;

        const canAfford = this.scene.money >= this.cost;
        const hasSelection = this.selectedSlot !== -1;

        if (canAfford && hasSelection) {
            this.elShopBtn.disabled = false;
            this.elShopBtn.style.opacity = '1';
            this.elShopBtn.style.cursor = 'pointer';
        } else {
            this.elShopBtn.disabled = true;
            this.elShopBtn.style.opacity = '0.5';
            this.elShopBtn.style.cursor = 'not-allowed';
        }

        // Refresh Btn State
        this.elRefreshBtn.innerHTML = `‚Üª ${this.refreshCost}üí∞`; // NEW: Update text dynamically
        if (this.scene.money >= this.refreshCost) {
            this.elRefreshBtn.disabled = false;
            this.elRefreshBtn.style.opacity = '1';
            this.elRefreshBtn.style.cursor = 'pointer';
        } else {
            this.elRefreshBtn.disabled = true;
            this.elRefreshBtn.style.opacity = '0.5';
            this.elRefreshBtn.style.cursor = 'not-allowed';
        }
    }

    private render() {
        this.elSlotsContainer.innerHTML = '';

        this.shopCards.forEach((key, idx) => {
            const typeConfig = CONFIG.CARD_TYPES[key];

            // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å–ª–æ—Ç–∞
            const slot = document.createElement('div');
            slot.className = 'slot shop-slot';

            // --- –í–ò–ó–£–ê–õ–¨–ù–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï ---
            // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É –≤–Ω—É—Ç—Ä–∏, —Ç–æ—á–Ω–æ —Ç–∞–∫—É—é –∂–µ, –∫–∞–∫ –≤ —Ä—É–∫–µ
            const cardVisual = document.createElement('div');
            cardVisual.className = `card type-${typeConfig.id} level-1`;
            // –£–±–∏—Ä–∞–µ–º pointer-events, —á—Ç–æ–±—ã –∫–ª–∏–∫ –ø—Ä–æ—Ö–æ–¥–∏–ª —Å–∫–≤–æ–∑—å –∫–∞—Ä—Ç—É –Ω–∞ —Å–ª–æ—Ç
            cardVisual.style.pointerEvents = 'none';

            // Get stats HTML for level 1
            const statsHTML = this.getCardStatsHTML(typeConfig.id);

            // –í –º–∞–≥–∞–∑–∏–Ω–µ –º—ã –ø—Ä–æ–¥–∞–µ–º –∫–∞—Ä—Ç—ã 1 —É—Ä–æ–≤–Ω—è
            cardVisual.innerHTML = `
                <div class="card-level">‚òÖ</div>
                <div class="card-icon">${typeConfig.icon}</div>
                <div class="card-stats">${statsHTML}</div>
            `;

            slot.appendChild(cardVisual);
            // -----------------------------

            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞
            if (this.selectedSlot === idx) {
                slot.classList.add('selected');
            } else {
                slot.classList.remove('selected');
            }

            // Clean inline styles that might persist if we swapped logic
            // slot.style.border = '';
            // slot.style.boxShadow = '';
            // slot.style.background = '';

            slot.style.cursor = 'pointer';
            slot.onclick = () => this.selectSlot(idx);

            this.elSlotsContainer.appendChild(slot);
        });
    }

    private getCardStatsHTML(typeId: string): string {
        // Same logic as CardSystem, but always level 1
        switch (typeId) {
            case 'fire':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +15</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 50</div>`;
            case 'ice':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +3</div><div class="card-stat-line">‚ùÑÔ∏è 30%</div>`;
            case 'sniper':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +14</div><div class="card-stat-line">üéØ +80</div>`;
            case 'multi':
                return `<div class="card-stat-primary">2 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.8x —É—Ä–æ–Ω</div>`;
            case 'minigun':
                return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+3 —É—Ä–æ–Ω/—Å</div>`;
            default:
                return `<div class="card-stat-line">–ö–∞—Ä—Ç–∞</div>`;
        }
    }
}
</file>

<file path="src/UIManager.ts">
import { IGameScene } from './scenes/IGameScene';
import { GameHUD } from './ui/GameHUD';
import { PauseMenu } from './ui/PauseMenu';
import { GameOverUI } from './ui/GameOverUI';
import { ShopUI } from './ui/ShopUI';

export type UIMode = 'menu' | 'game' | 'gameOver';

export class UIManager {
    private scene: IGameScene;

    public currentMode: UIMode = 'menu';

    // Components
    public shop: ShopUI;
    public hud: GameHUD;
    public pauseMenu: PauseMenu;
    public gameOver: GameOverUI;

    // –°—Å—ã–ª–∫–∏ –Ω–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã –¥–ª—è —Å–∫—Ä—ã—Ç–∏—è/–ø–æ–∫–∞–∑–∞
    private elHandContainer: HTMLElement;
    private elUiLayer: HTMLElement;

    constructor(scene: IGameScene) {
        this.scene = scene;

        // Init Components
        this.shop = new ShopUI(scene);
        this.hud = new GameHUD(scene);
        console.log('‚ú® UIManager: Initializing PauseMenu...');
        this.pauseMenu = new PauseMenu(scene);
        this.gameOver = new GameOverUI(scene);

        // Containes via UIRoot
        this.elHandContainer = this.scene.game.uiRoot.getLayer('hand');
        this.elUiLayer = this.scene.game.uiRoot.getLayer('ui');
    }

    public updatePauseMenu(paused: boolean) {
        this.pauseMenu.update(paused);
    }

    // --- –ù–û–í–´–ï –ú–ï–¢–û–î–´ –£–ü–†–ê–í–õ–ï–ù–ò–Ø –í–ò–î–ò–ú–û–°–¢–¨–Æ ---
    public setMode(mode: UIMode) {
        this.currentMode = mode;

        switch (mode) {
            case 'menu':
                this.hide();
                break;
            case 'game':
                this.show();
                break;
            case 'gameOver':
                // Handled in showGameOver mostly, but ensure overlays
                this.elUiLayer.style.display = 'block';
                this.elHandContainer.style.display = 'none'; // Hide hand on game over
                break;
        }
    }

    private show() {
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–≥—Ä–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
        this.elUiLayer.style.display = 'block';
        this.elHandContainer.style.display = 'block';
        // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ Game Over —Å–∫—Ä—ã—Ç –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
        this.gameOver.hide();
        this.update();
    }

    public hide() {
        // –ü—Ä—è—á–µ–º –≤—Å—ë –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –≤ –º–µ–Ω—é –∏–ª–∏ —Ä–µ–¥–∞–∫—Ç–æ—Ä
        this.elUiLayer.style.display = 'none';
        this.elHandContainer.style.display = 'none';
        this.gameOver.hide();
    }
    // ------------------------------------------

    public showGameOver(wave: number) {
        this.setMode('gameOver');
        this.gameOver.show(wave);
    }

    public hideGameOver() {
        this.gameOver.hide();
    }

    public update() {
        if (!this.scene) return;

        this.hud.update();
        this.shop.update();
    }

    public destroy() {
        // Destroy components to clean up listeners
        if (this.shop) this.shop.destroy();
        if (this.hud) this.hud.destroy();
        if (this.gameOver) this.gameOver.dispose();

        // Clear dynamic UI layers (hand), but KEEP static UI layer (HUD/Shop structure)
        if (this.scene && this.scene.game && this.scene.game.uiRoot) {
            // this.scene.game.uiRoot.clearLayer('ui'); // DO NOT CLEAR STATIC UI
            this.scene.game.uiRoot.clearLayer('hand');
            this.scene.game.uiRoot.clearLayer('tooltip');
        }
    }
}
</file>

<file path="src/renderers/TowerRenderer.ts">
import { Assets } from '../Assets';
import { CONFIG } from '../Config';
import { VISUALS } from '../VisualConfig';
import type { Tower } from '../Tower';
import { getTurretRenderer } from './turrets';

export class TowerRenderer {
    static drawSprite(ctx: CanvasRenderingContext2D, tower: Tower) {
        const size = CONFIG.TILE_SIZE;
        const drawX = (tower.col * size) | 0;
        const drawY = (tower.row * size) | 0;

        if (tower.isBuilding) {
            TowerRenderer.drawBuildingSprite(ctx, tower, drawX, drawY, size);
        } else {
            TowerRenderer.drawActiveSprite(ctx, tower, size);
        }
    }

    static drawUI(ctx: CanvasRenderingContext2D, tower: Tower) {
        const size = CONFIG.TILE_SIZE;
        const drawX = (tower.col * size) | 0;
        const drawY = (tower.row * size) | 0;

        if (tower.isBuilding) {
            TowerRenderer.drawBuildingUI(ctx, tower, drawX, drawY, size);
        } else {
            // Overheat bar for Minigun
            let turretName = 'turret_standard';
            const mainCard = tower.cards[0];
            if (mainCard && mainCard.type.id === 'minigun') turretName = 'turret_minigun';

            if (turretName === 'turret_minigun' && tower.spinupTime > 0) {
                TowerRenderer.drawOverheatBar(ctx, tower);
            }
        }
    }

    static drawPreview(ctx: CanvasRenderingContext2D, x: number, y: number, cardId?: string) {
        ctx.globalAlpha = 0.5;
        // Draw Base
        const baseImg = Assets.get('base_default');
        if (baseImg) {
            ctx.drawImage(baseImg, x - 32, y - 32);
        } else {
            ctx.fillStyle = VISUALS.TOWER.BASE_COLOR;
            ctx.beginPath();
            ctx.arc(x, y, 22, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw Turret (if card selected)
        if (cardId) {
            const renderer = getTurretRenderer(cardId);
            const turretImg = Assets.get(renderer.getTurretAsset(1));

            // Should also draw preview modules? Maybe too much detail.
            // Just draw the main turret for now.
            if (turretImg) {
                // Determine scale based on... level 1 for preview
                ctx.drawImage(turretImg, x - 32, y - 32);
            }

            // Draw range circle in preview?
            // Already handled by UI usually, but good to ensure visual clarity
        }
        ctx.globalAlpha = 1.0;
    }


    private static drawBuildingSprite(ctx: CanvasRenderingContext2D, tower: Tower, drawX: number, drawY: number, size: number) {
        // ... existing building sprite logic ...
        // Enhanced building animation - base emerges from below with opacity
        const pct = tower.buildProgress / tower.maxBuildProgress;
        const emergeOffset = (1 - pct) * 15; // Starts 15px below, rises to 0
        const halfSize = size / 2;

        ctx.save();

        // Clip to only show portion based on progress (reveal from bottom)
        ctx.beginPath();
        const clipHeight = size * pct;
        ctx.rect(drawX, drawY + size - clipHeight - emergeOffset, size, clipHeight + 5);
        ctx.clip();

        // Draw actual base with reduced opacity
        ctx.globalAlpha = 0.5 + pct * 0.5; // 50% -> 100% opacity
        const baseImg = Assets.get('base_default');
        if (baseImg) {
            ctx.drawImage(baseImg, drawX, drawY - emergeOffset);
        } else {
            // Fallback circle
            ctx.fillStyle = VISUALS.TOWER.BASE_COLOR;
            ctx.beginPath();
            ctx.arc(tower.x, tower.y - emergeOffset, size * 0.35, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();

        // Holographic construction lines overlay
        ctx.save();
        ctx.globalAlpha = 0.3 * (1 - pct); // Fade out as progress increases
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(tower.x, tower.y, size * 0.35, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }

    private static drawBuildingUI(ctx: CanvasRenderingContext2D, tower: Tower, drawX: number, drawY: number, size: number) {
        // ... existing building UI logic ...
        // Progress bar
        const pct = tower.buildProgress / tower.maxBuildProgress;
        const barWidth = size - 10;
        ctx.fillStyle = VISUALS.TOWER.BUILDING.BAR_BG;
        ctx.fillRect(drawX + 5, drawY + size - 10, barWidth, 5);
        ctx.fillStyle = '#4caf50'; // Green progress
        ctx.fillRect(drawX + 5, drawY + size - 10, barWidth * pct, 5);
    }

    private static drawActiveSprite(ctx: CanvasRenderingContext2D, tower: Tower, size: number) {
        // 0. Draw Shadow (Phase 3: Visual Polish)
        ctx.save();
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(tower.x + 3, tower.y + 5, 22, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // 1. Draw Base (Static - NO Rotation, NO Recoil)
        const halfSize = size / 2;
        const baseImg = Assets.get('base_default');
        if (baseImg) {
            ctx.drawImage(baseImg, tower.x - halfSize, tower.y - halfSize);
        }

        // 2. Get turret renderer via Strategy Pattern
        const mainCard = tower.cards[0];
        const renderer = getTurretRenderer(mainCard?.type.id || 'default');

        // Progressive scaling based on HIGHEST card level
        const cardLevel = tower.cards.length > 0
            ? Math.max(...tower.cards.map(c => c.level))
            : 1;

        const turretName = renderer.getTurretAsset(cardLevel);

        // 3. Draw Turret (Rotated + Recoiled)
        const turretImg = Assets.get(turretName);
        if (turretImg) {
            ctx.save();
            ctx.translate(tower.x, tower.y);

            // Apply rotation
            // For Minigun, we might have additional barrel rotation? 
            // Usually minigun barrels spin AROUND the aim axis.
            // But this is top-down 2D. 
            // So 'barrelRotation' might effectively just be 'angle' if we want the whole gun to spin?
            // No, minigun barrels spin around the central axis.
            // Visually in 2D top down, this might look like the sprite switching frames OR
            // just blurring.
            // For now, standard rotation towards target:
            ctx.rotate(tower.angle);

            const scaleMultiplier = 1.0 + ((cardLevel - 1) * 0.15);
            ctx.scale(scaleMultiplier, scaleMultiplier);

            // Apply Barrel Recoil (Kickback)
            // Move along the negative X axis (since we are rotated, X is "forward")
            // Wait, standard canvas rotation: 0 is right (East).
            // So translates X moves forward/back.
            // Apply Barrel Recoil (Kickback)
            if (tower.barrelRecoil) {
                ctx.translate(tower.barrelRecoil, 0);
            }

            // Draw turret body
            if (renderer.drawTurret) {
                // Custom renderer handles the turret body + moving parts
                renderer.drawTurret(ctx, tower);
            } else {
                // Standard Sprite Drawing
                ctx.drawImage(turretImg, -halfSize, -halfSize);
            }

            // 4. Draw Modules (Attachments) - Attached to turret body?
            // If modules are attached to the rotating turret (like side-mounted guns), draw here.
            // If they are on the base, draw before.
            // Current design: Modules are ON the turret.
            TowerRenderer.drawModules(ctx, tower);

            // 5. Draw turret-specific effects (laser, heat haze)
            // Called INSIDE rotated+recoiled context so effects move with barrel
            if (renderer.drawEffects) {
                renderer.drawEffects(ctx, tower);
            }

            ctx.restore();

            // Level-based visual effects (outside rotation context, e.g. auras)
            TowerRenderer.drawLevelVisuals(ctx, tower, cardLevel, mainCard);
        }
    }

    // Cache for module shapes to avoid re-drawing vectors every frame
    private static moduleCache: Record<string, HTMLCanvasElement> = {};

    private static getModuleImage(type: string, color: string): HTMLCanvasElement {
        const key = `${type}_${color}`;
        if (this.moduleCache[key]) return this.moduleCache[key];

        const canvas = document.createElement('canvas');
        canvas.width = 12;
        canvas.height = 12;
        const ctx = canvas.getContext('2d');
        if (!ctx) return canvas;

        const cx = 6;
        const cy = 6;

        ctx.fillStyle = color;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;

        ctx.beginPath();
        switch (type) {
            case 'fire': // Circle
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                break;
            case 'ice': // Diamond
                ctx.moveTo(cx, cy - 5);
                ctx.lineTo(cx + 5, cy);
                ctx.lineTo(cx, cy + 5);
                ctx.lineTo(cx - 5, cy);
                ctx.closePath();
                break;
            case 'sniper': // Triangle
                ctx.moveTo(cx + 5, cy);
                ctx.lineTo(cx - 4, cy - 4);
                ctx.lineTo(cx - 4, cy + 4);
                ctx.closePath();
                break;
            case 'multi': // Hexagon (Split)
                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3;
                    const vx = cx + Math.cos(angle) * 4;
                    const vy = cy + Math.sin(angle) * 4;
                    if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                }
                ctx.closePath();
                break;
            case 'minigun': // Square
                ctx.rect(cx - 4, cy - 4, 8, 8);
                break;
            default: // Small circle default
                ctx.arc(cx, cy, 3, 0, Math.PI * 2);
        }
        ctx.fill();
        ctx.stroke();

        this.moduleCache[key] = canvas;
        return canvas;
    }

    private static drawModules(ctx: CanvasRenderingContext2D, tower: Tower) {
        tower.cards.forEach((card, index) => {
            if (index > 0) {
                // Determine position
                let offX = 0;
                let offY = 0;
                if (index === 1) { offX = -5; offY = 12; }
                else if (index === 2) { offX = -5; offY = -12; }
                else { offX = -12; offY = 0; }

                // PERF: Use cached image
                const img = this.getModuleImage(card.type.id, card.type.color);
                // Center the 12x12 image
                ctx.drawImage(img, (offX - 6) | 0, (offY - 6) | 0);
            }
        });
    }

    private static drawLevelVisuals(ctx: CanvasRenderingContext2D, tower: Tower, visualLevel: number, mainCard: any) {
        if (visualLevel > 1) {
            ctx.save();
            ctx.translate(tower.x, tower.y);

            if (visualLevel === 2) {
                // LVL 2: Pulse Glow
                // LVL 2: Pulse Glow
                const pulse = 0.3 + Math.sin(performance.now() * 0.003) * 0.1;
                const cardColor = mainCard?.type.color || '#fff';

                ctx.globalAlpha = pulse;
                ctx.fillStyle = cardColor;
                ctx.beginPath();
                ctx.arc(0, 0, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            } else if (visualLevel === 3) {
                // LVL 3: Rotating Aura Ring
                const rotation = (performance.now() * 0.002) % (Math.PI * 2);
                const cardColor = mainCard?.type.color || '#fff';
                ctx.strokeStyle = cardColor;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;

                // Draw rotating arc segments
                for (let i = 0; i < 3; i++) {
                    const angle = rotation + (i * Math.PI * 2 / 3);
                    ctx.beginPath();
                    ctx.arc(0, 0, 28, angle, angle + Math.PI / 3);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1.0;
            }

            // Level counter badge
            ctx.fillStyle = '#ffd700'; // Gold
            ctx.font = 'bold 14px Arial';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            // PERF: cached string or simple cast
            const levelStr = visualLevel.toString();
            ctx.strokeText(levelStr, 20, -20);
            ctx.fillText(levelStr, 20, -20);

            ctx.restore();
        }
    }

    private static drawOverheatBar(ctx: CanvasRenderingContext2D, tower: Tower) {
        // Calculate percentage
        let pct = 0;

        if (tower.isOverheated) {
            // During overheat, show REVERSE progress (draining)
            // If totalOverheatDuration is 0 (shouldn't happen), avoid divide by zero
            const totalDur = tower.totalOverheatDuration || 1.5;
            pct = tower.overheatCooldown / totalDur;
        } else {
            // Normal heating up
            const maxTime = tower.maxHeat || 5;
            pct = tower.spinupTime / maxTime;
        }

        if (pct > 1) pct = 1;
        if (pct < 0) pct = 0;

        const barW = 6; // Slightly wider (was 4)
        const barH = 24; // Taller (was 20)
        const barX = tower.x + 22; // Right of tower
        const barY = tower.y - 12;

        // Bg
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(barX, barY, barW, barH);

        // Border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barW, barH);

        // Fill Logic
        if (tower.isOverheated) {
            // Flashing Red/Orange indicating danger/lockout
            const flash = Math.floor(Date.now() / 100) % 2 === 0;
            ctx.fillStyle = flash ? '#ff4400' : '#ff8800';
        } else {
            // Check if Cooling (No target, spinupTime > 0)
            // Ideally we'd pass a "isCooling" flag, but we can infer it if heat is decreasing.
            // However, TowerRenderer is static. 
            // Let's use blue tint if heat is not full and likely cooling? 
            // Actually, we don't know if it's cooling just by state here.
            // But we can check if it has a target in Tower? No.
            // Let's just keep the Red/Green gradient but maybe add a blue border if cooling?
            // Actually, user complained about "no animation of cooling".
            // The bar shrinking IS the animation.
            // Maybe they want the BAR COLOR to trigger "Cooling".
            // In WeaponSystem, when cooling, we reduce spinupTime.

            // Gradient Green -> Yellow -> Red
            if (pct < 0.5) {
                const r = Math.floor(255 * (pct * 2));
                ctx.fillStyle = `rgb(${r},255,0)`;
            } else {
                const g = Math.floor(255 * (2 - pct * 2));
                ctx.fillStyle = `rgb(255,${g},0)`;
            }
        }

        // Draw from bottom up
        const fillH = barH * pct;
        ctx.fillRect(barX + 1, barY + (barH - fillH) - 1, barW - 2, fillH);
    }
    static update(dt: number, tower: Tower) {
        if (tower.cards.length > 0) {
            const renderer = getTurretRenderer(tower.cards[0].type.id);
            if (renderer.update) {
                renderer.update(dt, tower);
            }
        }
    }
}
</file>

<file path="src/scenes/GameController.ts">
import { ICard } from '../CardSystem';
import { CONFIG } from '../Config';
import { Tower } from '../Tower';
import { GameState } from './GameState';
import { EntityManager } from './EntityManager';
import { EffectSystem } from '../EffectSystem';
import { InspectorSystem } from '../InspectorSystem';
import { UIManager } from '../UIManager';
import { MetricsSystem } from '../MetricsSystem';
import { IMapData } from '../MapData';
import { EventEmitter } from '../Events';
import { SoundManager } from '../SoundManager';
import { EventBus, Events } from '../EventBus';

/**
 * Handles user actions and game controller logic:
 * - Tower building/selection
 * - Card drop handling
 * - Grid click handling
 * - Keyboard hotkeys
 */
export class GameController {
    private recentActionIds: Set<string> = new Set();
    private unsubCardDrop: () => void = () => { };

    // Bound handler for safe unsubscription
    private onCardDropped = (data: any) => {
        if (data.actionId) {
            if (this.recentActionIds.has(data.actionId)) {
                console.warn(`Duplicate card action detected: ${data.actionId}`);
                return;
            }
            this.recentActionIds.add(data.actionId);
            if (this.recentActionIds.size > 256) {
                const first = this.recentActionIds.values().next().value;
                if (first) this.recentActionIds.delete(first);
            }
        }
        this.handleCardDrop(data.card, data.x, data.y);
    };

    constructor(
        private state: GameState,
        private entityManager: EntityManager,
        private effects: EffectSystem,
        private inspector: InspectorSystem,
        private ui: UIManager,
        private metrics: MetricsSystem,
        private mapData: IMapData,
        private map: any, // MapManager reference (using any to avoid types circle for now or need import)
        private isBuildable: (col: number, row: number) => boolean,
        private cardSys: any, // CardSystem reference
        private events: EventEmitter,
    ) {
        this.unsubCardDrop = EventBus.getInstance().on(Events.CARD_DROPPED, this.onCardDropped);
    }

    public dispose(): void {
        this.unsubCardDrop();
    }

    public handleMenuAction(action: { type: 'UNLOCK' | 'CLICK_SLOT' | 'REMOVE_CARD', slotId: number }, tower: Tower) {
        if (action.type === 'UNLOCK') {
            const cost = CONFIG.ECONOMY.SLOT_UNLOCK_COST[action.slotId];
            if (this.state.money >= cost) {
                if (tower.unlockSlot(action.slotId)) {
                    this.state.spendMoney(cost);
                    this.showFloatingText('Slot Unlocked!', tower.x, tower.y, '#ffd700');
                    SoundManager.play('upgrade_unlock');
                }
            } else {
                this.showFloatingText('Not enough money!', tower.x, tower.y, '#ff4444');
                SoundManager.play('error');
            }
        } else if (action.type === 'REMOVE_CARD') {
            // Immediate removal (used by Inspector) -> SELLS the card
            const slot = tower.slots.find(s => s.id === action.slotId);
            if (slot && slot.card) {
                const card = tower.removeCardFromSlot(action.slotId);
                if (card) {
                    // SELL LOGIC
                    const prices = CONFIG.ECONOMY.CARD_SELL_PRICES;
                    const refund = prices[card.level] || 5;
                    this.state.addMoney(refund);

                    this.showFloatingText(`+${refund}üí∞`, tower.x, tower.y, 'gold');
                    SoundManager.play('ui_click');

                    tower.selectedSlotId = -1;

                    // CRITICAL: Refresh Inspector to show empty slot immediately
                    this.inspector.selectTower(tower);
                }
            }
        } else if (action.type === 'CLICK_SLOT') {
            // First click selects the slot
            if (tower.selectedSlotId !== action.slotId) {
                tower.selectedSlotId = action.slotId;
                // Optional: Sound for selection
                // TODO: Add slot selection sound if needed
            } else {
                // Second click on SAME slot -> Action (Remove Card)
                // Only if there is a card
                const slot = tower.slots.find(s => s.id === action.slotId);
                if (slot && slot.card) {
                    const card = tower.removeCardFromSlot(action.slotId);
                    if (card) {
                        this.cardSys.addCardWithEvolution(card.type.id, card.level, card.evolutionPath);
                        this.showFloatingText('Card Removed', tower.x, tower.y, '#fff');
                        tower.selectedSlotId = -1; // Reset selection after action
                    }
                } else {
                    // Clicking empty selected slot again - maybe Deselect?
                    tower.selectedSlotId = -1;
                }
            }
        }
        this.ui.update();
    }

    private lastErrorTime: number = 0;

    // === Tower Building ===

    public startBuildingTower(col: number, row: number): void {
        const screenX = col * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const screenY = row * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;



        const validation = this.entityManager.canBuildTower(col, row, this.mapData, this.isBuildable);

        if (this.map.flowField) {
            // Retrieve spawn points from map waypoints (usually first point is spawn)
            // But we might need all spawns if multiple.
            // For now, assuming first waypoint is spawn. 
            const spawns = this.map.waypoints.length > 0 ? [this.map.waypoints[0]] : [];

            // Check if blocking
            const isSafe = this.map.flowField.checkBuildability(this.map.grid, col, row, spawns);
            if (!isSafe) {
                this.showFloatingText("Path Blocked!", screenX, screenY, 'red');
                return;
            }
        }

        if (!validation.valid) {
            // Debounce error text to prevent infinite spam
            const now = Date.now();
            if (now - this.lastErrorTime > 500) {
                this.showFloatingText(validation.reason!, screenX, screenY, 'red');
                this.lastErrorTime = now;
            }
            return;
        }

        const tower = this.entityManager.buildTower(col, row);
        this.ui.update();

        // Trigger Flow Field update (Debounced)
        this.requestFlowFieldUpdate();
    }

    private requestFlowFieldUpdate() {
        if (this.map && this.map.requestFlowFieldUpdate) {
            this.map.requestFlowFieldUpdate();
        }
    }

    // === Grid Click Handling ===

    public handleGridClick(col: number, row: number): void {
        const tower = this.entityManager.getTowerAt(col, row);
        if (tower) {
            this.state.selectTower(tower);
            this.inspector.selectTower(tower);
        } else {
            this.state.selectTower(null);
            this.inspector.hide();
        }
    }

    // === Card Drop Handling ===

    public handleCardDrop(card: ICard, x: number, y: number): boolean {
        const col = Math.floor(x / CONFIG.TILE_SIZE);
        const row = Math.floor(y / CONFIG.TILE_SIZE);

        // Check if this is a tower card (exists in CONFIG.CARD_TYPES)
        const isTowerCard = Object.values(CONFIG.CARD_TYPES).some(t => t.id === card.type.id);
        if (isTowerCard) {
            const success = this.entityManager.addCardToTower(card, col, row, this.isBuildable);

            if (success) {
                this.cardSys.removeCardFromHand(card);
                this.showFloatingText('Card installed!', x, y, 'lime');
                this.ui.update();

                // Refresh inspector if this tower is selected
                const tower = this.entityManager.getTowerAt(col, row);
                if (tower && this.state.selectedTower === tower) {
                    this.inspector.selectTower(tower);
                }
                return true;
            } else {
                const tower = this.entityManager.getTowerAt(col, row);
                if (tower && tower.cards.length >= 3) {
                    this.showFloatingText('Tower full!', x, y, 'orange');
                } else if (this.state.money < CONFIG.ECONOMY.TOWER_COST) {
                    this.showFloatingText('Not enough money!', x, y, 'red');
                } else {
                    this.showFloatingText("Can't build here", x, y, 'red');
                }
                return false;
            }
        }

        return false;
    }

    // === Tower Selling ===

    public sellTower(tower: Tower): void {
        const refund = this.entityManager.sellTower(tower);
        if (refund > 0) {
            this.inspector.hide();
            this.ui.update();
        }
    }

    public sellCardFromTower(tower: Tower, cardIndex: number): void {
        const result = this.entityManager.sellCardFromTower(tower, cardIndex);
        if (result.card) {
            this.ui.update();
            // Refresh inspector to show updated card slots
            this.inspector.selectTower(tower);
        }
    }

    // === Card Management ===

    public giveRandomCard(): void {
        const keys = Object.keys(CONFIG.CARD_TYPES);
        const key = keys[Math.floor(Math.random() * keys.length)];
        this.cardSys.addCard(key, 1);
        this.ui.update();
    }

    // === Keyboard Hotkeys ===

    public handleKeyDown(e: KeyboardEvent): void {
        if (this.state.paused) return;

        switch (e.code) {
            case 'Space':
                this.handleSpaceKey();
                break;

            case 'Delete':
            case 'Backspace':
                if (this.state.selectedTower) {
                    this.sellTower(this.state.selectedTower);
                }
                break;

            case 'KeyM':
                console.log('CHEAT: Give Minigun');
                this.cardSys.addCard('MINIGUN', 1);
                this.ui.update();
                this.showFloatingText('+ MINIGUN', window.innerWidth / 2, window.innerHeight / 2, '#d0f');
                break;
            case 'Digit1':
            case 'Digit2':
            case 'Digit3':
            case 'Digit4':
            case 'Digit5':
                // Card selection hotkeys (if implemented in future)
                break;
        }
    }

    private handleSpaceKey(): void {
        // Space key exclusively toggles time scale, anytime.
        this.state.toggleTimeScale();

        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const text = this.state.timeScale >= 2.0 ? '>> 2x Speed' : '> 1x Speed';

        this.showFloatingText(text, centerX, centerY, '#fff');
    }

    // === Helper Methods ===

    public showFloatingText(text: string, x: number, y: number, color: string = '#fff'): void {
        this.effects.add({ type: 'text', text, x, y, life: 1.0, color, vy: -60 });
    }
}
</file>

<file path="src/InputSystem.ts">
import { Game } from './Game';
import { GameScene } from './scenes/GameScene';
import { CONFIG } from './Config';
import { SoundManager } from './SoundManager';

export class InputSystem {
    private game: Game;
    private canvas: HTMLCanvasElement;

    public mouseX: number = 0;
    public mouseY: number = 0;
    public hoverCol: number = -1;
    public hoverRow: number = -1;

    public isMouseDown: boolean = false;
    private holdTimer: number = 0;
    private holdStartCol: number = -1;
    private holdStartRow: number = -1;
    private readonly HOLD_THRESHOLD: number = 0.2; // 0.2 seconds (was 12 frames)

    constructor(game: Game) {
        this.game = game;
        this.canvas = game.canvas;

        // Bind methods to context
        this.onPointerMove = this.onPointerMove.bind(this);
        this.onPointerDown = this.onPointerDown.bind(this);
        this.onPointerUp = this.onPointerUp.bind(this);

        this.initListeners();
    }

    private initListeners() {
        // Prevent default touch actions (scrolling) on canvas
        this.canvas.style.touchAction = 'none';

        this.canvas.addEventListener('pointermove', this.onPointerMove);
        this.canvas.addEventListener('pointerdown', this.onPointerDown);
        this.canvas.addEventListener('pointerleave', this.onPointerLeave.bind(this));
        window.addEventListener('pointerup', this.onPointerUp);
    }

    public destroy() {
        this.canvas.removeEventListener('pointermove', this.onPointerMove);
        this.canvas.removeEventListener('pointerdown', this.onPointerDown);
        this.canvas.removeEventListener('pointerleave', this.onPointerLeave.bind(this));
        window.removeEventListener('pointerup', this.onPointerUp);
    }

    private onPointerMove(e: PointerEvent) {
        const rect = this.canvas.getBoundingClientRect();

        // Map screen pixels to logical game pixels
        // game.width is the logical width (e.g. 1000), rect.width is display width (e.g. 1000)
        // If CSS stretches the canvas, this handles it.
        const scaleX = this.game.width / rect.width;
        const scaleY = this.game.height / rect.height;

        this.mouseX = (e.clientX - rect.left) * scaleX;
        this.mouseY = (e.clientY - rect.top) * scaleY;

        this.hoverCol = Math.floor(this.mouseX / CONFIG.TILE_SIZE);
        this.hoverRow = Math.floor(this.mouseY / CONFIG.TILE_SIZE);

        const scene = this.game.currentScene;
        // Pass logical coordinates to drag update
        if (scene instanceof GameScene) {
            if (scene.cardSys && scene.cardSys.dragCard) {
                // dragCard expects global screen coords or logical?
                // CardSystem usually uses DOM elements or Canvas drawing?
                // CardSystem ghost uses DOM style.left/top, so it needs real viewport coordinates (clientX/Y)
                scene.cardSys.updateDrag(e.clientX, e.clientY);
            }
        }
    }

    private onPointerLeave(_e: PointerEvent) {
        // Reset hover position when mouse leaves canvas to prevent stuck highlights
        this.hoverCol = -1;
        this.hoverRow = -1;
    }

    private onPointerDown(e: PointerEvent) {
        SoundManager.resume();
        if (e.isPrimary && e.button === 0) {
            this.isMouseDown = true;
            this.holdStartCol = this.hoverCol;
            this.holdStartRow = this.hoverRow;
            this.holdTimer = 0;

            // Allow dragging outside canvas to be tracked if needed, 
            // but for now relying on window.pointerup is fine.
            // this.canvas.setPointerCapture(e.pointerId);
        }
    }

    private onPointerUp(e: PointerEvent) {
        if (this.isMouseDown) {
            this.isMouseDown = false;
            // this.canvas.releasePointerCapture(e.pointerId);
        }

        const scene = this.game.currentScene;
        if (scene instanceof GameScene) {
            // –ï—Å–ª–∏ —Ç–∞—â–∏–ª–∏ –∫–∞—Ä—Ç—É
            if (scene.cardSys.dragCard) {
                scene.cardSys.endDrag(e);
                return;
            }

            // CRITICAL FIX: Only process grid clicks if click was on the canvas
            // Otherwise UI clicks (sell button, cards) will trigger grid click and deselect tower
            const clickTarget = e.target as HTMLElement;
            const clickedOnCanvas = clickTarget === this.canvas;

            if (!clickedOnCanvas) {
                // Click was on a UI element, don't process as grid click
                this.holdTimer = 0;
                return;
            }

            // –ï—Å–ª–∏ —ç—Ç–æ –±—ã–ª –∫–ª–∏–∫ (–Ω–µ —É–¥–µ—Ä–∂–∞–Ω–∏–µ)
            if (this.holdTimer < this.HOLD_THRESHOLD) {
                // –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–∞ GameScene
                scene.handleGridClick(this.hoverCol, this.hoverRow);
            }
        }

        this.holdTimer = 0;
    }

    public update(dt: number) {
        const scene = this.game.currentScene;

        if (this.isMouseDown && scene instanceof GameScene) {
            if (!scene.cardSys.dragCard) {
                if (
                    this.hoverCol === this.holdStartCol &&
                    this.hoverRow === this.holdStartRow &&
                    this.hoverCol !== -1
                ) {
                    this.holdTimer += dt;
                    if (this.holdTimer >= this.HOLD_THRESHOLD) {
                        // –í—ã–∑–æ–≤ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
                        scene.startBuildingTower(this.hoverCol, this.hoverRow);
                    }
                } else {
                    this.holdTimer = 0;
                }
            }
        }
    }
}
</file>

<file path="src/scenes/EntityManager.ts">
import { Enemy } from '../Enemy';
import { Tower } from '../Tower';
import { ICard } from '../CardSystem';
import { CONFIG, getEnemyType } from '../Config';
import { EntityFactory } from '../EntityFactory';
import { GameState } from './GameState';
import { EffectSystem } from '../EffectSystem';
import { MetricsSystem } from '../MetricsSystem';
import { PerformanceMonitor } from '../utils/PerformanceMonitor';
import { SoundManager } from '../SoundManager';
import { EventBus, Events } from '../EventBus';
import { playDeathAnimation } from '../effects';

/**
 * Manages entity lifecycle:
 * - Tower building/selling
 * - Enemy spawning/death
 * - Projectile cleanup
 * - Visual effects coordination
 */
export class EntityManager {
    constructor(
        private state: GameState,
        private effects: EffectSystem,
        private metrics: MetricsSystem,
    ) { }

    // === Tower Management ===

    /**
     * Validate if a tower can be built at the given position
     */
    public canBuildTower(col: number, row: number, mapData: any, isBuildable: (c: number, r: number) => boolean): { valid: boolean; reason?: string } {
        if (!isBuildable(col, row)) {
            return { valid: false, reason: "Can't build here!" };
        }

        // Check existing tower
        const existingTower = this.state.towers.find((t) => t.col === col && t.row === row);
        if (existingTower) {
            return { valid: false, reason: 'Tower already here!' };
        }

        // Check money
        if (this.state.money < CONFIG.ECONOMY.TOWER_COST) {
            return { valid: false, reason: 'Not enough money!' };
        }

        return { valid: true };
    }

    /**
     * Build a tower at the specified position
     */
    public buildTower(col: number, row: number): Tower {
        this.state.spendMoney(CONFIG.ECONOMY.TOWER_COST);
        this.metrics.trackMoneySpent(CONFIG.ECONOMY.TOWER_COST);

        const tower = EntityFactory.createTower(col, row);
        tower.isBuilding = true;
        tower.buildProgress = 0;
        this.state.towers.push(tower);

        this.metrics.trackTowerBuilt();
        return tower;
    }

    /**
     * Sell an existing tower
     */
    public sellTower(tower: Tower): number {
        const idx = this.state.towers.indexOf(tower);
        if (idx === -1) return 0;

        this.state.towers.splice(idx, 1);
        const refund = Math.floor(CONFIG.ECONOMY.TOWER_COST * CONFIG.ECONOMY.SELL_REFUND);
        this.state.addMoney(refund);

        // Visual feedback
        this.showFloatingText(`+${refund}üí∞`, tower.x, tower.y, 'gold');

        if (this.state.selectedTower === tower) {
            this.state.selectTower(null);
        }

        return refund;
    }

    /**
     * Add a card to a tower or create new tower if none exists
     */
    public addCardToTower(card: ICard, col: number, row: number, isBuildable: (c: number, r: number) => boolean): boolean {
        let tower = this.state.towers.find((t) => t.col === col && t.row === row);

        // If no tower exists, we do NOT build one automatically on drop
        // User requested: "if card is carried not to tower base but to empty cell... it should return to hand"
        if (!tower) {
            return false;
        }

        // Add card to tower
        if (tower.addCard(card)) {
            this.metrics.trackCardUsed(card.type.id);
            return true;
        }

        return false;
    }

    /**
     * Sell a card from a tower
     */
    public sellCardFromTower(tower: Tower, cardIndex: number): { card: ICard | null; refund: number } {
        const card = tower.removeCard(cardIndex);
        if (!card) return { card: null, refund: 0 };

        const prices = CONFIG.ECONOMY.CARD_SELL_PRICES;
        const refund = prices[card.level] || 5;
        this.state.addMoney(refund);

        this.showFloatingText(`+${refund}üí∞`, tower.x, tower.y - 30, 'gold');
        this.metrics.trackMoneyEarned(refund);

        return { card, refund };
    }

    // === Enemy Management ===

    /**
     * Spawn an enemy of the given type
     */
    public spawnEnemy(type: string, waypoints: { x: number; y: number }[]): Enemy | null {
        if (!waypoints || waypoints.length === 0) return null;

        PerformanceMonitor.startTimer('Spawn');

        const enemy = this.state.enemyPool.obtain();
        EntityFactory.setupEnemy(enemy, type, this.state.wave, waypoints);
        this.state.enemies.push(enemy);

        // Notify systems
        EventBus.getInstance().emit(Events.ENEMY_SPAWNED, type);

        PerformanceMonitor.endTimer('Spawn');
        return enemy;
    }

    /**
     * Update enemy counter in HUD
     */
    private updateEnemyCounterUI(): void {
        // This will be called from updateEnemies
    }

    /**
     * Process enemy death - rewards, effects, cleanup
     */
    public handleEnemyDeath(enemy: Enemy): void {
        const reward = enemy.reward || 5;
        this.state.addMoney(reward);
        this.metrics.trackEnemyKilled();
        this.metrics.trackMoneyEarned(reward);

        const enemyTypeConf = getEnemyType(enemy.typeId.toUpperCase());

        // === –ê—Ä—Ö–µ—Ç–∏–ø-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è —Å–º–µ—Ä—Ç–∏ ===
        playDeathAnimation(this.effects, enemy, enemyTypeConf);

        // Soft death sound (throttled by SoundManager)
        SoundManager.play('death');

        // Floating text with emoji
        this.effects.add({
            type: 'text',
            text: `+${reward}üí∞`,
            x: enemy.x,
            y: enemy.y,
            life: 0.6,
            color: 'gold',
            vy: -90,
        });

        // Coin particle burst
        const particleCount = Math.min(3 + Math.floor(reward / 5), 8);
        for (let p = 0; p < particleCount; p++) {
            this.effects.add({
                type: 'particle',
                x: enemy.x + (Math.random() - 0.5) * 20,
                y: enemy.y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 360,
                vy: -(Math.random() * 240 + 120),
                life: 0.4 + Math.random() * 0.25,
                radius: 3 + Math.random() * 2,
                color: Math.random() > 0.3 ? '#ffd700' : '#ffeb3b',
            });
        }
    }

    /**
 * Process enemy reaching the end - lose life, cleanup
     */
    public handleEnemyFinished(enemy: Enemy): void {
        const damage = enemy.typeId === 'sapper_rat' ? 5 : 1;
        this.state.loseLife(damage, this.effects); // Pass effects for screen flash

        if (damage > 1) {
            this.showFloatingText(`CRYITICAL BREACH! -${damage}‚ù§Ô∏è`, enemy.x, enemy.y - 20, '#d32f2f');
            SoundManager.play('explosion'); // Louder/Standard
        }

        this.metrics.trackLifeLost();
        // Removed triggerShake - flash effect is enough
        if (damage === 1) SoundManager.play('explosion', 1);
    }

    /**
     * Update all enemies and handle death/finish
     */
    public updateEnemies(dt: number, flowField: any): void { // Using 'any' to avoid circular ref, but should be FlowField
        for (let i = this.state.enemies.length - 1; i >= 0; i--) {
            const e = this.state.enemies[i];
            e.move(dt, flowField);
            e.update(dt);

            if (!e.isAlive()) {
                this.handleEnemyDeath(e);
                this.state.enemyPool.free(e);
                this.state.enemies.splice(i, 1);
            } else if (e.finished) {
                this.handleEnemyFinished(e);
                this.state.enemies.splice(i, 1);
                this.state.enemyPool.free(e);
            }
        }
    }

    // === Projectile Management ===

    // Projectiles are now managed by ProjectileSystem

    // === Helper Methods ===

    private showFloatingText(text: string, x: number, y: number, color: string = '#fff'): void {
        this.effects.add({ type: 'text', text, x, y, life: 1.0, color, vy: -60 });
    }

    /**
     * Get tower at specific grid position
     */
    public getTowerAt(col: number, row: number): Tower | null {
        return this.state.towers.find((t) => t.col === col && t.row === row) || null;
    }
}
</file>

<file path="src/Assets.ts">
import { CONFIG } from './Config';
import { VISUALS } from './VisualConfig';
import { ProceduralPatterns } from './ProceduralPatterns';
import { ProceduralRoad } from './renderers/ProceduralRoad';
import { ProceduralGrass } from './renderers/ProceduralGrass';
import { SpriteBaker } from './utils/SpriteBaker';
import { OrcUnitRenderer } from './renderers/units/OrcUnitRenderer';
import { SkeletonUnitRenderer } from './renderers/units/SkeletonUnitRenderer';
import { GoblinUnitRenderer } from './renderers/units/GoblinUnitRenderer';
import { SpiderUnitRenderer } from './renderers/units/SpiderUnitRenderer';
import { TrollUnitRenderer } from './renderers/units/TrollUnitRenderer';
import { RatUnitRenderer } from './renderers/units/RatUnitRenderer';
import { HellhoundUnitRenderer } from './renderers/units/HellhoundUnitRenderer';
import { MagmaUnitRenderer } from './renderers/units/MagmaUnitRenderer';
import { FleshUnitRenderer } from './renderers/units/FleshUnitRenderer';
import { SkeletonMinerRenderer } from './renderers/units/SkeletonMinerRenderer';
import { SkeletonBerserkerRenderer } from './renderers/units/SkeletonBerserkerRenderer';
import { SkeletonCommanderUnitRenderer } from './renderers/units/SkeletonCommanderUnitRenderer';
import { Logger, LogChannel, LogLevel } from './utils/Logger';

export class Assets {
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    private static images: Record<string, HTMLCanvasElement | HTMLImageElement> = {};

    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è —Ä–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, grass –º–æ–∂–µ—Ç –∏–º–µ—Ç—å grass_1, grass_2, grass_3)
    private static variants: Record<string, (HTMLCanvasElement | HTMLImageElement)[]> = {};

    // –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã: true = –ø—ã—Ç–∞—Ç—å—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å PNG, false = —Ç–æ–ª—å–∫–æ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è
    private static USE_EXTERNAL_ASSETS = true;

    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏
    private static loadStats = {
        attempted: 0,
        loaded: 0,
        failed: 0,
        procedural: 0
    };

    private static missingAssets: Record<string, string[]> = {
        tiles: [],
        enemies: [],
        towers: [],
        props: [],
        projectiles: [],
        other: []
    };

    private static skippedAssets: number = 0;

    // –ì–õ–ê–í–ù–´–ô –ú–ï–¢–û–î –ó–ê–ì–†–£–ó–ö–ò
    public static async loadAll(): Promise<void> {
        console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
        console.log('‚ïë   ASSETS: –ù–∞—á–∞–ª–æ –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤    ‚ïë');
        console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

        this.loadStats = { attempted: 0, loaded: 0, failed: 0, procedural: 0 };

        if (this.USE_EXTERNAL_ASSETS) {
            Logger.info(LogChannel.ASSETS, '[1/3] –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –≤–Ω–µ—à–Ω–∏–µ PNG –∞—Å—Å–µ—Ç—ã...');
            try {
                await this.loadExternalAssets();
            } catch (error) {
                Logger.warn(LogChannel.ASSETS, '–û—à–∏–±–∫–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ PNG, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ', error);
            }
        }

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –∞—Å—Å–µ—Ç–æ–≤
        Logger.info(LogChannel.ASSETS, '[2/3] –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã—Ö —Ç–µ–∫—Å—Ç—É—Ä –¥–ª—è –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –∞—Å—Å–µ—Ç–æ–≤...');
        this.generateFallbackTextures();

        // PHASE 3: Bake Animations
        Logger.info(LogChannel.ASSETS, '[3/3] –ó–∞–ø–µ–∫–∞–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–π –≤—Ä–∞–≥–æ–≤ (Sprite Baking)...');
        this.generateBakedSprites();

        Logger.groupCollapsed('ASSETS Boot Summary');
        Logger.info(LogChannel.ASSETS, `PNG Loaded: ${this.loadStats.loaded}`);
        Logger.info(LogChannel.ASSETS, `Procedural Generated: ${this.loadStats.procedural}`);

        if (this.skippedAssets > 0) {
            Logger.info(LogChannel.ASSETS, `Skipped N already-cached textures: ${this.skippedAssets}`);
        }

        const missingCount = Object.values(this.missingAssets).reduce((a, b) => a + b.length, 0);
        if (missingCount > 0) {
            Logger.warn(LogChannel.ASSETS, `Missing PNG (${missingCount}) ‚Üí procedural fallback enabled`);
            for (const [key, list] of Object.entries(this.missingAssets)) {
                if (list.length > 0) {
                    const showCount = Math.min(list.length, 5);
                    const hidden = list.length - showCount;
                    Logger.warn(LogChannel.ASSETS, `  ${key}/* (${list.length}): ${list.slice(0, showCount).join(', ')}${hidden > 0 ? ` ...and ${hidden} more` : ''}`);
                }
            }
        }
        Logger.groupEnd();

        return Promise.resolve();
    }

    /**
     * –ü–æ–ª—É—á–∏—Ç—å –∞—Å—Å–µ—Ç –ø–æ –∏–º–µ–Ω–∏. –ï—Å–ª–∏ –µ—Å—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã - –≤–µ—Ä–Ω–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π.
     */
    public static get(name: string): HTMLCanvasElement | HTMLImageElement | undefined {
        // –ï—Å–ª–∏ –µ—Å—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã - –≤—ã–±—Ä–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–π
        if (this.variants[name] && this.variants[name].length > 0) {
            const variantList = this.variants[name];
            return variantList[Math.floor(Math.random() * variantList.length)];
        }

        // –ò–Ω–∞—á–µ –≤–µ—Ä–Ω—É—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π –∞—Å—Å–µ—Ç
        return this.images[name];
    }

    /**
     * –ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –∞—Å—Å–µ—Ç–∞ (–¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞)
     */
    public static getVariant(name: string, variantIndex: number): HTMLCanvasElement | HTMLImageElement | undefined {
        if (this.variants[name] && this.variants[name][variantIndex]) {
            return this.variants[name][variantIndex];
        }
        return this.images[name];
    }

    /**
     * –ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è –∞—Å—Å–µ—Ç–∞
     */
    public static getVariantCount(name: string): number {
        return this.variants[name]?.length || 0;
    }

    /**
     * –ó–∞–≥—Ä—É–∑–∫–∞ –æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
     * –ü—ã—Ç–∞–µ—Ç—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å: name.png, name_1.png, name_2.png, etc.
     */
    private static async loadImage(name: string, path: string, maxVariants: number = 5): Promise<void> {
        this.loadStats.attempted++;

        // –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª
        const mainLoaded = await this.tryLoadSingleImage(name, path);

        if (mainLoaded) {
            this.loadStats.loaded++;

            // –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã (name_1.png, name_2.png, etc.)
            const variantList: (HTMLCanvasElement | HTMLImageElement)[] = [];

            // –î–æ–±–∞–≤–∏—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–∫ –ø–µ—Ä–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç
            if (this.images[name]) {
                variantList.push(this.images[name]);
            }

            // –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
            for (let i = 1; i <= maxVariants; i++) {
                const variantPath = path.replace(/\.png$/, `_${i}.png`);
                const variantName = `${name}_${i}`;
                const loaded = await this.tryLoadSingleImage(variantName, variantPath, true); // silent = true

                if (loaded && this.images[variantName]) {
                    variantList.push(this.images[variantName]);
                }
            }

            // –ï—Å–ª–∏ –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ - —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏—Ö
            if (variantList.length > 1) {
                this.variants[name] = variantList;
                console.log(`Assets: Found ${variantList.length} variants for "${name}"`);
            }
        } else {
            this.loadStats.failed++;
        }
    }

    /**
     * –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
     */
    private static tryLoadSingleImage(name: string, path: string, silent: boolean = false): Promise<boolean> {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                this.images[name] = img;
                resolve(true);
            };
            img.onerror = () => {
                if (!silent) {
                    // Categorize missing assets for the final summary
                    let prefix = 'other';
                    if (path.includes('tiles/')) prefix = 'tiles';
                    else if (path.includes('enemies/')) prefix = 'enemies';
                    else if (path.includes('towers/')) prefix = 'towers';
                    else if (path.includes('projectiles/')) prefix = 'projectiles';
                    else if (path.includes('props/')) prefix = 'props';

                    if (this.missingAssets[prefix]) {
                        this.missingAssets[prefix].push(path);
                    } else {
                        this.missingAssets['other'].push(path);
                    }
                }
                resolve(false);
            };
            // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑ –∫–æ—Ä–Ω—è (–µ—Å–ª–∏ –ø—É—Ç—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å '../')
            img.src = path.startsWith('../') ? path : `/assets/images/${path}`;
        });
    }

    /**
     * –ó–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö –≤–Ω–µ—à–Ω–∏—Ö –∞—Å—Å–µ—Ç–æ–≤
     */
    private static async loadExternalAssets(): Promise<void> {
        const loadTasks: Promise<void>[] = [];

        // === –ö–†–ò–¢–ò–ß–ù–´–ï –ê–°–°–ï–¢–´ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è PNG) ===

        // Tiles - –æ–∫—Ä—É–∂–µ–Ω–∏–µ (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è)
        // –§–ê–ó–ê 2: –û—Ç–∫–ª—é—á–µ–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é grass_0...grass_3
        // loadTasks.push(this.loadImage('grass', 'tiles/grass.png', 5));  // –¥–æ 5 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
        loadTasks.push(this.loadImage('path', 'tiles/path.png', 3));

        // Fog tiles (0-15) - –±–µ–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, —Ç.–∫. –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è –±–∏—Ç–º–∞—Å–∫–∏–Ω–≥–∞
        for (let i = 0; i < 16; i++) {
            loadTasks.push(this.loadImage(`fog_${i}`, `tiles/fog_${i}.png`, 0));
        }

        // –î–µ–∫–æ—Ä–∞—Ü–∏–∏ - –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã
        loadTasks.push(this.loadImage('decor_tree', 'tiles/tree.png', 3));
        loadTasks.push(this.loadImage('decor_rock', 'tiles/rock.png', 5));
        loadTasks.push(this.loadImage('stone', 'tiles/stone.png', 3));
        loadTasks.push(this.loadImage('wheat', 'tiles/wheat.png', 2));
        loadTasks.push(this.loadImage('flowers', 'tiles/flowers.png', 3));

        // –ë–∞—à–Ω–∏ - –±–∞–∑–æ–≤—ã–µ (–±–µ–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, —Ç.–∫. –≤–∏–∑—É–∞–ª—å–Ω–æ –≤–∞–∂–Ω–∞ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å)
        loadTasks.push(this.loadImage('tower_base', 'towers/base.png'));
        loadTasks.push(this.loadImage('base_default', 'towers/base_default.png'));
        loadTasks.push(this.loadImage('tower_gun', 'towers/gun.png'));

        // –¢—É—Ä–µ–ª–∏
        loadTasks.push(this.loadImage('turret_standard', 'towers/turret_standard.png'));
        loadTasks.push(this.loadImage('turret_ice', 'towers/turret_ice.png'));
        loadTasks.push(this.loadImage('turret_fire', 'towers/turret_fire.png'));
        loadTasks.push(this.loadImage('turret_sniper', 'towers/turret_sniper.png'));
        loadTasks.push(this.loadImage('turret_split', 'towers/turret_split.png'));
        loadTasks.push(this.loadImage('turret_minigun', 'towers/turret_minigun.png'));

        // –ú–æ–¥—É–ª–∏
        loadTasks.push(this.loadImage('mod_ice', 'modules/ice.png'));
        loadTasks.push(this.loadImage('mod_fire', 'modules/fire.png'));
        loadTasks.push(this.loadImage('mod_sniper', 'modules/sniper.png'));
        loadTasks.push(this.loadImage('mod_split', 'modules/split.png'));
        loadTasks.push(this.loadImage('mod_minigun', 'modules/minigun.png'));

        // –í—Ä–∞–≥–∏ - –±–∞–∑–æ–≤—ã–µ –∞—Ä—Ö–µ—Ç–∏–ø—ã (–º–æ–≥—É—Ç –∏–º–µ—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è)
        loadTasks.push(this.loadImage('enemy_skeleton', 'enemies/skeleton.png', 3));
        loadTasks.push(this.loadImage('enemy_wolf', 'enemies/wolf.png', 2));
        loadTasks.push(this.loadImage('enemy_troll', 'enemies/troll.png', 2));
        loadTasks.push(this.loadImage('enemy_spider', 'enemies/spider.png', 2));

        // Props –≤—Ä–∞–≥–æ–≤
        loadTasks.push(this.loadImage('prop_shield', 'props/shield.png'));
        loadTasks.push(this.loadImage('prop_helmet', 'props/helmet.png'));
        loadTasks.push(this.loadImage('prop_weapon', 'props/weapon.png'));
        loadTasks.push(this.loadImage('prop_barrier', 'props/barrier.png'));

        // –°–Ω–∞—Ä—è–¥—ã - –∫—Ä–∏—Ç–∏—á–Ω—ã–µ –¥–ª—è –≥–µ–π–º–ø–ª–µ—è
        loadTasks.push(this.loadImage('projectile_standard', 'projectiles/standard.png'));
        loadTasks.push(this.loadImage('projectile_ice', 'projectiles/ice.png'));
        loadTasks.push(this.loadImage('projectile_fire', 'projectiles/fire.png'));
        loadTasks.push(this.loadImage('projectile_sniper', 'projectiles/sniper.png'));
        loadTasks.push(this.loadImage('projectile_split', 'projectiles/split.png'));
        loadTasks.push(this.loadImage('projectile_minigun', 'projectiles/minigun.png'));

        // –§–æ–Ω—ã –º–µ–Ω—é (–∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ –∫–æ—Ä–Ω—è)
        loadTasks.push(this.tryLoadSingleImage('menu_start', '../start.jpg').then(() => { }));
        loadTasks.push(this.tryLoadSingleImage('menu_map', '../map.jpg').then(() => { }));


        // –≠–§–§–ï–ö–¢–´ - –æ—Å—Ç–∞–≤–ª—è–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–º–∏ (–Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ–º PNG)

        // effect_muzzle_flash, shadow_small - –±—É–¥—É—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
        await Promise.all(loadTasks);
    }


    /**
     * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è –≤—Å–µ—Ö –∞—Å—Å–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –±—ã–ª–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
     */
    private static generateFallbackTextures(): void {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∫–∏–µ –∞—Å—Å–µ—Ç—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–ª—è –Ω–∏—Ö –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã
        const requiredAssets = [
            'grass_0', 'grass_1', 'grass_2', 'grass_3', // 4 variants for grass
            'path', 'decor_tree', 'decor_rock', 'stone', 'wheat', 'flowers',
            'tower_base', 'base_default', 'tower_gun',
            'turret_standard', 'turret_ice', 'turret_fire', 'turret_sniper', 'turret_split', 'turret_minigun',
            'mod_ice', 'mod_fire', 'mod_sniper', 'mod_split', 'mod_minigun',
            'projectile_standard', 'projectile_ice', 'projectile_fire', 'projectile_sniper', 'projectile_split', 'projectile_minigun',
            'effect_muzzle_flash', 'shadow_small',
            'fx_boss_aura', 'fx_boss_eye', 'fx_boss_shield', 'fx_soul', 'fx_glow_red'
        ];

        // –î–æ–±–∞–≤–ª—è–µ–º fog tiles
        for (let i = 0; i < 16; i++) {
            requiredAssets.push(`fog_${i}`);
        }

        // –î–æ–±–∞–≤–ª—è–µ–º path tiles (Phase 2 - bitmasking)
        for (let i = 0; i < 16; i++) {
            requiredAssets.push(`path_${i}`);
        }

        // –î–æ–±–∞–≤–ª—è–µ–º enemies
        const enemies = Object.values(CONFIG.ENEMY_TYPES);
        enemies.forEach((e) => {
            requiredAssets.push(`enemy_${e.id}`);
        });

        // –î–æ–±–∞–≤–ª—è–µ–º props
        requiredAssets.push('prop_shield', 'prop_helmet', 'prop_weapon', 'prop_barrier');

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ
        requiredAssets.forEach(assetName => {
            if (!this.images[assetName]) {
                this.generateProceduralAsset(assetName);
            }
        });
    }

    /**
     * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—É—é —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∞—Å—Å–µ—Ç–∞
     */
    private static generateProceduralAsset(name: string): void {
        // –í—ã–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ä—É—é —Å–∏—Å—Ç–µ–º—É –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
        if (name.startsWith('grass_')) {
            // –§–ê–ó–ê 2: –û–±–Ω–æ–≤–ª–µ–Ω–æ - –ø—Ä–æ—Å—Ç–∞—è –∑–µ–ª–µ–Ω–∞—è —Ç—Ä–∞–≤–∞ (–ø–æ –∑–∞–ø—Ä–æ—Å—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
            const variantIdx = parseInt(name.split('_')[1]);

            this.generateTexture(name, CONFIG.TILE_SIZE, (ctx, w, h) => {
                // –ü—Ä–æ—Å—Ç–æ –∑–µ–ª—ë–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç –ë–ï–ó –¥–µ—Ç–∞–ª–µ–π
                ctx.fillStyle = '#6b9e4a'; // –°—Ä–µ–¥–Ω–∏–π –∑–µ–ª—ë–Ω—ã–π
                ctx.fillRect(0, 0, w, h);
            });

            // IMPORTANT: Register as variant for 'grass'
            if (!this.variants['grass']) {
                this.variants['grass'] = [];
            }
            if (this.images[name] instanceof HTMLCanvasElement) {
                this.variants['grass'].push(this.images[name] as HTMLCanvasElement);
            }

            this.loadStats.procedural++;

            // –ï—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –µ–≥–æ –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–π –∞—Å—Å–µ—Ç 'grass'
            if (name === 'grass_0') {
                this.images['grass'] = this.images[name];
            }


        } else if (name === 'path') {
            this.generateTexture('path', CONFIG.TILE_SIZE, (ctx, w, h) => {
                ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.MAIN;
                ctx.fillRect(0, 0, w, h);
                for (let i = 0; i < 15; i++) {
                    ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.DETAIL;
                    ctx.beginPath();
                    ctx.arc(Math.random() * w, Math.random() * h, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            this.loadStats.procedural++;
        } else if (name.startsWith('fog_')) {
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º fog tiles –ø–æ —Å—Ç–∞—Ä–æ–º—É
            const index = parseInt(name.replace('fog_', ''));
            if (!isNaN(index)) {
                this.generateFogTile(index);
                this.loadStats.procedural++;
            }
        } else if (name.startsWith('path_')) {
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º path tiles (Phase 2 - bitmasking)
            this.generatePathTiles(); // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Å–µ 16 –∑–∞ —Ä–∞–∑
            this.loadStats.procedural++;
        } else if (name.startsWith('enemy_')) {
            // Enemies
            const enemyId = name.replace('enemy_', '');
            const enemy = Object.values(CONFIG.ENEMY_TYPES).find(e => e.id === enemyId);
            if (enemy) {
                this.generateEnemyTexture(enemy.id, enemy.color);
                this.loadStats.procedural++;
            }
        } else {
            // –î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∞—Å—Å–µ—Ç–æ–≤ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —á–µ—Ä–µ–∑ —Å—Ç–∞—Ä—É—é —Å–∏—Å—Ç–µ–º—É
            // –ù–û –¢–û–õ–¨–ö–û –ï–°–õ–ò –æ–Ω–∏ –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!
            if (!this.images[name]) {
                this.generateAllTextures();  // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –í–°–ï –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ
            } else {
                this.skippedAssets++;
            }
        }
    }

    // --- –°–¢–ê–†–ê–Ø –°–ò–°–¢–ï–ú–ê –ü–†–û–¶–ï–î–£–†–ù–û–ô –ì–ï–ù–ï–†–ê–¶–ò–ò (–æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è fallback) ---
    private static generateAllTextures() {
        // –§–ê–ó–ê 2: –°—Ç–∞—Ä–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è 'grass' –£–î–ê–õ–ï–ù–ê
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—É—é —Å–∏—Å—Ç–µ–º—É grass_0...grass_3 (—Å–º. generateProceduralAsset)


        this.generateTexture('path', CONFIG.TILE_SIZE, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.MAIN;
            ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 15; i++) {
                ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.DETAIL;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        this.generateTexture('decor_tree', CONFIG.TILE_SIZE, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.TREE.BASE;
            ctx.fillRect(0, 0, w, h); // –§–æ–Ω —Ç—Ä–∞–≤—ã
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.TREE.FOLIAGE_LIGHT;
            ctx.beginPath();
            ctx.arc(w / 2, h / 2, 16, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.TREE.FOLIAGE_DARK;
            ctx.beginPath();
            ctx.arc(w / 2 - 5, h / 2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
        });

        this.generateTexture('decor_rock', CONFIG.TILE_SIZE, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.ROCK.BASE;
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.ROCK.STONE;
            ctx.beginPath();
            ctx.moveTo(10, h - 10);
            ctx.lineTo(w / 2, 10);
            ctx.lineTo(w - 10, h - 10);
            ctx.fill();
        });

        // –ë–∞—à–Ω–∏
        this.generateTexture('tower_base', CONFIG.TILE_SIZE, (ctx, w, h) => {
            const center = w / 2;
            ctx.fillStyle = VISUALS.TOWER.BASE.PLATFORM;
            ctx.beginPath();
            ctx.arc(center, center, w * 0.375, 0, Math.PI * 2); // 24/64 = 0.375
            ctx.fill();
            ctx.strokeStyle = VISUALS.TOWER.BASE.RIM;
            ctx.lineWidth = 4;
            ctx.stroke();
        });

        this.generateTexture('tower_gun', CONFIG.TILE_SIZE, (ctx, w, h) => {
            const center = w / 2;
            const barrelWidth = w * 0.125;  // 8/64 = 0.125
            const barrelLength = w * 0.53;  // 34/64 ~= 0.53
            const barrelStart = w * 0.31;   // 20/64 ~= 0.31

            ctx.fillStyle = VISUALS.TOWER.BASE.RIVETS; // Using rivets color for gun? Original was #424242 which matches rivets
            // Draw barrel horizontally pointing RIGHT (East)
            ctx.fillRect(barrelStart, center - barrelWidth / 2, barrelLength, barrelWidth);
            ctx.beginPath();
            ctx.arc(center, center, w * 0.22, 0, Math.PI * 2); // 14/64 ~= 0.22
            ctx.fill(); // Turret body
            ctx.fillStyle = '#eceff1';
            ctx.beginPath();
            ctx.arc(center, center, w * 0.094, 0, Math.PI * 2); // 6/64 ~= 0.094
            ctx.fill();
        });

        // –í—Ä–∞–≥–∏
        const enemies = Object.values(CONFIG.ENEMY_TYPES);
        enemies.forEach((e) => {
            this.generateEnemyTexture(e.id, e.color);
        });

        // Fog
        this.generateFogTiles();

        // Path tiles (Phase 2 - bitmasking)
        this.generatePathTiles();

        // --- NEW MODULAR TOWER ASSETS ---
        this.generateTowerParts();

        // --- PROJECTILES & EFFECTS ---
        this.generateProjectiles();
        this.generateMisc();
        this.generateBossEffects(); // New Phase 8
    }

    private static generateBossEffects() {
        const size = 64; // Base size for effects

        // 1. Boss Aura (Pulse)
        this.generateTexture('fx_boss_aura', size * 2, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            const grad = ctx.createRadialGradient(cx, cy, w * 0.2, cx, cy, w * 0.5);
            grad.addColorStop(0, 'rgba(255, 111, 0, 0.0)');
            grad.addColorStop(0.7, 'rgba(255, 111, 0, 0.4)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);
        });

        // 2. Boss Eye (Glowing)
        this.generateTexture('fx_boss_eye', 32, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            // Halo
            const grad = ctx.createRadialGradient(cx, cy, 2, cx, cy, 14);
            grad.addColorStop(0, '#00e5ff');
            grad.addColorStop(1, 'rgba(0, 229, 255, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);
            // Core
            ctx.fillStyle = '#e0f7fa';
            ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI * 2); ctx.fill();
        });

        // 3. Invulnerability Shield
        this.generateTexture('fx_boss_shield', 128, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            const r = w * 0.45;
            // Shield Body
            const grad = ctx.createRadialGradient(cx, cy, r * 0.5, cx, cy, r);
            grad.addColorStop(0, 'rgba(255, 215, 0, 0)');
            grad.addColorStop(0.6, 'rgba(255, 215, 0, 0.1)');
            grad.addColorStop(1, 'rgba(255, 235, 59, 0.4)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
            // Rim
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke();
        });

        // 4. Soul Particle
        this.generateTexture('fx_soul', 16, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            const grad = ctx.createRadialGradient(cx, cy, 1, cx, cy, 8);
            grad.addColorStop(0, '#00e5ff');
            grad.addColorStop(1, 'rgba(0, 229, 255, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(cx, cy, 8, 0, Math.PI * 2); ctx.fill();
        });

        // 5. Red Glow (For Skeleton Commander)
        this.generateTexture('fx_glow_red', 32, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            const grad = ctx.createRadialGradient(cx, cy, 2, cx, cy, 14);
            grad.addColorStop(0, '#ff3d00');
            grad.addColorStop(1, 'rgba(255, 61, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);
        });
    }

    private static generateTexture(
        name: string,
        size: number,
        drawFn: (ctx: CanvasRenderingContext2D, w: number, h: number) => void,
    ) {
        // –ö–†–ò–¢–ò–ß–ù–û: –ù–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞—Ç—å —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ PNG!
        if (this.images[name]) {
            this.skippedAssets++;
            return;
        }

        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d')!;
        drawFn(ctx, size, size);
        this.images[name] = canvas;
        console.log(`[generateTexture] Generated procedural "${name}"`);
    }

    /**
     * Layered Texture Generation (Phase 1)
     * Generates textures using multiple layers for richer visuals
     * @param name Asset name
     * @param size Texture size
     * @param layers Layer functions: base, pattern, highlight, dirt
     */
    private static generateLayeredTexture(
        name: string,
        size: number,
        layers: {
            base: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
            pattern?: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
            highlight?: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
            dirt?: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
        }
    ): void {
        // –ö–†–ò–¢–ò–ß–ù–û (–∏–∑ –∞—É–¥–∏—Ç–∞): –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏!
        if (this.images[name]) {
            this.skippedAssets++;
            return;
        }

        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d')!;

        // Layer 1: Base (–ø–æ–¥–ª–æ–∂–∫–∞)
        layers.base(ctx, size, size);

        // Layer 2: Pattern (—É–∑–æ—Ä)
        if (layers.pattern) {
            layers.pattern(ctx, size, size);
        }

        // Layer 3: Highlight (–±–ª–∏–∫–∏/–∞–∫—Ü–µ–Ω—Ç—ã)
        if (layers.highlight) {
            layers.highlight(ctx, size, size);
        }

        // Layer 4: Dirt (–≥—Ä—è–∑—å/—à—É–º)
        if (layers.dirt) {
            layers.dirt(ctx, size, size);
        }

        this.images[name] = canvas;
    }


    private static generateEnemyTexture(name: string, color: string) {
        this.generateTexture(`enemy_${name}`, 48, (ctx, w, h) => {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(w / 2, h / 2, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            // –ì–ª–∞–∑–∞
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(w / 2 - 6, h / 2 - 5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(w / 2 + 6, h / 2 - 5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(w / 2 - 6, h / 2 - 5, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(w / 2 + 6, h / 2 - 5, 1.5, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    private static generateFogTiles() {
        const TS = CONFIG.TILE_SIZE;
        // Generate 16 bitmask variations (0-15)
        for (let i = 0; i < 16; i++) {
            this.generateTexture(`fog_${i}`, TS, (ctx, w, h) => {
                const NORTH = (i & 1) !== 0;
                const WEST = (i & 2) !== 0;
                const EAST = (i & 4) !== 0;
                const SOUTH = (i & 8) !== 0;

                // Base fog color (Dark)
                ctx.fillStyle = VISUALS.ENVIRONMENT.FOG.BASE; // Dark Blue Grey

                // Draw main body based on connections
                // We draw a center rect and extend to connected sides
                const cx = w / 2;
                const cy = h / 2;
                const halfW = w / 2;
                const halfH = h / 2;

                // Always draw center
                ctx.fillRect(cx - halfW, cy - halfH, w, h);

                // This simple logic fills the whole tile if it's fog
                // But to make it look nice (soft edges), we can use gradients or rounded corners 
                // on sides that are NOT connected to other fog.

                // Let's retry the visual approach:
                // We fill the whole tile with black/dark.
                // Then, for sides that are NOT connected (value 0 in bitmask), we fade out or draw a border?
                // Wait, standard bitmasking works by selecting a sprite that "connects" to neighbors.
                // So '15' (connected all sides) is a solid dark block.
                // '0' (connected to none, i.e., isolated fog) is a dark circle or blob.

                ctx.clearRect(0, 0, w, h); // Start fresh
                ctx.fillStyle = VISUALS.ENVIRONMENT.FOG.BASE;

                // Dynamic dimensions based on tile size (25% margins, 50% center)
                const cX = Math.floor(w / 4);      // Left margin
                const cY = Math.floor(h / 4);      // Top margin
                const cW = Math.floor(w / 2);      // Center width
                const cH = Math.floor(h / 2);      // Center height
                const arcRadius = Math.floor(cW / 2);

                // Draw Center
                ctx.fillRect(cX, cY, cW, cH);

                // NORTH
                if (NORTH) {
                    ctx.fillRect(cX, 0, cW, cY);
                } else {
                    ctx.beginPath();
                    ctx.arc(w / 2, cY, arcRadius, Math.PI, 0);
                    ctx.fill();
                }

                // SOUTH
                if (SOUTH) {
                    ctx.fillRect(cX, cY + cH, cW, h - (cY + cH));
                } else {
                    ctx.beginPath();
                    ctx.arc(w / 2, cY + cH, arcRadius, 0, Math.PI);
                    ctx.fill();
                }

                // WEST
                if (WEST) {
                    ctx.fillRect(0, cY, cX, cH);
                } else {
                    ctx.beginPath();
                    ctx.arc(cX, h / 2, arcRadius, Math.PI * 0.5, Math.PI * 1.5);
                    ctx.fill();
                }

                // EAST
                if (EAST) {
                    ctx.fillRect(cX + cW, cY, w - (cX + cW), cH);
                } else {
                    ctx.beginPath();
                    ctx.arc(cX + cW, h / 2, arcRadius, Math.PI * 1.5, Math.PI * 0.5);
                    ctx.fill();
                }

                // Fill corners if both adjacent sides are connected
                // NW
                if (NORTH && WEST) ctx.fillRect(0, 0, cX, cY);
                // NE
                if (NORTH && EAST) ctx.fillRect(cX + cW, 0, w - (cX + cW), cY);
                // SW
                if (SOUTH && WEST) ctx.fillRect(0, cY + cH, cX, h - (cY + cH));
                // SE
                if (SOUTH && EAST) ctx.fillRect(cX + cW, cY + cH, w - (cX + cW), h - (cY + cH));
            });
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ç–∏—Ä—É–µ—Ç –æ–¥–∏–Ω fog tile –ø–æ –∏–Ω–¥–µ–∫—Å—É (–¥–ª—è fallback)
     */
    private static generateFogTile(index: number) {
        const TS = CONFIG.TILE_SIZE;
        this.generateTexture(`fog_${index}`, TS, (ctx, w, h) => {
            const NORTH = (index & 1) !== 0;
            const WEST = (index & 2) !== 0;
            const EAST = (index & 4) !== 0;
            const SOUTH = (index & 8) !== 0;

            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = VISUALS.ENVIRONMENT.FOG.BASE;

            const cX = Math.floor(w / 4);
            const cY = Math.floor(h / 4);
            const cW = Math.floor(w / 2);
            const cH = Math.floor(h / 2);
            const arcRadius = Math.floor(cW / 2);

            // Draw Center
            ctx.fillRect(cX, cY, cW, cH);

            // NORTH
            if (NORTH) {
                ctx.fillRect(cX, 0, cW, cY);
            } else {
                ctx.beginPath();
                ctx.arc(w / 2, cY, arcRadius, Math.PI, 0);
                ctx.fill();
            }

            // SOUTH
            if (SOUTH) {
                ctx.fillRect(cX, cY + cH, cW, h - (cY + cH));
            } else {
                ctx.beginPath();
                ctx.arc(w / 2, cY + cH, arcRadius, 0, Math.PI); ctx.fill();
            }

            // WEST
            if (WEST) {
                ctx.fillRect(0, cY, cX, cH);
            } else {
                ctx.beginPath();
                ctx.arc(cX, h / 2, arcRadius, Math.PI * 0.5, Math.PI * 1.5);
                ctx.fill();
            }

            // EAST
            if (EAST) {
                ctx.fillRect(cX + cW, cY, w - (cX + cW), cH);
            } else {
                ctx.beginPath();
                ctx.arc(cX + cW, h / 2, arcRadius, Math.PI * 1.5, Math.PI * 0.5);
                ctx.fill();
            }

            // Fill corners if both adjacent sides are connected
            if (NORTH && WEST) ctx.fillRect(0, 0, cX, cY);
            if (NORTH && EAST) ctx.fillRect(cX + cW, 0, w - (cX + cW), cY);
            if (SOUTH && WEST) ctx.fillRect(0, cY + cH, cX, h - (cY + cH));
            if (SOUTH && EAST) ctx.fillRect(cX + cW, cY + cH, w - (cX + cW), h - (cY + cH));
        });
    }

    /**
     * Generate Path Tiles with Bitmasking
     * Creates 16 variants (0-15) for smooth path connections
     * –§–ê–ó–ê 1: –û–±–Ω–æ–≤–ª–µ–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ProceduralRoad –¥–ª—è –∫–∞–º–µ–Ω–Ω–æ–π —Ç–µ–∫—Å—Ç—É—Ä—ã
     */
    private static generatePathTiles() {
        const TS = CONFIG.TILE_SIZE;



        // Generate 16 bitmask variations (0-15)
        for (let i = 0; i < 16; i++) {
            this.generateTexture(`path_${i}`, TS, (ctx, w, h) => {
                // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å ProceduralRoad –¥–ª—è –∫–∞–º–µ–Ω–Ω–æ–π —Ç–µ–∫—Å—Ç—É—Ä—ã
                try {
                    ProceduralRoad.draw(ctx, 0, 0, i);
                } catch (error) {
                    console.error(`[Assets] ProceduralRoad.draw failed for path_${i}:`, error);
                    // Fallback - –ø—Ä–æ—Å—Ç–æ–π –∫–∞–º–µ–Ω—å
                    ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.STONE_BASE || '#c5b8a1';
                    ctx.fillRect(0, 0, w, h);
                }
            });
        }
    }


    private static generateTowerParts() {
        const size = CONFIG.TILE_SIZE;

        // -- 1. Bases --
        this.generateTexture('base_default', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            const r = w * 0.35;
            // Main platform
            ctx.fillStyle = '#9e9e9e'; // Grey 500
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            // Rim
            ctx.strokeStyle = '#616161'; // Grey 700
            ctx.lineWidth = 3;
            ctx.stroke();
            // Rivets
            ctx.fillStyle = '#424242';
            for (let i = 0; i < 4; i++) {
                const a = i * (Math.PI / 2);
                ctx.beginPath();
                ctx.arc(cx + Math.cos(a) * (r - 4), cy + Math.sin(a) * (r - 4), 2, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        // -- 2. Turrets --

        // -- 2. Turrets --

        // Standard / Default
        this.generateTexture('turret_standard', size, (ctx, w, h) => {
            ctx.save();
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);
            // Simple gun
            ctx.fillStyle = VISUALS.TOWER.TURRET.STANDARD.BARREL;
            ctx.fillRect(0, -6, 20, 12); // Barrel
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2); // Body
            ctx.fill();
            ctx.strokeStyle = VISUALS.TOWER.TURRET.STANDARD.STROKE;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        });

        // Loop for 3 levels
        for (let level = 1; level <= 3; level++) {

            // --- FIRE TURRET (Mortar) ---
            this.generateTexture(`turret_fire_${level}`, size, (ctx, w, h) => {
                ctx.save();
                const cx = w / 2;
                const cy = h / 2;
                ctx.translate(cx, cy);

                // Level 1: Basic Mortar Cannon
                // Level 2: + Heat Fins + Reinforced
                // Level 3: + Magma Core + Glowing Cracks

                // === BARREL (Conical, not flat rectangle) ===
                const barrelLen = 18 + level * 2; // 20-24px
                const barrelBaseW = 14 + level * 2; // 16-20px base
                const barrelTipW = 8 + level; // 9-11px tip (tapered)

                // Barrel gradient (dark to hot)
                const barrelGrad = ctx.createLinearGradient(0, 0, barrelLen, 0);
                barrelGrad.addColorStop(0, '#5d4037'); // Dark brown base
                barrelGrad.addColorStop(0.7, '#8d6e63'); // Mid brown
                barrelGrad.addColorStop(1, '#ff5722'); // Hot orange tip

                ctx.fillStyle = barrelGrad;
                ctx.beginPath();
                ctx.moveTo(0, -barrelBaseW / 2);
                ctx.lineTo(barrelLen, -barrelTipW / 2);
                ctx.lineTo(barrelLen, barrelTipW / 2);
                ctx.lineTo(0, barrelBaseW / 2);
                ctx.closePath();
                ctx.fill();

                // Barrel metal bands
                ctx.fillStyle = '#3e2723'; // Dark metal
                ctx.fillRect(4, -barrelBaseW / 2 - 1, 3, barrelBaseW + 2);
                if (level >= 2) {
                    ctx.fillRect(10, -barrelBaseW / 2 + 2, 2, barrelBaseW - 4);
                }

                // Muzzle ring
                ctx.strokeStyle = '#ff9800';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(barrelLen, 0, barrelTipW / 2, -Math.PI / 2, Math.PI / 2);
                ctx.stroke();

                // === BODY (Armored sphere with details) ===
                const bodyR = 13 + level;

                // Body gradient (metallic look)
                const bodyGrad = ctx.createRadialGradient(-3, -3, 0, 0, 0, bodyR);
                bodyGrad.addColorStop(0, '#a1887f'); // Highlight
                bodyGrad.addColorStop(0.5, '#795548'); // Mid
                bodyGrad.addColorStop(1, '#4e342e'); // Shadow

                ctx.fillStyle = bodyGrad;
                ctx.beginPath();
                ctx.arc(0, 0, bodyR, 0, Math.PI * 2);
                ctx.fill();

                // Body outline
                ctx.strokeStyle = '#3e2723';
                ctx.lineWidth = 2;
                ctx.stroke();

                // === LEVEL 2+ DETAILS ===
                if (level >= 2) {
                    // Heat dissipation fins (side plates)
                    ctx.fillStyle = '#5d4037';
                    // Top fin
                    ctx.beginPath();
                    ctx.moveTo(-8, -bodyR + 2);
                    ctx.lineTo(-4, -bodyR - 4);
                    ctx.lineTo(4, -bodyR - 4);
                    ctx.lineTo(8, -bodyR + 2);
                    ctx.closePath();
                    ctx.fill();
                    // Bottom fin
                    ctx.beginPath();
                    ctx.moveTo(-8, bodyR - 2);
                    ctx.lineTo(-4, bodyR + 4);
                    ctx.lineTo(4, bodyR + 4);
                    ctx.lineTo(8, bodyR - 2);
                    ctx.closePath();
                    ctx.fill();

                    // Rivets on body
                    ctx.fillStyle = '#8d6e63';
                    const rivetAngles = [Math.PI * 0.7, Math.PI * 0.85, Math.PI * 1.15, Math.PI * 1.3];
                    rivetAngles.forEach(a => {
                        ctx.beginPath();
                        ctx.arc(Math.cos(a) * (bodyR - 3), Math.sin(a) * (bodyR - 3), 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                // === LEVEL 3 DETAILS ===
                if (level === 3) {
                    // Magma core glow (center)
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
                    coreGrad.addColorStop(0, '#ffeb3b'); // Yellow center
                    coreGrad.addColorStop(0.4, '#ff9800'); // Orange
                    coreGrad.addColorStop(1, 'rgba(255,87,34,0)'); // Fade

                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();

                    // Magma cracks radiating from center
                    ctx.strokeStyle = '#ff5722';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    for (let i = 0; i < 4; i++) {
                        const angle = (i * Math.PI / 2) + Math.PI / 4;
                        ctx.moveTo(Math.cos(angle) * 4, Math.sin(angle) * 4);
                        ctx.lineTo(Math.cos(angle) * (bodyR - 4), Math.sin(angle) * (bodyR - 4));
                    }
                    ctx.stroke();
                }
                ctx.restore();
            });


            // --- ICE TURRET (Magical Crystal) ---
            this.generateTexture(`turret_ice_${level}`, size, (ctx, w, h) => {
                ctx.save();
                const cx = w / 2;
                const cy = h / 2;
                ctx.translate(cx, cy);

                // Level 1: Crystal spike + ice sphere
                // Level 2: + Frost base + inner facets
                // Level 3: + Floating shards + core glow

                // === MAIN CRYSTAL BODY (Hexagon for crystalline look) ===
                const bodyR = 14 + level; // 15-17px

                // === FROST BASE (Level 2+) ===
                if (level >= 2) {
                    ctx.fillStyle = 'rgba(224, 247, 250, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(0, 3, bodyR + 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Hexagon path
                const hexPath = () => {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI / 3) - Math.PI / 6;
                        const x = Math.cos(angle) * bodyR;
                        const y = Math.sin(angle) * bodyR;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                };

                // Gradient fill
                const bodyGrad = ctx.createRadialGradient(-3, -3, 0, 0, 0, bodyR);
                bodyGrad.addColorStop(0, '#e0f7fa');
                bodyGrad.addColorStop(0.3, '#80deea');
                bodyGrad.addColorStop(0.7, '#26c6da');
                bodyGrad.addColorStop(1, '#00acc1');

                ctx.fillStyle = bodyGrad;
                hexPath();
                ctx.fill();

                // Outline
                ctx.strokeStyle = '#0097a7';
                ctx.lineWidth = 2;
                hexPath();
                ctx.stroke();

                // === CRYSTAL SPIKE (Multi-faceted) ===
                const spikeLen = 22 + level * 3; // 25-31px
                const spikeBaseW = 8 + level; // 9-11px

                // Spike gradient (white tip -> cyan base)
                const spikeGrad = ctx.createLinearGradient(0, 0, spikeLen, 0);
                spikeGrad.addColorStop(0, '#4dd0e1'); // Base cyan
                spikeGrad.addColorStop(0.7, '#b2ebf2'); // Light cyan
                spikeGrad.addColorStop(1, '#ffffff'); // White tip

                // Main spike body
                ctx.fillStyle = spikeGrad;
                ctx.beginPath();
                ctx.moveTo(bodyR - 4, -spikeBaseW / 2);
                ctx.lineTo(spikeLen, 0);
                ctx.lineTo(bodyR - 4, spikeBaseW / 2);
                ctx.closePath();
                ctx.fill();

                // Spike facet (darker underside)
                ctx.fillStyle = 'rgba(0, 151, 167, 0.4)';
                ctx.beginPath();
                ctx.moveTo(bodyR - 2, 0);
                ctx.lineTo(spikeLen - 2, 0);
                ctx.lineTo(bodyR - 2, spikeBaseW / 2 - 1);
                ctx.closePath();
                ctx.fill();

                // Spike highlight (top edge)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(bodyR - 2, -spikeBaseW / 2 + 1);
                ctx.lineTo(spikeLen - 3, 0);
                ctx.stroke();

                // === INNER FACETS (Level 2+) ===
                if (level >= 2) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.moveTo(-bodyR + 4, -2);
                    ctx.lineTo(0, -bodyR + 3);
                    ctx.lineTo(bodyR - 6, -2);
                    ctx.closePath();
                    ctx.fill();

                    // Secondary facet
                    ctx.fillStyle = 'rgba(178, 235, 242, 0.5)';
                    ctx.beginPath();
                    ctx.moveTo(-bodyR + 5, 2);
                    ctx.lineTo(0, bodyR - 4);
                    ctx.lineTo(bodyR - 7, 2);
                    ctx.closePath();
                    ctx.fill();
                }

                // === CORE GLOW (Level 3) ===
                if (level === 3) {
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 6);
                    coreGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    coreGrad.addColorStop(0.5, 'rgba(128, 222, 234, 0.6)');
                    coreGrad.addColorStop(1, 'rgba(77, 208, 225, 0)');

                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI * 2);
                    ctx.fill();

                    // Floating shards (static positions, animated in renderer)
                    ctx.fillStyle = '#4dd0e1';
                    const shardPositions = [
                        { x: -10, y: -14, r: 0.3 },
                        { x: 12, y: -10, r: -0.5 },
                        { x: -8, y: 12, r: 0.7 }
                    ];
                    shardPositions.forEach(s => {
                        ctx.save();
                        ctx.translate(s.x, s.y);
                        ctx.rotate(s.r);
                        ctx.beginPath();
                        ctx.moveTo(0, -3);
                        ctx.lineTo(2, 0);
                        ctx.lineTo(0, 3);
                        ctx.lineTo(-2, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    });
                }
                ctx.restore();
            });


            // --- SNIPER TURRET (Rail Gun) ---
            this.generateTexture(`turret_sniper_${level}`, size, (ctx, w, h) => {
                ctx.save();
                const cx = w / 2;
                const cy = h / 2;
                ctx.translate(cx, cy);

                // Level 1: Precision rifle + scope
                // Level 2: + Carbon fiber body + enhanced optics
                // Level 3: + Energy rails + neon accents

                const barrelLen = 28 + level * 4; // 32-40px
                const barrelBaseH = 6 + level; // 7-9px
                const barrelTipH = 3 + level; // 4-6px

                // === BODY (Angular armored housing) ===
                const bodyGrad = ctx.createLinearGradient(-12, -10, -12, 10);
                bodyGrad.addColorStop(0, '#558b2f'); // Light green top
                bodyGrad.addColorStop(0.5, '#33691e'); // Forest green
                bodyGrad.addColorStop(1, '#1b5e20'); // Dark green bottom

                ctx.fillStyle = bodyGrad;
                ctx.beginPath();
                ctx.moveTo(-12, -9);
                ctx.lineTo(8, -6);
                ctx.lineTo(8, 6);
                ctx.lineTo(-12, 9);
                ctx.closePath();
                ctx.fill();

                // Body outline
                ctx.strokeStyle = '#1b5e20';
                ctx.lineWidth = 1;
                ctx.stroke();

                // === BARREL (Tapered precision barrel) ===
                const barrelGrad = ctx.createLinearGradient(6, 0, barrelLen, 0);
                barrelGrad.addColorStop(0, '#424242'); // Gun metal
                barrelGrad.addColorStop(0.3, '#616161');
                barrelGrad.addColorStop(0.7, '#757575');
                barrelGrad.addColorStop(1, '#9e9e9e'); // Light tip

                ctx.fillStyle = barrelGrad;
                ctx.beginPath();
                ctx.moveTo(6, -barrelBaseH / 2);
                ctx.lineTo(barrelLen, -barrelTipH / 2);
                ctx.lineTo(barrelLen, barrelTipH / 2);
                ctx.lineTo(6, barrelBaseH / 2);
                ctx.closePath();
                ctx.fill();

                // Barrel highlight
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(8, -barrelBaseH / 2 + 1);
                ctx.lineTo(barrelLen - 2, -barrelTipH / 2 + 1);
                ctx.stroke();

                // === MUZZLE BRAKE ===
                ctx.fillStyle = '#37474f';
                ctx.fillRect(barrelLen - 3, -barrelTipH / 2 - 2, 5, barrelTipH + 4);

                // Brake slots
                ctx.strokeStyle = '#263238';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(barrelLen - 1, -barrelTipH / 2 - 1);
                ctx.lineTo(barrelLen - 1, barrelTipH / 2 + 1);
                ctx.stroke();

                // === SCOPE (Level 1+) ===
                // Scope body
                ctx.fillStyle = '#263238';
                ctx.fillRect(-6, -10, 14, 4);

                // Scope lens (front)
                const lensGrad = ctx.createRadialGradient(8, -8, 0, 8, -8, 3);
                lensGrad.addColorStop(0, '#4dd0e1'); // Cyan center
                lensGrad.addColorStop(0.6, '#00acc1');
                lensGrad.addColorStop(1, '#006064');

                ctx.fillStyle = lensGrad;
                ctx.beginPath();
                ctx.arc(8, -8, 3, 0, Math.PI * 2);
                ctx.fill();

                // Lens reflection
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.beginPath();
                ctx.arc(7, -9, 1, 0, Math.PI * 2);
                ctx.fill();

                // === LEVEL 2+ DETAILS ===
                if (level >= 2) {
                    // Carbon fiber pattern on body
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-10 + i * 5, -7);
                        ctx.lineTo(-8 + i * 5, 7);
                        ctx.stroke();
                    }

                    // Enhanced scope mount
                    ctx.fillStyle = '#37474f';
                    ctx.fillRect(-2, -12, 6, 3);
                }

                // === LEVEL 3: ENERGY RAILS ===
                if (level === 3) {
                    ctx.strokeStyle = '#69f0ae'; // Neon green
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#69f0ae';
                    ctx.shadowBlur = 4;

                    // Top rail
                    ctx.beginPath();
                    ctx.moveTo(10, -barrelBaseH / 2 - 1);
                    ctx.lineTo(barrelLen - 5, -barrelTipH / 2 - 1);
                    ctx.stroke();

                    // Bottom rail
                    ctx.beginPath();
                    ctx.moveTo(10, barrelBaseH / 2 + 1);
                    ctx.lineTo(barrelLen - 5, barrelTipH / 2 + 1);
                    ctx.stroke();

                    ctx.shadowBlur = 0;

                    // Energy core in body
                    const coreGrad = ctx.createRadialGradient(-2, 0, 0, -2, 0, 5);
                    coreGrad.addColorStop(0, '#b9f6ca');
                    coreGrad.addColorStop(0.5, '#69f0ae');
                    coreGrad.addColorStop(1, 'rgba(105,240,174,0)');

                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(-2, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            });


            // --- SPLIT TURRET (Rocket Volley) ---
            this.generateTexture(`turret_split_${level}`, size, (ctx, w, h) => {
                ctx.save();
                const cx = w / 2;
                const cy = h / 2;
                ctx.translate(cx, cy);

                // Level 1: 2 rocket tubes + base turret
                // Level 2: 3 tubes + armor plates
                // Level 3: 4 tubes + energy ring

                const barrelCount = level + 1; // 2, 3, 4
                const barrelLen = 20 + level * 3; // 23-29px
                const barrelW = 5 + level; // 6-8px

                const spreadAngle = 0.25; // Radians between tubes
                const startAngle = -spreadAngle * (barrelCount - 1) / 2;

                // === ROCKET TUBES ===
                for (let i = 0; i < barrelCount; i++) {
                    ctx.save();
                    ctx.rotate(startAngle + i * spreadAngle);

                    // Tube gradient (dark to hot)
                    const tubeGrad = ctx.createLinearGradient(0, 0, barrelLen, 0);
                    tubeGrad.addColorStop(0, '#5d4037'); // Dark brown base
                    tubeGrad.addColorStop(0.6, '#8d6e63'); // Medium brown
                    tubeGrad.addColorStop(1, '#ff8f00'); // Amber tip

                    ctx.fillStyle = tubeGrad;
                    ctx.beginPath();
                    ctx.moveTo(8, -barrelW / 2);
                    ctx.lineTo(barrelLen, -barrelW / 2 + 1);
                    ctx.lineTo(barrelLen, barrelW / 2 - 1);
                    ctx.lineTo(8, barrelW / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Tube hollow (dark interior)
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(barrelLen, 0, barrelW / 2 - 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Tube band
                    ctx.fillStyle = '#3e2723';
                    ctx.fillRect(12, -barrelW / 2 - 1, 3, barrelW + 2);

                    // Tube highlight
                    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(10, -barrelW / 2 + 1);
                    ctx.lineTo(barrelLen - 2, -barrelW / 2 + 2);
                    ctx.stroke();

                    ctx.restore();
                }

                // === ARMORED BODY (Squared with chamfers - military look) ===
                const bodySize = 13 + level; // 14-16px
                const chamfer = 4;

                // Squared body path
                const squarePath = () => {
                    ctx.beginPath();
                    ctx.moveTo(-bodySize + chamfer, -bodySize);
                    ctx.lineTo(bodySize - chamfer, -bodySize);
                    ctx.lineTo(bodySize, -bodySize + chamfer);
                    ctx.lineTo(bodySize, bodySize - chamfer);
                    ctx.lineTo(bodySize - chamfer, bodySize);
                    ctx.lineTo(-bodySize + chamfer, bodySize);
                    ctx.lineTo(-bodySize, bodySize - chamfer);
                    ctx.lineTo(-bodySize, -bodySize + chamfer);
                    ctx.closePath();
                };

                const bodyGrad = ctx.createRadialGradient(-2, -2, 0, 0, 0, bodySize * 1.2);
                bodyGrad.addColorStop(0, '#ffca28');
                bodyGrad.addColorStop(0.4, '#ff8f00');
                bodyGrad.addColorStop(1, '#e65100');

                ctx.fillStyle = bodyGrad;
                squarePath();
                ctx.fill();

                // Outline
                ctx.strokeStyle = '#bf360c';
                ctx.lineWidth = 2;
                squarePath();
                ctx.stroke();

                // === LEVEL 2+ ARMOR PLATES ===
                if (level >= 2) {
                    ctx.fillStyle = '#5d4037';
                    // Side plates
                    ctx.fillRect(-bodySize - 2, -4, 4, 8);
                    ctx.fillRect(bodySize - 2, -4, 4, 8);

                    // Top/bottom rivets
                    ctx.fillStyle = '#8d6e63';
                    [-6, 0, 6].forEach(x => {
                        ctx.beginPath();
                        ctx.arc(x, -bodySize + 3, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(x, bodySize - 3, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                // === LEVEL 3: ENERGY RING ===
                if (level === 3) {
                    ctx.strokeStyle = '#ffab00';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#ffab00';
                    ctx.shadowBlur = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, bodySize + 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Inner core glow
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 5);
                    coreGrad.addColorStop(0, '#fff8e1');
                    coreGrad.addColorStop(0.5, '#ffca28');
                    coreGrad.addColorStop(1, 'rgba(255,202,40,0)');

                    ctx.fillStyle = coreGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            });



            // --- VOID PRISM (Magical Minigun) ---
            // Pedestal only - floating crystal is drawn procedurally by renderer
            this.generateTexture(`turret_minigun_${level}`, size, (ctx, w, h) => {
                ctx.save();
                const cx = w / 2;
                const cy = h / 2;
                ctx.translate(cx, cy);

                // Level 1: Stone pedestal
                // Level 2: + Rune carvings
                // Level 3: + Energy channel + glow

                // === PEDESTAL BASE ===
                const baseW = 20 + level * 2; // 22-26px
                const baseH = 10 + level; // 11-13px

                // Pedestal gradient (dark stone)
                const baseGrad = ctx.createLinearGradient(0, 0, 0, baseH);
                baseGrad.addColorStop(0, '#37474f'); // Blue grey 800
                baseGrad.addColorStop(0.5, '#263238'); // Blue grey 900
                baseGrad.addColorStop(1, '#1a1a1a'); // Near black

                ctx.fillStyle = baseGrad;
                ctx.beginPath();
                ctx.moveTo(-baseW / 2, 0);
                ctx.lineTo(-baseW / 2 + 4, baseH);
                ctx.lineTo(baseW / 2 - 4, baseH);
                ctx.lineTo(baseW / 2, 0);
                ctx.closePath();
                ctx.fill();

                // Pedestal top rim
                ctx.fillStyle = '#455a64';
                ctx.fillRect(-baseW / 2 + 2, -2, baseW - 4, 4);

                // Pedestal highlight
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-baseW / 2 + 3, -1);
                ctx.lineTo(baseW / 2 - 3, -1);
                ctx.stroke();

                // === RUNE CARVINGS (Level 2+) ===
                if (level >= 2) {
                    ctx.strokeStyle = '#7c4dff'; // Deep purple glow
                    ctx.lineWidth = 1;

                    // Left rune
                    ctx.beginPath();
                    ctx.moveTo(-8, 2);
                    ctx.lineTo(-6, 6);
                    ctx.lineTo(-10, 6);
                    ctx.closePath();
                    ctx.stroke();

                    // Right rune
                    ctx.beginPath();
                    ctx.moveTo(8, 2);
                    ctx.lineTo(10, 6);
                    ctx.lineTo(6, 6);
                    ctx.closePath();
                    ctx.stroke();

                    // Center rune
                    ctx.beginPath();
                    ctx.moveTo(0, 3);
                    ctx.lineTo(0, 7);
                    ctx.stroke();
                }

                // === ENERGY CHANNEL (Level 3) ===
                if (level === 3) {
                    // Glowing channel up the pedestal
                    const channelGrad = ctx.createLinearGradient(0, baseH, 0, -5);
                    channelGrad.addColorStop(0, 'rgba(124,77,255,0.1)');
                    channelGrad.addColorStop(0.5, 'rgba(124,77,255,0.4)');
                    channelGrad.addColorStop(1, 'rgba(124,77,255,0.8)');

                    ctx.fillStyle = channelGrad;
                    ctx.fillRect(-2, -5, 4, baseH + 3);

                    // Side energy lines
                    ctx.strokeStyle = '#b388ff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-baseW / 2 + 5, 1);
                    ctx.lineTo(-4, -3);
                    ctx.moveTo(baseW / 2 - 5, 1);
                    ctx.lineTo(4, -3);
                    ctx.stroke();
                }
                ctx.restore();
            });
        }


        // -- 3. Modules (Overlay attachments) --

        // Mod Ice (Cooling tank - Blue canister)
        this.generateTexture('mod_ice', 24, (ctx, w, h) => {
            // Anchor point is roughly center relative to mounting point
            ctx.fillStyle = VISUALS.TOWER.MODULES.ICE.BODY; // Light Blue 800
            ctx.fillRect(4, 4, 16, 10);
            ctx.fillStyle = VISUALS.TOWER.MODULES.ICE.LIQUID; // Light Blue 300 (liquid level)
            ctx.fillRect(6, 6, 12, 6);
            // Cap
            ctx.fillStyle = VISUALS.TOWER.MODULES.ICE.CAP;
            ctx.fillRect(18, 6, 4, 6);
        });

        // Mod Fire (Fuel tank - Red canister)
        this.generateTexture('mod_fire', 24, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.MODULES.FIRE.BODY; // Red 800
            ctx.beginPath();
            ctx.rect(6, 4, 12, 16);
            ctx.fill();
            // Symbol
            ctx.fillStyle = VISUALS.TOWER.MODULES.FIRE.SYMBOL;
            ctx.font = '10px Arial';
            ctx.fillText('‚ö°', 8, 16);
        });

        // Mod Sniper (Scope - Lens)
        this.generateTexture('mod_sniper', 24, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.MODULES.SNIPER.BODY; // Black body
            ctx.fillRect(2, 8, 20, 8);
            // Lens
            ctx.fillStyle = VISUALS.TOWER.MODULES.SNIPER.LENS; // Cyan accent
            ctx.beginPath();
            ctx.arc(22, 12, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        // Mod Split (Ammo box / Extra barrel)
        this.generateTexture('mod_split', 24, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.MODULES.SPLIT.BODY; // Amber 900
            ctx.fillRect(4, 4, 16, 16);
            // Bullets hint
            ctx.fillStyle = VISUALS.TOWER.MODULES.SPLIT.ACCENT;
            ctx.fillRect(6, 6, 4, 12);
            ctx.fillRect(14, 6, 4, 12);
        });

        // Mod Minigun (Ammo belt / Power cell)
        this.generateTexture('mod_minigun', 24, (ctx, w, h) => {
            // Purple ammunition belt with electric coils
            ctx.fillStyle = '#6a1b9a'; // Purple 800
            ctx.fillRect(4, 6, 16, 12);

            // Belt links
            ctx.fillStyle = '#ce93d8'; // Purple 200 (light)
            for (let i = 0; i < 4; i++) {
                ctx.fillRect(6 + i * 4, 8, 2, 8);
            }

            // Energy cell accent
            ctx.fillStyle = '#ba68c8'; // Purple 300
            ctx.beginPath();
            ctx.arc(12, 12, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        this.generateEnemyArchetypes();
        this.generateEnemyProps();
    }

    private static generateEnemyArchetypes() {
        const size = 48; // Base enemy size

        // 1. Skeleton (Standard)
        this.generateTexture('enemy_skeleton', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Bones (White/Grey)
            ctx.fillStyle = VISUALS.ENEMY.SKELETON.BONE;

            // Skull
            ctx.beginPath();
            ctx.arc(cx, cy - 5, 10, 0, Math.PI * 2);
            ctx.fill();

            // Ribcage/Shoulders
            ctx.fillRect(cx - 8, cy + 2, 16, 6);

            // Spine
            ctx.fillRect(cx - 2, cy + 8, 4, 8);

            // Pelvis
            ctx.fillRect(cx - 6, cy + 16, 12, 4);

            // Eyes (Hollow)
            ctx.fillStyle = VISUALS.ENEMY.SKELETON.EYES;
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 5, 2, 0, Math.PI * 2);
            ctx.arc(cx + 3, cy - 5, 2, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. Wolf (Fast)
        this.generateTexture('enemy_wolf', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Body (Elongated) - Grey/Brown
            ctx.fillStyle = VISUALS.ENEMY.WOLF.BODY; // Brownish grey

            ctx.beginPath();
            ctx.ellipse(cx, cy + 2, 8, 14, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.arc(cx, cy - 10, 8, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.beginPath();
            ctx.moveTo(cx - 5, cy - 14);
            ctx.lineTo(cx - 8, cy - 20);
            ctx.lineTo(cx - 2, cy - 16);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(cx + 5, cy - 14);
            ctx.lineTo(cx + 8, cy - 20);
            ctx.lineTo(cx + 2, cy - 16);
            ctx.fill();

            // Tail
            ctx.strokeStyle = VISUALS.ENEMY.WOLF.BODY;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(cx, cy + 14);
            ctx.lineTo(cx, cy + 22);
            ctx.stroke();

            // Eyes (Red glow)
            ctx.fillStyle = VISUALS.ENEMY.WOLF.EYES;
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.arc(cx + 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.fill();
        });

        // 3. Troll (Heavy)
        this.generateTexture('enemy_troll', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Body (Massive) - Green skin
            ctx.fillStyle = VISUALS.ENEMY.TROLL.SKIN;

            ctx.beginPath();
            ctx.arc(cx, cy, 18, 0, Math.PI * 2);
            ctx.fill();

            // Arms (Big shoulders)
            ctx.beginPath();
            ctx.arc(cx - 16, cy - 5, 8, 0, Math.PI * 2);
            ctx.arc(cx + 16, cy - 5, 8, 0, Math.PI * 2);
            ctx.fill();

            // Head (Small relative to body)
            ctx.beginPath();
            ctx.arc(cx, cy - 10, 10, 0, Math.PI * 2);
            ctx.fill();

            // Angry brow
            ctx.fillStyle = VISUALS.ENEMY.TROLL.FEATURE;
            ctx.beginPath();
            ctx.arc(cx, cy - 12, 10, 0.2, Math.PI - 0.2, true);
            ctx.fill();
        });

        // 4. Spider (Boss)
        this.generateTexture('enemy_spider', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Abdomen (Large rear) - Black/Dark Purple
            ctx.fillStyle = VISUALS.ENEMY.SPIDER.BODY;
            ctx.beginPath();
            ctx.ellipse(cx, cy + 8, 12, 16, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cephalothorax (Head/Chest)
            ctx.fillStyle = VISUALS.ENEMY.SPIDER.HEAD;
            ctx.beginPath();
            ctx.arc(cx, cy - 8, 10, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.strokeStyle = VISUALS.ENEMY.SPIDER.BODY;
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                // Right legs
                ctx.beginPath();
                ctx.moveTo(cx + 5, cy - 5 + i * 4);
                ctx.lineTo(cx + 20, cy - 10 + i * 6);
                ctx.stroke();

                // Left legs
                ctx.beginPath();
                ctx.moveTo(cx - 5, cy - 5 + i * 4);
                ctx.lineTo(cx - 20, cy - 10 + i * 6);
                ctx.stroke();
            }

            // Many eyes
            ctx.fillStyle = VISUALS.ENEMY.SPIDER.EYES;
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.arc(cx + 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.arc(cx, cy - 12, 2, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    private static generateEnemyProps() {
        const size = 32;

        // 1. Shield (Armor)
        this.generateTexture('prop_shield', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Wood texture
            ctx.fillStyle = VISUALS.ENEMY.PROPS.SHIELD.WOOD;
            ctx.beginPath();
            ctx.arc(cx, cy, 12, 0, Math.PI * 2);
            ctx.fill();
            // Metal rim
            ctx.strokeStyle = VISUALS.ENEMY.PROPS.SHIELD.METAL;
            ctx.lineWidth = 3;
            ctx.stroke();
            // Center boss
            ctx.fillStyle = VISUALS.ENEMY.PROPS.SHIELD.METAL;
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. Helmet (Leader)
        this.generateTexture('prop_helmet', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Gold
            ctx.fillStyle = VISUALS.ENEMY.PROPS.HELMET.GOLD;
            ctx.beginPath();
            ctx.moveTo(cx - 10, cy + 5);
            ctx.lineTo(cx + 10, cy + 5);
            ctx.lineTo(cx + 10, cy - 5);
            ctx.lineTo(cx, cy - 12); // Spike
            ctx.lineTo(cx - 10, cy - 5);
            ctx.closePath();
            ctx.fill();

            // Horns
            ctx.strokeStyle = VISUALS.ENEMY.PROPS.HELMET.HORN;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - 10, cy - 2);
            ctx.quadraticCurveTo(cx - 16, cy - 8, cx - 14, cy - 14);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cx + 10, cy - 2);
            ctx.quadraticCurveTo(cx + 16, cy - 8, cx + 14, cy - 14);
            ctx.stroke();
        });

        // 3. Barrier (Energy Shield)
        this.generateTexture('prop_barrier', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Semi-transparent sphere
            ctx.fillStyle = VISUALS.ENEMY.PROPS.BARRIER.FILL;
            ctx.beginPath();
            ctx.arc(cx, cy, 14, 0, Math.PI * 2);
            ctx.fill();

            // Runes
            ctx.strokeStyle = VISUALS.ENEMY.PROPS.BARRIER.STROKE;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx, cy, 12, 0, Math.PI * 2);
            ctx.stroke();
        });

        // 4. Weapon (Sword)
        this.generateTexture('prop_weapon', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            ctx.translate(cx, cy);
            ctx.rotate(Math.PI / 4); // Diagonal

            // Handle
            ctx.fillStyle = VISUALS.ENEMY.PROPS.WEAPON.HANDLE;
            ctx.fillRect(-2, 4, 4, 10);

            // Guard
            ctx.fillStyle = VISUALS.ENEMY.PROPS.WEAPON.GUARD;
            ctx.fillRect(-6, 2, 12, 2);

            // Blade
            ctx.fillStyle = VISUALS.ENEMY.PROPS.WEAPON.BLADE;
            ctx.fillRect(-3, -14, 6, 16);
            // Tip
            ctx.beginPath();
            ctx.moveTo(-3, -14);
            ctx.lineTo(3, -14);
            ctx.lineTo(0, -18);
            ctx.fill();
        });
    }
    private static generateProjectiles() {
        const size = 16;
        const cx = size / 2;
        const cy = size / 2;

        // 1. Standard (White Ball)
        this.generateTexture('projectile_standard', size, (ctx, w, h) => {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. Ice (Spike)
        this.generateTexture('projectile_ice', size, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.TURRET.ICE.SPIKE;
            ctx.beginPath();
            ctx.moveTo(cx + 6, cy);
            ctx.lineTo(cx - 2, cy + 4);
            ctx.lineTo(cx - 4, cy);
            ctx.lineTo(cx - 2, cy - 4);
            ctx.fill();
        });

        // 3. Fire (Fireball)
        this.generateTexture('projectile_fire', size, (ctx, w, h) => {
            // Core
            ctx.fillStyle = VISUALS.TOWER.TURRET.FIRE.MAIN;
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, Math.PI * 2);
            ctx.fill();
            // Outer glow (simulated)
            ctx.fillStyle = 'rgba(255, 87, 34, 0.5)';
            ctx.beginPath();
            ctx.arc(cx, cy, 7, 0, Math.PI * 2);
            ctx.fill();
        });

        // 4. Sniper (Bullet Head) - Trail is drawn dynamically
        this.generateTexture('projectile_sniper', size, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.TURRET.SNIPER.BARREL;
            ctx.fillRect(cx - 4, cy - 1.5, 8, 3);
        });

        // 5. Split (Small Pellet)
        this.generateTexture('projectile_split', size, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.TURRET.SPLIT.BARREL;
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        // 6. Minigun (Tracer round)
        this.generateTexture('projectile_minigun', size, (ctx, w, h) => {
            // Small fast tracer with purple/electric glow
            ctx.fillStyle = '#ba68c8'; // Purple 300
            ctx.fillRect(cx - 2, cy - 1, 5, 2);

            // Core
            ctx.fillStyle = '#e1bee7'; // Purple 100 (bright center)
            ctx.fillRect(cx, cy - 0.5, 3, 1);
        });
    }

    private static generateMisc() {
        // Shadow (Generic)
        this.generateTexture('shadow_small', 32, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(cx, cy, 12, 6, 0, 0, Math.PI * 2);
            ctx.fill();
        });

        // Muzzle Flash
        this.generateTexture('effect_muzzle_flash', 32, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 12);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(cx, cy, 12, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    /**
     * Runtime Sprite Baking (Phase 3)
     */
    private static generateBakedSprites() {
        try {
            // 1. Orc
            SpriteBaker.bakeWalkCycle('orc', new OrcUnitRenderer());
            console.log('‚úì Baked walk cycle for "orc"');

            // 2. Skeleton
            SpriteBaker.bakeWalkCycle('skeleton', new SkeletonUnitRenderer());
            console.log('‚úì Baked walk cycle for "skeleton"');

            // 2.5 Skeleton Miner
            SpriteBaker.bakeWalkCycle('skeleton_miner', new SkeletonMinerRenderer());
            console.log('‚úì Baked walk cycle for "skeleton_miner"');

            // 3. Goblin
            SpriteBaker.bakeWalkCycle('goblin', new GoblinUnitRenderer());
            console.log('‚úì Baked walk cycle for "goblin"');

            // 4. Spider
            SpriteBaker.bakeWalkCycle('spider', new SpiderUnitRenderer());
            console.log('‚úì Baked walk cycle for "spider"');

            // 5. Troll
            SpriteBaker.bakeWalkCycle('troll', new TrollUnitRenderer());
            console.log('‚úì Baked walk cycle for "troll"');

            // 6. Rat
            SpriteBaker.bakeWalkCycle('rat', new RatUnitRenderer());
            SpriteBaker.bakeWalkCycle('sapper_rat', new RatUnitRenderer());
            console.log('‚úì Baked walk cycle for "rat" & "sapper_rat"');

            // 7. Hellhound
            SpriteBaker.bakeWalkCycle('hellhound', new HellhoundUnitRenderer());
            SpriteBaker.bakeWalkCycle('scout', new HellhoundUnitRenderer());
            SpriteBaker.bakeWalkCycle('skeleton_berserker', new SkeletonBerserkerRenderer());
            SpriteBaker.bakeWalkCycle('skeleton_commander', new SkeletonCommanderUnitRenderer());
            console.log('‚úì Baked walk cycle for "hellhound", "scout", "skeleton_berserker", "skeleton_commander"');

            // 8. Magma (King & Statue)
            SpriteBaker.bakeWalkCycle('magma_king', new MagmaUnitRenderer());
            SpriteBaker.bakeWalkCycle('magma_statue', new MagmaUnitRenderer());
            console.log('‚úì Baked walk cycle for "magma_king" & "magma_statue"');

            // 9. Flesh Colossus
            SpriteBaker.bakeWalkCycle('flesh_colossus', new FleshUnitRenderer());
            console.log('‚úì Baked walk cycle for "flesh_colossus"');

            // TODO: Add more enemies here as their renderers are updated

        } catch (e) {
            console.error('Failed to bake sprites:', e);
        }
    }
}
</file>

<file path="src/scenes/MenuScene.ts">
import { BaseScene } from '../BaseScene';
import { Game } from '../Game';
import { DEMO_MAP, IMapData } from '../MapData';
import { validateMap } from '../Utils';
import { MapStorage } from '../MapStorage';
import { MapManager } from '../Map';
import { CONFIG } from '../Config';
import { UIUtils } from '../UIUtils';
import { Assets } from '../Assets';
import { VISUALS } from '../VisualConfig';
import { StressTestScene } from './StressTestScene';

export class MenuScene extends BaseScene {
    private game: Game;
    private container!: HTMLElement;
    private mapSelectionContainer!: HTMLElement;
    private _refreshGeneration: number = 0;

    constructor(game: Game) {
        super();
        this.game = game;
        // UI creation moved to onEnterImpl
    }

    protected onEnterImpl() {
        if (!this.container) {
            this.createUI();
        }
        if (!this.mapSelectionContainer) {
            this.createMapSelectionUI();
        }

        this.container.style.display = 'flex';
        this.mapSelectionContainer.style.display = 'none';

        // Hide game UI layers via UIRoot
        this.game.uiRoot.hideGameUI();
    }

    protected onExitImpl() {
        if (this.container) this.container.style.display = 'none';
        if (this.mapSelectionContainer) this.mapSelectionContainer.style.display = 'none';

        // Cleanup canvas elements to prevent memory leaks
        this.clearMapPreviews();
    }

    public update(dt: number) { }

    public draw(ctx: CanvasRenderingContext2D) {
        // === –§–æ–Ω–æ–≤–æ–µ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ ===
        const bgImage = Assets.get('menu_start');
        if (bgImage) {
            // Cover-fit —Å —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º (–º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ—Ç —á—Ç–æ–±—ã –ø–æ–∫—Ä—ã—Ç—å –≤–µ—Å—å canvas)
            const scale = Math.max(
                this.game.width / bgImage.width,
                this.game.height / bgImage.height
            );
            const x = (this.game.width - bgImage.width * scale) / 2;
            const y = (this.game.height - bgImage.height * scale) / 2;

            ctx.drawImage(bgImage, x, y, bgImage.width * scale, bgImage.height * scale);

            // –ó–∞—Ç–µ–º–Ω–µ–Ω–∏–µ –¥–ª—è —á–∏—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç–∏
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, this.game.width, this.game.height);
        } else {
            // === Fallback - —Å—Ç–∞—Ä—ã–π —Ñ–æ–Ω (—Å–µ—Ç–∫–∞) ===
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, this.game.width, this.game.height);

            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            const s = 64;
            const gridSize = 64;
            for (let x = 0; x < this.game.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, this.game.height);
                ctx.stroke();
            }
            for (let y = 0; y < this.game.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(this.game.width, y);
                ctx.stroke();
            }
        }

        // === –ó–∞–≥–æ–ª–æ–≤–æ–∫ ===
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 60px Segoe UI';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // –î–≤–æ–π–Ω–∞—è —Ç–µ–Ω—å –¥–ª—è –≥–ª—É–±–∏–Ω—ã
        ctx.shadowColor = 'rgba(0,0,0,0.9)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetY = 4;
        ctx.fillText('NEW TOWER', this.game.width / 2, 150);

        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–æ–¥—Å–≤–µ—Ç–∫–∞
        ctx.shadowColor = 'rgba(255,255,255,0.3)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetY = -2;
        ctx.fillText('NEW TOWER', this.game.width / 2, 150);

        ctx.restore();
    }


    private createUI() {
        this.container = UIUtils.createContainer({
            position: 'absolute',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            display: 'none',
            flexDirection: 'column',
            alignItems: 'flex-start', // –°–¥–≤–∏–≥ –≤–ª–µ–≤–æ
            justifyContent: 'center',
            gap: '20px',
            pointerEvents: 'none'
        });
        // –î–æ–±–∞–≤–ª—è–µ–º paddingLeft –≤—Ä—É—á–Ω—É—é
        this.container.style.paddingLeft = '15%';

        UIUtils.createButton(this.container, '‚ñ∂ START GAME', () => {
            this.showMapSelection();
        }, { width: '300px', fontSize: '24px', padding: '15px 40px' });

        UIUtils.createButton(this.container, 'üõ† EDITOR', () => {
            this.game.toEditor();
        }, { width: '300px', fontSize: '24px', padding: '15px 40px' });

        UIUtils.createButton(this.container, 'üß™ STRESS TEST', () => {
            // Dynamic import to avoid circular dependency if any, 
            // but standard import is fine here as MenuScene -> StressTestScene is one way usually.
            // However, to be safe let's use the import at top.
            this.game.changeScene(new StressTestScene(this.game));
        }, { width: '300px', fontSize: '24px', padding: '15px 40px', background: 'linear-gradient(135deg, #444, #222)' });

        document.body.appendChild(this.container);
    }

    private createMapSelectionUI() {
        this.mapSelectionContainer = UIUtils.createContainer({
            position: 'absolute',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            display: 'none',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: '2000',
            color: '#fff'
        });
        // –§–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤—Ä—É—á–Ω—É—é (–∏–∑ –∫–æ—Ä–Ω—è)
        this.mapSelectionContainer.style.backgroundImage = 'url("../map.jpg")';
        this.mapSelectionContainer.style.backgroundSize = 'cover';
        this.mapSelectionContainer.style.backgroundPosition = 'center';
        this.mapSelectionContainer.style.backgroundRepeat = 'no-repeat';

        // –ó–∞—Ç–µ–º–Ω—è—é—â–∏–π overlay —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º –¥–ª—è –ª—É—á—à–µ–≥–æ —Ñ–æ–∫—É—Å–∞
        const overlay = document.createElement('div');
        Object.assign(overlay.style, {
            position: 'absolute',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            background: 'radial-gradient(circle at center, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.7) 100%)',
            zIndex: '-1',
            pointerEvents: 'none'
        });
        this.mapSelectionContainer.appendChild(overlay);

        const title = document.createElement('h2');
        title.innerText = 'SELECT MAP';
        Object.assign(title.style, {
            marginBottom: `${VISUALS.UI.SPACING.xl}px`,
            fontSize: VISUALS.UI.FONTS.size.huge,
            fontWeight: VISUALS.UI.FONTS.weight.bold,
            textShadow: VISUALS.UI.SHADOWS.lg,
            letterSpacing: '2px'
        });
        this.mapSelectionContainer.appendChild(title);

        const listContainer = document.createElement('div');
        Object.assign(listContainer.style, {
            display: 'flex',
            gap: `${VISUALS.UI.SPACING.lg}px`,
            overflowX: 'auto',
            overflowY: 'hidden',
            maxWidth: '90%',
            maxHeight: '70vh',
            padding: `${VISUALS.UI.SPACING.xl}px`,
            border: `${VISUALS.UI.BORDERS.width.normal} solid ${VISUALS.UI.COLORS.glass.border}`,
            borderRadius: VISUALS.UI.BORDERS.radius.xl,
            background: VISUALS.UI.COLORS.glass.bgLight,
            backdropFilter: 'blur(10px)',
            boxShadow: VISUALS.UI.SHADOWS.xl,
            scrollbarWidth: 'thin',
            scrollbarColor: `${VISUALS.UI.COLORS.glass.borderHover} ${VISUALS.UI.COLORS.glass.bgDark}`
        });
        this.mapSelectionContainer.appendChild(listContainer);

        // Function to refresh list
        (this.mapSelectionContainer as any).refreshList = () => {
            const gen = ++this._refreshGeneration;
            listContainer.innerHTML = '';

            // DEMO MAP
            this.createMapCard(listContainer, 'Demo Map', DEMO_MAP);

            // –§–∞–∑–∞ 1 (sync): local maps –º–≥–Ω–æ–≤–µ–Ω–Ω–æ
            const local = MapStorage.getLocalMaps();
            const localNames = new Set(Object.keys(local));
            for (const key of localNames) {
                this.createMapCard(listContainer, `üíæ ${key}`, local[key]);
            }

            // –§–∞–∑–∞ 2 (async): bundled maps –¥–æ–ø–∏—Å—ã–≤–∞—é—Ç—Å—è
            MapStorage.getBundledMaps().then(bundled => {
                if (gen !== this._refreshGeneration) return; // race condition guard

                for (const name of Object.keys(bundled).sort()) {
                    if (localNames.has(name)) continue; // local override
                    this.createMapCard(listContainer, `üì¶ ${name}`, bundled[name]);
                }
            }).catch(e => {
                console.warn('[MenuScene] Failed to load bundled maps', e);
            });
        };

        UIUtils.createButton(this.mapSelectionContainer, 'BACK', () => {
            this.mapSelectionContainer.style.display = 'none';
            this.container.style.display = 'flex';
        }, {
            background: `linear-gradient(135deg, ${VISUALS.UI.COLORS.danger}, #b71c1c)`,
            fontSize: VISUALS.UI.FONTS.size.xl,
            padding: `${VISUALS.UI.SPACING.md}px ${VISUALS.UI.SPACING.xxl}px`,
            border: `${VISUALS.UI.BORDERS.width.normal} solid ${VISUALS.UI.COLORS.glass.border}`,
            borderRadius: VISUALS.UI.BORDERS.radius.lg,
            boxShadow: VISUALS.UI.SHADOWS.glow.danger,
            width: 'auto'
        });

        document.body.appendChild(this.mapSelectionContainer);
    }

    private createMapCard(parent: HTMLElement, name: string, data: IMapData) {
        try {
            const card = document.createElement('div');
            Object.assign(card.style, {
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                gap: `${VISUALS.UI.SPACING.sm}px`,
                background: VISUALS.UI.COLORS.glass.bg,
                padding: `${VISUALS.UI.SPACING.md}px`,
                borderRadius: VISUALS.UI.BORDERS.radius.lg,
                minWidth: '220px',
                cursor: 'pointer',
                border: `${VISUALS.UI.BORDERS.width.thick} solid ${VISUALS.UI.COLORS.glass.border}`,
                backdropFilter: 'blur(5px)',
                transition: VISUALS.UI.TRANSITIONS.presets.normal,
                boxShadow: VISUALS.UI.SHADOWS.md,
                transform: 'translateZ(0)' // GPU acceleration
            });

            // Preview Canvas
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 150;
            const ctx = canvas.getContext('2d')!;

            // Render preview
            // We need a temporary MapManager to draw
            const tempMap = new MapManager(data);
            // Scale context to fit
            ctx.save();
            const scale = Math.min(200 / (tempMap.cols * CONFIG.TILE_SIZE), 150 / (tempMap.rows * CONFIG.TILE_SIZE));
            ctx.scale(scale, scale);
            tempMap.draw(ctx);
            ctx.restore();

            card.appendChild(canvas);

            const label = document.createElement('div');
            label.innerText = name;
            label.style.fontWeight = VISUALS.UI.FONTS.weight.bold;
            label.style.fontSize = VISUALS.UI.FONTS.size.lg;
            label.style.textShadow = VISUALS.UI.SHADOWS.md;
            card.appendChild(label);

            card.onmouseover = () => {
                card.style.borderColor = VISUALS.UI.COLORS.primary;
                card.style.transform = 'scale(1.05) translateY(-5px)';
                card.style.boxShadow = VISUALS.UI.SHADOWS.glow.primary;
            };
            card.onmouseout = () => {
                card.style.borderColor = VISUALS.UI.COLORS.glass.border;
                card.style.transform = 'scale(1)';
                card.style.boxShadow = VISUALS.UI.SHADOWS.md;
            };
            card.onclick = () => {
                console.log('Map card clicked:', name);
                console.log('Map data:', data);
                const isValid = validateMap(data);
                console.log('Map validation result:', isValid);
                if (isValid) {
                    console.log('Calling toGame...');
                    this.game.toGame(data);
                } else {
                    console.error('Map is invalid!');
                    alert('Map is invalid!');
                }
            };

            parent.appendChild(card);
        } catch (e) {
            console.error(`Failed to render map card for ${name}`, e);
            const errCard = document.createElement('div');
            errCard.innerText = `‚ùå ${name} (Corrupted)`;
            Object.assign(errCard.style, {
                background: '#300',
                color: '#f88',
                padding: '10px',
                borderRadius: '8px',
                minWidth: '200px',
                textAlign: 'center',
            });
            parent.appendChild(errCard);
        }
    }

    /**
     * Clears canvas previews to prevent memory leaks
     */
    private clearMapPreviews(): void {
        // Find the list container with map cards
        const listContainer = this.mapSelectionContainer.querySelector('div[style*="overflowX"]') as HTMLElement;
        if (!listContainer) return;

        // Clear all canvas contexts before removing from DOM
        const canvases = listContainer.querySelectorAll('canvas');
        canvases.forEach(canvas => {
            const ctx = canvas.getContext('2d');
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        });

        // Remove all map cards to free memory
        listContainer.innerHTML = '';
    }

    private showMapSelection() {
        this.container.style.display = 'none';
        this.mapSelectionContainer.style.display = 'flex';
        if ((this.mapSelectionContainer as any).refreshList) {
            (this.mapSelectionContainer as any).refreshList();
        }
    }

    // createBtn removed - replaced by UIUtils.createButton
}
</file>

<file path="src/Projectile.ts">
import { ICardEffect } from './cards';
import { Assets } from './Assets';
import { RendererFactory } from './RendererFactory';

export interface IProjectileStats {
    dmg: number;
    speed: number;
    color: string;
    effects: ICardEffect[];
    pierce: number;
    critChance?: number;           // Critical hit chance (0-1)
    isCrit?: boolean;               // Is this projectile a crit
    explodeOnDeath?: boolean;       // Fire level 3 effect
    explosionDamage?: number;       // Damage from explosion
    explosionRadius?: number;       // Radius of explosion
    projectileType?: string;        // Visual type: standard, ice, fire, sniper, split
    towerLevel?: number;            // Tower's max card level (for trail effects)
}

export class Projectile {
    public x: number = 0;
    public y: number = 0;
    public vx: number = 0;
    public vy: number = 0;
    public radius: number = 4;
    public alive: boolean = false;

    public damage: number = 0;
    public life: number = 0;
    public color: string = '#fff';
    public effects: ICardEffect[] = [];
    public pierce: number = 0;
    public hitList: number[] = [];
    public isCrit: boolean = false;           // Is this a critical hit
    public explodeOnDeath: boolean = false;   // Should explode on enemy death
    public explosionDamage: number = 0;       // Damage from explosion
    public explosionRadius: number = 0;       // Radius of explosion
    public projectileType: string = 'standard'; // Visual type
    public towerLevel: number = 1;            // Tower's max card level (for trails)

    private static readonly EMPTY_EFFECTS: ICardEffect[] = [];

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –ø—É—Å—Ç–æ–π!
    constructor() { }

    // –ú–µ—Ç–æ–¥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ –ø—É–ª–∞)
    public init(x: number, y: number, target: { x: number; y: number }, stats: IProjectileStats) {
        this.x = x;
        this.y = y;
        this.alive = true;
        this.damage = stats.dmg;
        this.color = stats.color;
        this.effects = stats.effects || Projectile.EMPTY_EFFECTS;
        this.pierce = stats.pierce || 0;
        this.hitList.length = 0; // PERF: Reuse array instead of allocating new
        this.projectileType = stats.projectileType || 'standard';
        this.towerLevel = stats.towerLevel || 1;
        this.radius = 4; // Default radius

        // Handle critical hits
        const critChance = stats.critChance || 0;
        this.isCrit = Math.random() < critChance;
        if (this.isCrit) {
            this.damage *= 2; // Critical hits deal 2x damage
        }

        // Handle explosion on death effect (Fire level 3)
        const explodeEffect = this.effects.find((e: any) => e.type === 'explodeOnDeath');
        if (explodeEffect) {
            this.explodeOnDeath = true;
            this.explosionDamage = stats.dmg * (explodeEffect.explosionDamagePercent || 0.5);
            this.explosionRadius = explodeEffect.explosionRadius || 40;
        } else {
            this.explodeOnDeath = false;
            this.explosionDamage = 0;
            this.explosionRadius = 0;
        }

        const angle = Math.atan2(target.y - y, target.x - x);
        this.vx = Math.cos(angle) * stats.speed;
        this.vy = Math.sin(angle) * stats.speed;

        this.life = 2.0; // 2 —Å–µ–∫—É–Ω–¥—ã –∂–∏–∑–Ω–∏
        // Adjust life for sniper (faster = less time needed)
        if (this.projectileType === 'sniper') this.life = 1.0;
    }

    // Decoupled update: No effects dependency
    public update(dt: number = 1) {
        if (!this.alive) return;

        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;

        if (this.life <= 0 || this.x < -100 || this.x > 2000 || this.y < -100 || this.y > 2000) {
            this.alive = false;
        }
    }

    public draw(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawProjectile(ctx, this);
    }

    public reset() {
        this.alive = false;
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.damage = 0;
        this.life = 0;
        this.effects = Projectile.EMPTY_EFFECTS; // Zero alloc reset
        this.hitList.length = 0;

        this.isCrit = false;
        this.explodeOnDeath = false;
        this.explosionDamage = 0;
        this.explosionRadius = 0;
        this.projectileType = 'standard';
        this.towerLevel = 1;
        this.pierce = 0;
        this.radius = 4;
        this.color = '#fff';
    }
}
</file>

<file path="src/Utils.ts">
import { MapManager } from './Map';
import { IMapData, IWaveConfig, IWaveGroupRaw, MAP_SCHEMA_VERSION } from './MapData';
import { CONFIG } from './Config';

// Fast ID generator using counter instead of regex-based UUID
let _idCounter = 0;
export function generateUUID(): string {
    return `id_${++_idCounter}_${Date.now().toString(36)}`;
}

/**
 * Linearly interpolates between two angles, handling the cyclic nature of rotation.
 * @param start Current angle (radians)
 * @param end Target angle (radians)
 * @param t Interpolation factor (0.0 to 1.0, usually dt * speed)
 */
export function lerpAngle(start: number, end: number, t: number): number {
    let diff = end - start;

    // Normalization: Force difference to be between -PI and +PI
    while (diff < -Math.PI) diff += Math.PI * 2;
    while (diff > Math.PI) diff -= Math.PI * 2;

    // Apply interpolation
    return start + diff * t;
}

export class ObjectPool<T> {
    private createFn: () => T;
    private pool: T[] = [];
    private hasReset: boolean = false;
    private resetChecked: boolean = false;

    constructor(createFn: () => T) {
        this.createFn = createFn;
    }
    public obtain(): T {
        return this.pool.length > 0 ? this.pool.pop()! : this.createFn();
    }
    public free(obj: T): void {
        // Check reset method only once per pool type
        if (!this.resetChecked) {
            this.hasReset = obj && typeof obj === 'object' && 'reset' in obj && typeof (obj as any).reset === 'function';
            this.resetChecked = true;
        }
        if (this.hasReset) {
            (obj as any).reset();
        }
        this.pool.push(obj);
    }
}

export function generateDefaultWaves(count: number = 10): IWaveConfig[] {
    const waves: IWaveConfig[] = [];
    for (let i = 1; i <= count; i++) {
        const waveEnemies: { type: string; count: number }[] = [];
        if (i <= 3) {
            waveEnemies.push({ type: 'grunt', count: 3 + i * 2 });
        } else {
            waveEnemies.push({ type: 'grunt', count: 5 + i });
            waveEnemies.push({ type: 'scout', count: Math.floor(i / 2) });
        }
        waves.push({ enemies: waveEnemies });
    }
    return waves;
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∏ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –≤–æ–ª–Ω—ã –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
 * –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –æ–±—Ä–∞—Ç–Ω—É—é —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è–º–∏
 */
export function normalizeWaveConfig(wave: any): IWaveConfig {
    if (!wave || !wave.enemies || !Array.isArray(wave.enemies)) {
        return { enemies: [] };
    }

    const result: IWaveConfig = {
        enemies: wave.enemies.map((group: any) => {
            const normalized: IWaveGroupRaw = {
                type: group.type || 'GRUNT',
                count: Math.max(1, parseInt(group.count) || 1),
                spawnPattern: (['normal', 'random', 'swarm'].includes(group.spawnPattern))
                    ? group.spawnPattern : 'normal',
                // Legacy compat
                speed: group.speed,
                spawnRate: group.spawnRate,
            };
            // New fields ‚Äî preserve with sane clamp
            if (group.pattern && ['normal', 'random', 'swarm'].includes(group.pattern)) {
                normalized.pattern = group.pattern;
            }
            if (group.baseInterval != null) {
                normalized.baseInterval = Math.max(0.05, Number(group.baseInterval) || 0.66);
            }
            if (group.delayBefore != null) {
                normalized.delayBefore = Math.max(0, Number(group.delayBefore) || 0);
            }
            return normalized;
        })
    };

    // Wave-level new fields ‚Äî preserve with sane clamp
    if (wave.name != null && String(wave.name).trim()) result.name = String(wave.name).trim();
    if (wave.startDelay != null) result.startDelay = Math.max(0, Number(wave.startDelay) || 0);
    if (wave.waitForClear != null) result.waitForClear = Boolean(wave.waitForClear);
    if (wave.bonusReward != null) result.bonusReward = Math.max(0, Number(wave.bonusReward) || 0);
    if (wave.shuffleMode && ['none', 'within_group', 'all'].includes(wave.shuffleMode)) {
        result.shuffleMode = wave.shuffleMode;
    }

    return result;
}


export function serializeMap(map: MapManager): IMapData {
    const simpleTiles: number[][] = [];
    for (let y = 0; y < map.rows; y++) {
        const row: number[] = [];
        for (let x = 0; x < map.cols; x++) {
            row.push(map.grid[y][x].type);
        }
        simpleTiles.push(row);
    }
    return {
        width: map.cols,
        height: map.rows,
        tiles: simpleTiles,
        waypoints: map.waypoints.map((wp) => ({ x: wp.x, y: wp.y })),
        objects: map.objects || [], // Include objects from map
        waves: map.waves && map.waves.length > 0 ? map.waves : generateDefaultWaves(15),
        startingMoney: CONFIG.PLAYER.START_MONEY,
        startingLives: CONFIG.PLAYER.START_LIVES,
        waypointsMode: map.waypointsMode,
        schemaVersion: MAP_SCHEMA_VERSION,
    };
}

export function validateMap(data: any): boolean {
    if (!data) return false;
    if (!data.tiles || !Array.isArray(data.tiles) || data.tiles.length === 0) {
        console.error('Map Validation Failed: No tiles data');
        return false;
    }
    if (!data.waypoints || !Array.isArray(data.waypoints)) {
        console.error('Map Validation Failed: No waypoints array');
        return false;
    }
    if (data.waypoints.length < 2) {
        console.error('Map Validation Failed: Path too short (<2 waypoints)');
        return false;
    }
    return true;
}

// --- STORAGE UTILS ---

/** @deprecated Use MapStorage.getLocalMaps() instead */
export function getSavedMaps(): Record<string, IMapData> {
    try {
        const raw = localStorage.getItem('NEWTOWER_MAPS');
        if (!raw) return {};

        const maps = JSON.parse(raw);

        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –≤–æ–ª–Ω –≤–æ –≤—Å–µ—Ö –∫–∞—Ä—Ç–∞—Ö –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        Object.keys(maps).forEach(mapName => {
            const mapData = maps[mapName];
            if (mapData.waves && Array.isArray(mapData.waves)) {
                mapData.waves = mapData.waves.map(normalizeWaveConfig);
            }
        });

        return maps;
    } catch (e) {
        console.error('Failed to load maps', e);
        return {};
    }
}

/** @deprecated Use MapStorage.saveLocal() instead */
export function saveMapToStorage(name: string, data: IMapData): boolean {
    try {
        const maps = getSavedMaps();
        maps[name] = data;
        const json = JSON.stringify(maps);
        // Storage size safety check
        const byteSize = new TextEncoder().encode(json).length;
        if (byteSize > 4 * 1024 * 1024) {
            console.warn(`[Storage] Approaching limit: ${(byteSize / 1024 / 1024).toFixed(1)}MB / 5MB`);
        }
        localStorage.setItem('NEWTOWER_MAPS', json);
        return true;
    } catch (e) {
        console.error('Failed to save map', e);
        return false;
    }
}


/** @deprecated Use MapStorage.deleteLocal() instead */
export function deleteMapFromStorage(name: string): void {
    const maps = getSavedMaps();
    delete maps[name];
    localStorage.setItem('NEWTOWER_MAPS', JSON.stringify(maps));
}

// === GLOBAL SESSION STORAGE ===
// To preserve Enemy.nextId and other session globals across reloads
interface IGlobalState {
    lastEnemyId: number;
}

export function saveGlobalState(): void {
    const state: IGlobalState = {
        lastEnemyId: (window as any).Enemy?.nextId || 0
    };
    // Need to access the Enemy class static, but importing it might cause cycles if not careful.
    // Better to pass the value in if possible, or use the class if imported.
    // Since we are in Utils, check imports. Enemy is NOT imported here.
    // Let's rely on the caller to pass it or import it dynamically?
    // Actually, Utils uses IMapData etc. It does not import Enemy class.
    // Importing Enemy class here might be fine.
}

// Better approach: Generic Save/Load for key-values that Game.ts can call
export function saveSessionData(key: string, value: any): void {
    try {
        const raw = localStorage.getItem('NEWTOWER_SESSION') || '{}';
        const data = JSON.parse(raw);
        data[key] = value;
        localStorage.setItem('NEWTOWER_SESSION', JSON.stringify(data));
    } catch (e) {
        console.error('Failed to save session data', e);
    }
}

export function loadSessionData(key: string): any {
    try {
        const raw = localStorage.getItem('NEWTOWER_SESSION');
        if (!raw) return null;
        const data = JSON.parse(raw);
        return data[key];
    } catch (e) {
        return null;
    }
}
</file>

<file path="src/EffectSystem.ts">
import { Assets } from './Assets';
import { RendererFactory } from './RendererFactory';
import { CONFIG } from './Config';
import { PerformanceMonitor } from './utils/PerformanceMonitor';

export enum EffectPriority {
    HIGH = 1, // Gameplay critical (Explosions, Muzzle Flash) - Budget: 400
    MEDIUM = 2, // Feedback (Damage Text, Status) - Budget: 200
    LOW = 3 // Cosmetic (Smoke, Debris, Sparks) - Budget: 200
}

export interface IEffect {
    type: 'explosion' | 'text' | 'particle' | 'scan' | 'debris' | 'screen_flash' | 'muzzle_flash' | 'scale_pop';
    x: number;
    y: number;
    life: number;
    maxLife?: number;
    priority?: EffectPriority; // Default: LOW

    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
    radius?: number;
    size?: number; // –î–ª—è —á–∞—Å—Ç–∏—Ü
    color?: string;
    text?: string;
    vx?: number;
    vy?: number;
    rotation?: number; // –í—Ä–∞—â–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü—ã
    vRot?: number; // –°–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞—â–µ–Ω–∏—è
    fontSize?: number; // For custom text size
    gravity?: number; // For debris with gravity
    flashColor?: string; // For screen flash
    enemySprite?: string; // For scale_pop death animation
    enemyColor?: string; // For enemy tint in scale_pop
}

export class EffectSystem {
    private effects: IEffect[] = [];
    private pool: IEffect[] = []; // Object Pool for recycling
    private ctx: CanvasRenderingContext2D;
    private canvasWidth: number;
    private canvasHeight: number;

    // Budgeting Limits
    private static LIMIT_HIGH = 400;
    private static LIMIT_MEDIUM = 200;
    private static LIMIT_LOW = 200;

    // Static Gradient Cache
    private static gradientCache: Map<string, HTMLCanvasElement> = new Map();

    // Helper to get cached gradient
    private static getCachedGradient(colorStart: string, colorEnd: string, size: number): HTMLCanvasElement {
        const key = `${colorStart}_${colorEnd}_${size}`;
        if (!this.gradientCache.has(key)) {
            const cvs = document.createElement('canvas'); // Not attached to DOM, lightweight
            cvs.width = size * 2;
            cvs.height = size * 2;
            const ctx = cvs.getContext('2d');
            if (ctx) {
                const g = ctx.createRadialGradient(size, size, 0, size, size, size);
                g.addColorStop(0, colorStart);
                g.addColorStop(1, colorEnd);
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, size * 2, size * 2);
            }
            this.gradientCache.set(key, cvs);
        }
        return this.gradientCache.get(key)!;
    }

    // Static Sprite Cache
    private static spriteCache: Map<string, HTMLCanvasElement> = new Map();

    private static getSprite(type: 'ring' | 'rays'): HTMLCanvasElement {
        if (!this.spriteCache.has(type)) {
            const size = 64;
            const cvs = document.createElement('canvas');
            cvs.width = size;
            cvs.height = size;
            const ctx = cvs.getContext('2d');
            if (!ctx) return cvs;

            const center = size / 2;

            if (type === 'ring') {
                // High quality ring
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(center, center, 28, 0, Math.PI * 2);
                ctx.stroke();
                // Add glow to ring
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 6;
                ctx.stroke();
            } else if (type === 'rays') {
                // Starburst rays
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                const count = 8;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(center + Math.cos(angle) * 10, center + Math.sin(angle) * 10);
                    ctx.lineTo(center + Math.cos(angle) * 30, center + Math.sin(angle) * 30);
                    ctx.stroke();
                }
            }
            this.spriteCache.set(type, cvs);
        }
        return this.spriteCache.get(type)!;
    }

    private static getGradientSprite(color: 'orange' | 'cyan'): HTMLCanvasElement {
        if (!this.spriteCache.has(color)) {
            const size = 64;
            const cvs = document.createElement('canvas');
            cvs.width = size;
            cvs.height = size;
            const ctx = cvs.getContext('2d');
            if (ctx) {
                const g = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
                if (color === 'orange') {
                    g.addColorStop(0, 'rgba(255, 255, 200, 1)');
                    g.addColorStop(0.5, 'rgba(255, 100, 0, 0.8)');
                    g.addColorStop(1, 'rgba(255, 0, 0, 0)');
                } else {
                    g.addColorStop(0, 'rgba(225, 255, 255, 1)');
                    g.addColorStop(0.5, 'rgba(0, 200, 255, 0.8)');
                    g.addColorStop(1, 'rgba(0, 0, 255, 0)');
                }
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, size, size);
            }
            this.spriteCache.set(color, cvs);
        }
        return this.spriteCache.get(color)!;
    }

    // Current counts
    private countHigh = 0;
    private countMedium = 0;
    private countLow = 0;

    constructor(ctx: CanvasRenderingContext2D) {
        this.ctx = ctx;
        this.canvasWidth = ctx.canvas.width;
        this.canvasHeight = ctx.canvas.height;
    }

    /**
     * Acquire an effect from pool or create new one
     * @performance Reduces GC pressure by reusing objects
     */
    public acquire(type: IEffect['type']): IEffect {
        const effect = this.pool.pop();
        if (effect) {
            // Reset pooled object
            effect.type = type;
            effect.x = 0;
            effect.y = 0;
            effect.life = 0;
            effect.maxLife = undefined;
            effect.priority = EffectPriority.LOW; // Default reset
            effect.radius = undefined;
            effect.size = undefined;
            effect.color = undefined;
            effect.text = undefined;
            effect.vx = undefined;
            effect.vy = undefined;
            effect.rotation = undefined;
            effect.vRot = undefined;
            effect.fontSize = undefined;
            effect.gravity = undefined;
            effect.flashColor = undefined;
            effect.enemySprite = undefined;
            effect.enemyColor = undefined;
            return effect;
        }
        return { type, x: 0, y: 0, life: 0, priority: EffectPriority.LOW };
    }

    /**
     * Release effect back to pool
     */
    private release(effect: IEffect): void {
        this.pool.push(effect);
    }

    public add(effect: IEffect) {
        // Enforce priority check if not already set (legacy calls)
        if (!effect.priority) effect.priority = EffectPriority.LOW;

        // Perform Check
        if (!this.canSpawn(effect.priority, effect.x, effect.y, effect.type)) {
            // Immediately pool it back if rejected (if it came from acquire)
            // But wait, 'add' usually takes a created object.
            // If we reject it here, the caller loses reference and it's GC'd.
            // That's fine for now.
            return;
        }

        if (!effect.maxLife) effect.maxLife = effect.life;

        this.effects.push(effect);
        this.incrementCount(effect.priority);
    }

    /**
     * Add effect using pool (preferred method)
     * @performance Use this instead of add() for better memory efficiency
     */
    public spawn(config: Partial<IEffect> & { type: IEffect['type']; life: number }): IEffect | null {
        // 1. Check if we SHOULD spawn
        const priority = config.priority || EffectPriority.LOW;
        const x = config.x || 0;
        const y = config.y || 0;

        if (!this.canSpawn(priority, x, y, config.type)) {
            return null;
        }

        const effect = this.acquire(config.type);
        Object.assign(effect, config);
        // Ensure priority is set from config or default
        effect.priority = priority;

        if (!effect.maxLife) effect.maxLife = effect.life;

        this.effects.push(effect);
        this.incrementCount(priority);

        return effect;
    }

    /**
     * Intelligent Spawn Logic (LOD + Culling + Budget)
     */
    private canSpawn(priority: EffectPriority, x: number, y: number, type: string): boolean {
        // 1. Spatial Culling (Skip if off-screen)
        // Global effects (screen_flash) ignore this
        if (type !== 'screen_flash') {
            const margin = 50;
            if (x < -margin || x > this.canvasWidth + margin ||
                y < -margin || y > this.canvasHeight + margin) {
                return false;
            }
        }

        // 2. Dynamic LOD based on FPS
        const fps = PerformanceMonitor.getFps();

        // Critical Performance (< 30 FPS): BLOCK Low & Medium
        if (fps < 30 && priority !== EffectPriority.HIGH) {
            return false;
        }

        // Low Performance (< 45 FPS): BLOCK Low
        if (fps < 45 && priority === EffectPriority.LOW) {
            return false;
        }

        // 3. Budget Check
        if (priority === EffectPriority.HIGH) {
            // High priority usually spawns, but let's keep sane limit (800 total?)
            // We implement "recycle oldest" later if needed, for now soft cap
            return this.countHigh < EffectSystem.LIMIT_HIGH;
        } else if (priority === EffectPriority.MEDIUM) {
            return this.countMedium < EffectSystem.LIMIT_MEDIUM;
        } else {
            return this.countLow < EffectSystem.LIMIT_LOW;
        }
    }

    private incrementCount(priority: EffectPriority) {
        if (priority === EffectPriority.HIGH) this.countHigh++;
        else if (priority === EffectPriority.MEDIUM) this.countMedium++;
        else this.countLow++;
    }

    private decrementCount(priority: EffectPriority) {
        if (priority === EffectPriority.HIGH) this.countHigh--;
        else if (priority === EffectPriority.MEDIUM) this.countMedium--;
        else this.countLow--;
    }

    public get activeEffects(): IEffect[] {
        return this.effects;
    }

    /**
     * Get number of active effects
     */
    public getCount(): number {
        return this.effects.length;
    }

    /**
     * Clear all active effects (for debugging)
     */
    public clear(): void {
        // Return all effects to pool
        for (let i = 0; i < this.effects.length; i++) {
            this.release(this.effects[i]);
        }
        this.effects.length = 0;
        this.countHigh = 0;
        this.countMedium = 0;
        this.countLow = 0;
    }

    public update(dt: number) {
        // Update all effects
        for (let i = 0; i < this.effects.length; i++) {
            const e = this.effects[i];
            e.life -= dt;

            if (e.type === 'particle' || e.type === 'text' || e.type === 'debris') {
                if (e.vx) e.x += e.vx * dt;
                if (e.vy) e.y += e.vy * dt;

                // Gravity for debris
                if (e.type === 'debris') {
                    if (e.gravity) e.vy = (e.vy || 0) + e.gravity * dt;
                    if (e.vx) {
                        e.vx *= Math.pow(0.3, dt);
                    }
                    if (e.rotation !== undefined && e.vRot) {
                        e.rotation += e.vRot * dt;
                    }
                }
            }
        }

        // In-place removal (backward iteration) - NO NEW ARRAY ALLOCATION
        for (let i = this.effects.length - 1; i >= 0; i--) {
            if (this.effects[i].life <= 0) {
                const dead = this.effects[i];
                // Swap with last and pop
                this.effects[i] = this.effects[this.effects.length - 1];
                this.effects.pop();

                // Track count cleanup
                this.decrementCount(dead.priority || EffectPriority.LOW);

                // Return to pool
                this.release(dead);
            }
        }
    }

    public draw() {
        for (let i = 0; i < this.effects.length; i++) {
            const e = this.effects[i];
            // Try Factory first
            if (RendererFactory.drawEffect(this.ctx, e)) {
                continue;
            }

            const progress = e.life / (e.maxLife || 1);

            this.ctx.save();
            this.ctx.globalAlpha = progress;

            if (e.type === 'explosion') {
                const radius = e.radius || 30;
                const time = 1 - progress; // 0 -> 1 over lifetime

                // Layer 1: Expanding shockwave ring
                const ringRadius = radius * (0.3 + time * 0.7);
                const ringWidth = 3 + (1 - time) * 4;
                this.ctx.strokeStyle = e.color || 'rgba(255, 150, 50, 0.8)';
                this.ctx.lineWidth = ringWidth;
                this.ctx.beginPath();
                this.ctx.arc(e.x, e.y, ringRadius, 0, Math.PI * 2);
                this.ctx.stroke();

                // Layer 2: Inner glow core (shrinking)
                const coreRadius = radius * 0.4 * progress;
                if (coreRadius > 1) {
                    // OPTIMIZED: Use cached gradient
                    const colorCore = 'rgba(255, 255, 200, 0.9)';
                    const colorFade = 'rgba(255, 100, 0, 0)';

                    // We can bake the color into the cache based on e.color if needed, 
                    // but for now let's use a generic warm glow + composite if possible, 
                    // or just cache specific colors.

                    // Let's use the explicit color from effect or default:
                    const mainColor = e.color || 'rgba(255, 150, 50, 0.6)';

                    // Draw using cache
                    // Note: We cache a generic white glow and tint it? 
                    // Canvas doesn't support easy tinting without composite overhead.
                    // Better to cache specific common colors: Fire (Orange), Ice (Cyan).

                    // For now, let's cache the exact gradient needed for this effect frame? No, that's too many.
                    // Cache the BASE gradient at fixed large size, then drawImage with scale.
                    const cacheSize = 64;
                    const cachedParams = e.color ? e.color : 'orange';
                    // Simple key based on color. We assume standard fade to transparent.

                    const glowCanvas = EffectSystem.getCachedGradient(
                        'rgba(255, 255, 255, 0.9)', // White core
                        'rgba(255, 255, 255, 0)',   // Transparent edge
                        cacheSize
                    );

                    this.ctx.save();
                    this.ctx.globalCompositeOperation = 'lighter'; // Additive blending for glow
                    // Apply tint via color (if we used white gradient) -> actually lighter blends colors.
                    // If we want colored glow, we should better cache colored gradients or use fillStyle.

                    // Let's rely on cached colored gradients for main types.
                    const isIce = e.color && e.color.includes('0, 188, 212');
                    const startColor = isIce ? 'rgba(0, 255, 255, 0.8)' : 'rgba(255, 200, 50, 0.8)';
                    const endColor = isIce ? 'rgba(0, 100, 255, 0)' : 'rgba(255, 50, 0, 0)';

                    const specificGlow = EffectSystem.getCachedGradient(startColor, endColor, 32);

                    this.ctx.drawImage(
                        specificGlow,
                        e.x - coreRadius,
                        e.y - coreRadius,
                        coreRadius * 2,
                        coreRadius * 2
                    );
                    this.ctx.restore();
                }

                // Layer 3: Radial rays (spikes)
                if (progress > 0.3) {
                    const rayCount = 8;
                    const rayLength = radius * 0.6 * progress;
                    this.ctx.strokeStyle = e.color || 'rgba(255, 200, 100, 0.7)';
                    this.ctx.lineWidth = 2;
                    for (let i = 0; i < rayCount; i++) {
                        const angle = (i / rayCount) * Math.PI * 2;
                        const startR = radius * 0.15;
                        this.ctx.beginPath();
                        this.ctx.moveTo(
                            e.x + Math.cos(angle) * startR,
                            e.y + Math.sin(angle) * startR
                        );
                        this.ctx.lineTo(
                            e.x + Math.cos(angle) * rayLength,
                            e.y + Math.sin(angle) * rayLength
                        );
                        this.ctx.stroke();
                    }
                }
            } else if (e.type === 'text') {
                const fontSize = e.fontSize || 16;
                this.ctx.fillStyle = e.color || '#fff';
                this.ctx.font = `bold ${fontSize}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(e.text || '', e.x, e.y);

                // OPTIMIZATION: Only stroke text for High Priority (Crits)
                if (e.priority === EffectPriority.HIGH) {
                    this.ctx.strokeStyle = 'black';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeText(e.text || '', e.x, e.y);
                }
            } else if (e.type === 'particle') {
                // Standard Spark - OPTIMIZED to fillRect for small particles
                this.ctx.fillStyle = e.color || '#fff';
                const r = e.radius || 2;
                if (r < 3) {
                    // Faster than arc
                    this.ctx.fillRect(e.x - r, e.y - r, r * 2, r * 2);
                } else {
                    this.ctx.beginPath();
                    this.ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            } else if (e.type === 'debris') {
                // –û—Å–∫–æ–ª–æ–∫ (–∫–≤–∞–¥—Ä–∞—Ç), –∫–æ—Ç–æ—Ä—ã–π –∫—Ä—É—Ç–∏—Ç—Å—è –∏ –ø–∞–¥–∞–µ—Ç
                this.ctx.translate(e.x, e.y);
                if (e.rotation) this.ctx.rotate(e.rotation);
                this.ctx.fillStyle = e.color || '#fff';
                const s = e.size || 4;
                this.ctx.fillRect(-s / 2, -s / 2, s, s);
            } else if (e.type === 'muzzle_flash') {
                // –í—Å–ø—ã—à–∫–∞ –Ω–∞ –¥—É–ª–µ –±–∞—à–Ω–∏
                // If we have a specific image, usage it (color tinting is hard with drawImage without composite)
                // BUT Phase 2 requires colored flashes.
                // Let's rely on procedural gradient for colored flashes unless we have tinted assets.
                // Current asset 'effect_muzzle_flash' is likely yellow/orange.

                // If color is specified, FORCE procedural generation for now to ensure color match
                const useProcedural = !!e.color;

                const img = Assets.get('effect_muzzle_flash');
                if (img && !useProcedural) {
                    const r = e.radius || 12;
                    this.ctx.drawImage(img, e.x - r, e.y - r, r * 2, r * 2);
                } else {
                    // OPTIMIZED: Use cached gradient for muzzle flash
                    // Determine color key
                    const coreColor = e.color || 'rgba(255, 255, 200, 0.9)';
                    const fadeColor = 'rgba(255, 255, 255, 0)';

                    const flashSize = e.radius || 12;
                    const cacheKey = `${coreColor}_${flashSize}`;

                    // Get or create specific cache
                    let flashCanvas = EffectSystem.gradientCache.get(cacheKey);
                    if (!flashCanvas) {
                        flashCanvas = EffectSystem.getCachedGradient(coreColor, fadeColor, flashSize);
                        EffectSystem.gradientCache.set(cacheKey, flashCanvas);
                    }

                    this.ctx.save();
                    this.ctx.globalCompositeOperation = 'lighter';
                    this.ctx.drawImage(
                        flashCanvas,
                        e.x - flashSize,
                        e.y - flashSize
                    );
                    this.ctx.restore();
                }
            } else if (e.type === 'screen_flash') {
                // Flash –ø–æ –∫—Ä–∞—è–º —ç–∫—Ä–∞–Ω–∞
                const flashAlpha = progress * 0.4;
                const color = e.flashColor || 'rgba(255, 0, 0, ';
                const gradient = this.ctx.createRadialGradient(
                    this.canvasWidth / 2, this.canvasHeight / 2, 0,
                    this.canvasWidth / 2, this.canvasHeight / 2, Math.max(this.canvasWidth, this.canvasHeight) * 0.7
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(1, color + flashAlpha + ')');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
            } else if (e.type === 'scale_pop') {
                // Enemy death scale pop
                const scaleProgress = 1 - progress; // Reverse: 0 -> 1
                const scale = 1 + scaleProgress * 0.5; // Scale from 1.0 to 1.5

                if (e.enemySprite) {
                    const img = Assets.get(e.enemySprite);
                    if (img) {
                        this.ctx.save();
                        this.ctx.translate(e.x, e.y);
                        this.ctx.scale(scale, scale);

                        const size = 64;
                        const half = size / 2;
                        this.ctx.drawImage(img, -half, -half, size, size);

                        // Apply tint if available
                        if (e.enemyColor) {
                            this.ctx.globalCompositeOperation = 'source-atop';
                            this.ctx.fillStyle = e.enemyColor;
                            this.ctx.globalAlpha = 0.3 * progress;
                            this.ctx.fillRect(-half, -half, size, size);
                        }

                        this.ctx.restore();
                    }
                }
            }

            this.ctx.restore();
        }
    }
}
</file>

<file path="src/Map.ts">
import { CONFIG } from './Config';
import { IMapData, Cell, IMapObject, WaypointsMode, IWaveConfig } from './MapData';
import { Assets } from './Assets';
import { Pathfinder } from './Pathfinder';
import { FlowField } from './FlowField';
import { LightingSystem } from './systems/LightingSystem';
import { ObjectRenderer, ObjectType } from './ObjectRenderer';

export interface PathError {
    x: number;
    y: number;
    reason: 'blocked' | 'disconnected' | 'unreachable' | 'loop';
}

export class MapManager {
    public cols!: number;
    public rows!: number;

    public grid: Cell[][] = [];

    public tiles: number[][] = [];
    public waypoints: { x: number; y: number }[] = [];
    public waypointsMode: WaypointsMode = 'ENDPOINTS'; // Default

    public waves: IWaveConfig[] = [];
    public lighting?: LightingSystem;
    public objects: IMapObject[] = []; // Objects for decoration and blocking
    public flowField: FlowField;

    private cacheCanvas: HTMLCanvasElement;

    // Dirty flag pattern for FlowField optimization
    private isFlowFieldDirty: boolean = false;

    constructor(data: IMapData) {
        this.loadMap(data);
    }

    public loadMap(data: IMapData) {
        this.cols = data.width;
        this.rows = data.height;
        this.tiles = data.tiles;
        this.waves = (data.waves as IWaveConfig[]) || [];
        this.objects = data.objects || []; // Load objects

        // Default or Derived Waypoints Mode
        if (data.waypointsMode) {
            this.waypointsMode = data.waypointsMode;
        } else {
            // Migration Logic: Implicit Mode
            if (!data.waypoints || data.waypoints.length <= 2) {
                this.waypointsMode = 'ENDPOINTS';
            } else {
                this.waypointsMode = 'FULLPATH';
            }
        }

        // Copy waypoints initially
        this.waypoints = data.waypoints || [];

        // Build grid object for runtime usage
        this.grid = [];
        for (let y = 0; y < this.rows; y++) {
            const row: Cell[] = [];
            for (let x = 0; x < this.cols; x++) {
                const type = this.tiles[y][x];
                let decor = null;
                // Basic visual decor restoration
                if (type === 2) decor = Math.random() > 0.5 ? 'tree' : 'rock';
                row.push({ type, x, y, decor });
            }
            this.grid.push(row);
        }

        // STRICT LOADER CONTRACT
        if (this.waypointsMode === 'ENDPOINTS') {
            // RASTER IS CANONICAL
            // We expect strictly 2 waypoints (Start/End) or at least 2.
            // If < 2, we can't do anything (Editor should prevent saving this state).
            if (this.waypoints.length >= 2) {
                const start = this.waypoints[0];
                const end = this.waypoints[this.waypoints.length - 1];

                // Clear cache because mapping just loaded/changed
                Pathfinder.invalidateCache();

                const fullPath = Pathfinder.findPath(this.grid, start, end);
                if (fullPath.length > 0) {
                    this.waypoints = fullPath;
                } else {
                    console.error('[MapManager] Failed to derive path from endpoints!', start, end);
                    // Critical Error in Dev, might want to fallback or show UI error
                }
            }
        } else {
            // FULLPATH: VECTOR IS CANONICAL
            // We leave this.waypoints AS IS.
            // Validation happens separately.
        }

        // Initialize or Resize FlowField (Reuse buffers)
        if (!this.flowField) {
            this.flowField = new FlowField(this.cols, this.rows);
        } else {
            this.flowField.resize(this.cols, this.rows);
        }

        // Initial generation
        this.requestFlowFieldUpdate();
        this.updateFlowField(); // Force immediate update for init

        // Prerender the static map logic
        this.prerender();
        // Cache torches logic
        this.cacheTorches();
    }

    /**
     * Request a flow field rebuild on next update
     */
    public requestFlowFieldUpdate() {
        this.isFlowFieldDirty = true;
    }

    /**
     * Called every frame/tick by GameScene
     */
    public update(_dt: number) {
        if (this.isFlowFieldDirty) {
            this.updateFlowField();
            this.isFlowFieldDirty = false;
        }
    }

    /**
     * Regenerates the Flow Field based on current grid and target.
     */
    private updateFlowField() {
        let target = { x: 0, y: 0 };
        if (this.waypoints.length > 0) {
            target = this.waypoints[this.waypoints.length - 1];
        }

        // Mark pathfinder cache invalid if we are updating flow (likely means tiles changed)
        // Although loadMap handles init, if this is called from Editor, we likely changed tiles.
        Pathfinder.invalidateCache();

        this.flowField.generate(this.grid, target);
        console.log('[MapManager] FlowField Regenerated. Version:', this.flowField.version);
    }

    public prerender() {
        // Create offscreen canvas
        this.cacheCanvas = document.createElement('canvas');
        this.cacheCanvas.width = this.cols * CONFIG.TILE_SIZE;
        this.cacheCanvas.height = this.rows * CONFIG.TILE_SIZE;
        const ctx = this.cacheCanvas.getContext('2d');
        if (!ctx) return;

        const TS = CONFIG.TILE_SIZE;

        for (let y = 0; y < this.rows; y++) {
            for (let x = 0; x < this.cols; x++) {
                const type = this.tiles[y][x];
                const px = x * TS;
                const py = y * TS;

                // –†–∏—Å—É–µ–º —Ç–∞–π–ª –Ω–∞ –∫—ç—à-–∫–∞–Ω–≤–∞—Å
                if (type === 1) {
                    this.drawTile(ctx, 'path', px, py);
                } else {
                    this.drawTile(ctx, 'grass', px, py);
                }
            }
        }
    }

    public isBuildable(col: number, row: number): boolean {
        if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) return false;

        // MAZE FORBIDDEN CONTRACT: Cannot build on path
        if (this.tiles[row][col] === 1) return false;

        if (this.tiles[row][col] !== 0) return false; // Only grass is buildable

        // Check if any object occupies this tile
        const hasObject = this.objects.some(obj => {
            const size = obj.size || 1;
            return col >= obj.x && col < obj.x + size &&
                row >= obj.y && row < obj.y + size;
        });

        return !hasObject;
    }

    /**
     * Checks if building at (col, row) would block the path.
     * Delegates to FlowField but includes pre-checks.
     */
    public checkBuildability(col: number, row: number): boolean {
        // 1. Basic check
        if (!this.isBuildable(col, row)) return false;

        // 2. FlowField check
        // We need spawn points to check connectivity
        // In this game, usually we check if ANY spawn is blocked?
        // Or if the Target is reachable from all spawns?

        // Strict Mode: If we are on Grass, and Enemies are strictly on Path,
        // then building on Grass NEVER blocks path.
        // So we can return true immediately if we trust isBuildable!
        if (this.tiles[row][col] === 0) {
            return true;
        }

        // If we assumed "Mazing" was allowed (building on 0 blocks movement),
        // we would call this.flowField.checkBuildability(this.grid, col, row, this.waypoints[0] or spawns);
        // But since we enforced strict rules:
        return true;
    }

    public draw(ctx: CanvasRenderingContext2D) {
        // 1. Draw cached static background
        if (this.cacheCanvas) {
            ctx.drawImage(this.cacheCanvas, 0, 0);
        }

        const TS = CONFIG.TILE_SIZE;

        // 2. Draw dynamic objects (trees, rocks, etc that are "objects" not tiles)
        for (const obj of this.objects) {
            const px = obj.x * TS;
            const py = obj.y * TS;
            ObjectRenderer.draw(ctx, obj.type as ObjectType, px, py, obj.size || 1);
        }

        if (this.waypoints.length > 0) {
            const start = this.waypoints[0];
            const end = this.waypoints[this.waypoints.length - 1];
            this.drawIcon(ctx, '‚ò†Ô∏è', start.x, start.y);
            this.drawIcon(ctx, 'üè∞', end.x, end.y);
        }
    }

    // [NEW] Cache torch positions to avoid grid scanning every frame
    private torchPositions: { x: number, y: number, colorHash: number }[] = [];

    private cacheTorches() {
        this.torchPositions = [];
        const TS = CONFIG.TILE_SIZE;
        const checkGrass = (cx: number, cy: number) => {
            if (cx < 0 || cx >= this.cols || cy < 0 || cy >= this.rows) return true;
            return this.tiles[cy][cx] !== 1;
        };

        const spacing = 4; // Every 4th valid spot roughly

        for (let y = 0; y < this.rows; y++) {
            for (let x = 0; x < this.cols; x++) {
                if (this.tiles[y][x] === 1) { // Path
                    // Identify borders with grass
                    const top = checkGrass(x, y - 1);
                    const bottom = checkGrass(x, y + 1);
                    const left = checkGrass(x - 1, y);
                    const right = checkGrass(x + 1, y);

                    // Add to cache if valid
                    if (top && (x + y * 7) % spacing === 0) {
                        this.torchPositions.push({ x: x * TS + TS / 2, y: y * TS + 4, colorHash: 0 });
                    }
                    if (bottom && (x + y * 13) % spacing === 0) {
                        this.torchPositions.push({ x: x * TS + TS / 2, y: y * TS + TS - 4, colorHash: 1 });
                    }
                    if (left && (y + x * 11) % spacing === 0) {
                        this.torchPositions.push({ x: x * TS + 4, y: y * TS + TS / 2, colorHash: 2 });
                    }
                    if (right && (y + x * 17) % spacing === 0) {
                        this.torchPositions.push({ x: x * TS + TS - 4, y: y * TS + TS / 2, colorHash: 3 });
                    }
                }
            }
        }
    }

    public drawTorches(ctx: CanvasRenderingContext2D, time: number = 0) {
        if (!this.lighting) return;
        if (this.torchPositions.length === 0) return;

        const TS = CONFIG.TILE_SIZE;
        const radiusVal = TS * 1.5;

        for (const torch of this.torchPositions) {
            const flickerBase = Math.sin(time * 0.1 + torch.colorHash) * 0.05 + Math.sin(time * 0.03 + torch.colorHash * 2) * 0.05;
            const pop = (Math.random() > 0.98) ? (Math.random() * 0.1) : 0;
            const flickerLocal = 1.0 + flickerBase + pop;

            ctx.fillStyle = '#5d4037';
            ctx.fillRect(torch.x - 2, torch.y, 4, 6);

            const size = (8 + flickerBase * 4);
            ctx.fillStyle = `rgba(255, 87, 34, ${0.8 + flickerBase})`;
            ctx.beginPath();
            ctx.arc(torch.x, torch.y + 2, size / 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = `rgba(255, 235, 59, ${0.8 + flickerBase})`;
            ctx.beginPath();
            ctx.arc(torch.x, torch.y + 2, size / 4, 0, Math.PI * 2);
            ctx.fill();

            const lightRadius = radiusVal + flickerBase * 5;
            this.lighting!.addLight(torch.x, torch.y, lightRadius, '#ff9100', 0.8 * flickerLocal);
        }
    }

    private drawTile(ctx: CanvasRenderingContext2D, key: string, x: number, y: number) {
        if (key === 'path') {
            const col = Math.floor(x / CONFIG.TILE_SIZE);
            const row = Math.floor(y / CONFIG.TILE_SIZE);

            const NORTH = (row > 0 && this.tiles[row - 1][col] === 1) ? 1 : 0;
            const WEST = (col > 0 && this.tiles[row][col - 1] === 1) ? 1 : 0;
            const EAST = (col < this.cols - 1 && this.tiles[row][col + 1] === 1) ? 1 : 0;
            const SOUTH = (row < this.rows - 1 && this.tiles[row + 1][col] === 1) ? 1 : 0;

            const bitmask = NORTH | (WEST << 1) | (EAST << 2) | (SOUTH << 3);
            const pathTile = Assets.get(`path_${bitmask}`);

            if (pathTile) {
                ctx.drawImage(pathTile, x, y);
            } else {
                const fallback = Assets.get('path');
                if (fallback) {
                    ctx.drawImage(fallback, x, y);
                } else {
                    ctx.fillStyle = '#c5b8a1';
                    ctx.fillRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                }
            }
            return;
        }

        let img: HTMLCanvasElement | HTMLImageElement | undefined;

        if (key === 'grass') {
            const variantCount = Assets.getVariantCount('grass');
            if (variantCount > 0) {
                const index = Math.abs((x * 73 + y * 37)) % variantCount;
                img = Assets.getVariant('grass', index);
            } else {
                img = Assets.get('grass');
            }
        } else {
            img = Assets.get(key);
        }

        if (img) {
            if (key === 'grass') {
                const seed = x * 73 + y * 37;
                const flipH = (seed % 2) === 0;
                const flipV = (Math.floor(seed / 2) % 2) === 0;

                ctx.save();
                ctx.translate(x + CONFIG.TILE_SIZE / 2, y + CONFIG.TILE_SIZE / 2);
                ctx.scale(flipH ? -1 : 1, flipV ? -1 : 1);
                ctx.drawImage(img, -CONFIG.TILE_SIZE / 2, -CONFIG.TILE_SIZE / 2);
                ctx.restore();
            } else {
                ctx.drawImage(img, x, y);
            }
        } else {
            ctx.fillStyle = key === 'path' ? '#ded29e' : '#8bc34a';
            ctx.fillRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
        }
    }

    private drawIcon(ctx: CanvasRenderingContext2D, icon: string, col: number, row: number) {
        const halfTile = CONFIG.TILE_SIZE / 2;
        const x = col * CONFIG.TILE_SIZE + halfTile;
        const y = row * CONFIG.TILE_SIZE + halfTile;
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(icon, x, y);
    }

    /**
     * Engine-Grade Validation
     * Checks for: Connectivity, Alignment, Continuity, and Loops
     */
    public validatePath(_start?: { x: number; y: number }, _end?: { x: number; y: number }): PathError[] {
        const errors: PathError[] = [];

        // 1. Endpoint Existence
        if (this.waypoints.length < 2) {
            // If we have no waypoints at all, can't validate much, unless map expects them.
            return errors;
        }

        // 2. Alignment Check (All Modes: Path must be on Path Tiles)
        // If WaypointsMode is FULLPATH, this is critical.
        // If ENDPOINTS, it's derived so likely correct, but good to check.
        this.waypoints.forEach(wp => {
            if (wp.x < 0 || wp.x >= this.cols || wp.y < 0 || wp.y >= this.rows) {
                errors.push({ x: wp.x, y: wp.y, reason: 'unreachable' }); // Out of bounds
            } else if (this.tiles[wp.y][wp.x] !== 1) {
                errors.push({ x: wp.x, y: wp.y, reason: 'blocked' }); // Waypoint on Grass/Obstacle
            }
        });

        // 3. Continuity & Loop Check (Only for FULLPATH usually, but good for all)
        if (this.waypointsMode === 'FULLPATH' || this.waypoints.length > 2) {
            const visited = new Set<string>();

            for (let i = 0; i < this.waypoints.length; i++) {
                const wp = this.waypoints[i];
                const key = `${wp.x},${wp.y}`;

                // Self-Intersection / Loop Check
                if (visited.has(key)) {
                    errors.push({ x: wp.x, y: wp.y, reason: 'loop' });
                }
                visited.add(key);

                // Continuity Check (Distance to next)
                if (i < this.waypoints.length - 1) {
                    const next = this.waypoints[i + 1];
                    const dist = Math.abs(next.x - wp.x) + Math.abs(next.y - wp.y); // Manhattan
                    if (dist > 1) {
                        errors.push({ x: wp.x, y: wp.y, reason: 'disconnected' });
                    }
                }
            }
        }

        // 4. Connectivity Check (Raster Reachability)
        // Can we actually get from start to end on grid?
        // This validates if the tiles themselves form a valid corridor
        const start = this.waypoints[0];
        const end = this.waypoints[this.waypoints.length - 1];

        // Only run BFS if endpoints are valid
        if (this.tiles[start.y]?.[start.x] === 1 && this.tiles[end.y]?.[end.x] === 1) {
            const path = Pathfinder.findPath(this.grid, start, end);
            if (path.length === 0) {
                // Disconnected components
                errors.push({ x: end.x, y: end.y, reason: 'unreachable' });
            }
        }

        return errors;
    }
}
</file>

<file path="src/scenes/EditorScene.ts">
import { BaseScene } from '../BaseScene';
import { Game } from '../Game';
import { MapManager } from '../Map';
import { CONFIG } from '../Config';
import { IMapData, IMapObject, migrateMapData } from '../MapData';
import { serializeMap } from '../Utils';
import { MapStorage } from '../MapStorage';
import { UIUtils } from '../UIUtils';
import { Pathfinder } from '../Pathfinder';
import { WaveEditor } from '../WaveEditor';
import { FogSystem } from '../FogSystem';
import { EditorToolbar, EditorMode } from '../editor/EditorToolbar';
import { WaypointManager } from '../editor/WaypointManager';
import { EditorHistory, EditorActions } from '../editor/EditorHistory';

export class EditorScene extends BaseScene {
    private game: Game;
    private map: MapManager;
    private fog: FogSystem;
    private toolbar!: EditorToolbar;
    private controlsContainer!: HTMLElement;
    private waypointMgr!: WaypointManager;
    private history!: EditorHistory;
    private activeWaveEditor: WaveEditor | null = null;

    private mode: EditorMode = 'paint_road';

    // FEATURE: Saved maps panel
    private mapsPanel!: HTMLElement;
    private mapsPanelExpanded: boolean = false;
    private currentMapName: string = '';

    // Race condition guard –¥–ª—è async refreshMapsPanel
    private _refreshGeneration: number = 0;

    // Hidden file input for JSON import
    private _fileInput!: HTMLInputElement;

    // Track previous mouse state for click detection (not hold)
    private prevMouseDown: boolean = false;
    private lastClickedTile: { col: number; row: number } | null = null;

    constructor(game: Game) {
        super();
        this.game = game;

        // –°–æ–∑–¥–∞–µ–º –ø—É—Å—Ç—É—é —Å–µ—Ç–∫—É
        const cols = Math.ceil(game.width / CONFIG.TILE_SIZE);
        const rows = Math.ceil(game.height / CONFIG.TILE_SIZE);
        const emptyTiles = Array(rows)
            .fill(0)
            .map(() => Array(cols).fill(0));

        const emptyData: IMapData = {
            width: cols,
            height: rows,
            tiles: emptyTiles,
            waypoints: [],
            objects: [],
        };

        this.map = new MapManager(emptyData);
        this.fog = new FogSystem(emptyData);
        this.waypointMgr = new WaypointManager();
        this.history = new EditorHistory();
        this.createUI();
        this.createMapsPanel();
        // Hotkeys are now set up in onEnterImpl
    }

    protected onEnterImpl() {
        this.toolbar.show();
        this.controlsContainer.style.display = 'flex';
        this.mapsPanel.style.display = 'block';

        // Hide standard game UI
        (this.game as any).uiRoot.hideGameUI(); // Cast as any if TS doesn't know yet

        // Initial fog render
        this.fog.update(0);

        // Setup hotkeys with automatic cleanup
        this.on(document, 'keydown', (e: Event) => this.handleGlobalKey(e as KeyboardEvent));
    }

    protected onExitImpl() {
        // Full DOM cleanup (EditorScene is recreated each time by Game.toEditor())
        if (this.toolbar) {
            this.toolbar.destroy();
        }
        if (this.controlsContainer && this.controlsContainer.parentNode) {
            this.controlsContainer.parentNode.removeChild(this.controlsContainer);
        }
        if (this.mapsPanel && this.mapsPanel.parentNode) {
            this.mapsPanel.parentNode.removeChild(this.mapsPanel);
        }
        if (this.history) {
            this.history.clear();
        }
        if (this.activeWaveEditor) {
            this.activeWaveEditor.destroy();
            this.activeWaveEditor = null;
        }
        // BaseScene.dispose() handles listener cleanup
    }

    public update(dt: number) {
        // Don't update fog animation in editor - only static rendering
        const input = this.game.input;

        // Begin compound action on mouse down (for paint modes)
        if (input.isMouseDown && !this.prevMouseDown) {
            if (this.isPaintMode(this.mode)) {
                this.history.beginCompound(this.mode);
            }
        }

        // Handle mouse input - works on hold
        if (input.isMouseDown && input.hoverCol >= 0 && input.hoverRow >= 0) {
            // Check if clicked on a different tile
            const isDifferentTile =
                !this.lastClickedTile ||
                this.lastClickedTile.col !== input.hoverCol ||
                this.lastClickedTile.row !== input.hoverRow;

            if (isDifferentTile) {
                this.handleInput(input.hoverCol, input.hoverRow);
                this.lastClickedTile = { col: input.hoverCol, row: input.hoverRow };

                // Trigger fog re-render after data change (static, no animation)
                this.fog.update(0);
            }
        }

        // Mouse release -> Commit
        if (!input.isMouseDown && this.prevMouseDown) {
            this.history.commitCompound();
        }

        // Update previous state
        this.prevMouseDown = input.isMouseDown;

        // Reset last clicked tile when mouse is released
        if (!input.isMouseDown) {
            this.lastClickedTile = null;
        }
    }

    private handleInput(col: number, row: number) {
        if (col >= this.map.cols || row >= this.map.rows) return;

        const oldTileType = this.map.grid[row][col].type;
        const oldFogDensity = this.fog.getFog(col, row);

        if (this.mode === 'paint_road') {
            console.log('[EditorScene] paint_road mode active, tile type:', oldTileType, '‚Üí 1');
            if (oldTileType !== 1) {
                this.history.pushInCompound(EditorActions.createTileAction(this.map.grid, col, row, oldTileType, 1));
                this.map.grid[row][col].type = 1;
                this.map.grid[row][col].decor = null;
                Pathfinder.invalidateCache();
                console.log('[EditorScene] Road painted at', col, row);
            } else {
                console.log('[EditorScene] Tile already road, skipping');
            }
        } else if (this.mode === 'paint_grass') {
            if (oldTileType !== 0) {
                this.history.pushInCompound(EditorActions.createTileAction(this.map.grid, col, row, oldTileType, 0));
                this.map.grid[row][col].type = 0;
                Pathfinder.invalidateCache();
            }
        } else if (this.mode === 'eraser') {
            // FEATURE: Eraser - reset to grass, remove fog, and remove objects
            const hasObject = this.map.objects.find(obj => {
                const size = obj.size || 1;
                return col >= obj.x && col < obj.x + size &&
                    row >= obj.y && row < obj.y + size;
            });

            if (oldTileType !== 0 || oldFogDensity !== 0 || hasObject) {
                // –°–±—Ä–æ—Å —Ç–∞–π–ª–∞ –≤ —Ç—Ä–∞–≤—É
                if (oldTileType !== 0) {
                    this.history.pushInCompound(EditorActions.createTileAction(this.map.grid, col, row, oldTileType, 0));
                    this.map.grid[row][col].type = 0;
                    this.map.grid[row][col].decor = null;
                    Pathfinder.invalidateCache();
                }
                // –£–¥–∞–ª–µ–Ω–∏–µ —Ç—É–º–∞–Ω–∞
                if (oldFogDensity !== 0) {
                    this.history.pushInCompound(EditorActions.createFogAction(this.fog, col, row, oldFogDensity, 0));
                    this.fog.setFog(col, row, 0);
                }
                // –£–¥–∞–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ (–≤—Å–µ –æ–±—ä–µ–∫—Ç—ã, –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—é—â–∏–µ —ç—Ç–æ—Ç —Ç–∞–π–ª)
                if (hasObject) {
                    this.map.objects = this.map.objects.filter(obj => {
                        const size = obj.size || 1;
                        const overlaps = col >= obj.x && col < obj.x + size &&
                            row >= obj.y && row < obj.y + size;
                        return !overlaps;
                    });
                }
            }
        } else if (this.mode === 'set_start') {
            const oldState = {
                start: this.waypointMgr.getStart(),
                end: this.waypointMgr.getEnd(),
                waypoints: this.waypointMgr.getWaypoints()
            };
            this.history.push(EditorActions.createWaypointAction(this.waypointMgr, 'setStart', { x: col, y: row }, oldState));
            this.waypointMgr.setStart({ x: col, y: row });
            this.map.grid[row][col].type = 1;
        } else if (this.mode === 'set_end') {
            const oldState = {
                start: this.waypointMgr.getStart(),
                end: this.waypointMgr.getEnd(),
                waypoints: this.waypointMgr.getWaypoints()
            };
            this.history.push(EditorActions.createWaypointAction(this.waypointMgr, 'setEnd', { x: col, y: row }, oldState));
            this.waypointMgr.setEnd({ x: col, y: row });
            this.map.grid[row][col].type = 1;
        } else if (this.mode === 'place_waypoint') {
            if (this.waypointMgr.canAddWaypoint()) {
                const oldState = {
                    start: this.waypointMgr.getStart(),
                    end: this.waypointMgr.getEnd(),
                    waypoints: this.waypointMgr.getWaypoints()
                };
                this.history.push(EditorActions.createWaypointAction(this.waypointMgr, 'addWaypoint', { x: col, y: row }, oldState));
                this.waypointMgr.addWaypoint({ x: col, y: row });
            }
        } else if (this.mode === 'paint_fog') {
            // Cycle fog density: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 0
            this.fog.cycleFogDensity(col, row);
            const newFogDensity = this.fog.getFog(col, row);
            if (oldFogDensity !== newFogDensity) {
                this.history.pushInCompound(EditorActions.createFogAction(this.fog, col, row, oldFogDensity, newFogDensity));
            }
        } else if (this.mode === 'place_stone') {
            this.placeObject(col, row, 'stone', 1);
        } else if (this.mode === 'place_rock') {
            // –°–∫–∞–ª—ã - —Ä–∞–Ω–¥–æ–º–Ω—ã–π —Ä–∞–∑–º–µ—Ä 2-3 —Ç–∞–π–ª–∞
            const size = Math.random() > 0.5 ? 3 : 2;
            this.placeObject(col, row, 'rock', size);
        } else if (this.mode === 'place_tree') {
            this.placeObject(col, row, 'tree', 1);
        } else if (this.mode === 'place_wheat') {
            this.placeObject(col, row, 'wheat', 1);
        } else if (this.mode === 'place_flowers') {
            this.placeObject(col, row, 'flowers', 1);
        }
    }

    /**
     * Place an object on the map
     */
    private placeObject(col: number, row: number, type: string, size: number): void {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
        if (col + size > this.map.cols || row + size > this.map.rows) {
            return; // –í—ã—Ö–æ–¥–∏—Ç –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã
        }

        // –£–¥–∞–ª–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –æ–±—ä–µ–∫—Ç—ã –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏
        this.map.objects = this.map.objects.filter(obj => {
            const objSize = obj.size || 1;
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
            const overlaps = !(col + size <= obj.x || col >= obj.x + objSize ||
                row + size <= obj.y || row >= obj.y + objSize);
            return !overlaps;
        });

        // –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç
        const newObj = {
            type,
            x: col,
            y: row,
            properties: {},
            size: size > 1 ? size : undefined
        };
        this.map.objects.push(newObj);
    }

    public draw(ctx: CanvasRenderingContext2D) {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, this.game.width, this.game.height);

        for (let y = 0; y < this.map.rows; y++) {
            for (let x = 0; x < this.map.cols; x++) {
                this.map.tiles[y][x] = this.map.grid[y][x].type;
            }
        }

        // CRITICAL FIX: Regenerate prerendered cache after tile changes
        // The Map.draw() uses a cached canvas that must be updated when tiles change
        this.map.prerender();

        // We do NOT overwrite map.waypoints here every frame anymore.
        // It prevents saving them correctly.
        this.map.draw(ctx);
        this.fog.draw(ctx);

        // Draw waypoints with WaypointManager
        this.waypointMgr.draw(ctx);


        const input = this.game.input;
        if (input.hoverCol >= 0) {
            const x = input.hoverCol * CONFIG.TILE_SIZE;
            const y = input.hoverRow * CONFIG.TILE_SIZE;

            ctx.strokeStyle = 'yellow';
            if (this.mode === 'paint_grass') ctx.strokeStyle = 'red';
            if (this.mode === 'eraser') ctx.strokeStyle = '#ff6600';
            if (this.mode === 'set_start') ctx.strokeStyle = 'cyan';
            if (this.mode === 'set_end') ctx.strokeStyle = 'magenta';
            if (this.mode === 'place_waypoint') ctx.strokeStyle = '#00ff00';

            if (this.mode === 'paint_fog') {
                // Show current fog density with color intensity
                const density = this.fog.getFog(input.hoverCol, input.hoverRow);
                const intensity = density * 40 + 80; // 80-280 range
                ctx.strokeStyle = `rgb(${intensity}, ${intensity + 30}, ${intensity + 50})`;

                // Draw density indicator
                ctx.fillStyle = `rgba(200, 215, 230, ${density * 0.15})`;
                ctx.fillRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);

                // Draw density number
                if (density > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(density.toString(), x + CONFIG.TILE_SIZE / 2, y + CONFIG.TILE_SIZE / 2);
                }
            }

            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
        }
    }

    private openWaveConfig() {
        // Resolve sparse editor waypoints ‚Üí dense BFS path
        if (this.waypointMgr.isValid()) {
            const resolved = this.resolveFullPath();
            if (!resolved) return; // Error already shown to user
            this.map.waypoints = resolved;
        } else {
            alert('Set Start and End points first!');
            return;
        }

        const currentWaves = this.map.waves || [];

        this.activeWaveEditor = new WaveEditor(
            currentWaves,
            (waves) => {
                this.saveMap(waves);
                this.activeWaveEditor = null;
            },
            () => {
                // Cancelled
                this.activeWaveEditor = null;
            },
        );
    }

    private saveMap(waves: any[]) {
        // [FIX] Ensure map waves are updated before serialization
        this.map.waves = waves;

        // Resolve sparse editor waypoints ‚Üí dense BFS path for validation
        if (this.waypointMgr.isValid()) {
            const resolved = this.resolveFullPath();
            if (!resolved) return; // BFS failed ‚Äî error already shown
            this.map.waypoints = resolved;
            this.map.waypointsMode = 'FULLPATH';
        }

        // Validate before save
        Pathfinder.invalidateCache(); // Ensure fresh BFS
        const errors = this.map.validatePath();
        if (errors.length > 0) {
            const reasons = errors.map(e => `  (${e.x},${e.y}): ${e.reason}`).join('\n');
            alert(`Cannot save map ‚Äî path validation failed:\n${reasons}`);
            return;
        }

        const data = serializeMap(this.map);
        data.fogData = this.fog.getFogData();
        data.manualPath = this.waypointMgr.isValid(); // Using waypoint manager

        const name = prompt('Enter map name:', this.currentMapName || 'MyMap');
        if (!name) return;

        if (MapStorage.saveLocal(name, data)) {
            this.currentMapName = name; // Update current name
            alert(`Map "${name}" saved successfully!`);
            this.refreshMapsPanel(); // Refresh UI
        } else {
            alert('Failed to save map (Storage full?)');
        }
    }

    /**
     * Resolve sparse editor waypoints (Start, WP1, WP2, ..., End)
     * into a dense tile-by-tile BFS path.
     * Returns null if any segment is unreachable.
     */
    private resolveFullPath(): { x: number; y: number }[] | null {
        const sparse = this.waypointMgr.getFullPath();
        if (sparse.length < 2) {
            alert('Need at least Start and End points!');
            return null;
        }

        Pathfinder.invalidateCache();
        const fullPath: { x: number; y: number }[] = [];

        for (let i = 0; i < sparse.length - 1; i++) {
            const from = sparse[i];
            const to = sparse[i + 1];
            const segment = Pathfinder.findPath(this.map.grid, from, to);

            if (segment.length === 0) {
                alert(`No path between (${from.x},${from.y}) ‚Üí (${to.x},${to.y}).\nCheck that road tiles connect these points.`);
                return null;
            }

            // Append segment, skip first point on subsequent segments to avoid duplicates
            const startIdx = (i === 0) ? 0 : 1;
            for (let j = startIdx; j < segment.length; j++) {
                fullPath.push(segment[j]);
            }
        }

        return fullPath;
    }

    private createUI() {
        // Create new modular toolbar
        this.toolbar = new EditorToolbar((mode) => {
            console.log('[EditorScene] Mode changed to:', mode);
            this.mode = mode;
        });

        // Create controls container for additional buttons (WAVES, MENU, Clear Path)
        this.controlsContainer = UIUtils.createContainer({
            position: 'absolute',
            top: '20px',
            right: '20px',
            display: 'flex',
            flexDirection: 'column',
            gap: '8px',
            padding: '10px',
            background: 'rgba(0,0,0,0.85)',
            borderRadius: '8px',
            zIndex: '1000'
        });

        const addBtn = (text: string, onClick: () => void, color: string = '#444') => {
            UIUtils.createButton(this.controlsContainer, text, onClick, {
                background: color,
                border: '1px solid #666',
                padding: '10px 16px',
                borderRadius: '6px',
                fontSize: '14px',
                fontWeight: 'bold',
                width: '100%'
            });
        };

        addBtn('üóëÔ∏è Clear Path', () => {
            this.waypointMgr.clearAll();
        }, '#e91e63');

        addBtn('‚öôÔ∏è WAVES & SAVE', () => this.openWaveConfig(), '#ff9800');
        addBtn('üì• –≠–∫—Å–ø–æ—Ä—Ç JSON', () => this.exportCurrentMap(), '#2196f3');
        addBtn('üì§ –ò–º–ø–æ—Ä—Ç JSON', () => this.importMapFromFile(), '#9c27b0');
        addBtn('üö™ MENU', () => this.game.toMenu(), '#d32f2f');

        // Hidden file input for JSON import
        this._fileInput = document.createElement('input');
        this._fileInput.type = 'file';
        this._fileInput.accept = '.json';
        this._fileInput.style.display = 'none';
        this._fileInput.onchange = () => this.handleFileImport();
        this.controlsContainer.appendChild(this._fileInput);

        document.body.appendChild(this.controlsContainer);
    }

    // FEATURE: Create saved maps panel
    private createMapsPanel() {
        this.mapsPanel = UIUtils.createContainer({
            position: 'absolute',
            top: '20px',
            left: '20px',
            background: 'rgba(0, 0, 0, 0.9)',
            borderRadius: '8px',
            padding: '10px',
            maxWidth: '300px',
            maxHeight: '80vh',
            overflowY: 'auto',
            display: 'none',
            zIndex: '2000'
        });

        const header = document.createElement('div');
        Object.assign(header.style, {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: '10px',
            cursor: 'pointer',
            color: '#fff',
            fontWeight: 'bold',
        });

        header.innerHTML = `
            <span>üìÅ SAVED MAPS</span>
            <span style="font-size: 20px;">${this.mapsPanelExpanded ? '‚ñº' : '‚ñ∂'}</span>
        `;

        header.onclick = () => {
            this.mapsPanelExpanded = !this.mapsPanelExpanded;
            this.refreshMapsPanel();
        };

        this.mapsPanel.appendChild(header);
        document.body.appendChild(this.mapsPanel);
        this.refreshMapsPanel();
    }

    private refreshMapsPanel() {
        const gen = ++this._refreshGeneration;

        // Clear current content except header
        while (this.mapsPanel.children.length > 1) {
            this.mapsPanel.removeChild(this.mapsPanel.lastChild!);
        }

        // Update toggle icon
        const header = this.mapsPanel.children[0] as HTMLElement;
        header.innerHTML = `
            <span>üìÅ SAVED MAPS</span>
            <span style="font-size: 20px;">${this.mapsPanelExpanded ? '‚ñº' : '‚ñ∂'}</span>
        `;

        if (!this.mapsPanelExpanded) return;

        // –§–∞–∑–∞ 1 (sync): –ø–æ–∫–∞–∑–∞—Ç—å local –∫–∞—Ä—Ç—ã –º–≥–Ω–æ–≤–µ–Ω–Ω–æ
        const localMaps = MapStorage.getLocalMaps();
        const localNames = Object.keys(localMaps);

        if (localNames.length === 0) {
            const empty = document.createElement('div');
            empty.style.color = '#888';
            empty.style.padding = '10px';
            empty.innerText = 'No saved maps';
            empty.id = 'maps-panel-empty';
            this.mapsPanel.appendChild(empty);
        } else {
            localNames.forEach((name) => {
                this.createMapPanelItem(name, localMaps[name], 'local', false);
            });
        }

        // –§–∞–∑–∞ 2 (async): –¥–æ–ø–∏—Å–∞—Ç—å bundled –∫–∞—Ä—Ç—ã
        MapStorage.getBundledMaps().then(bundled => {
            if (gen !== this._refreshGeneration) return; // race condition guard

            const bundledNames = Object.keys(bundled).sort();
            if (bundledNames.length === 0) return;

            // –£–¥–∞–ª–∏—Ç—å "No saved maps" –µ—Å–ª–∏ –æ–Ω –±—ã–ª
            const emptyEl = this.mapsPanel.querySelector('#maps-panel-empty');
            if (emptyEl) emptyEl.remove();

            // –û–±–Ω–æ–≤–∏—Ç—å local –∫–∞—Ä—Ç—ã: –ø–æ–º–µ—Ç–∏—Ç—å overridesBundled
            for (const name of localNames) {
                if (name in bundled) {
                    const existingItem = this.mapsPanel.querySelector(`[data-map-name="${name}"]`) as HTMLElement;
                    if (existingItem) {
                        const nameSpan = existingItem.querySelector('.map-name') as HTMLElement;
                        if (nameSpan && !nameSpan.innerText.includes('‚ö°')) {
                            nameSpan.innerText = `üíæ ${name} ‚ö°`;
                        }
                        // –î–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫—É Restore
                        this.addRestoreButton(existingItem, name);
                    }
                }
            }

            // –î–æ–±–∞–≤–∏—Ç—å bundled –∫–∞—Ä—Ç—ã (—Ç–æ–ª—å–∫–æ —Ç–µ, —á—Ç–æ –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω—ã)
            for (const name of bundledNames) {
                if (localNames.includes(name)) continue; // local override ‚Äî —É–∂–µ –ø–æ–∫–∞–∑–∞–Ω–∞
                this.createMapPanelItem(name, bundled[name], 'bundled', false);
            }
        }).catch(e => {
            console.warn('[EditorScene] Failed to load bundled maps', e);
        });
    }

    /** –°–æ–∑–¥–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∫–∞—Ä—Ç—ã –≤ –ø–∞–Ω–µ–ª–∏ */
    private createMapPanelItem(name: string, data: IMapData, source: 'bundled' | 'local', overridesBundled: boolean) {
        const item = document.createElement('div');
        item.setAttribute('data-map-name', name);
        Object.assign(item.style, {
            background: source === 'bundled' ? '#1a2a3a' : '#222',
            padding: '10px',
            marginBottom: '5px',
            borderRadius: '4px',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
        });

        const nameSpan = document.createElement('span');
        nameSpan.className = 'map-name';
        nameSpan.style.color = '#fff';
        nameSpan.style.flex = '1';
        const icon = source === 'bundled' ? 'üì¶' : 'üíæ';
        const suffix = overridesBundled ? ' ‚ö°' : '';
        nameSpan.innerText = `${icon} ${name}${suffix}`;

        const btnContainer = document.createElement('div');
        btnContainer.style.display = 'flex';
        btnContainer.style.gap = '5px';

        // Load button ‚Äî always available
        const loadBtn = document.createElement('button');
        loadBtn.innerText = 'üìÇ';
        loadBtn.title = 'Load';
        Object.assign(loadBtn.style, {
            background: '#4caf50',
            color: '#fff',
            border: 'none',
            padding: '5px 10px',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '12px',
        });
        loadBtn.onclick = () => this.loadMap(name, data);
        btnContainer.appendChild(loadBtn);

        // Delete button ‚Äî only for local maps
        if (source === 'local') {
            const delBtn = document.createElement('button');
            delBtn.innerText = 'üóëÔ∏è';
            delBtn.title = 'Delete';
            Object.assign(delBtn.style, {
                background: '#f44336',
                color: '#fff',
                border: 'none',
                padding: '5px 10px',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '12px',
            });
            delBtn.onclick = () => this.deleteMap(name);
            btnContainer.appendChild(delBtn);
        }

        // Restore button for overridden
        if (overridesBundled) {
            this.addRestoreButton(item, name);
        }

        item.appendChild(nameSpan);
        item.appendChild(btnContainer);
        this.mapsPanel.appendChild(item);
    }

    /** –î–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫—É ¬´–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª¬ª */
    private addRestoreButton(item: HTMLElement, name: string) {
        const btnContainer = item.querySelector('div') as HTMLElement;
        if (!btnContainer) return;
        // –ù–µ –¥–æ–±–∞–≤–ª—è—Ç—å –¥–≤–∞–∂–¥—ã
        if (btnContainer.querySelector('.restore-btn')) return;

        const restoreBtn = document.createElement('button');
        restoreBtn.innerText = '‚ü≥';
        restoreBtn.title = '–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª';
        restoreBtn.className = 'restore-btn';
        Object.assign(restoreBtn.style, {
            background: '#ff9800',
            color: '#fff',
            border: 'none',
            padding: '5px 10px',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '12px',
        });
        restoreBtn.onclick = () => {
            if (!confirm(`–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª –∫–∞—Ä—Ç—ã "${name}"? –õ–æ–∫–∞–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã.`)) return;
            MapStorage.deleteLocal(name);
            this.refreshMapsPanel();
        };
        btnContainer.appendChild(restoreBtn);
    }

    /** –≠–∫—Å–ø–æ—Ä—Ç —Ç–µ–∫—É—â–µ–π –∫–∞—Ä—Ç—ã –∫–∞–∫ JSON-—Ñ–∞–π–ª */
    private exportCurrentMap() {
        const localMaps = MapStorage.getLocalMaps();
        if (!this.currentMapName || !localMaps[this.currentMapName]) {
            alert('–°–Ω–∞—á–∞–ª–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç–µ –∫–∞—Ä—Ç—É —á–µ—Ä–µ–∑ WAVES & SAVE');
            return;
        }

        const data = localMaps[this.currentMapName];
        const blob = MapStorage.createExportBlob(data);
        const fileName = MapStorage.sanitizeFileName(this.currentMapName) + '.json';

        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    /** –ò–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞—Ç—å –∏–º–ø–æ—Ä—Ç —á–µ—Ä–µ–∑ hidden file input */
    private importMapFromFile() {
        this._fileInput.value = ''; // Reset –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞ —Ç–æ–≥–æ –∂–µ —Ñ–∞–π–ª–∞
        this._fileInput.click();
    }

    /** –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ */
    private async handleFileImport() {
        const file = this._fileInput.files?.[0];
        if (!file) return;

        try {
            const data = await MapStorage.importFromFile(file);
            const defaultName = file.name.replace(/\.json$/i, '');
            const name = prompt('–ò–º—è –∫–∞—Ä—Ç—ã:', defaultName);
            if (!name) return;

            // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç –∏–º—ë–Ω
            const existing = MapStorage.getLocalMaps();
            if (name in existing) {
                if (!confirm(`–ö–∞—Ä—Ç–∞ "${name}" —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –ü–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å?`)) return;
            }

            MapStorage.saveLocal(name, data);
            this.loadMap(name, data);
            this.refreshMapsPanel();
            alert(`–ö–∞—Ä—Ç–∞ "${name}" –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞!`);
        } catch (e) {
            alert(`–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: ${(e as Error).message}`);
        }
    }

    private loadMap(name: string, data: any) {
        if (!confirm(`Load map "${name}"? Current work will be lost.`)) return;

        let mapData: IMapData;
        try {
            mapData = migrateMapData(data);
        } catch (e) {
            alert(`Failed to load map "${name}": ${(e as Error).message}`);
            return;
        }

        // Load map data into editor
        this.currentMapName = name;
        this.map = new MapManager(mapData);
        this.fog = new FogSystem(mapData);

        // Clear history on new map load
        this.history.clear();

        // Load waypoints into WaypointManager
        this.waypointMgr.clearAll();
        if (mapData.waypoints && mapData.waypoints.length > 0) {
            // First point is always Start
            this.waypointMgr.setStart(mapData.waypoints[0]);

            // Last point is always End (if more than 1)
            if (mapData.waypoints.length > 1) {
                this.waypointMgr.setEnd(mapData.waypoints[mapData.waypoints.length - 1]);
            }

            // Middle points are waypoints
            for (let i = 1; i < mapData.waypoints.length - 1; i++) {
                this.waypointMgr.addWaypoint(mapData.waypoints[i]);
            }
        }

        // Render loaded fog
        this.fog.update(0);
    }

    private deleteMap(name: string) {
        if (!confirm(`Delete map "${name}"? This cannot be undone.`)) return;

        MapStorage.deleteLocal(name);
        this.refreshMapsPanel();
    }

    private handleGlobalKey(e: KeyboardEvent) {
        // Ignore if typing in input fields
        if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
            return;
        }

        // Ctrl+Z - Undo
        if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            if (this.history.undo()) {
                this.fog.update(0); // Re-render fog after undo
            }
            return; // Fixed: was return; in original? Yes
        }

        // Ctrl+Shift+Z - Redo
        if (e.ctrlKey && e.shiftKey && e.key === 'Z') {
            e.preventDefault();
            if (this.history.redo()) {
                this.fog.update(0); // Re-render fog after redo
            }
            return;
        }

        // Ctrl+S - Save
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            this.openWaveConfig();
            return;
        }

        // E - Eraser mode
        if (e.key === 'e' || e.key === 'E') {
            this.mode = 'eraser';
            // Also update toolbar UI if possible?
            // current toolbar implementation relies on callback to update scene, not vice versa.
            // Ideally we should sync toolbar state.
            return;
        }

        // 1-3 - Category selection
        if (e.key >= '1' && e.key <= '3') {
            const categoryIndex = parseInt(e.key) - 1;
            this.toolbar.selectCategory(categoryIndex);
            return;
        }
    }

    private isPaintMode(mode: EditorMode): boolean {
        return mode === 'paint_road' || mode === 'paint_grass' ||
            mode === 'eraser' || mode === 'paint_fog';
    }
}
</file>

<file path="src/CardSystem.ts">
import { IGameScene } from './scenes/IGameScene';
import { CONFIG } from './Config';
import { generateUUID } from './Utils';
import { EventBus, Events } from './EventBus';

export interface ICard {
    id: string;
    type: any;
    level: number;
    isDragging: boolean;
    evolutionPath?: string;  // 'inferno', 'napalm', 'frost', etc. undefined = 'classic'
}

export class CardSystem {
    private scene: IGameScene;
    public hand: ICard[] = [];
    private static actionCounter: number = 0;

    // Dragging state
    public dragCard: ICard | null = null;
    private ghostEl!: HTMLElement;

    private handContainer!: HTMLElement;
    private isUIInitialized: boolean = false;

    constructor(scene: IGameScene, startingCards: string[] = ['FIRE', 'ICE', 'SNIPER']) {
        this.scene = scene;

        // Add starting cards
        startingCards.forEach(cardKey => this.addCard(cardKey, 1));
    }

    public initUI() {
        let wrapper = document.getElementById('hand-container');
        if (wrapper) {
            let hand = document.getElementById('hand');
            if (!hand) {
                hand = document.createElement('div');
                hand.id = 'hand';
                wrapper.appendChild(hand);
            }
            this.handContainer = hand;
        } else {
            this.handContainer = document.createElement('div');
            this.handContainer.id = 'hand';
            document.body.appendChild(this.handContainer);
        }

        let ghost = document.getElementById('drag-ghost');
        if (!ghost) {
            ghost = document.createElement('div');
            ghost.id = 'drag-ghost';
            document.body.appendChild(ghost);
        }
        this.ghostEl = ghost;
        this.ghostEl.style.display = 'none';
        this.ghostEl.style.pointerEvents = 'none';

        this.isUIInitialized = true;
        this.render();
    }

    public startDrag(card: ICard, e: PointerEvent) {
        if (this.scene.forge.isForging) return;
        this.dragCard = card;
        card.isDragging = true;

        this.ghostEl.style.display = 'block';
        this.ghostEl.innerHTML = `<div style="font-size:32px;">${card.type.icon}</div>`;
        this.updateDrag(e.clientX, e.clientY);

        this.render();
    }

    public updateDrag(x: number, y: number) {
        if (!this.dragCard) return;
        this.ghostEl.style.left = `${x}px`;
        this.ghostEl.style.top = `${y}px`;
    }

    public endDrag(e: PointerEvent) {
        if (!this.dragCard) return;

        // Check forge slots FIRST via ForgeSystem
        const droppedInForge = this.scene.forge.tryDropCard(e.clientX, e.clientY, this.dragCard);

        if (!droppedInForge) {
            // Drop on Canvas
            const rect = this.scene.game.canvas.getBoundingClientRect();
            const inCanvas =
                e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;

            if (inCanvas) {
                // Use logical game dimensions for coordinate mapping
                // rect.width is display width, game.width is logical width
                const x = (e.clientX - rect.left) * (this.scene.game.width / rect.width);
                const y = (e.clientY - rect.top) * (this.scene.game.height / rect.height);

                const actionId = `card_drop_${Date.now()}_${CardSystem.actionCounter++}`;
                EventBus.getInstance().emit(Events.CARD_DROPPED, { card: this.dragCard, x, y, actionId });
            }
        }

        this.dragCard.isDragging = false;
        this.dragCard = null;
        this.ghostEl.style.display = 'none';
        this.render();
    }

    public addCard(typeKey: string, level: number = 1) {
        this.addCardWithEvolution(typeKey, level, undefined);
    }

    public addCardWithEvolution(typeKey: string, level: number, evolutionPath?: string) {
        if (this.hand.length >= CONFIG.PLAYER.HAND_LIMIT) {
            this.scene.showFloatingText('Hand Full!', window.innerWidth / 2, window.innerHeight - 100, 'red');
            return;
        }

        const type = CONFIG.CARD_TYPES[typeKey];
        if (!type) {
            console.warn(`Unknown card type: ${typeKey}`);
            return;
        }

        const card: ICard = {
            id: generateUUID(),
            type: type,
            level: level,
            isDragging: false,
            evolutionPath: evolutionPath,  // May be undefined for Lv1/classic cards
        };
        this.hand.push(card);
        this.render();
        if (this.scene.ui) this.scene.ui.update();
    }

    public addRandomCardToHand() {
        const keys = Object.keys(CONFIG.CARD_TYPES);
        const randomKey = keys[Math.floor(Math.random() * keys.length)];
        this.addCard(randomKey, 1);
    }

    public removeCardFromHand(card: ICard) {
        const index = this.hand.indexOf(card);
        if (index !== -1) {
            this.hand.splice(index, 1);
            this.render();
            if (this.scene.ui) this.scene.ui.update();
        }
    }

    public render() {
        if (!this.isUIInitialized || !this.handContainer) return;
        this.handContainer.innerHTML = '';
        this.hand.forEach((card) => {
            const el = CardSystem.createCardElement(card);
            el.onpointerdown = (e: any) => this.startDrag(card, e);
            if (card.isDragging) el.classList.add('dragging-placeholder');
            this.handContainer.appendChild(el);
        });
    }

    public static createCardElement(card: ICard): HTMLElement {
        const el = document.createElement('div');
        el.className = `card type-${card.type.id} level-${card.level}`;

        // Add evolution-specific styling class
        if (card.evolutionPath && card.evolutionPath !== 'classic') {
            el.classList.add(`evo-${card.evolutionPath}`);
        }

        // Star rating
        let stars = '‚òÖ'.repeat(card.level);

        // Stats HTML - use evolution-specific if available
        let statsHTML = this.getCardStatsHTML(card);

        // Evolution badge (for evolved cards)
        let evoBadge = '';
        let playstyleTag = '';
        if (card.evolutionPath && card.evolutionPath !== 'classic') {
            const evoIcon = this.getEvolutionIcon(card.evolutionPath);
            const playstyle = this.getEvolutionPlaystyle(card.evolutionPath);
            evoBadge = `<div class="evo-badge">${evoIcon}</div>`;
            if (playstyle) {
                playstyleTag = `<div class="evo-playstyle">${playstyle}</div>`;
            }
        }

        el.innerHTML = `
            ${evoBadge}
            <div class="card-level">${stars}</div>
            <div class="card-icon">${card.type.icon}</div>
            <div class="card-stats">${statsHTML}</div>
            ${playstyleTag}
        `;
        return el;
    }

    /**
     * Get evolution icon by path ID
     */
    private static getEvolutionIcon(evolutionPath: string): string {
        const icons: Record<string, string> = {
            'inferno': 'üåã', 'napalm': 'üî•', 'meteor': '‚òÑÔ∏è', 'hellfire': 'üëπ', 'magma': 'üåä', 'scorch': 'üî•',
            'frost': '‚ùÑÔ∏è', 'shatter': 'üíé', 'absolutezero': 'üßä', 'blizzard': 'üå®Ô∏è', 'permafrost': 'üí†', 'glacier': 'üèîÔ∏è',
            'precision': 'üéØ', 'penetrator': 'üî´', 'executor': '‚öîÔ∏è', 'headhunter': 'üé≠', 'railgun': '‚ö°', 'marksman': 'üèπ',
            'barrage': 'üí•', 'spread': 'üéØ', 'storm': 'üå™Ô∏è', 'volley': 'üéÜ', 'homing': 'üéØ', 'twin': 'üëØ',
            'chaingun': '‚ö°', 'gatling': 'üí™', 'autocannon': 'üîß', 'rotary': 'üåÄ', 'devastator': 'üíÄ', 'suppressor': 'üõ°Ô∏è',
        };
        return icons[evolutionPath] || '‚ú®';
    }

    /**
     * Get evolution playstyle label
     */
    private static getEvolutionPlaystyle(evolutionPath: string): string {
        const playstyles: Record<string, string> = {
            // Fire
            'inferno': '–ù–Æ–ö–ê', 'napalm': 'DOT', 'meteor': 'MEGA', 'hellfire': 'CHAIN', 'magma': 'BURN', 'scorch': 'STACK',
            // Ice
            'frost': '–°–¢–û–ü', 'shatter': '–£–†–û–ù', 'absolutezero': 'FREEZE', 'blizzard': 'AOE', 'permafrost': '–ö–ê–ó–ù–¨', 'glacier': 'RANGE',
            // Sniper
            'precision': '–ë–û–°–°', 'penetrator': '–õ–ò–ù–ò–Ø', 'executor': 'DELETE', 'headhunter': 'HUNTER', 'railgun': 'LASER', 'marksman': 'HYBRID',
            // Multi
            'barrage': '–í–ï–ï–†', 'spread': '–¢–û–ß–ù–´–ô', 'storm': '–•–ê–û–°', 'volley': 'SPAM', 'homing': 'TRACK', 'twin': 'x2 HIT',
            // Minigun
            'chaingun': 'BURST', 'gatling': 'SUSTAIN', 'autocannon': '‚àû', 'rotary': 'SPEED', 'devastator': 'RAMP', 'suppressor': 'CC',
        };
        return playstyles[evolutionPath] || '';
    }

    public static getCardStatsHTML(card: ICard): string {
        // Check for evolution-specific display
        if (card.evolutionPath && card.evolutionPath !== 'classic') {
            return this.getEvolutionStatsHTML(card.evolutionPath);
        }

        const type = card.type.id;
        const level = card.level;

        switch (type) {
            case 'fire':
                if (level === 1) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +12</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 45</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +22</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 70</div>`;
                } else {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +25</div><div class="card-stat-line">–í–∑—Ä—ã–≤ + üíÄ</div>`;
                }

            case 'ice':
                if (level === 1) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +1</div><div class="card-stat-line">‚ùÑÔ∏è 30%</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +3</div><div class="card-stat-line">‚ùÑÔ∏è 45%</div>`;
                } else {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +6</div><div class="card-stat-line">‚ùÑÔ∏è 75% ‚õìÔ∏è</div>`;
                }

            case 'sniper':
                if (level === 1) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +14</div><div class="card-stat-line">üéØ +80</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +24</div><div class="card-stat-line">üéØ +160</div>`;
                } else {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +46</div><div class="card-stat-line">üéØ +240 üí´</div>`;
                }

            case 'multi':
                if (level === 1) {
                    return `<div class="card-stat-primary">2 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.8x —É—Ä–æ–Ω</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">3 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.6x —É—Ä–æ–Ω</div>`;
                } else {
                    return `<div class="card-stat-primary">4 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.45x —É—Ä–æ–Ω</div>`;
                }

            case 'minigun':
                if (level === 1) {
                    return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+4 —É—Ä–æ–Ω/—Å</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+5 —É—Ä–æ–Ω +–∫—Ä–∏—Ç</div>`;
                } else {
                    return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">–¥–æ +45 —É—Ä–æ–Ω</div>`;
                }

            default:
                return `<div class="card-stat-line">${card.type.desc}</div>`;
        }
    }

    /**
     * Get evolution-specific stats display
     */
    private static getEvolutionStatsHTML(evolutionPath: string): string {
        const stats: Record<string, { primary: string; secondary: string }> = {
            // Fire
            'inferno': { primary: 'üí• AoE 120', secondary: '-35% —Å–∫–æ—Ä–æ—Å—Ç—å' },
            'napalm': { primary: 'üî• 32 DoT', secondary: '+10% —Å–∫–æ—Ä–æ—Å—Ç—å' },
            'meteor': { primary: '‚òÑÔ∏è AoE 160', secondary: 'MEGA —É—Ä–æ–Ω' },
            'hellfire': { primary: 'üëπ –í–∑—Ä—ã–≤', secondary: '75% —É—Ä–æ–Ω–∞' },
            'magma': { primary: 'üåä 60 DoT', secondary: '12 dps √ó 5s' },
            'scorch': { primary: 'üî• –°—Ç–∞–∫–∏', secondary: '+25% —Å–∫–æ—Ä–æ—Å—Ç—å' },
            // Ice
            'frost': { primary: '‚ùÑÔ∏è 70% –°–¢–û–ü', secondary: '0 —É—Ä–æ–Ω–∞' },
            'shatter': { primary: 'üíé +60%', secondary: 'vs –∑–∞–º–µ–¥–ª.' },
            'absolutezero': { primary: 'üßä 85% FREEZE', secondary: '0 —É—Ä–æ–Ω–∞' },
            'blizzard': { primary: 'üå®Ô∏è –¶–µ–ø—å', secondary: '100px' },
            'permafrost': { primary: 'üí† +80%!', secondary: '–ö–∞–∑–Ω—å' },
            'glacier': { primary: 'üèîÔ∏è –î–∞–ª—å–Ω–æ—Å—Ç—å', secondary: '+10% range' },
            // Sniper
            'precision': { primary: 'üéØ 30% –∫—Ä–∏—Ç', secondary: 'x2.5' },
            'penetrator': { primary: 'üî´ Pierce 3', secondary: '-10%/—Ü–µ–ª—å' },
            'executor': { primary: '‚öîÔ∏è 40% –∫—Ä–∏—Ç', secondary: 'x3.0' },
            'headhunter': { primary: 'üé≠ +100%', secondary: 'vs >70% HP' },
            'railgun': { primary: '‚ö° Pierce 6', secondary: '300 range' },
            'marksman': { primary: 'üèπ Pierce 4', secondary: '20% –∫—Ä–∏—Ç' },
            // Multi
            'barrage': { primary: 'üí• 4 —Å–Ω–∞—Ä—è–¥–∞', secondary: '60¬∞ –≤–µ–µ—Ä' },
            'spread': { primary: 'üéØ 2 –º–æ—â–Ω—ã—Ö', secondary: '85% —É—Ä–æ–Ω' },
            'storm': { primary: 'üå™Ô∏è 6 —Å–Ω–∞—Ä—è–¥–æ–≤', secondary: '—Ö–∞–æ—Å' },
            'volley': { primary: 'üéÜ +30% APS', secondary: 'spam' },
            'homing': { primary: 'üéØ –ù–∞–≤–µ–¥–µ–Ω–∏–µ', secondary: '3 —Å–Ω–∞—Ä—è–¥–∞' },
            'twin': { primary: 'üëØ x2 —É–¥–∞—Ä', secondary: '100% —É—Ä–æ–Ω' },
            // Minigun
            'chaingun': { primary: '‚ö° 3—Å –æ–≥–æ–Ω—å', secondary: '+8 dps/—Å' },
            'gatling': { primary: 'üí™ 10—Å –æ–≥–æ–Ω—å', secondary: '+4 dps/—Å' },
            'autocannon': { primary: 'üîß ‚àû –û–ì–û–ù–¨', secondary: '–ë–µ–∑ –ø–µ—Ä–µ–≥—Ä–µ–≤–∞' },
            'rotary': { primary: 'üåÄ x3.5 speed', secondary: '+5% –∫—Ä–∏—Ç/—Å' },
            'devastator': { primary: 'üíÄ +100 —É—Ä–æ–Ω', secondary: '–Ω–∞ –º–∞–∫—Å' },
            'suppressor': { primary: 'üõ°Ô∏è 20% slow', secondary: '–Ω–∞ –º–∞–∫—Å' },
        };

        const s = stats[evolutionPath];
        if (!s) return '';
        return `<div class="card-stat-primary">${s.primary}</div><div class="card-stat-line">${s.secondary}</div>`;
    }
}
</file>

<file path="src/renderers/EnemyRenderer.ts">
import { Assets } from '../Assets';
import { CONFIG, getEnemyType } from '../Config';
import type { Enemy } from '../Enemy';
import { UnitRenderer, DefaultUnitRenderer } from './units/UnitRenderer';
import { SkeletonUnitRenderer } from './units/SkeletonUnitRenderer';
import { HellhoundUnitRenderer } from './units/HellhoundUnitRenderer';
import { OrcUnitRenderer } from './units/OrcUnitRenderer';
import { WraithUnitRenderer } from './units/WraithUnitRenderer';
import { GoblinUnitRenderer } from './units/GoblinUnitRenderer';

import { SpiderUnitRenderer } from './units/SpiderUnitRenderer';
import { SkeletonCommanderUnitRenderer } from './units/SkeletonCommanderUnitRenderer';
import { SkeletonMinerRenderer } from './units/SkeletonMinerRenderer';
import { SkeletonBerserkerRenderer } from './units/SkeletonBerserkerRenderer';

import { TrollUnitRenderer } from './units/TrollUnitRenderer';
import { RatUnitRenderer } from './units/RatUnitRenderer';
import { MagmaUnitRenderer } from './units/MagmaUnitRenderer';
import { FleshUnitRenderer } from './units/FleshUnitRenderer';

export class EnemyRenderer {
    // Registry of specific renderers (Singleton/Stateless instances)
    private static defaultRenderer: UnitRenderer = new DefaultUnitRenderer();
    private static renderers: Record<string, UnitRenderer> = {
        'SKELETON': new SkeletonUnitRenderer(),
        'WOLF': new DefaultUnitRenderer(),
        'TROLL': new TrollUnitRenderer(),
        'SPIDER': new SpiderUnitRenderer(),
        'HELLHOUND': new HellhoundUnitRenderer(),
        'ORC': new OrcUnitRenderer(),
        'WRAITH': new WraithUnitRenderer(),
        'GOBLIN': new GoblinUnitRenderer(),
        'SKELETON_COMMANDER': new SkeletonCommanderUnitRenderer(),
        'SKELETON_MINER': new SkeletonMinerRenderer(),
        'SKELETON_BERSERKER': new SkeletonBerserkerRenderer(),
        'RAT': new RatUnitRenderer(),
        'MAGMA': new MagmaUnitRenderer(),
        'FLESH': new FleshUnitRenderer(),
    };

    static drawSprite(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        // PERF: Use cached typeConfig instead of getEnemyType() per frame
        const typeConf = enemy.typeConfig || { scale: 1.0, archetype: 'SKELETON', props: [], color: '#fff' };

        // Defaults
        const scale = typeConf.scale || 1.0;
        const archetype = typeConf.archetype || 'SKELETON';
        const props = typeConf.props || [];

        ctx.save();
        ctx.translate((enemy.x | 0), (enemy.y | 0));

        // PERF: Use cached moveAngle from enemy.move()
        const moveAngle = enemy.moveAngle || 0;

        // 2. Breathing (pulsation) - PERF: use performance.now() instead of Date.now()
        // FIXED: enemy.id is number now, so we use modulo for variation
        const breathePhase = (performance.now() * 0.001) + ((enemy.id % 100) * 0.5);
        const breatheScale = 1.0 + Math.sin(breathePhase) * 0.03;
        ctx.scale(breatheScale, breatheScale);

        // -- VISUAL STACK --

        // 1. Shadow Layer
        EnemyRenderer.drawShadow(ctx, scale);

        // 2. Body Layer (STRATEGY PATTERN DELEGATION)
        const renderer = EnemyRenderer.renderers[archetype] || EnemyRenderer.defaultRenderer;
        try {
            renderer.drawBody(ctx, enemy, scale, moveAngle);
        } catch (e) {
            console.error(`Renderer failed for ${archetype}`, e);
            EnemyRenderer.defaultRenderer.drawBody(ctx, enemy, scale, moveAngle);
        }

        // 3. Props Layer
        if (props.length > 0) {
            for (let i = 0; i < props.length; i++) {
                const propImg = Assets.get(props[i]);
                if (propImg) {
                    const pSize = 32 * scale;
                    const pHalf = pSize / 2;
                    ctx.drawImage(propImg, -pHalf, -pHalf, pSize, pSize);
                }
            }
        }

        // 3.5. Status Particles Layer
        EnemyRenderer.drawStatusEffects(ctx, enemy);

        ctx.restore();
    }

    static drawUI(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        // PERF: Use cached typeConfig
        const typeConf = enemy.typeConfig || { scale: 1.0 };
        const scale = typeConf.scale || 1.0;

        ctx.save();
        ctx.translate(enemy.x, enemy.y);
        EnemyRenderer.drawHealthBar(ctx, enemy, scale);
        ctx.restore();
    }

    private static drawRimLight(ctx: CanvasRenderingContext2D, color: string, scale: number) {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.3;

        const rimSize = (48 * scale) * 1.2;
        ctx.beginPath();
        ctx.arc(0, 0, rimSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    private static drawShadow(ctx: CanvasRenderingContext2D, scale: number) {
        const shadowImg = Assets.get('shadow_small');
        if (shadowImg) {
            const shadowW = 32 * scale;
            const shadowH = 16 * scale;
            ctx.drawImage(shadowImg, -shadowW / 2, -shadowH / 2 + 10 * scale, shadowW, shadowH);
        } else {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            const shadowW = 16 * scale;
            const shadowH = 8 * scale;
            ctx.ellipse(0, 10 * scale, shadowW, shadowH, 0, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // PERF: Pre-computed burn colors per-particle (avoids rgba() string creation ‚Äî Rule 3)
    private static readonly BURN_COLORS = ['#ff6400', '#ffa000', '#ff8c00'];

    private static drawStatusEffects(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        // PERF: Manual status check ‚Äî no .some() closure allocation (Rule 5)
        let hasSlow = false;
        let hasBurn = false;
        for (let s = 0; s < enemy.statuses.length; s++) {
            const t = enemy.statuses[s].type;
            if (t === 'slow') hasSlow = true;
            else if (t === 'burn') hasBurn = true;
        }

        // SLOW (Blue Orbs)
        if (hasSlow) {
            const time = performance.now() * 0.003;
            for (let i = 0; i < 3; i++) {
                const angle = time + (i * Math.PI * 2 / 3);
                const orbX = Math.cos(angle) * 20;
                const orbY = Math.sin(angle) * 20;
                ctx.fillStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.arc(orbX, orbY, 3, 0, Math.PI * 2);
                ctx.fill();
                // Inner glow
                ctx.fillStyle = '#e1f5fe';
                ctx.beginPath();
                ctx.arc(orbX, orbY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // BURN (Rising Fire Particles) ‚Äî Rule 8: fillRect for size < 3
        if (hasBurn) {
            const now = Date.now(); // PERF: call once, not per particle
            for (let i = 0; i < 3; i++) {
                // Deterministic offset based on ID to desync particles
                const offset = (enemy.id * 10) + i * 100;
                const progress = ((now + offset) % 600) / 600; // 0..1 loop every 600ms

                // Rising motion with slight wiggle
                const pY = 10 - (progress * 30); // Start low, rise up
                const pX = Math.sin(progress * 10 + enemy.id) * 5;

                const alpha = 1 - progress; // Fade out
                const size = 3 + (1 - progress) * 2; // Shrink as they rise

                // PERF: Use pre-computed colors + globalAlpha (no rgba() string ‚Äî Rule 3)
                ctx.globalAlpha = alpha;
                ctx.fillStyle = EnemyRenderer.BURN_COLORS[i];
                // PERF: fillRect for particles (Rule 8: ctx.arc forbidden for r < 3,
                // but here size can be up to 5, so we use fillRect as per guidelines)
                ctx.fillRect(pX - size * 0.5, pY - size * 0.5, size, size);
            }
            ctx.globalAlpha = 1.0; // PERF: Restore immediately
        }
    }

    private static drawHealthBar(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number) {
        if (enemy.currentHealth < enemy.maxHealth) {
            const barWidth = CONFIG.UI.HP_BAR_WIDTH;
            const barHeight = CONFIG.UI.HP_BAR_HEIGHT;
            const barY = -30 * scale;

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(-barWidth / 2, barY, barWidth, barHeight);

            // Health bar
            const hpPercent = enemy.currentHealth / enemy.maxHealth;
            let hpColor = '#4caf50'; // green

            if (enemy.isInvulnerable) {
                hpColor = '#ffd700'; // Gold if immune
            } else if (hpPercent < 0.3) {
                hpColor = '#f44336'; // red
            } else if (hpPercent < 0.6) {
                hpColor = '#ff9800'; // orange
            }

            ctx.fillStyle = hpColor;
            ctx.fillRect(-barWidth / 2, barY, barWidth * hpPercent, barHeight);
        }
    }
    static drawEmissive(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        // PERF: Use cached typeConfig
        const typeConf = enemy.typeConfig || { scale: 1.0, archetype: 'SKELETON' };
        const scale = typeConf.scale || 1.0;
        const archetype = typeConf.archetype || 'SKELETON';

        const renderer = EnemyRenderer.renderers[archetype] || EnemyRenderer.defaultRenderer;
        if (renderer.drawEmissive) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);

            // PERF: Use cached moveAngle instead of recalculating
            const moveAngle = enemy.moveAngle || 0;

            renderer.drawEmissive(ctx, enemy, scale, moveAngle);
            ctx.restore();
        }
    }
}
</file>

<file path="src/WaveManager.ts">
import { IGameScene } from './scenes/IGameScene';
import { CONFIG } from './Config';
import { IWaveConfig, SpawnPattern, IWaveGroup, IWaveGroupRaw } from './MapData';
import { Rng } from './utils/Rng';
import { SoundManager, SoundPriority } from './SoundManager';
import { EventBus, Events } from './EventBus';

/** Marker type for delay entries in spawn queue. Not an actual enemy. */
const DELAY_MARKER = '__DELAY__' as const;

/**
 * Metadata for a queued enemy spawn.
 * Internal Use Only: Derives from normalized IWaveGroup.
 */
interface SpawnQueueEntry {
    type: string;
    pattern: SpawnPattern;
    interval: number; // Delay BEFORE this unit spawns (seconds)
}

/**
 * Manages wave logic, spawning enemies, and tracking wave progress.
 */
export class WaveManager {
    private scene: IGameScene;
    public isWaveActive: boolean = false;

    // Queue with pre-calculated determinism
    private spawnQueue: SpawnQueueEntry[] = [];
    private spawnTimer: number = 0;

    // Determinism & State
    private readonly runSeed: number;
    private pendingWaveStarts: number = 0; // Tracks queued early starts
    private lastEarlyBonusTime: number = -1; // Cooldown for early wave bonus (ms)
    private waveStartLives: number = 0; // Snapshot for perfect wave check

    // Card reward tracking
    private lastCardGivenForWave: number = 0;

    constructor(scene: IGameScene, runSeed: number) {
        this.scene = scene;
        this.runSeed = runSeed;
    }

    /**
     * Starts the next wave. If already active, appends to queue and adds bonus.
     */
    public startWave() {
        const nowMs = Date.now();

        // Logic split:
        if (!this.isWaveActive) {
            // Case A: Fresh Start
            this.scene.wave++;
            this.isWaveActive = true;
            this.pendingWaveStarts = 0;

            // Snapshot lives for "Perfect Wave" check (only on fresh start of a sequence)
            this.waveStartLives = this.scene.lives;
            this.lastEarlyBonusTime = nowMs; // Initialize to prevent instant early bonus on first stack

            this.generateWave(this.scene.wave);
            const emitConfig = this.getWaveConfig(this.scene.wave);
            EventBus.getInstance().emit(Events.WAVE_STARTED, {
                wave: this.scene.wave,
                name: emitConfig?.name
            });
        } else {
            // Case B: Early Start (Stacking)
            // Block stacking if current wave requires clear
            const currentWaveConfig = this.getWaveConfig(this.scene.wave);
            if (currentWaveConfig?.waitForClear) {
                return; // Silently block ‚Äî UI should disable the button
            }

            // Give bonus only if cooldown passed to prevent accidental double-clicks
            if (nowMs - this.lastEarlyBonusTime > 500) {
                this.scene.addMoney(CONFIG.ECONOMY.EARLY_WAVE_BONUS);
                this.scene.metrics.trackMoneyEarned(CONFIG.ECONOMY.EARLY_WAVE_BONUS);
                this.scene.showFloatingText(`EARLY! +${CONFIG.ECONOMY.EARLY_WAVE_BONUS}üí∞`, this.scene.game.width / 2, 300, 'gold');
                this.lastEarlyBonusTime = nowMs;
            }

            this.pendingWaveStarts++;
            this.scene.wave++;
            this.generateWave(this.scene.wave); // Appends to queue WITHOUT clearing

            // Notify UI of new wave number
            const emitConfig = this.getWaveConfig(this.scene.wave);
            EventBus.getInstance().emit(Events.WAVE_STARTED, {
                wave: this.scene.wave,
                name: emitConfig?.name
            });
        }

        this.scene.metrics.trackWaveReached(this.scene.wave);
    }

    public update(dt: number) {
        if (!this.isWaveActive) return;

        // Process Spawn Queue
        if (this.spawnQueue.length > 0) {
            this.spawnTimer += dt;

            // Peek at next enemy
            const nextEntry = this.spawnQueue[0];

            if (this.spawnTimer >= nextEntry.interval) {
                // Time to spawn!
                // FIFO: Remove from head
                const entry = this.spawnQueue.shift()!;

                if (entry.type !== DELAY_MARKER) {
                    this.scene.spawnEnemy(entry.type);
                    // Sound: Boss Spawn
                    if (entry.type.toUpperCase() === 'SPIDER' || entry.type.toUpperCase() === 'TANK') {
                        SoundManager.play('boss_spawn', SoundPriority.HIGH);
                    }
                }
                // DELAY entries consume their interval and do nothing

                this.spawnTimer = 0;
            }
        } else {
            // If queue is empty AND no enemies alive -> Wave Complete
            if (this.scene.enemies.length === 0) {
                this.endWave();
            }
        }
    }

    private endWave() {
        this.isWaveActive = false;
        EventBus.getInstance().emit(Events.WAVE_COMPLETED, this.scene.wave);

        // Progressive economy
        const reward = CONFIG.ECONOMY.WAVE_BASE_REWARD + (this.scene.wave * CONFIG.ECONOMY.WAVE_SCALING_FACTOR);
        this.scene.addMoney(reward);

        // Custom bonus reward (Variant A: applies to last wave in stack)
        const endWaveConfig = this.getWaveConfig(this.scene.wave);
        if (endWaveConfig?.bonusReward && endWaveConfig.bonusReward > 0) {
            this.scene.addMoney(endWaveConfig.bonusReward);
            this.scene.metrics.trackMoneyEarned(endWaveConfig.bonusReward);
        }
        // Perfect wave bonus
        if (this.scene.lives >= this.waveStartLives) {
            this.scene.addMoney(CONFIG.ECONOMY.PERFECT_WAVE_BONUS);
            this.scene.metrics.trackMoneyEarned(CONFIG.ECONOMY.PERFECT_WAVE_BONUS);
            this.scene.showFloatingText(
                `PERFECT! +${CONFIG.ECONOMY.PERFECT_WAVE_BONUS}üí∞`,
                this.scene.game.width / 2,
                350,
                '#00ffff'
            );
        }

        // Give card reward (for all completed waves since last grant)
        const wavesToReward = this.scene.wave - this.lastCardGivenForWave;
        if (wavesToReward > 0) {
            for (let i = 0; i < wavesToReward; i++) {
                this.scene.giveRandomCard();
            }
            this.lastCardGivenForWave = this.scene.wave;
        }
    }

    public getWaveConfig(waveNum: number): IWaveConfig | null {
        let waveConfig: IWaveConfig | null = null;

        // 1. Try Map Data
        if (this.scene.mapData && this.scene.mapData.waves && this.scene.mapData.waves.length > 0) {
            const idx = Math.min(waveNum - 1, this.scene.mapData.waves.length - 1);
            waveConfig = this.scene.mapData.waves[idx];
        }

        // 2. Fallback to Global Config
        if (!waveConfig) {
            const idx = Math.min(waveNum - 1, CONFIG.WAVES.length - 1);
            const rawData = CONFIG.WAVES[idx];

            if (Array.isArray(rawData)) {
                // @ts-ignore
                waveConfig = { enemies: rawData };
            } else {
                waveConfig = rawData as unknown as IWaveConfig;
            }
        }

        return waveConfig;
    }

    /**
     * Generates a wave DETERMINISTICALLY.
     * Normalizes config before processing.
     */
    private generateWave(waveNum: number) {
        const waveConfig = this.getWaveConfig(waveNum);
        if (!waveConfig || !waveConfig.enemies) return;

        // Start delay for this wave
        const startDelay = waveConfig.startDelay ?? 0;
        if (startDelay > 0) {
            this.spawnQueue.push({ type: DELAY_MARKER, pattern: 'normal', interval: startDelay });
        }

        // 1. Create ISOLATED RNG
        const waveSeed = (this.runSeed ^ (waveNum * 1664525)) >>> 0;
        const waveRng = new Rng(waveSeed);

        // 2. Normalize and Process Config
        const waveEnemies: SpawnQueueEntry[] = [];

        waveConfig.enemies.forEach((rawGroup: IWaveGroupRaw) => {
            // STRICT MIGRATION: Convert Raw Config to Normalized Group
            const group: IWaveGroup = WaveManager.normalizeWaveGroup(rawGroup);

            // Group delay (gap before this group)
            const groupDelay = rawGroup.delayBefore ?? 0;
            if (groupDelay > 0) {
                waveEnemies.push({ type: DELAY_MARKER, pattern: 'normal', interval: groupDelay });
            }

            for (let i = 0; i < group.count; i++) {
                // Use NORMALIZED baseInterval
                const delay = this.calculateDelay(group.pattern, group.baseInterval, waveRng);

                waveEnemies.push({
                    type: group.type,
                    pattern: group.pattern,
                    interval: delay
                });
            }
        });

        // 3. Shuffle control ‚Äî default 'all' preserves legacy behavior for old maps
        // New maps from WaveEditor use 'none' by default
        const shuffleMode = waveConfig.shuffleMode ?? 'all';
        if (shuffleMode === 'all') {
            waveRng.shuffle(waveEnemies);
        }
        // 'none' and 'within_group' preserve group order

        // 4. Append
        this.spawnQueue.push(...waveEnemies);
    }

    /**
     * Pure function to normalize legacy or partial config into strict IWaveGroup
     * Made PUBLIC STATIC to allow ThreatService to use the EXACT same logic
     */
    public static normalizeWaveGroup(raw: IWaveGroupRaw): IWaveGroup {
        // Validation
        if (!raw.type) throw new Error('[WaveManager] Invalid group: missing type');
        if (raw.count <= 0) throw new Error('[WaveManager] Invalid group: count must be > 0');

        // Resolve Pattern
        // Priority: pattern > spawnPattern > default
        const pattern: SpawnPattern = raw.pattern || raw.spawnPattern || 'normal';

        // Resolve Base Interval
        // Priority: baseInterval > spawnRate mapping > default
        let baseInterval = 0.66; // default medium

        if (raw.baseInterval !== undefined) {
            baseInterval = raw.baseInterval;
        } else if (raw.spawnRate) {
            baseInterval = WaveManager.getBaseIntervalFromRate(raw.spawnRate);
        }

        // Clamping (Safety)
        // Prevent near-zero intervals crashing the game or 50s intervals breaking flow
        baseInterval = Math.max(0.05, Math.min(baseInterval, 10.0));

        return {
            type: raw.type,
            count: raw.count,
            baseInterval: baseInterval,
            pattern: pattern
        };
    }

    private calculateDelay(pattern: SpawnPattern, baseInterval: number, rng: Rng): number {
        // Use normalized interval
        const safeBase = baseInterval;

        switch (pattern) {
            case 'normal':
                return safeBase;

            case 'random':
                // ¬±30% variance
                const variance = safeBase * 0.3;
                const randomOffset = (rng.next() - 0.5) * 2 * variance;
                return Math.max(0.05, safeBase + randomOffset);

            case 'swarm':
                // Fast: 10-25% of base
                const swarmBase = safeBase * 0.15;
                const swarmVariance = swarmBase * 0.5;
                const swarmDelay = swarmBase + rng.next() * swarmVariance;
                return Math.max(0.02, swarmDelay);

            default:
                return safeBase;
        }
    }

    public static getBaseIntervalFromRate(rate: 'fast' | 'medium' | 'slow'): number {
        switch (rate) {
            case 'fast': return 0.4;
            case 'slow': return 1.0;
            case 'medium':
            default: return 0.66;
        }
    }
}
</file>

<file path="src/WeaponSystem.ts">
import { Tower } from './Tower';
import { Enemy } from './Enemy';
import { Projectile } from './Projectile';
import { CONFIG } from './Config';
import { VISUALS } from './VisualConfig';
import { EffectSystem } from './EffectSystem';
import { SoundManager, SoundPriority } from './SoundManager';
import { ProjectileSystem } from './systems/ProjectileSystem';
import { getTurretRenderer } from './renderers/turrets';

export class WeaponSystem {

    public update(towers: Tower[], enemies: Enemy[], projectileSystem: ProjectileSystem, dt: number, effects?: EffectSystem) {
        for (let i = 0; i < towers.length; i++) {
            this.processTower(towers[i], enemies, projectileSystem, dt, effects);
        }
    }

    private processTower(tower: Tower, enemies: Enemy[], projectileSystem: ProjectileSystem, dt: number, effects?: EffectSystem) {
        if (tower.isBuilding) return;
        // if (tower.cards.length === 0) return; // Removed to allow base firing


        // Handle overheat cooldown
        if (tower.isOverheated) {
            if (tower.overheatCooldown > 0) {
                tower.overheatCooldown -= dt;
            } else {
                tower.isOverheated = false;
                tower.spinupTime = 0; // Reset spinup after overheat
            }
            return; // Can't shoot while overheated
        }

        // Cooldown is handled in Tower.update()


        // Decrement recoil (seconds)
        if (tower.recoilTimer > 0) {
            tower.recoilTimer -= dt;
            if (tower.recoilTimer < 0) tower.recoilTimer = 0;
        }

        // Decay barrel recoil (spring physics)
        if (tower.barrelRecoil < 0) {
            tower.barrelRecoil += dt * 20; // Recovery speed
            if (tower.barrelRecoil > 0) tower.barrelRecoil = 0;
        }

        const stats = tower.getStats();

        // 1. Use Cached Target (from Tower.update)
        const target = tower.target;

        if (target) {
            // === SPINUP MECHANIC ===
            // Increment spinup progress whenever we have a target (and not overheated yet)
            const spinupEffect = stats.effects.find(e => e.type === 'spinup');
            if (spinupEffect && !tower.isOverheated) {
                // PHYSICS-BASED HEAT GENERATION
                // Heat generation depends on how fast the gun is firing.
                // Standard Minigun (LVL1) has ~2.65x multiplier.
                // If we add Sniper (0.5x), heat should generate slower.
                // If we add Rapid Fire (2.0x), heat should generate faster.
                // We normalize against the base Minigun speed (~2.65) to keep the 5s duration standard.
                const MINIGUN_BASE_SPEED_MULT = 2.65;
                const speedFactor = (stats.attackSpeedMultiplier || 1.0) / MINIGUN_BASE_SPEED_MULT;

                // If using Sniper card, speedFactor will be < 1, so heat builds slower (takes longer to overheat)
                // If using Rapid card, speedFactor will be > 1, so heat builds faster
                tower.spinupTime += dt * speedFactor;

                const maxSpinupSeconds = spinupEffect.maxSpinupSeconds || 5;
                tower.maxHeat = maxSpinupSeconds; // Sync for visual bar

                // VISUAL STATE UPDATE
                tower.heatLevel = Math.min(1, tower.spinupTime / tower.maxHeat);

                // Check if tower has Ice card (for overheat extension)
                const hasIceCard = tower.cards.some(c => c.type.id === 'ice');
                const overheatExtension = hasIceCard ? (spinupEffect.overheatExtensionWithIce || 0) : 0;
                const overheatThreshold = maxSpinupSeconds + overheatExtension;

                if (tower.spinupTime >= overheatThreshold) {
                    tower.isOverheated = true;
                    tower.overheatCooldown = spinupEffect.overheatDuration || 1.5;
                    tower.totalOverheatDuration = tower.overheatCooldown; // Store for UI
                    tower.spinupTime = 0;
                }
            }

            // 2. Aim Check (Rotation is handled in Tower.update)
            const dx = target.x - tower.x;
            const dy = target.y - tower.y;
            const desiredAngle = Math.atan2(dy, dx);

            // 3. Fire only if aimed close enough
            const angleDiff = Math.abs(this.getShortestAngleDifference(tower.angle, desiredAngle));

            if (tower.cooldown <= 0 && angleDiff < tower.firingArc) {
                this.fire(tower, target, stats, projectileSystem, effects);
                tower.cooldown = stats.cd;
            }
        } else {
            // === SPINUP RESET / COOLING ===
            // No target - Start cooling down
            if (tower.spinupTime > 0) {
                // Cool down rate: 
                // User wants 1.5 seconds to cool down from max heat
                const coolRate = (tower.maxHeat / 1.5) * dt;
                tower.spinupTime = Math.max(0, tower.spinupTime - coolRate);
                tower.heatLevel = Math.min(1, tower.spinupTime / tower.maxHeat);
            }
            if (tower.isOverheated) {
                // If we lost target but are overheated, we still cool down the overheat timer?
                // The overheat timer is handled at the top of processTower logic.
                // We don't need to force clear it here, let it run its course.
            }
        }
    }

    /**
     * Returns the shortest difference between two angles in radians (-PI to PI)
     */
    private getShortestAngleDifference(current: number, target: number): number {
        let diff = target - current;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        return diff;
    }

    private fire(tower: Tower, target: { x: number, y: number }, stats: any, projectileSystem: ProjectileSystem, effects?: EffectSystem) {
        // Muzzle Math
        // NEW: Get dynamic muzzle length from renderer
        const renderer = getTurretRenderer(tower.cards[0]?.type.id || 'default');
        const barrelLen = renderer.getMuzzleOffset ? renderer.getMuzzleOffset() : CONFIG.TOWER.BARREL_LENGTH;

        const muzzleX = tower.x + Math.cos(tower.angle) * barrelLen;
        const muzzleY = tower.y + Math.sin(tower.angle) * barrelLen;

        // === MUZZLE FLASH EFFECT ===
        if (effects) {
            let flashColor = VISUALS.TOWER.MUZZLE_FLASH.STANDARD;
            let flashRadius = 15;

            // Determine color based on projectile type
            switch (stats.projectileType) {
                case 'fire':
                case 'explosive':
                    flashColor = VISUALS.TOWER.MUZZLE_FLASH.FIRE;
                    flashRadius = 20;
                    break;
                case 'ice':
                    flashColor = VISUALS.TOWER.MUZZLE_FLASH.ICE;
                    flashRadius = 18;
                    break;
                case 'sniper':
                    flashColor = VISUALS.TOWER.MUZZLE_FLASH.SNIPER;
                    flashRadius = 12; // Smaller but intense
                    break;
                case 'split':
                    flashColor = VISUALS.TOWER.MUZZLE_FLASH.SPLIT;
                    flashRadius = 22; // Wide flash
                    break;
                case 'minigun':
                    flashColor = VISUALS.TOWER.MUZZLE_FLASH.MINIGUN;
                    flashRadius = 14;
                    break;
            }

            effects.add({
                type: 'muzzle_flash',
                x: muzzleX,
                y: muzzleY,
                radius: flashRadius,
                life: 0.08,
                color: flashColor
            });

            // === SHELL CASING EFFECT ===
            // Eject shell perpendicular to fire angle
            const ejectAngle = tower.angle + Math.PI / 2 + (Math.random() - 0.5) * 0.5;
            const ejectSpeed = (2 + Math.random() * 2) * 60; // Convert to px/sec
            effects.add({
                type: 'debris',
                x: tower.x, // Eject from tower center/breech
                y: tower.y,
                vx: Math.cos(ejectAngle) * ejectSpeed,
                vy: Math.sin(ejectAngle) * ejectSpeed,
                gravity: 720, // 12 * 60 (Acceleration: px/sec^2)
                rotation: Math.random() * Math.PI,
                vRot: (Math.random() - 0.5) * 30, // 0.5 * 60 (rad/sec)
                life: 1.0, // 60 frames -> 1.0 second
                color: '#ffd700', // Gold shell
                size: 3,
            });
        }

        // Multishot logic
        if (stats.projCount > 1) {
            const startAngle = tower.angle - (stats.spread * (stats.projCount - 1)) / 2;

            for (let i = 0; i < stats.projCount; i++) {
                const currentAngle = startAngle + i * stats.spread;

                // For 'shotgun' spread, we might want the projectile to originate from the same muzzle point
                // but travel in different directions.
                // Or we can slightly offset the origin if it's a wide bank of guns.
                // Let's keep origin same, vary velocity vector implies target varies OR we just calculate velocity manually in Projectile.
                // Currently Projectile.init calculates angle to target. 
                // We need to override this or create a virtual target for the spread shots.

                // Calculate a virtual target point in the direction of fire
                const range = 500; // Arbitrary far distance
                const vx = Math.cos(currentAngle) * range;
                const vy = Math.sin(currentAngle) * range;
                const virtualTarget = { x: muzzleX + vx, y: muzzleY + vy };

                const finalDamage = Math.max(1, stats.damage * (stats.damageMultiplier || 1));
                projectileSystem.spawn(muzzleX, muzzleY, virtualTarget, { ...stats, damage: finalDamage });
            }
        } else {
            // Single shot
            const finalDamage = Math.max(1, stats.damage * (stats.damageMultiplier || 1));
            const p = projectileSystem.spawn(muzzleX, muzzleY, target, { ...stats, damage: finalDamage });

            // Trigger recoil for critical hits
            if (p.isCrit) {
                // Apply barrel recoil (visual only)
                tower.barrelRecoil = -6;

                // Keep body recoil for critical hits (screen shake effect optional)
                tower.recoilTimer = 0.2;
                tower.recoilIntensity = 3;
            } else {
                // Standard recoil (Single shot kickback)
                // specific types might handle their own recoil (e.g. Minigun vibrates)
                if (stats.projectileType !== 'minigun') {
                    tower.barrelRecoil = -4;
                }
            }
        }

        // Minigun vibration (constant while firing)
        if (stats.projectileType === 'minigun') {
            tower.recoilTimer = 0.1; // 0.1s duration (was 5 frames)
            // Vibration is handled in renderer via heatLevel
        }

        // Play Sound
        const isSniper = stats.projectileType === 'sniper';
        const soundKey = isSniper ? 'shoot_sniper' : 'shoot_basic';
        const priority = isSniper ? SoundPriority.HIGH : SoundPriority.LOW;

        SoundManager.play(soundKey, priority);
    }
}
</file>

<file path="src/Config.ts">
import type { ICardTypeConfig, IEnemyTypeConfig } from './types';
import { ENEMY_CONFIG, ENEMY_TYPES } from './config/Enemies';
import { TOWER_CONFIG, TARGETING_MODES } from './config/Towers';
import { WAVE_CONFIG, ECONOMY_CONFIG } from './config/Levels';

export const CONFIG = {
    // Configuration flags for safe refactoring
    USE_NEW_RENDERER: true, // Toggle this to enable new modular renderers

    TILE_SIZE: 64,

    AMBIENT: {
        DAY_SPEED: 0.0005,
        NIGHT_SPEED_MULTIPLIER: 1.5,
        LIGHTING: {
            FIRE: '#ff5722',
            ICE: '#00bcd4',
            SNIPER: '#4caf50',
            MINIGUN: '#e040fb',
            STANDARD: '#ffeb3b',
        }
    },

    PLAYER: {
        START_MONEY: 250,
        START_LIVES: 20,
        HAND_LIMIT: 7,
    },

    ECONOMY: {
        ...ECONOMY_CONFIG,
        SLOT_UNLOCK_COST: [0, 150, 350], // Cost to unlock Slot 1 (0), Slot 2, Slot 3
    },

    TOWER: TOWER_CONFIG,

    TARGETING_MODES: TARGETING_MODES,

    UI: {
        HP_BAR_WIDTH: 40,
        HP_BAR_HEIGHT: 4,
        HP_BAR_OFFSET: -30,
        FLOATING_TEXT_LIFE: 1.0, // 1 second
    },

    CARD_TYPES: {
        FIRE: { id: 'fire', name: '–ú–æ—Ä—Ç–∏—Ä–∞', icon: 'üî•', color: '#f44336', desc: '–£—Ä–æ–Ω –ø–æ –ø–ª–æ—â–∞–¥–∏', turretAsset: 'turret_fire', moduleAsset: 'mod_fire' },
        ICE: { id: 'ice', name: '–°—Ç—É–∂–∞', icon: '‚ùÑÔ∏è', color: '#00bcd4', desc: '–ó–∞–º–µ–¥–ª—è–µ—Ç –≤—Ä–∞–≥–æ–≤', turretAsset: 'turret_ice', moduleAsset: 'mod_ice' },
        SNIPER: { id: 'sniper', name: '–°–Ω–∞–π–ø–µ—Ä', icon: 'üéØ', color: '#4caf50', desc: '–î–∞–ª—å–Ω—è—è —Å—Ç—Ä–µ–ª—å–±–∞', turretAsset: 'turret_sniper', moduleAsset: 'mod_sniper' },
        MULTISHOT: { id: 'multi', name: '–ó–∞–ª–ø', icon: 'üí•', color: '#ff9800', desc: '+1 —Å–Ω–∞—Ä—è–¥, -—É—Ä–æ–Ω', turretAsset: 'turret_split', moduleAsset: 'mod_split' },
        MINIGUN: { id: 'minigun', name: '–ü—É–ª–µ–º—ë—Ç', icon: '‚ö°', color: '#9c27b0', desc: '–ë—ã—Å—Ç—Ä–∞—è —Å—Ç—Ä–µ–ª—å–±–∞, —É—Ä–æ–Ω —Ä–∞—Å—Ç—ë—Ç', turretAsset: 'turret_minigun', moduleAsset: 'mod_minigun' },
    } as Readonly<Record<string, ICardTypeConfig>>,

    ENEMY: ENEMY_CONFIG,

    ENEMY_TYPES: ENEMY_TYPES,

    WAVES: WAVE_CONFIG,
};

/**
 * Type-safe helper to get card type configuration
 */
export function getCardType(key: string): ICardTypeConfig | undefined {
    return CONFIG.CARD_TYPES[key];
}

/**
 * Type-safe helper to get enemy type configuration
 */
export function getEnemyType(key: string): IEnemyTypeConfig | undefined {
    // Try exact match first, then uppercase
    // @ts-ignore
    return CONFIG.ENEMY_TYPES[key] || CONFIG.ENEMY_TYPES[key.toUpperCase()];
}
</file>

<file path="src/CollisionSystem.ts">
import { Enemy } from './Enemy';
import { Projectile } from './Projectile';
import { EffectSystem, EffectPriority } from './EffectSystem';
import { PerformanceMonitor } from './utils/PerformanceMonitor';
import { PerformanceProfiler } from './utils/PerformanceProfiler';
import { SoundManager, SoundPriority } from './SoundManager';
import { SpatialGrid } from './SpatialGrid';

export class CollisionSystem {
    private effects: EffectSystem;
    private enemyGrid: SpatialGrid<Enemy>;

    private gridDirty: boolean = true;
    private enemyLastCells: WeakMap<Enemy, { x: number, y: number }> = new WeakMap();

    constructor(effects: EffectSystem) {
        this.effects = effects;
        // Initialize grid with screen dimensions, 128px cells
        this.enemyGrid = new SpatialGrid<Enemy>(window.innerWidth, window.innerHeight, 128);
    }


    private static aoeBuffer: Enemy[] = [];

    public invalidateGrid() {
        this.gridDirty = true;
    }

    public getValidGrid(enemies: Enemy[]): SpatialGrid<Enemy> {
        // Automatically check if rebuilding is necessary
        let autoDirty = false;

        let aliveCount = 0;
        for (let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            if (enemy && enemy.isAlive()) {
                aliveCount++;
                const currentCellX = Math.floor(enemy.x / this.enemyGrid.cellSize);
                const currentCellY = Math.floor(enemy.y / this.enemyGrid.cellSize);

                const lastCell = this.enemyLastCells.get(enemy);
                if (!lastCell || lastCell.x !== currentCellX || lastCell.y !== currentCellY) {
                    autoDirty = true;
                    this.enemyLastCells.set(enemy, { x: currentCellX, y: currentCellY });
                }
            }
        }

        // We also need to know if the total alive enemies changed. 
        // A simple check is comparing grid size to aliveCount.
        if (aliveCount !== this.enemyGrid.size) {
            autoDirty = true;
        }

        if (this.gridDirty || autoDirty) {
            this.prepareGrid(enemies);
            this.gridDirty = false;
        }
        return this.enemyGrid;
    }

    private prepareGrid(enemies: Enemy[]) {
        this.enemyGrid.clear();
        for (let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            // Safety check for holes in array
            if (enemy && enemy.isAlive()) {
                this.enemyGrid.register(enemy);
            }
        }
    }

    public update(projectiles: Projectile[], enemies: Enemy[]) {
        const activeGrid = this.getValidGrid(enemies);

        // Check projectile collisions using spatial grid
        for (let p = 0; p < projectiles.length; p++) {
            const proj = projectiles[p];
            if (!proj || !proj.alive) continue;

            // Out of bounds check
            if (proj.x < -50 || proj.x > window.innerWidth + 50 || proj.y < -50 || proj.y > window.innerHeight + 50) {
                proj.alive = false;
                continue;
            }

            // Get only nearby enemies instead of checking all enemies
            const searchRadius = 100; // Reasonable search radius for collision
            const count = activeGrid.queryInRadius(proj.x, proj.y, searchRadius, CollisionSystem.aoeBuffer);

            // PERF: Custom Stress Test Profiler
            PerformanceProfiler.count('pairsChecked', count);

            for (let e = 0; e < count; e++) {
                const enemy = CollisionSystem.aoeBuffer[e];
                // CRITICAL FIX: Safety check for undefined logic
                if (!enemy || !enemy.isAlive()) continue;
                if (proj.hitList.includes(enemy.id)) continue;

                // Squared distance check (faster than Math.hypot)
                const dx = enemy.x - proj.x;
                const dy = enemy.y - proj.y;
                const distSq = dx * dx + dy * dy;
                const hitDist = 20 + proj.radius;
                const hitDistSq = hitDist * hitDist;

                if (distSq < hitDistSq) {
                    this.handleHit(proj, enemy, enemies, activeGrid);

                    if (proj.pierce > 0) {
                        proj.pierce--;
                        proj.hitList.push(enemy.id);
                    } else {
                        proj.alive = false;
                        break;
                    }
                }
            }
        }
    }

    private handleHit(p: Projectile, target: Enemy, allEnemies: Enemy[], activeGrid: SpatialGrid<Enemy>) {
        // Apply damage with projectile reference (for tracking kills)
        let wasSlowed = false;
        for (let i = 0; i < target.statuses.length; i++) {
            if (target.statuses[i].type === 'slow') {
                wasSlowed = true;
                break;
            }
        }

        target.takeDamage(p.damage, p);

        // Sound Hit
        SoundManager.play('hit', SoundPriority.LOW);

        // --- –í–ò–ó–£–ê–õ: –ò—Å–∫—Ä—ã –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏ (critical hit = more particles) ---
        // DECOUPLED: Visuals are fire-and-forget
        const particleCount = p.isCrit ? 10 : 5;
        for (let i = 0; i < particleCount; i++) {
            this.effects.spawn({
                type: 'particle',
                x: target.x,
                y: target.y,
                vx: (Math.random() - 0.5) * (p.isCrit ? 480 : 240), // 8/4 * 60
                vy: (Math.random() - 0.5) * (p.isCrit ? 480 : 240),
                life: p.isCrit ? 0.5 : 0.35, // 30/20 frames
                color: p.color, // Use projectile color (tower type)
                radius: p.isCrit ? 4 : 2,
            });
        }

        // === CRIT FLASH + BIG TEXT ===
        if (p.isCrit) {
            // Screen flash (white)
            this.effects.spawn({
                type: 'screen_flash',
                x: 0,
                y: 0,
                life: 0.15,
                priority: EffectPriority.HIGH, // Critical feedback
                flashColor: 'rgba(255, 255, 255, ',
            });

            // Big "CRIT!" text
            this.effects.spawn({
                type: 'text',
                text: 'CRIT!',
                x: target.x,
                y: target.y - 30,
                life: 0.6,
                color: '#ff0',
                fontSize: 28,
                priority: EffectPriority.HIGH, // Critical feedback
                vy: -120,
            });

            // Enlarged damage number for Crit
            this.spawnDamageText(target, Math.floor(p.damage), true);
        } else {
            // Normal damage text (Accumulated)
            this.spawnDamageText(target, Math.floor(p.damage), false);
        }
        // === END CRIT EFFECTS ===
        // -----------------------------------

        // Handle enemy death effects
        const enemyDied = !target.isAlive();
        if (enemyDied) {
            this.handleEnemyDeath(target, p, wasSlowed, activeGrid);
        }

        // Splash damage effect
        let splash = null;
        for (let i = 0; i < p.effects.length; i++) {
            if (p.effects[i].type === 'splash') {
                splash = p.effects[i];
                break;
            }
        }
        if (splash) {
            // 1. VISUAL
            this.effects.spawn({
                type: 'explosion',
                x: target.x,
                y: target.y,
                radius: splash.splashRadius || splash.radius,
                life: 0.25,
                priority: EffectPriority.HIGH, // Gameplay effect
                color: 'rgba(255, 100, 0, 0.5)',
            });

            // 2. PHYSICS (Decoupled: Instant Area Damage via Grid)
            // PERF: Use local array for splash to prevent recursive static buffer overwrite if enemies die and explode
            const radius = splash.splashRadius || splash.radius || 40;
            const splashTargets: Enemy[] = [];
            const count = activeGrid.queryInRadius(target.x, target.y, radius, splashTargets);
            const radiusSq = radius * radius;

            for (let i = 0; i < count; i++) {
                const neighbor = splashTargets[i];
                if (neighbor === target || !neighbor.isAlive()) continue;

                const dx = neighbor.x - target.x;
                const dy = neighbor.y - target.y;
                if (dx * dx + dy * dy <= radiusSq) {
                    neighbor.takeDamage(p.damage * 0.7, p); // Pass projectile context
                }
            }
        }

        // Slow effect (with damage modifier)
        let slow = null;
        for (let i = 0; i < p.effects.length; i++) {
            if (p.effects[i].type === 'slow') {
                slow = p.effects[i];
                break;
            }
        }
        if (slow) {
            const damageBonus = slow.damageToSlowed || 1.0;
            target.applyStatus('slow', slow.slowDuration || slow.dur || 1.0, slow.slowPower || slow.power || 0.4, damageBonus);
        }

        // Burn effect (Napalm evolution)
        let burn = null;
        for (let i = 0; i < p.effects.length; i++) {
            if (p.effects[i].type === 'burn') {
                burn = p.effects[i];
                break;
            }
        }
        if (burn) {
            // Power = DPS for burn
            target.applyStatus('burn', burn.burnDuration || 3, burn.burnDps || 5);
        }
    }

    private handleEnemyDeath(enemy: Enemy, killingProjectile: Projectile, wasSlowed: boolean, activeGrid: SpatialGrid<Enemy>) {
        const deathX = enemy.x;
        const deathY = enemy.y;

        // Sound Death
        SoundManager.play('death', SoundPriority.LOW);

        // Fire Level 3: Explosion on death
        if (killingProjectile.explodeOnDeath) {
            // 1. VISUAL
            this.effects.spawn({
                type: 'explosion',
                x: deathX,
                y: deathY,
                radius: killingProjectile.explosionRadius,
                life: 0.35,
                priority: EffectPriority.HIGH, // Gameplay effect
                color: 'rgba(255, 69, 0, 0.8)',
            });

            // 2. PHYSICS (Decoupled: Instant Area Damage via Grid)
            // PERF: Use local array for death explosion to prevent recursive static buffer overwrite
            const radius = killingProjectile.explosionRadius || 60;
            const deathExplosionTargets: Enemy[] = [];
            const count = activeGrid.queryInRadius(deathX, deathY, radius, deathExplosionTargets);
            const radiusSq = radius * radius;

            for (let i = 0; i < count; i++) {
                const neighbor = deathExplosionTargets[i];
                if (!neighbor.isAlive()) continue;

                const dx = neighbor.x - deathX;
                const dy = neighbor.y - deathY;
                if (dx * dx + dy * dy <= radiusSq) {
                    neighbor.takeDamage(killingProjectile.explosionDamage, killingProjectile);
                }
            }
        }

        // Ice Level 3: Chain slow on death (if enemy was slowed when it died)
        if (wasSlowed) {
            const chainSlowEffect = killingProjectile.effects.find((ef: any) => ef.type === 'chainSlowOnDeath');
            if (chainSlowEffect) {
                const chainRadius = chainSlowEffect.chainRadius || 60;

                // Visual effect for chain slow
                this.effects.spawn({
                    type: 'explosion',
                    x: deathX,
                    y: deathY,
                    radius: chainRadius,
                    life: 0.3, // Shortened life
                    color: 'rgba(0, 188, 212, 0.5)',
                });

                // Apply slow to nearby enemies - PERF: Using local array
                const chainSlowTargets: Enemy[] = [];
                const count = activeGrid.queryInRadius(deathX, deathY, chainRadius, chainSlowTargets);
                const radiusSq = chainRadius * chainRadius;

                // Find original slow effect properties
                const slowEffect = killingProjectile.effects.find((ef: any) => ef.type === 'slow');

                if (slowEffect) {
                    const damageBonus = slowEffect.damageToSlowed || 1.0;
                    const duration = slowEffect.slowDuration || slowEffect.dur || 1.0;
                    const power = slowEffect.slowPower || slowEffect.power || 0.4;

                    for (let i = 0; i < count; i++) {
                        const neighbor = chainSlowTargets[i];
                        if (!neighbor.isAlive()) continue;

                        const dx = neighbor.x - deathX;
                        const dy = neighbor.y - deathY;
                        if (dx * dx + dy * dy <= radiusSq) {
                            neighbor.applyStatus('slow', duration, power, damageBonus);
                        }
                    }
                }
            }
        }
    }


    private spawnDamageText(target: Enemy, amount: number, isCrit: boolean) {
        const now = performance.now();
        // Check if target has an active damage text
        if (!isCrit && target.lastDamageText && (now - target.lastDamageTextTime < 100)) {
            // Accumulate
            target.currentDamageAccumulation += amount;
            target.lastDamageTextTime = now;

            if (target.lastDamageText.life > 0) {
                target.lastDamageText.text = Math.floor(target.currentDamageAccumulation).toString();
                target.lastDamageText.life = 0.6; // Refresh life
                target.lastDamageText.y = target.y - 10; // Reset position slightly
                target.lastDamageText.scale = 1.2; // Pop effect
                return;
            }
        }

        // New text
        const textObj = this.effects.spawn({
            type: 'text',
            text: amount.toString(),
            x: target.x + (Math.random() * 20 - 10),
            y: target.y - 10,
            life: 0.6,
            color: isCrit ? '#ffd700' : '#fff',
            fontSize: isCrit ? 22 : 14,
            priority: isCrit ? EffectPriority.HIGH : EffectPriority.MEDIUM, // High for crit, Med for normal
            vy: -60,
        });

        if (!isCrit) {
            target.lastDamageText = textObj;
            target.lastDamageTextTime = now;
            target.currentDamageAccumulation = amount;
        }
    }
}
</file>

<file path="src/Game.ts">
import { Assets } from './Assets';
import { UIRoot } from './UIRoot';
import { IMapData } from './MapData';
import { Scene } from './Scene';
import { MenuScene } from './scenes/MenuScene';
import { InputSystem } from './InputSystem';
import { SoundManager } from './SoundManager';
import { CardSelectionUI } from './CardSelectionUI';
import { loadSessionData, saveSessionData } from './Utils';
import { Enemy } from './Enemy';
import { PerformanceMonitor } from './utils/PerformanceMonitor';

export class Game {
    public canvas: HTMLCanvasElement;
    public ctx: CanvasRenderingContext2D;
    public uiRoot: UIRoot;

    public input: InputSystem;
    public currentScene: Scene | null = null;
    private lastTime: number = 0;
    private cardSelection: CardSelectionUI;

    // Logical dimensions (CSS pixels)
    public get width(): number {
        return this.canvas.width / this.dpr;
    }

    public get height(): number {
        return this.canvas.height / this.dpr;
    }

    private dpr: number = 1;

    constructor(canvasId: string) {
        const canvas = document.getElementById(canvasId) as HTMLCanvasElement;
        if (!canvas) throw new Error('Canvas not found!');
        this.canvas = canvas;
        this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;
        this.uiRoot = new UIRoot();

        // Initial resize
        this.resize();

        // Handle window resizing
        window.addEventListener('resize', () => this.resize());

        this.input = new InputSystem(this);
        this.loop = this.loop.bind(this);

        // Auto-save session state on unload
        window.addEventListener('beforeunload', () => {
            saveSessionData('lastEnemyId', Enemy.nextId);
        });
    }

    public resize() {
        // Cap DPR at 2.0 to balance quality and performance (saves battery/GPU)
        this.dpr = Math.min(window.devicePixelRatio || 1, 2);

        // Get physical display size
        const rect = this.canvas.getBoundingClientRect();

        // NOTE: We rely on CSS (width: 100vw; height: 100vh) to set the display size.
        // If rect is 0 (hidden), stick to window dimensions as fallback.
        const displayWidth = rect.width || window.innerWidth;
        const displayHeight = rect.height || window.innerHeight;

        // Set buffer size (physical pixels)
        this.canvas.width = displayWidth * this.dpr;
        this.canvas.height = displayHeight * this.dpr;

        // Scale context so we draw in "logical" pixels (CSS pixels)
        this.ctx.scale(this.dpr, this.dpr);

        // OPTIONAL: Reset smoothing if needed (pixel art style?)
        // this.ctx.imageSmoothingEnabled = false;

        console.log(`[Game] Resized to ${displayWidth}x${displayHeight} (DPR: ${this.dpr}, Buffer: ${this.canvas.width}x${this.canvas.height})`);
    }

    public async start() {
        this.drawLoadingScreen();

        // Restore global state
        const lastId = loadSessionData('lastEnemyId');
        if (typeof lastId === 'number') {
            Enemy.nextId = lastId;
            console.log(`Restored Enemy.nextId: ${lastId}`);
        }

        try {
            await SoundManager.init();

            // Global Audio Resume logic (Deduplicated from UIManager)
            const resumeAudio = () => {
                SoundManager.resume();
            };
            window.addEventListener('click', resumeAudio, { once: true });
            window.addEventListener('keydown', resumeAudio, { once: true });

            await Assets.loadAll();

            // FIXED: Initialize card selection UI AFTER Assets loaded (DOM is ready)
            this.cardSelection = new CardSelectionUI((selectedCards) => {
                // Callback: when selection is complete, load the game with selected cards
                this.startGameWithCards(selectedCards);
            });

            console.log('Game started!');
            this.toMenu();
            this.loop(0);
        } catch (e) {
            console.error('FATAL ERROR: Failed to load assets', e);
            this.ctx.fillStyle = 'red';
            this.ctx.fillText('FAILED TO LOAD ASSETS', 50, 50);
        }
    }

    private drawLoadingScreen() {
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.fillStyle = '#fff';
        this.ctx.font = '30px Segoe UI';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('LOADING ASSETS...', this.canvas.width / 2, this.canvas.height / 2);
    }

    public changeScene(newScene: Scene) {
        if (this.currentScene) {
            this.currentScene.onExit();
        }

        // Destroy old input listeners to prevent duplication/leaks
        if (this.input) {
            this.input.destroy();
        }
        // Re-initialize input system for the new scene
        this.input = new InputSystem(this);

        this.currentScene = newScene;
        this.currentScene.onEnter();
    }

    private menuScene: MenuScene;

    // ...

    public toMenu() {
        if (!this.menuScene) {
            this.menuScene = new MenuScene(this);
        }
        this.changeScene(this.menuScene);
    }

    private pendingMapData?: IMapData;

    public toGame(mapData?: IMapData) {
        // Store map data and show card selection
        this.pendingMapData = mapData;
        this.cardSelection.show();
    }

    // ...

    private startGameWithCards(selectedCards: string[]) {
        import('./scenes/GameScene')
            .then(({ GameScene }) => {
                // Pass selected cards directly to constructor
                // Verify GameScene constructor signature update in next step
                this.changeScene(new GameScene(this, this.pendingMapData, selectedCards));
            })
            .catch((err) => {
                console.error('Failed to load GameScene:', err);
                this.drawError('Failed to load GameScene. Check console.');
                setTimeout(() => this.toMenu(), 3000);
            });
    }

    public toEditor() {
        import('./scenes/EditorScene')
            .then(({ EditorScene }) => {
                this.changeScene(new EditorScene(this));
            })
            .catch((err) => {
                console.error('Failed to load EditorScene:', err);
                this.drawError('Failed to load EditorScene. Check console.');
                setTimeout(() => this.toMenu(), 3000);
            });
    }

    private loop(timestamp: number) {
        PerformanceMonitor.beginFrame();

        // 1. –í—ã—á–∏—Å–ª—è–µ–º –¥–µ–ª—å—Ç—É (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        // –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–∫–∞—á–∫–æ–≤: –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º dt –¥–æ 0.1 (10 FPS –º–∏–Ω–∏–º—É–º)
        // –ï—Å–ª–∏ dt –±–æ–ª—å—à–µ, –ø—Ä–æ—Å—Ç–æ –∑–∞–º–µ–¥–ª—è–µ–º –∏–≥—Ä—É, –Ω–æ –Ω–µ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–∞–¥—Ä
        if (dt > 0.1) {
            // dt = 0.1; // Optional: Force clamp?
            // For now, let's just SKIP the return so logic runs even if slow
            // But if we want to avoid huge jumps, we clamp:
        }
        const safeDt = Math.min(dt, 0.1);

        // 2. –ü–µ—Ä–µ–¥–∞–µ–º safeDt –¥–∞–ª—å—à–µ
        this.input.update(safeDt);
        if (this.currentScene) {
            this.currentScene.update(safeDt);
            this.currentScene.draw(this.ctx);
        }

        requestAnimationFrame(this.loop);
    }
    private drawError(msg: string) {
        this.ctx.fillStyle = 'rgba(0,0,0,0.8)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = 'red';
        this.ctx.font = '30px Segoe UI';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(msg, this.canvas.width / 2, this.canvas.height / 2);
    }
}
</file>

<file path="src/Enemy.ts">
import { CONFIG, getEnemyType } from './Config';
import { EventBus, Events } from './EventBus';
import { RendererFactory } from './RendererFactory';
import { Assets } from './Assets';
import { Projectile } from './Projectile';
import { EnemyRenderer } from './renderers/EnemyRenderer';

export interface IEnemyConfig {
    // id removed - generated internally
    health: number;
    speed: number;
    armor?: number;
    x?: number;
    y?: number;
    path: { x: number; y: number }[];
}

interface IStatus {
    type: 'slow' | 'burn';
    duration: number;
    power: number;
}

export class Enemy {
    // Global ID counter for session
    public static nextId: number = 0;

    public id: number = 0;
    public typeId: string = 'grunt';

    public currentHealth: number;
    public maxHealth: number;
    public baseSpeed: number;
    public armor: number;
    public reward: number = 5; // Reward for killing this enemy

    public x: number;
    public y: number;

    public path: { x: number; y: number }[];
    public pathIndex: number = 0;
    public finished: boolean = false;

    public statuses: IStatus[] = [];
    public damageModifier: number = 1.0;     // Damage multiplier (e.g., 1.2 = +20% damage)
    public killedByProjectile: Projectile | null = null;   // Track what projectile killed this enemy
    public hitFlashTimer: number = 0;        // Timer for white flash on hit

    public lastFacingLeft: boolean = false; // Persistent facing state
    private static readonly FACING_VX_EPSILON = 0.1;

    // Targeting Support
    public threatPriority: number = 0;       // 0 = Normal, >0 = High Priority (Taunt)

    // === BOSS MECHANICS (Spectral Shift) ===
    public isInvulnerable: boolean = false;
    private shieldTimer: number = 0;

    // Magma King Mechanics
    public spawnThresholds: number[] = []; // HP percentages to trigger spawn (0.75, 0.5, 0.25)

    // Thresholds: [HP Percent, Duration in Seconds]
    private thresholds: { p: number, d: number, used: boolean }[] = [];

    // === PERFORMANCE CACHES (Phase 3a) ===
    public typeConfig: any = null;      // Cached getEnemyType() result
    public moveAngle: number = 0;       // Cached Math.atan2() from move()
    private _moveVector = { x: 0, y: 0 }; // Zero-allocation vector for movement

    // Damage Text Accumulation (Phase 6)
    public lastDamageText: any = null; // Ref to active text effect
    public lastDamageTextTime: number = 0;
    public currentDamageAccumulation: number = 0;

    constructor(config?: IEnemyConfig) {
        // Constructor only allocates memory
        if (config) {
            this.init(config);
        }
    }

    public init(config: IEnemyConfig) {
        // 1. Generate NEW identity
        this.id = ++Enemy.nextId;

        this.maxHealth = config.health;
        this.currentHealth = config.health;
        this.baseSpeed = config.speed;
        this.armor = config.armor || 0;

        this.x = config.x || 0;
        this.y = config.y || 0;
        this.path = config.path;
        this.pathIndex = 0;
        this.finished = false;

        this.damageModifier = 1.0;
        this.killedByProjectile = null;
        this.lastFacingLeft = false; // Reset facing

        // Reset specific fields
        this.threatPriority = 0;
        // Arrays are cleared in reset(), but here we ensure they are empty or set specific initial values if needed
        // For pooling safety, reset() should have been called before init() or init should overwrite everything.
        // But since init overwrites primitives, we just need to adhere to standard lifecycle.
    }

    public reset() {
        // 3. Clear arrays without GC (keep capacity)
        this.statuses.length = 0;
        this.hitFlashTimer = 0;
        this.pathIndex = 0;
        this.finished = false;
        this.damageModifier = 1.0;
        this.killedByProjectile = null;
        this.x = -1000; // Move offscreen
        this.y = -1000;
        this.lastFacingLeft = false;

        this.threatPriority = 0;
        this.spawnThresholds.length = 0;
        this.thresholds.length = 0;

        // Reset Boss mechanics
        this.isInvulnerable = false;
        this.shieldTimer = 0;

        // Reset Performance caches
        this.typeConfig = null;
        this.moveAngle = 0;
        this._moveVector.x = 0;
        this._moveVector.y = 0;

        // Reset Damage Text
        this.lastDamageText = null;
        this.lastDamageTextTime = 0;
        this.currentDamageAccumulation = 0;
    }

    public setType(id: string) {
        this.typeId = id;

        // PERF: Cache typeConfig to avoid getEnemyType() calls in render loop
        this.typeConfig = getEnemyType(id.toUpperCase()) || getEnemyType('GRUNT');

        // Initialize Boss Mechanics if this is a boss
        if (id.toLowerCase() === 'boss') {
            this.thresholds = [
                { p: 0.8, d: 3.0, used: false },
                { p: 0.5, d: 5.0, used: false },
                { p: 0.2, d: 8.0, used: false }
            ];
        } else if (id === 'magma_king') {
            this.spawnThresholds = [0.75, 0.5, 0.25];
        } else if (id === 'magma_statue') {
            this.threatPriority = 999; // Maximum priority
        } else {
            // Already cleared in reset, but strictly set here if strictly needed
            // this.thresholds.length = 0; 
            // this.spawnThresholds.length = 0;
        }
    }

    public takeDamage(amount: number, projectile?: Projectile): void {
        if (this.isInvulnerable) {
            // Visual Effect "BLOCKED"
            EventBus.getInstance().emit(Events.ENEMY_IMMUNE, { x: this.x, y: this.y });
            return;
        }

        const prevHpPercent = this.currentHealth / this.maxHealth;

        // Apply damage modifier (from slow effects, etc.)
        const modifiedAmount = amount * this.damageModifier;
        const actualDamage = Math.max(1, modifiedAmount - this.armor);
        this.currentHealth -= actualDamage;
        if (this.currentHealth < 0) this.currentHealth = 0;

        const currentHpPercent = this.currentHealth / this.maxHealth;

        // Check Thresholds (Invulnerable Shield Boss)
        for (const t of this.thresholds) {
            if (!t.used && currentHpPercent <= t.p && prevHpPercent > t.p) {
                this.activateShield(t.d);
                t.used = true;
                break; // Activate one threshold at a time
            }
        }

        // Check Spawn Thresholds (Magma King)
        for (let i = this.spawnThresholds.length - 1; i >= 0; i--) {
            const threshold = this.spawnThresholds[i];
            if (currentHpPercent <= threshold && prevHpPercent > threshold) {
                // Trigger Split Event
                EventBus.getInstance().emit('ENEMY_SPLIT', { enemy: this, threshold });
                this.spawnThresholds.splice(i, 1); // Remove used threshold
            }
        }

        // Visual Feedback: Hit Flash
        this.hitFlashTimer = 0.08; // ~5 frames at 60fps

        // Track what killed this enemy
        if (!this.isAlive()) {
            if (projectile) {
                this.killedByProjectile = projectile;
            }

            // Check for Death Spawns (Flesh Colossus mechanic)
            const typeConfig = getEnemyType(this.typeId);
            if (typeConfig?.deathSpawns && typeConfig.deathSpawns.length > 0) {
                EventBus.getInstance().emit('ENEMY_DEATH_SPAWN', {
                    enemy: this,
                    spawns: typeConfig.deathSpawns
                });
            }

            EventBus.getInstance().emit(Events.ENEMY_DIED, { enemy: this });
        }
    }

    private activateShield(duration: number) {
        this.isInvulnerable = true;
        this.shieldTimer = duration;
        // Float text handled by event listener or renderer (if we want persistency)
        // But for "IMMUNE!" popup, we can emit event
        EventBus.getInstance().emit(Events.ENEMY_IMMUNE, { x: this.x, y: this.y - 40 });
    }

    // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –º–µ—Ç–æ–¥ —Å—Ç–∞–ª public
    public move(dt: number, flowField: any): void { // Using 'any' briefly to avoid circular deps if types not ready, but better import FlowField interface
        let speedMod = 1;
        // Apply slow statuses
        for (const status of this.statuses) { // Assuming statuses is an array of IStatus
            if (status.type === 'slow') { // Assuming IStatus has a 'type' and 'power' property
                speedMod *= (1 - status.power); // Assuming 'power' is the slow percentage (e.g., 0.5 for 50% slow)
            }
        }

        // BERSERKER ENRAGE MECHANIC
        // Double movement speed when health drops below 50%
        if (this.typeId === 'skeleton_berserker' && (this.currentHealth / this.maxHealth) < 0.5) {
            speedMod *= 2.0;
        }

        const currentSpeed = Math.max(0, this.baseSpeed * speedMod * dt);

        // Flow Field Movement
        // Get vector from the field (Zero Allocation)
        flowField.getVector(this.x, this.y, this._moveVector);
        const vector = this._moveVector;

        if (vector.x === 0 && vector.y === 0) {
            // Reached target or stuck
            // Check distance to center of target tile
            const targetTile = flowField.target;
            if (targetTile) {
                const tx = targetTile.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
                const ty = targetTile.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
                const dx = tx - this.x;
                const dy = ty - this.y;
                const dist = Math.hypot(dx, dy);

                // If close enough, finish
                if (dist < 5) {
                    this.finished = true;
                    return;
                }

                // Otherwise, manually steer towards center to complete the path
                if (dist > 0.001) {
                    vector.x = dx / dist;
                    vector.y = dy / dist;
                }
            } else {
                return;
            }
        }

        this.x += vector.x * currentSpeed;
        this.y += vector.y * currentSpeed;

        // Calculate angle for visual rotation
        // Only update if moving significant amount to avoid jitter
        if (Math.abs(vector.x) > 0.01 || Math.abs(vector.y) > 0.01) {
            this.moveAngle = Math.atan2(vector.y, vector.x);

            // Update Facing State (Stabilized)
            // Use a threshold to prevent flipping when moving vertically (jitter)
            if (Math.abs(vector.x) > Enemy.FACING_VX_EPSILON) {
                this.lastFacingLeft = vector.x < 0;
            }
        }
    }

    public isAlive(): boolean {
        return this.currentHealth > 0;
    }

    public getHealthPercent(): number {
        return this.currentHealth / this.maxHealth;
    }

    public applyStatus(type: 'slow' | 'burn', duration: number, power: number, damageBonus?: number) {
        let existing = null;
        for (let i = 0; i < this.statuses.length; i++) {
            if (this.statuses[i].type === type) {
                existing = this.statuses[i];
                break;
            }
        }

        if (existing) {
            // Refresh duration
            existing.duration = Math.max(existing.duration, duration);

            if (type === 'slow') {
                // For slow, keep the strongest effect (highest power/slow amount)
                existing.power = Math.max(existing.power, power);
                // Apply highest damage modifier
                if (damageBonus) {
                    this.damageModifier = Math.max(this.damageModifier, damageBonus);
                }
            } else if (type === 'burn') {
                // For burn, keep the strongest DoT
                existing.power = Math.max(existing.power, power);
            }
        } else {
            this.statuses.push({ type, duration, power });
            if (type === 'slow' && damageBonus) {
                this.damageModifier = Math.max(this.damageModifier, damageBonus);
            }
        }
    }

    public update(dt: number): void {
        // Update status durations - in-place removal (no new array)
        for (let i = this.statuses.length - 1; i >= 0; i--) {
            this.statuses[i].duration -= dt;
            if (this.statuses[i].duration <= 0) {
                // Swap with last and pop
                this.statuses[i] = this.statuses[this.statuses.length - 1];
                this.statuses.pop();
            }
        }

        // Reset damage modifier if no slow status
        let hasSlow = false;
        for (let i = 0; i < this.statuses.length; i++) {
            if (this.statuses[i].type === 'slow') {
                hasSlow = true;
                break;
            }
        }
        if (!hasSlow) {
            this.damageModifier = 1.0;
        }

        // Burn damage tick
        for (let i = 0; i < this.statuses.length; i++) {
            if (this.statuses[i].type === 'burn') {
                // power = burnDps (damage per second)
                // Direct health subtraction (bypasses armor ‚Äî burn is TRUE damage)
                this.currentHealth -= this.statuses[i].power * dt;

                // Check death from DOT
                if (this.currentHealth <= 0) {
                    this.currentHealth = 0;

                    // Emit death events ‚Äî same as takeDamage() death path
                    // Without this, deathSpawns (Flesh Colossus), sapper_rat explosion,
                    // and ENEMY_DIED listeners won't fire for burn kills
                    const typeConfig = getEnemyType(this.typeId);
                    if (typeConfig && typeConfig.deathSpawns && typeConfig.deathSpawns.length > 0) {
                        EventBus.getInstance().emit('ENEMY_DEATH_SPAWN', {
                            enemy: this,
                            spawns: typeConfig.deathSpawns
                        });
                    }
                    EventBus.getInstance().emit(Events.ENEMY_DIED, { enemy: this });

                    // Critical hit fix: purge burn status so we don't emit death twice if update is called again
                    this.statuses.splice(i, 1);
                }
                break; // One burn source (last applied overwrites)
            }
        }

        // Update flash timer
        if (this.hitFlashTimer > 0) this.hitFlashTimer -= dt;

        // Update Shield
        if (this.isInvulnerable) {
            this.shieldTimer -= dt;
            if (this.shieldTimer <= 0) {
                this.isInvulnerable = false;
            }
        }
    }

    public draw(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawEnemy(ctx, this);
    }

    public drawSprite(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawEnemySprite(ctx, this);
    }

    public drawUI(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawEnemyUI(ctx, this);
    }
}
</file>

<file path="src/Tower.ts">
import { CONFIG } from './Config';
import { RendererFactory } from './RendererFactory';
import { ICard } from './CardSystem';
import { Enemy } from './Enemy';
import { Projectile, IProjectileStats } from './Projectile';
import { ObjectPool, lerpAngle } from './Utils';
import { EffectSystem } from './EffectSystem';
import { Assets } from './Assets';
import { VISUALS } from './VisualConfig';
import { getCardUpgrade, getMultishotConfig, ICardEffect } from './cards';
import { mergeCardsWithStacking } from './CardStackingSystem';
import { TowerRenderer } from './renderers/TowerRenderer';
import { TargetingSystem } from './systems/TargetingSystem';
import { SpatialGrid } from './SpatialGrid';
import { FlowField } from './FlowField';

export interface SlotState {
    id: number;
    isLocked: boolean;
    card: ICard | null;
}

export class Tower {
    public col: number;
    public row: number;
    public x: number;
    public y: number;

    // Slot System (Replaces simple cards array)
    public slots: SlotState[] = [];
    public selectedSlotId: number = -1; // -1: None, 0-2: Slot ID selected in UI

    // Backward compatibility getter: Returns all equipped cards
    public get cards(): ICard[] {
        return this.slots
            .filter(s => !s.isLocked && s.card !== null)
            .map(s => s.card!);
    }

    // Legacy setter (optional, but safer to prevent direct assignment bugs)
    public set cards(v: ICard[]) {
        // Clear slots
        this.slots.forEach(s => s.card = null);
        // Try fill
        v.forEach(c => this.addCard(c));
    }
    public cooldown: number = 0;
    public angle: number = 0;
    public turnSpeed: number = 10.0; // Default turn speed (radians/sec)
    public firingArc: number = 0.5; // Firing arc in radians (0.5 ~= 28 degrees)
    public targetingMode: string = 'first'; // Targeting priority: first, closest, strongest, weakest, last

    // Targeting State (Optimized)
    public target: Enemy | null = null;
    public searchTimer: number = Math.random() * 0.2; // Random offset to spread CPU load
    public rangeSquared: number = 0;

    public isBuilding: boolean = false;
    public buildProgress: number = 0;
    public maxBuildProgress: number = CONFIG.TOWER.BUILD_TIME;

    public costSpent: number = 0;

    // Cache State
    private statsDirty: boolean = true;
    private cachedStats: (IProjectileStats & { range: number; cd: number; projCount: number; spread: number; projectileType: string; attackSpeedMultiplier: number }) | null = null;
    // public rangeSquared: number = 0; // Removed duplicate declaration

    // Spinup state (for Minigun cards)
    public spinupTime: number = 0;        // Seconds spent firing continuously
    public maxHeat: number = 5;             // Max seconds before overheat (default 5s)
    public isOverheated: boolean = false;   // Whether tower is overheated
    public overheatCooldown: number = 0;    // Seconds remaining in overheat lockout
    public totalOverheatDuration: number = 0; // Total duration of the current overheat lockout (for UI)

    // Visual state (Phase 3)
    public recoilTimer: number = 0;        // Recoil animation timer (seconds)
    public recoilIntensity: number = 0;     // Recoil strength
    public barrelRotation: number = 0;      // Rotation angle of the barrel (Minigun)
    public barrelRecoil: number = 0;        // Recoil offset of the barrel (px)
    public heatLevel: number = 0;          // Heat level 0-1 (Minigun visual)
    public chargeProgress: number = 0;      // Charge progress 0-1 (Sniper visual)

    // Generic container for visual state (Phase 2)
    public visualState: Record<string, any> = {};

    constructor(c: number, r: number) {
        this.col = c;
        this.row = r;
        this.x = c * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        this.y = r * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        this.costSpent = CONFIG.ECONOMY.TOWER_COST;

        // Initialize Slots
        // Slot 0: Open
        // Slot 1: Locked
        // Slot 2: Locked
        this.slots = [
            { id: 0, isLocked: false, card: null },
            { id: 1, isLocked: true, card: null },
            { id: 2, isLocked: true, card: null }
        ];
    }

    public static getPreviewStats(cards: ICard[]): any {
        const dummy = new Tower(0, 0);
        dummy.cards = cards;
        return dummy.getStats();
    }

    // Force cache update
    public invalidateCache() {
        this.statsDirty = true;
        this.rangeSquared = 0; // Force range recalc
    }

    getStats(): IProjectileStats & { range: number; cd: number; projCount: number; spread: number; projectileType: string; attackSpeedMultiplier: number } {
        // === PERF: Two-tier caching ===
        // Tier 1 (Dirty Flag): Full recalculation only when cards change
        // Tier 2 (Spinup Overlay): Lightweight recalc of spinup-dependent values every frame

        if (this.statsDirty || !this.cachedStats) {
            // === FULL RECALCULATION (only on card add/remove) ===
            let range = CONFIG.TOWER.BASE_RANGE;
            let damage = CONFIG.TOWER.BASE_DMG;
            let attackSpeed = CONFIG.TOWER.BASE_CD;
            let speed = 480; // 8 * 60
            let color = VISUALS.PROJECTILES.STANDARD;
            let critChance = 0;
            let pierce = 0;
            let projectileType = 'standard';

            // PERF: mergeCardsWithStacking is expensive ‚Äî only run when dirty
            const { modifiers: mergedMods, effects: allEffects } = mergeCardsWithStacking(this.cards);

            const baseDamage = CONFIG.TOWER.BASE_DMG;
            const flatDamageBonuses = mergedMods.damage || 0;

            if (mergedMods.damageMultiplier !== undefined) {
                damage = (baseDamage + flatDamageBonuses) * mergedMods.damageMultiplier;
            } else {
                damage = baseDamage + flatDamageBonuses;
            }

            range += mergedMods.range || 0;
            range *= mergedMods.rangeMultiplier || 1.0;
            critChance = mergedMods.critChance || 0;

            let projCount = 1;
            let damageMultiplier = 1.0;
            let spread = 0;

            // PERF: Manual scan instead of .filter() (Rule 4: no .filter() in hot path)
            let bestMultiLevel = -1;
            let bestMultiCard: ICard | null = null;
            for (let i = 0; i < this.cards.length; i++) {
                if (this.cards[i].type.id === 'multi' && this.cards[i].level > bestMultiLevel) {
                    bestMultiLevel = this.cards[i].level;
                    bestMultiCard = this.cards[i];
                }
            }

            const mainCard = this.cards[0];
            if (mainCard) {
                const upgrade = getCardUpgrade(mainCard.type.id, mainCard.level, mainCard.evolutionPath);
                if (upgrade?.visualOverrides) {
                    projectileType = upgrade.visualOverrides.projectileType || 'standard';
                    color = upgrade.visualOverrides.projectileColor || VISUALS.PROJECTILES.STANDARD;
                    speed = upgrade.visualOverrides.projectileSpeed || 480;
                } else if (mainCard.type.id === 'multi') {
                    projectileType = 'split';
                    color = VISUALS.PROJECTILES.SPLIT;
                }
            }

            if (bestMultiCard) {
                const multiConfig = getMultishotConfig(bestMultiCard.level, bestMultiCard.evolutionPath);
                projCount = multiConfig.projectileCount;
                damageMultiplier = multiConfig.damageMultiplier;
                spread = multiConfig.spread;
            }

            damage *= damageMultiplier;

            // PERF: Manual scan instead of .find() (no closure allocation)
            let pierceEffect = null;
            let spinupEffect = null;
            for (let i = 0; i < allEffects.length; i++) {
                if (allEffects[i].type === 'pierce') pierceEffect = allEffects[i];
                else if (allEffects[i].type === 'spinup') spinupEffect = allEffects[i];
            }
            if (pierceEffect) {
                pierce = pierceEffect.pierceCount || 0;
            }

            const baseSpeedMult = mergedMods.attackSpeedMultiplier || 1.0;

            this.cachedStats = {
                range: Math.round(range),
                dmg: damage,
                cd: attackSpeed,
                speed,
                color,
                effects: allEffects,
                pierce,
                projCount,
                spread,
                critChance,
                projectileType,
                attackSpeedMultiplier: baseSpeedMult,
                // Cache spinup inputs for Tier 2 overlay
                _baseDamage: damage,
                _baseCrit: critChance,
                _baseCd: attackSpeed,
                _baseSpeedMult: baseSpeedMult,
                _spinupEffect: spinupEffect,
            } as any;
            this.statsDirty = false;
        }

        // === TIER 2: Lightweight spinup overlay (runs every frame for Minigun) ===
        const cached = this.cachedStats!;
        const se = (cached as any)._spinupEffect;

        if (se && this.spinupTime > 0) {
            const spinupSeconds = this.spinupTime;
            let bonusDamage = 0;
            let bonusCrit = 0;
            let spinupSpeedBonus = 0;

            // Damage bonus
            if (se.spinupSteps) {
                for (const step of se.spinupSteps) {
                    if (spinupSeconds >= step.threshold) {
                        bonusDamage = step.damage;
                    } else break;
                }
            } else if (se.spinupDamagePerSecond) {
                bonusDamage = se.spinupDamagePerSecond * spinupSeconds;
            }

            // Crit bonus
            if (se.spinupCritPerSecond) {
                bonusCrit = se.spinupCritPerSecond * spinupSeconds;
            }

            // Speed bonus
            if (se.spinupSpeedBonus) {
                const maxSpinup = se.maxSpinupSeconds || 5;
                const ratio = Math.min(1, spinupSeconds / maxSpinup);
                spinupSpeedBonus = se.spinupSpeedBonus * ratio;
            }

            // Apply overlays (mutate cached ‚Äî it's our own object)
            cached.dmg = (cached as any)._baseDamage + bonusDamage;
            cached.critChance = (cached as any)._baseCrit + bonusCrit;
            cached.cd = (cached as any)._baseCd / ((cached as any)._baseSpeedMult + spinupSpeedBonus);
        } else if (se) {
            // No spinup active ‚Äî restore base values
            cached.dmg = (cached as any)._baseDamage;
            cached.critChance = (cached as any)._baseCrit;
            cached.cd = (cached as any)._baseCd / (cached as any)._baseSpeedMult;
        }

        return cached;
    }

    addCard(c: ICard): boolean {
        // Find first empty, unlocked slot
        const emptySlot = this.slots.find(s => !s.isLocked && s.card === null);
        if (emptySlot) {
            emptySlot.card = c;
            this.invalidateCache();
            this.updateTowerStats(); // Recalculate turn speed etc
            return true;
        }
        return false;
    }

    private updateTowerStats() {
        // Determine Turn Speed based on Main Card (Slot 0)
        // Default: 10.0
        this.turnSpeed = 10.0;
        this.firingArc = 0.5;

        const mainCard = this.slots[0]?.card;
        if (mainCard) {
            switch (mainCard.type.id) {
                case 'sniper':
                    this.turnSpeed = 5.0; // Slow, heavy
                    this.firingArc = 0.15; // Requires precise aim
                    break;
                case 'minigun':
                    this.turnSpeed = 15.0; // Fast, light
                    this.firingArc = 0.6; // Spray and pray
                    break;
                case 'ice':
                    this.turnSpeed = 8.0;
                    this.firingArc = 0.4;
                    break;
                case 'fire':
                    this.turnSpeed = 6.0;
                    this.firingArc = 0.4;
                    break;
                default:
                    this.turnSpeed = 10.0;
                    this.firingArc = 0.5;
                    break;
            }
        }
    }

    removeCard(index: number): ICard | null {
        // In legacy system, index was simple array index.
        // In slot system, it corresponds to the equipped cards list?
        // OR does it correspond to slot ID?
        // For UI drag-out, we usually know the specific card or slot.

        // Strategy: "index" here is treated as an index into the `this.cards` array (legacy behavior)
        // to keep existing UI compatible if it loops through cards.
        // HOWEVER, for the new Menu, we will call `removeCardFromSlot` directly.

        // Legacy fallback: find the Nth active card
        const activeSlots = this.slots.filter(s => !s.isLocked && s.card !== null);
        if (index >= 0 && index < activeSlots.length) {
            const card = activeSlots[index].card;
            activeSlots[index].card = null;
            this.invalidateCache();
            this.updateTowerStats();
            return card;
        }
        return null;
    }

    public removeCardFromSlot(slotId: number): ICard | null {
        const slot = this.slots.find(s => s.id === slotId);
        if (slot && slot.card) {
            const c = slot.card;
            slot.card = null;
            this.invalidateCache();
            this.updateTowerStats();
            return c;
        }
        return null;
    }

    public unlockSlot(slotId: number): boolean {
        const slot = this.slots.find(s => s.id === slotId);
        if (slot && slot.isLocked) {
            slot.isLocked = false;
            this.invalidateCache();
            return true;
        }
        return false;
    }

    updateBuilding(effects: EffectSystem, dt: number) {
        if (this.isBuilding) {
            this.buildProgress += dt;

            // Spawn dust particles during construction (every ~0.15s)
            // Using a hacky random check for now to avoid storing another timer
            if (Math.random() < dt * 6) { // Approx 6 times per second
                effects.add({
                    type: 'particle',
                    x: this.x + (Math.random() - 0.5) * 30,
                    y: this.y + 15,
                    vx: (Math.random() - 0.5) * 120, // ~2 px/frame -> 120 px/sec
                    vy: -Math.random() * 120,
                    life: 0.3 + Math.random() * 0.15, // ~20 frames -> 0.3s
                    color: '#a69060',
                    radius: 2 + Math.random() * 2
                });
            }

            if (this.buildProgress >= this.maxBuildProgress) {
                this.isBuilding = false;

                // Completion burst - dust cloud
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    effects.add({
                        type: 'particle',
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * 180, // 3 px/frame -> 180 px/sec
                        vy: Math.sin(angle) * 180 - 60, // gravity effect approximately
                        life: 0.4 + Math.random() * 0.15,
                        color: '#c0a060',
                        radius: 3 + Math.random() * 2
                    });
                }

                // Flash effect
                effects.add({ type: 'explosion', x: this.x, y: this.y, radius: 25, life: 0.25, color: '#ffd700' });
            }
        }
    }

    /**
     * Optimized Tower Update
     * Handles Lazy Targeting and State Updates
     */
    public update(dt: number, grid: SpatialGrid<Enemy>, flowField: FlowField) {
        // 1. Update Cooldowns
        if (this.cooldown > 0) this.cooldown -= dt;

        // --- TARGETING (Low Frequency) ---
        // Only verify target once in a while to save CPU
        this.searchTimer -= dt;

        // Check conditions to re-target:
        // 1. Timer expired
        // 2. Current target is dead/invalid (immediate re-target attempt allowed)
        // 3. We are idle and have no target (immediate search)

        let needsSearch = this.searchTimer <= 0;

        // Instant check if target became invalid
        if (this.target && !this.target.isAlive()) {
            this.target = null;
            needsSearch = true; // Search immediately
        }

        if (needsSearch) {
            // Validate existing target range if we have one
            if (this.target) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const distSq = dx * dx + dy * dy;

                // Recalc range only if needed
                if (this.rangeSquared === 0) {
                    const range = this.getRange();
                    this.rangeSquared = range * range;
                }

                if (distSq > this.rangeSquared) {
                    this.target = null; // Out of range, drop it
                }
            }

            // If we need a new target (either dropped, or just periodic check for better one)
            // We only check for BETTER target if we are ready to fire (cooldown <= 0) 
            // OR if we have no target.
            // Switching targets while aiming (cooldown > 0) is bad for "charged" towers, 
            // but generally we want to stick to target until it dies or leaves range.

            // The user logic suggests we should search periodically.
            // TargetingSystem now handles "Hysteresis" internally (stickiness).
            // So we can safely call findTarget() and it will prefer current target.

            const newTarget = TargetingSystem.findTarget(this, grid, flowField);

            // Only update if changed (TargetingSystem handles the bias)
            if (newTarget !== this.target) {
                this.target = newTarget;
            }

            // Reset Timer: 5-6 times per second (approx 0.15s - 0.25s)
            this.searchTimer = 0.15 + Math.random() * 0.1;
        }

        // --- TRACKING (High Frequency: Every Frame) ---
        // Always look at the target's CURRENT position
        if (this.target && this.target.isAlive()) {
            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const targetAngle = Math.atan2(dy, dx);

            // Smooth Interpolation
            // dt * turnSpeed (e.g. 0.016 * 10 = 0.16 interpolation factor)
            this.angle = lerpAngle(this.angle, targetAngle, dt * this.turnSpeed);
        }
    }

    public getRange(): number {
        // Fast path: use cached stats if available? 
        // For now, re-calculate stats is expense but acceptable if not every frame.
        // Optimization: In real implementation, cache 'stats' object when cards change.
        return this.getStats().range;
    }

    draw(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawTower(ctx, this);
    }

    drawSprite(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawTowerSprite(ctx, this);
    }

    drawUI(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawTowerUI(ctx, this);
    }
}
</file>

<file path="src/scenes/GameScene.ts">
import { Game } from '../Game';
import { BaseScene } from '../BaseScene';
import { IGameScene } from './IGameScene';
import { MapManager } from '../Map';
import { UIManager } from '../UIManager';
import { CONFIG } from '../Config';
import { CardSystem, ICard } from '../CardSystem';
import { EventEmitter } from '../Events';
import { EventBus, Events } from '../EventBus';
import { InputSystem } from '../InputSystem';
import { EffectSystem } from '../EffectSystem';
// import { DebugSystem } from '../DebugSystem';
import { DevConsole } from '../ui/DevConsole';
import { Logger, LogChannel } from '../utils/Logger';
import { Tower } from '../Tower';
import { SoundManager } from '../SoundManager';
import { WaveManager } from '../WaveManager';
import { ForgeSystem } from '../ForgeSystem';
import { CollisionSystem } from '../CollisionSystem';
import { InspectorSystem } from '../InspectorSystem';
import { BestiarySystem } from '../BestiarySystem';
import { IMapData, DEMO_MAP } from '../MapData';
import { MetricsSystem } from '../MetricsSystem';
import { WeaponSystem } from '../WeaponSystem';
import { FogSystem } from '../FogSystem';
import { LightingSystem } from '../systems/LightingSystem';
import { NotificationSystem } from '../systems/NotificationSystem';
import { DayNightCycle } from '../DayNightCycle';
import { AtmosphereSystem } from '../systems/AtmosphereSystem';
import { ProjectileSystem } from '../systems/ProjectileSystem';
import { Enemy } from '../Enemy';
import { PerformanceMonitor } from '../utils/PerformanceMonitor';

import { GameController } from './GameController';
import { GameState } from './GameState';
import { EntityManager } from './EntityManager';
import { RendererFactory } from '../RendererFactory';

import { EnemyRenderer } from '../renderers/EnemyRenderer';
import { AcidPuddleSystem } from '../systems/AcidPuddleSystem';
import { SkeletonCommanderSystem } from '../systems/SkeletonCommanderSystem';
import { SaveManager } from '../SaveManager';
import { GameSession } from '../GameSession';

/**
 * Main game scene - REFACTORED VERSION
 * Orchestrates game systems using modular components.
 * Implements IGameScene interface to decouple systems.
 */
export class GameScene extends BaseScene implements IGameScene {
    // Core references
    public game: Game;
    public mapData: IMapData;
    public readonly startingLives: number;
    private startingCards: string[];

    // The Game Session (Logic / Simulation)
    private session: GameSession;

    // Ambient cycle (Visual + Logic?)
    // DayNightCycle is used by Atmosphere (Visual) and maybe logic?
    // Session has it? No, I didn't put DayNight in Session in previous step!
    // I put Atmosphere in Session? No.
    // Let's check GameSession.ts content I wrote.
    // I did NOT put DayNightCycle or Atmosphere in GameSession constructor.
    // I put: gameState, entityManager, waveManager, projectileSystem, collision, metrics, weapon, card, forge, inspector, bestiary, notifications, acid, commander.
    // So DayNight, Atmosphere, Fog, Lighting REMAIN in GameScene (Visuals).

    // Map & rendering
    public map: MapManager;
    public fog: FogSystem;
    public lighting: LightingSystem;

    // Systems provided by Session (IGameScene interface)
    public get gameState() { return this.session.gameState; }
    public get entityManager() { return this.session.entityManager; }
    public get waveManager() { return this.session.waveManager; }
    public get projectileSystem() { return this.session.projectileSystem; }
    public get collision() { return this.session.collision; }
    public get metrics() { return this.session.metrics; }
    public get weaponSystem() { return this.session.weaponSystem; }
    public get cardSys() { return this.session.cardSys; }
    public get forge() { return this.session.forge; }
    public get inspector() { return this.session.inspector; }
    public get bestiary() { return this.session.bestiary; }
    public get notifications() { return this.session.notifications; }
    public get acidSystem() { return this.session.acidSystem; }
    public get commanderSystem() { return this.session.commanderSystem; }

    // UI (Scene specific)
    public ui: UIManager;
    public devConsole: DevConsole;

    // Visual Systems
    public effects: EffectSystem;
    private dayNightCycle!: DayNightCycle;
    private atmosphere!: AtmosphereSystem;

    // Input / Events
    public events: EventEmitter;
    public input: InputSystem;
    public gameController: GameController;

    // IGameScene compatibility properties
    public get wave(): number { return this.session.gameState.wave; }
    public set wave(value: number) { this.session.gameState.wave = value; }

    public get money(): number { return this.session.gameState.money; }

    public get lives(): number { return this.session.gameState.lives; }

    public get paused(): boolean { return this.session.gameState.paused; }

    public get selectedTower(): Tower | null { return this.session.gameState.selectedTower; }
    public set selectedTower(value: Tower | null) { this.session.gameState.selectTower(value); }

    public get enemies() { return this.session.gameState.enemies; }
    public get towers() { return this.session.gameState.towers; }
    public get projectiles() { return this.session.projectileSystem.projectiles; }

    public get enemyPool() { return this.session.gameState.enemyPool; }

    // Persist Safe Save State
    private lastSavedStats = { money: 0, kills: 0, waves: 0 };

    // Event Subscriptions
    private unsubs: (() => void)[] = [];


    // Ambient cycle
    private dayTime: number = 0;

    constructor(game: Game, mapData: IMapData, startingCards: string[]) {
        super();
        this.game = game;
        this.mapData = mapData || DEMO_MAP;
        this.startingCards = startingCards;

        // Initialize map and rendering FIRST
        this.map = new MapManager(this.mapData);
        this.fog = new FogSystem(this.mapData);
        this.lighting = new LightingSystem(game.width, game.height);
        this.map.lighting = this.lighting; // Link lighting
        this.dayNightCycle = new DayNightCycle();
        this.atmosphere = new AtmosphereSystem(this.dayNightCycle);
        const worldWidth = this.mapData.width * CONFIG.TILE_SIZE;
        const worldHeight = this.mapData.height * CONFIG.TILE_SIZE;
        this.atmosphere.setWorldSize(worldWidth, worldHeight);
        this.events = new EventEmitter();
        this.effects = new EffectSystem(game.ctx);
        this.input = game.input;

        // Initialize Game Session (Logic / Simulation)
        this.session = new GameSession(
            game,
            this,
            this.map,
            this.mapData,
            this.effects,
            this.startingCards
        );

        // Initialize UI (depends on Scene/Session)
        this.ui = new UIManager(this);
        this.devConsole = new DevConsole(this);

        Logger.info(LogChannel.GAME, 'GameScene Initialized');

        // Initialize game controller (depends on Session logic via getters)
        this.gameController = new GameController(
            this.session.gameState,
            this.session.entityManager,
            this.effects,
            this.session.inspector,
            this.ui,
            this.session.metrics,
            this.mapData,
            this.map,
            (col, row) => this.map.isBuildable(col, row),
            this.session.cardSys,
            this.events,
        );

        // Listen for Global Events
        this.unsubs.push(EventBus.getInstance().on(Events.ENEMY_DIED, (data: any) => {
            const enemy = data.enemy as Enemy;
            if (enemy && enemy.typeId === 'sapper_rat') {
                this.triggerExplosion(enemy.x, enemy.y, 45, 200, true); // Visual + Logic (Damage)
            }
        }));

        // Magma King Split Logic
        this.unsubs.push(EventBus.getInstance().on(Events.ENEMY_SPLIT, (data: any) => {
            const enemy = data.enemy as Enemy;
            if (enemy && enemy.typeId === 'magma_king') {
                const decoy = this.entityManager.spawnEnemy('MAGMA_STATUE', this.map.waypoints);
                if (decoy) {
                    decoy.x = enemy.x;
                    decoy.y = enemy.y;
                    decoy.pathIndex = enemy.pathIndex;

                    this.effects.add({
                        type: 'explosion',
                        x: enemy.x,
                        y: enemy.y,
                        radius: 40,
                        life: 0.3,
                        color: '#b0bec5'
                    });

                    this.showFloatingText('DECOY!', enemy.x, enemy.y - 30, '#b0bec5');
                }
            }
        }));

        // Flesh Colossus Death-Spawn Logic
        this.unsubs.push(EventBus.getInstance().on(Events.ENEMY_DEATH_SPAWN, (data: any) => {
            const parent = data.enemy as Enemy;
            const spawns: string[] = data.spawns;

            if (!parent || !spawns || spawns.length === 0) return;

            this.effects.add({
                type: 'explosion',
                x: parent.x,
                y: parent.y,
                radius: 55,
                life: 0.5,
                color: '#8b0000'
            });

            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2 + Math.random() * 0.3;
                const speed = 120 + Math.random() * 80;
                this.effects.add({
                    type: 'debris',
                    x: parent.x + (Math.random() - 0.5) * 20,
                    y: parent.y + (Math.random() - 0.5) * 20,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 100,
                    life: 0.5 + Math.random() * 0.3,
                    size: 5 + Math.random() * 7,
                    color: Math.random() > 0.5 ? '#6d2c2c' : '#8d4545',
                    gravity: 450,
                    rotation: Math.random() * Math.PI * 2,
                    vRot: (Math.random() - 0.5) * 12
                });
            }

            for (let i = 0; i < spawns.length; i++) {
                const typeKey = spawns[i];
                const child = this.entityManager.spawnEnemy(typeKey.toUpperCase(), this.map.waypoints);
                if (child) {
                    child.pathIndex = parent.pathIndex;
                    const angle = (i / spawns.length) * Math.PI * 2 + Math.random() * 0.3;
                    const offset = 25 + Math.random() * 15;
                    child.x = parent.x + Math.cos(angle) * offset;
                    child.y = parent.y + Math.sin(angle) * offset;
                }
            }

            this.showFloatingText('BURST!', parent.x, parent.y - 40, '#ff5252');
            SoundManager.play('explosion');
            this.triggerShake(0.35, 7);
        }));

        // === SAFE SAVE CADENCE ===
        // 1. Wave Completed
        this.unsubs.push(EventBus.getInstance().on(Events.WAVE_COMPLETED, () => {
            this.saveProgress();
        }));

        // 2. Card Installed (or just dropped effectively)
        this.unsubs.push(EventBus.getInstance().on(Events.CARD_DROPPED, (data: any) => {
            // Only save if actionId is present (implies successful drop logic initiated)
            // or just save anyway, cheap operation with deltas
            this.saveProgress();
        }));
    }

    private saveProgress() {
        if (!this.session || !this.session.metrics) return;

        const current = this.session.metrics.getCurrentSessionStats();

        const delta = {
            money: current.money - this.lastSavedStats.money,
            kills: current.kills - this.lastSavedStats.kills,
            waves: current.waves - this.lastSavedStats.waves,
            maxWave: current.waves // Always pass current max
        };

        if (delta.money > 0 || delta.kills > 0 || delta.waves > 0) {
            SaveManager.updateProgress(delta);
            this.lastSavedStats = { ...current };
        }
    }

    protected onEnterImpl() {
        // UI Initialization via Manager
        if (this.ui) {
            this.ui.setMode('game');
            this.ui.update();
        }

        // Initialize CardSystem UI safely AFTER the UIManager is set up
        this.session.cardSys.initUI();

        // Use this.on for automatic cleanup
        this.on(window, 'keydown', this.onKeyDown);
    }

    protected onExitImpl() {
        // 1. Stop Logic (Controller first to prevent input handling during shutdown)
        if (this.gameController) this.gameController.dispose();

        // 2. UI Cleanup
        if (this.ui) this.ui.destroy();

        // 3. Session Cleanup (Systems, Listeners)
        if (this.session) this.session.destroy();

        // 4. Global Event Cleanup
        this.unsubs.forEach(u => u());
        this.unsubs = [];

        const ui = document.getElementById('ui-layer');
        if (ui) ui.style.display = 'none';

        // Note: this.bestiary is part of session, so session.destroy() handles it.
    }

    private onKeyDown = (e: KeyboardEvent) => {
        this.gameController.handleKeyDown(e);
    };

    public update(dt: number) {
        // PERF: Track frame timing for FPS graph
        PerformanceMonitor.beginFrame();
        PerformanceMonitor.startTimer('Logic');

        if (!this.gameState.isRunning) {
            PerformanceMonitor.endTimer('Logic');
            return;
        }
        if (this.gameState.paused) {
            PerformanceMonitor.endTimer('Logic');
            return;
        }

        this.gameState.frames++;

        // Time scale support (1x or 2x speed)
        const loops = (this.gameState.timeScale >= 2) ? 2 : 1;

        // Day/Night Cycle (Simple Sine Wave)
        // Cycle duration: approx 60 seconds (3600 frames)

        // Determine current phase (Sine Wave)
        // Math.sin(this.dayTime) -> -1 (Night) to 1 (Day)
        const currentSin = Math.sin(this.dayTime);
        const isNight = currentSin < 0;

        // Modulate speed: Night passes 50% faster, Day is normal
        const speedMultiplier = isNight ? 1.5 : 1.0;

        // Update DayTime
        // Warning: this relies on loops count. We should probably use dt.
        // But for now keeping loops based 
        this.dayTime += 0.0005 * loops * speedMultiplier;

        // Update DayNightCycle system
        // Pass real dt (accumulated per loop if we loop, but here we pass dt * loops roughly?)
        // Actually, if we loop 2 times with dt, we advance 2 * dt time. Correct.

        // Oscillate between 0.5 (Darkest evening) and 0.95 (Brightest day)
        // Math.sin goes -1 to 1. 
        // We want range [0.5, 0.95]. Center is 0.725, Amplitude is 0.225
        const brightness = 0.75 + currentSin * 0.20;
        this.lighting.ambientLight = brightness;

        // delta frames is NOT used anymore for logic, everything uses dt (seconds)
        // const delta = dt * 60; 

        for (let l = 0; l < loops; l++) {
            this.dayNightCycle.update(dt);
            this.atmosphere.update(dt);
            this.map.update(dt);
            this.waveManager.update(dt);
            this.fog.update(dt);
            // Lighting doesn't need explicit update logic for now, just render

            // 1. Update Entities (Move enemies first)
            PerformanceMonitor.startTimer('Entities');
            this.entityManager.updateEnemies(dt, this.map.flowField);
            this.acidSystem.update(dt, this.gameState.enemies);
            this.commanderSystem.update(dt, this.gameState.enemies);
            PerformanceMonitor.endTimer('Entities');

            // 2. Invalidate Spatial Grid check (Auto-rebuilds if dirty in getValidGrid)
            this.collision.invalidateGrid();

            // 3. Update Towers (Targeting & Visuals)
            for (let i = 0; i < this.gameState.towers.length; i++) {
                const t = this.gameState.towers[i];
                // Targeting logic
                t.update(dt, this.collision.getValidGrid(this.gameState.enemies), this.map.flowField);
                // Visual logic
                t.updateBuilding(this.effects, dt);
                RendererFactory.updateTower(dt, t);
            }

            PerformanceMonitor.startTimer('Entities');
            // 4. Update weapon system (tower shooting)
            this.weaponSystem.update(
                this.gameState.towers,
                this.gameState.enemies,
                this.projectileSystem,
                dt,
                this.effects
            );
            PerformanceMonitor.endTimer('Entities');

            PerformanceMonitor.startTimer('Projectiles');
            // 5. Update projectiles
            this.projectileSystem.update(dt, this.effects);
            PerformanceMonitor.endTimer('Projectiles');

            PerformanceMonitor.startTimer('Collision');
            // 6. Check collisions
            this.collision.update(this.projectileSystem.projectiles, this.gameState.enemies);
            PerformanceMonitor.endTimer('Collision');

            this.effects.update(dt);

            // Update enemy counter in HUD
            this.ui.hud.updateEnemyCounter(this.gameState.enemies.length);
        }
        // Update shake (once per frame, not per loop)
        this.gameState.updateShake();
        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –®–ê–ì 3: –î—É–±–ª–∏–∫–∞—Ç effects.update() –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω
        // –≠—Ñ—Ñ–µ–∫—Ç—ã —É–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –≤ —Ü–∏–∫–ª–µ –≤—ã—à–µ (—Å—Ç—Ä–æ–∫–∞ 237)
        // –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —ç—Ç—É —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–∫–∞—Ç–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π:
        // this.effects.update();

        PerformanceMonitor.endTimer('Logic');
    }

    public draw(ctx: CanvasRenderingContext2D) {
        PerformanceMonitor.startTimer('Render');
        ctx.save();

        // Reset global canvas state to prevent artifacts from previous frames
        ctx.globalAlpha = 1.0;
        ctx.globalCompositeOperation = 'source-over';

        // Apply screen shake
        if (this.gameState.shakeTimer > 0) {
            const dx = (Math.random() - 0.5) * this.gameState.shakeIntensity;
            const dy = (Math.random() - 0.5) * this.gameState.shakeIntensity;
            ctx.translate(dx, dy);
        }

        // Complete canvas clearing to prevent "Hall of Mirrors" artifacts
        ctx.clearRect(0, 0, this.game.width, this.game.height);
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, this.game.width, this.game.height);

        // Draw map and fog
        // Draw map and fog
        RendererFactory.drawMap(ctx, this.map);
        // Torches
        this.map.drawTorches(ctx, this.gameState.frames); // [NEW] Draw torches with time

        // === PHASE 6: VIGNETTE (Cinematic Polish) ===
        // Draw a subtle dark gradient at the edges
        // const w = this.game.width;
        // const h = this.game.height;
        //
        // ctx.save();
        // const gradient = ctx.createRadialGradient(w / 2, h / 2, h * 0.45, w / 2, h / 2, h * 0.9);
        // gradient.addColorStop(0, 'rgba(0,0,0,0)');
        // gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
        // ctx.fillStyle = gradient;
        // ctx.fillRect(0, 0, w, h);
        // ctx.restore();
        // === END VIGNETTE ===

        // Draw ground decals (acid puddles, tracks) - Layer 2 (After Map, Before Objects)
        this.acidSystem.draw();
        this.commanderSystem.draw();

        // Draw path preview
        this.drawPathPreview(ctx);

        // Draw hover highlight
        this.drawHoverHighlight(ctx);

        // Draw entities
        for (let i = 0; i < this.gameState.towers.length; i++) {
            this.gameState.towers[i].draw(ctx);
        }
        this.drawSelectedTowerRange(ctx);


        // Draw targeting mode tooltip for hovered tower
        this.drawTargetingModeTooltip(ctx);

        const viewW = this.game.width;
        const viewH = this.game.height;
        const cullMargin = 64; // Safe margin for large sprites/effects

        PerformanceMonitor.startTimer('RenderEntities');
        for (let i = 0; i < this.gameState.enemies.length; i++) {
            const e = this.gameState.enemies[i];
            // Culling: Skip if off-screen
            if (e.x < -cullMargin || e.x > viewW + cullMargin ||
                e.y < -cullMargin || e.y > viewH + cullMargin) {
                continue;
            }
            e.draw(ctx);
        }
        PerformanceMonitor.endTimer('RenderEntities');

        this.projectileSystem.draw(ctx);
        // Draw effects
        this.effects.draw();

        // Draw Fog Overlay (After units/effects, before lighting)
        this.fog.draw(ctx);

        // Draw lighting (over everything except UI)
        // Update size if needed
        if (this.game.width !== this.lighting['width'] || this.game.height !== this.lighting['height']) {
            this.lighting.resize(this.game.width, this.game.height);
        }
        // Reset lights
        this.lighting.clear();
        // Add dynamic lights...
        // Add dynamic lights...
        this.lighting.render(ctx);

        // === EMISSIVE PASS (Glowing Eyes through Fog/Darkness) ===
        // Draw this AFTER lighting so it "pops"
        for (let i = 0; i < this.gameState.enemies.length; i++) {
            EnemyRenderer.drawEmissive(ctx, this.gameState.enemies[i]);
        }

        // Draw atmosphere effects (sunlight, moonlight, stars, etc)
        this.atmosphere.draw(ctx);

        ctx.restore();
        PerformanceMonitor.endTimer('Render');
    }

    private drawPathPreview(ctx: CanvasRenderingContext2D) {
        if (this.map.waypoints && this.map.waypoints.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 10]);

            const start = this.map.waypoints[0];
            const ts = CONFIG.TILE_SIZE;
            const half = ts / 2;

            ctx.moveTo(start.x * ts + half, start.y * ts + half);
            for (let i = 1; i < this.map.waypoints.length; i++) {
                const wp = this.map.waypoints[i];
                ctx.lineTo(wp.x * ts + half, wp.y * ts + half);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    private drawHoverHighlight(ctx: CanvasRenderingContext2D) {
        if (this.input.hoverCol >= 0) {
            const hx = this.input.hoverCol * CONFIG.TILE_SIZE;
            const hy = this.input.hoverRow * CONFIG.TILE_SIZE;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(hx, hy, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
        }
    }

    private drawSelectedTowerRange(ctx: CanvasRenderingContext2D) {
        if (this.gameState.selectedTower) {
            const stats = this.gameState.selectedTower.getStats();
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
            ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(
                this.gameState.selectedTower.x,
                this.gameState.selectedTower.y,
                stats.range,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.stroke();
        }
    }

    private drawTargetingModeTooltip(ctx: CanvasRenderingContext2D) {
        // Find tower under mouse cursor
        if (this.input.hoverCol < 0 || this.input.hoverRow < 0) return;

        const hoverX = this.input.hoverCol * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const hoverY = this.input.hoverRow * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        let hoveredTower: Tower | null = null;
        for (let i = 0; i < this.gameState.towers.length; i++) {
            const t = this.gameState.towers[i];
            const distSq = (t.x - hoverX) * (t.x - hoverX) + (t.y - hoverY) * (t.y - hoverY);
            if (distSq < 1024) { // 32 * 32
                hoveredTower = t;
                break;
            }
        }

        if (hoveredTower && !hoveredTower.isBuilding) {
            const modeKey = hoveredTower.targetingMode.toUpperCase();
            const targetingModes = Object.values(CONFIG.TARGETING_MODES);
            let mode = null;
            for (let i = 0; i < targetingModes.length; i++) {
                if ((targetingModes[i] as any).id === hoveredTower.targetingMode) {
                    mode = targetingModes[i] as any;
                    break;
                }
            }
            if (mode) {
                // Draw small icon above tower
                ctx.save();
                // PERF: Removed shadowBlur - causes severe performance hit in render loop
                // Use layered circles for fake shadow effect instead

                // Shadow layer (dark circle behind)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(hoveredTower.x + 2, hoveredTower.y - 43, 18, 0, Math.PI * 2);
                ctx.fill();

                // Background circle
                ctx.fillStyle = 'rgba(50, 50, 70, 0.95)';
                ctx.beginPath();
                ctx.arc(hoveredTower.x, hoveredTower.y - 45, 18, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = '#4caf50';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();

                // Icon
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(mode.icon, hoveredTower.x, hoveredTower.y - 45);

                // Tooltip text below
                ctx.font = '12px Arial';
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(mode.name, hoveredTower.x, hoveredTower.y - 22);
                ctx.fillText(mode.name, hoveredTower.x, hoveredTower.y - 22);
            }
        }
    }

    // === IGameScene Implementation (Delegate to modules) ===

    public addMoney(amount: number): void {
        this.gameState.addMoney(amount);
    }

    public spendMoney(amount: number): boolean {
        return this.gameState.spendMoney(amount);
    }

    public loseLife(amount: number = 1): void {
        this.gameState.loseLife(amount);
    }

    public spawnEnemy(type: string): void {
        this.entityManager.spawnEnemy(type, this.map.waypoints);
    }

    public startBuildingTower(col: number, row: number): void {
        this.gameController.startBuildingTower(col, row);
    }

    public handleGridClick(col: number, row: number) {
        this.gameController.handleGridClick(col, row);
    }

    public showFloatingText(text: string, x: number, y: number, color: string = '#fff'): void {
        this.gameController.showFloatingText(text, x, y, color);
    }

    public handleCardDrop(card: ICard, x: number, y: number): boolean {
        return this.gameController.handleCardDrop(card, x, y);
    }

    public giveRandomCard(): void {
        this.gameController.giveRandomCard();
    }

    public sellTower(tower: Tower): void {
        this.gameController.sellTower(tower);
    }

    public sellCardFromTower(tower: Tower, cardIndex: number): void {
        this.gameController.sellCardFromTower(tower, cardIndex);
    }

    public restart(): void {
        this.game.changeScene(new GameScene(this.game, this.mapData, this.startingCards));
    }

    public togglePause(): void {
        this.gameState.togglePause();
        this.ui.updatePauseMenu(this.gameState.paused);
    }

    public gameOver(): void {
        this.saveProgress();
        this.gameState.endGame();
        this.metrics.endGame(false);
        this.ui.showGameOver(this.gameState.wave);
    }

    public triggerShake(duration: number, intensity: number): void {
        this.gameState.triggerShake(duration, intensity);
    }

    /**
     * Spawns an explosion that can damage enemies (Friendly Fire)
     */
    public triggerExplosion(x: number, y: number, radius: number, damage: number, friendlyFire: boolean = false) {
        // 1. Main Explosion Visual
        this.effects.add({
            type: 'explosion',
            x: x,
            y: y,
            radius: radius, // No multiplier - new effect looks good at base size
            life: 0.45,
            color: friendlyFire ? 'rgba(118, 255, 3, 0.8)' : 'rgba(255, 100, 0, 0.7)',
        });

        // 2. Explosion particles (debris flying out)
        const particleCount = friendlyFire ? 8 : 5;
        for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2 + Math.random() * 0.5;
            const speed = 150 + Math.random() * 100;
            this.effects.add({
                type: 'debris',
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 50,
                life: 0.4 + Math.random() * 0.2,
                size: 3 + Math.random() * 3,
                color: friendlyFire ? '#76ff03' : '#ff6d00',
                rotation: Math.random() * Math.PI * 2,
                vRot: (Math.random() - 0.5) * 20,
                gravity: 400,
            });
        }

        // 3. Sound and shake
        SoundManager.play('explosion');
        this.triggerShake(0.4, friendlyFire ? 8 : 5);

        // 4. Damage Logic
        if (friendlyFire) {
            // Damage ALL enemies in range
            const enemies = this.gameState.enemies;
            for (const enemy of enemies) {
                if (!enemy.isAlive()) continue;

                const dist = Math.hypot(enemy.x - x, enemy.y - y);
                if (dist <= radius) {
                    enemy.takeDamage(damage);
                }
            }
        }
    }
}
</file>

</files>
