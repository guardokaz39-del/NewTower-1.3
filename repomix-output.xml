This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__tests__/Card.test.d.ts
__tests__/Card.test.ts
__tests__/demo.test.d.ts
__tests__/demo.test.ts
__tests__/Enemy.test.d.ts
__tests__/WaveManager.test.ts
.gitignore
.prettierrc
{
–≤–æ–ª–Ω–∞
eslint.config.js
implementation_plan.md
index.html
jest.config.js
js/card.js
js/config.js
js/enemy.js
js/events.js
js/game old.zip
js/game.js
js/map.js
js/map.zip
js/projectile.js
js/tower.js
js/ui.js
js/utils.js
Math.random()
package.json
public/assets/–ò–ù–°–¢–†–£–ö–¶–ò–Ø.md
public/assets/README.md
review.md
scripts/verify.js
src/Assets.ts
src/BaseScene.ts
src/BestiarySystem.ts
src/Card.ts
src/cards/CardType.ts
src/cards/FireCard.ts
src/cards/IceCard.ts
src/cards/index.ts
src/cards/MinigunCard.ts
src/cards/MultishotCard.ts
src/cards/SniperCard.ts
src/CardSelectionUI.ts
src/CardStackingSystem.ts
src/CardSystem.ts
src/CollisionSystem.ts
src/Config.ts
src/CrashHandler.ts
src/DayNightCycle.ts
src/editor/EditorHistory.ts
src/editor/EditorToolbar.ts
src/editor/WaypointManager.ts
src/EffectSystem.ts
src/Enemy.ts
src/EntityFactory.ts
src/EventBus.ts
src/Events.ts
src/FogRenderer.ts
src/FogStructure.ts
src/FogSystem.ts
src/ForgeSystem.ts
src/Game.ts
src/graphics/InkConfig.ts
src/graphics/InkFogRenderer.ts
src/graphics/InkHatching.ts
src/graphics/InkLightingSystem.ts
src/graphics/InkParticles.ts
src/graphics/InkUtils.ts
src/graphics/InkWatercolor.ts
src/graphics/PaperTexture.ts
src/index.ts
src/InputSystem.ts
src/InspectorSystem.ts
src/Map.ts
src/MapData.ts
src/MetricsSystem.ts
src/ObjectRenderer.ts
src/Pathfinder.ts
src/ProceduralPatterns.ts
src/Projectile.ts
src/RendererFactory.ts
src/renderers/EnemyRenderer.ts
src/renderers/InkDecorRenderer.ts
src/renderers/InkEffectRenderer.ts
src/renderers/InkEnemyRenderer.ts
src/renderers/InkMapRenderer.ts
src/renderers/InkProjectileRenderer.ts
src/renderers/InkTowerRenderer.ts
src/renderers/ProceduralGrass.ts
src/renderers/ProceduralRoad.ts
src/renderers/SpriteProjectileRenderer.ts
src/renderers/TowerRenderer.ts
src/renderers/units/SkeletonUnitRenderer.ts
src/renderers/units/UnitRenderer.ts
src/SaveManager.ts
src/Scene.ts
src/scenes/EditorScene.ts
src/scenes/EntityManager.ts
src/scenes/GameController.ts
src/scenes/GameScene.ts
src/scenes/GameState.ts
src/scenes/IGameScene.ts
src/scenes/MenuScene.ts
src/SimplexNoise.ts
src/SoundManager.ts
src/SpatialGrid.ts
src/systems/AtmosphereSystem.ts
src/systems/LightingSystem.ts
src/systems/NotificationSystem.ts
src/Tower.ts
src/types.ts
src/ui/DevConsole.ts
src/ui/GameHUD.ts
src/ui/GameOverUI.ts
src/ui/PauseMenu.ts
src/ui/ShopUI.ts
src/UIManager.ts
src/UIUtils.ts
src/Utils.ts
src/utils/Logger.ts
src/utils/SafeJson.ts
src/VisualConfig.ts
src/vite-env.d.ts
src/WaveEditor.ts
src/WaveManager.ts
src/WeaponSystem.ts
style_analysis_and_roadmap.md
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="–≤–æ–ª–Ω–∞">

</file>

<file path="public/assets/–ò–ù–°–¢–†–£–ö–¶–ò–Ø.md">
# üé® –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ –î–æ–±–∞–≤–ª–µ–Ω–∏—é –ì—Ä–∞—Ñ–∏–∫–∏ - New Tower Defense

## ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –í–∞—à–µ–≥–æ –§–∞–π–ª–∞

**–§–∞–π–ª:** `grass.png` (25.9 KB)  
**–ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ:** `public/assets/images/tiles/grass.png`  
**–°—Ç–∞—Ç—É—Å:** ‚úÖ **–ü—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–∞–∑–º–µ—â–µ–Ω!**

–ò–≥—Ä–∞ –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–æ—Ç —Ñ–∞–π–ª –≤–º–µ—Å—Ç–æ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç—Ä–∞–≤—ã.

---

## üìÅ –ö—É–¥–∞ –î–æ–±–∞–≤–ª—è—Ç—å –§–∞–π–ª—ã

### –ë–∞–∑–æ–≤–∞—è –ü–∞–ø–∫–∞

–í—Å–µ –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –≤:

```
c:\Users\Luisa\Desktop\NewTower\NewTower 1.4 alfa\public\assets\images\
```

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ü–æ–¥–ø–∞–ø–æ–∫

```
public/assets/images/
‚îú‚îÄ‚îÄ tiles/          üëà –û–∫—Ä—É–∂–µ–Ω–∏–µ (–∑–µ–º–ª—è, –¥–æ—Ä–æ–≥–∏, –¥–µ–∫–æ—Ä–∞—Ü–∏–∏)
‚îú‚îÄ‚îÄ towers/         üëà –ë–∞—à–Ω–∏ (–ø–ª–∞—Ç—Ñ–æ—Ä–º—ã, —Ç—É—Ä–µ–ª–∏)
‚îú‚îÄ‚îÄ modules/        üëà –ú–æ–¥—É–ª–∏ —É–ª—É—á—à–µ–Ω–∏–π –±–∞—à–µ–Ω
‚îú‚îÄ‚îÄ enemies/        üëà –í—Ä–∞–≥–∏
‚îú‚îÄ‚îÄ props/          üëà –î–æ–ø–æ–ª–Ω–µ–Ω–∏—è –¥–ª—è –≤—Ä–∞–≥–æ–≤ (—â–∏—Ç—ã, —à–ª–µ–º—ã)
‚îú‚îÄ‚îÄ projectiles/    üëà –°–Ω–∞—Ä—è–¥—ã
‚îî‚îÄ‚îÄ effects/        üëà –≠—Ñ—Ñ–µ–∫—Ç—ã (–æ—Å—Ç–∞–≤–∏—Ç—å –ø—É—Å—Ç–æ–π, –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –∫–æ–¥–æ–º)
```

---

## üìù –ü–æ–ª–Ω—ã–π –°–ø–∏—Å–æ–∫ –§–∞–π–ª–æ–≤

### 1Ô∏è‚É£ –û–∫—Ä—É–∂–µ–Ω–∏–µ (–ø–∞–ø–∫–∞ `tiles/`)

#### –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¢–∞–π–ª—ã

| –§–∞–π–ª | –û–ø–∏—Å–∞–Ω–∏–µ | Size | –ì–æ—Ç–æ–≤ |
|------|----------|------|-------|
| `grass.png` | –¢—Ä–∞–≤–∞ | 64x64 | ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω! |
| `path.png` | –î–æ—Ä–æ–≥–∞ | 64x64 | ‚¨ú |

#### –¢—É–º–∞–Ω –í–æ–π–Ω—ã (16 —Ñ–∞–π–ª–æ–≤)

| –§–∞–π–ª—ã | –û–ø–∏—Å–∞–Ω–∏–µ |
|-------|----------|
| `fog_0.png` –¥–æ `fog_15.png` | –ü–ª–∏—Ç–∫–∏ —Ç—É–º–∞–Ω–∞ –≤–æ–π–Ω—ã (16 —à—Ç—É–∫) | 64x64 | ‚¨ú |

> **–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:** Fog —Ñ–∞–π–ª—ã –∏–º–µ–Ω—É—é—Ç—Å—è –æ—Ç `fog_0.png` –¥–æ `fog_15.png` (–≤—Å–µ–≥–æ 16 —Ñ–∞–π–ª–æ–≤). –≠—Ç–æ –≤–∞–∂–Ω–æ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –±–∏—Ç–º–∞—Å–∫–∏–Ω–≥–∞.

#### –î–µ–∫–æ—Ä–∞—Ü–∏–∏

| –§–∞–π–ª | –û–ø–∏—Å–∞–Ω–∏–µ | Size | –ì–æ—Ç–æ–≤ |
|------|----------|------|-------|
| `tree.png` | –î–µ—Ä–µ–≤–æ | 64x64 | ‚¨ú |
| `rock.png` | –ë–æ–ª—å—à–æ–π –∫–∞–º–µ–Ω—å | 64x64 | ‚¨ú |
| `stone.png` | –ú–∞–ª–µ–Ω—å–∫–∏–µ –∫–∞–º–Ω–∏ | 64x64 | ‚¨ú |
| `wheat.png` | –ü—à–µ–Ω–∏—Ü–∞ | 64x64 | ‚¨ú |
| `flowers.png` | –¶–≤–µ—Ç—ã | 64x64 | ‚¨ú |

---

### 2Ô∏è‚É£ –ë–∞—à–Ω–∏ (–ø–∞–ø–∫–∞ `towers/`)

| –§–∞–π–ª | –û–ø–∏—Å–∞–Ω–∏–µ | Size | –ì–æ—Ç–æ–≤ |
|------|----------|------|-------|
| `base.png` | –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ –±–∞—à–Ω–∏ | 64x64 | ‚¨ú |
| `base_default.png` | –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ (–∞–ª—å—Ç.) | 64x64 | ‚¨ú |
| `gun.png` | –ë–∞–∑–æ–≤–æ–µ –æ—Ä—É–¥–∏–µ | 64x64 | ‚¨ú |
| `turret_standard.png` | –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Ç—É—Ä–µ–ª—å | 64x64 | ‚¨ú |
| `turret_ice.png` | –õ–µ–¥—è–Ω–∞—è —Ç—É—Ä–µ–ª—å | 64x64 | ‚¨ú |
| `turret_fire.png` | –û–≥–Ω–µ–Ω–Ω–∞—è —Ç—É—Ä–µ–ª—å | 64x64 | ‚¨ú |
| `turret_sniper.png` | –°–Ω–∞–π–ø–µ—Ä—Å–∫–∞—è —Ç—É—Ä–µ–ª—å | 64x64 | ‚¨ú |
| `turret_split.png` | –ú—É–ª—å—Ç–∏–≤—ã—Å—Ç—Ä–µ–ª | 64x64 | ‚¨ú |
| `turret_minigun.png` | –ü—É–ª–µ–º—ë—Ç | 64x64 | ‚¨ú |

---

### 3Ô∏è‚É£ –ú–æ–¥—É–ª–∏ (–ø–∞–ø–∫–∞ `modules/`)

| –§–∞–π–ª | –û–ø–∏—Å–∞–Ω–∏–µ | Size | –ì–æ—Ç–æ–≤ |
|------|----------|------|-------|
| `ice.png` | –ú–æ–¥—É–ª—å –ª—å–¥–∞ | 24x24 | ‚¨ú |
| `fire.png` | –ú–æ–¥—É–ª—å –æ–≥–Ω—è | 24x24 | ‚¨ú |
| `sniper.png` | –°–Ω–∞–π–ø–µ—Ä—Å–∫–∏–π –º–æ–¥—É–ª—å | 24x24 | ‚¨ú |
| `split.png` | –ú–æ–¥—É–ª—å –∑–∞–ª–ø–∞ | 24x24 | ‚¨ú |
| `minigun.png` | –ú–æ–¥—É–ª—å –ø—É–ª–µ–º—ë—Ç–∞ | 24x24 | ‚¨ú |

---

### 4Ô∏è‚É£ –í—Ä–∞–≥–∏ (–ø–∞–ø–∫–∞ `enemies/`)

| –§–∞–π–ª | –û–ø–∏—Å–∞–Ω–∏–µ | Size | –ì–æ—Ç–æ–≤ |
|------|----------|------|-------|
| `skeleton.png` | –°–∫–µ–ª–µ—Ç | 48x48 | ‚¨ú |
| `wolf.png` | –í–æ–ª–∫ | 48x48 | ‚¨ú |
| `troll.png` | –¢—Ä–æ–ª–ª—å | 48x48 | ‚¨ú |
| `spider.png` | –ü–∞—É–∫ | 48x48 | ‚¨ú |

---

### 5Ô∏è‚É£ –î–æ–ø–æ–ª–Ω–µ–Ω–∏—è –í—Ä–∞–≥–æ–≤ (–ø–∞–ø–∫–∞ `props/`)

| –§–∞–π–ª | –û–ø–∏—Å–∞–Ω–∏–µ | Size | –ì–æ—Ç–æ–≤ |
|------|----------|------|-------|
| `shield.png` | –©–∏—Ç | 32x32 | ‚¨ú |
| `helmet.png` | –®–ª–µ–º | 32x32 | ‚¨ú |
| `weapon.png` | –û—Ä—É–∂–∏–µ | 32x32 | ‚¨ú |
| `barrier.png` | –ë–∞—Ä—å–µ—Ä | 32x32 | ‚¨ú |

---

### 6Ô∏è‚É£ –°–Ω–∞—Ä—è–¥—ã (–ø–∞–ø–∫–∞ `projectiles/`)

| –§–∞–π–ª | –û–ø–∏—Å–∞–Ω–∏–µ | Size | –ì–æ—Ç–æ–≤ |
|------|----------|------|-------|
| `standard.png` | –û–±—ã—á–Ω—ã–π —Å–Ω–∞—Ä—è–¥ | 16x16 | ‚¨ú |
| `ice.png` | –õ–µ–¥—è–Ω–æ–π —Å–Ω–∞—Ä—è–¥ | 16x16 | ‚¨ú |
| `fire.png` | –û–≥–Ω–µ–Ω–Ω—ã–π —Å–Ω–∞—Ä—è–¥ | 16x16 | ‚¨ú |
| `sniper.png` | –°–Ω–∞–π–ø–µ—Ä—Å–∫–∞—è –ø—É–ª—è | 16x16 | ‚¨ú |
| `split.png` | –î—Ä–æ–±—å | 16x16 | ‚¨ú |
| `minigun.png` | –¢—Ä–∞—Å—Å–∏—Ä—É—é—â–∞—è –ø—É–ª—è | 16x16 | ‚¨ú |

---

## üé≤ –°–∏—Å—Ç–µ–º–∞ –í–∞—Ä–∏–∞–Ω—Ç–æ–≤ (–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

### –ö–∞–∫ –î–æ–±–∞–≤–∏—Ç—å –í–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è –†–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è

–î–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –æ–¥–Ω–æ–≥–æ –∞—Å—Å–µ—Ç–∞:

**–ü—Ä–∏–º–µ—Ä —Å —Ç—Ä–∞–≤–æ–π:**

```
tiles/grass.png       üëà –û—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª (–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û)
tiles/grass_1.png     üëà –í–∞—Ä–∏–∞–Ω—Ç 1 (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
tiles/grass_2.png     üëà –í–∞—Ä–∏–∞–Ω—Ç 2 (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
tiles/grass_3.png     üëà –í–∞—Ä–∏–∞–Ω—Ç 3 (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
tiles/grass_4.png     üëà –í–∞—Ä–∏–∞–Ω—Ç 4 (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
tiles/grass_5.png     üëà –í–∞—Ä–∏–∞–Ω—Ç 5 (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –ò–≥—Ä–∞ –±—É–¥–µ—Ç —Å–ª—É—á–∞–π–Ω–æ –≤—ã–±–∏—Ä–∞—Ç—å –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–π –∫–ª–µ—Ç–∫–∏ —Ç—Ä–∞–≤—ã!

### –ö–∞–∫–∏–µ –ê—Å—Å–µ—Ç—ã –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –í–∞—Ä–∏–∞–Ω—Ç—ã

| –ê—Å—Å–µ—Ç | –ú–∞–∫—Å. –í–∞—Ä–∏–∞–Ω—Ç–æ–≤ | –ü—Ä–∏–º–µ—Ä—ã —Ñ–∞–π–ª–æ–≤ |
|-------|-----------------|----------------|
| `grass.png` | 5 | grass.png, grass_1.png ... grass_5.png |
| `path.png` | 3 | path.png, path_1.png, path_2.png |
| `tree.png` | 3 | tree.png, tree_1.png, tree_2.png |
| `rock.png` | 5 | rock.png, rock_1.png ... rock_5.png |
| `stone.png` | 3 | stone.png, stone_1.png, stone_2.png |
| `wheat.png` | 2 | wheat.png, wheat_1.png |
| `flowers.png` | 3 | flowers.png, flowers_1.png, flowers_2.png |
| `skeleton.png` | 3 | skeleton.png, skeleton_1png, skeleton_2.png |
| `wolf.png` | 2 | wolf.png, wolf_1.png |
| `troll.png` | 2 | troll.png, troll_1.png |
| `spider.png` | 2 | spider.png, spider_1.png |

> **‚ö†Ô∏è –í–∞–∂–Ω–æ:** –ë–∞—à–Ω–∏, —Å–Ω–∞—Ä—è–¥—ã –∏ fog tiles –ù–ï –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã (–¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ –≥–µ–π–º–ø–ª–µ—è).

---

## üöÄ –ö–∞–∫ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ß—Ç–æ –§–∞–π–ª –ó–∞–≥—Ä—É–∑–∏–ª—Å—è

### –°–ø–æ—Å–æ–± 1: –ö–æ–Ω—Å–æ–ª—å –ë—Ä–∞—É–∑–µ—Ä–∞

1. –û—Ç–∫—Ä–æ–π—Ç–µ –∏–≥—Ä—É: <http://localhost:8080/>
2. –ù–∞–∂–º–∏—Ç–µ **F12** (–æ—Ç–∫—Ä–æ–µ—Ç—Å—è –∫–æ–Ω—Å–æ–ª—å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞)
3. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É (**Ctrl+R**)
4. –ò—â–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏—è:

```
Assets: External loading complete! Loaded: 1, Failed: 55
Assets: Loading complete! Total: 180 assets (1 PNG, 179 procedural)
```

**`Loaded: 1`** –æ–∑–Ω–∞—á–∞–µ—Ç —á—Ç–æ –≤–∞—à `grass.png` –∑–∞–≥—Ä—É–∑–∏–ª—Å—è! ‚úÖ

### –°–ø–æ—Å–æ–± 2: –í–∏–∑—É–∞–ª—å–Ω–æ

–ü—Ä–æ—Å—Ç–æ –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ —Ç—Ä–∞–≤—É –≤ –∏–≥—Ä–µ - –µ—Å–ª–∏ –æ–Ω–∞ –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –≤–∞—à–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∞ –≤–º–µ—Å—Ç–æ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–π, –∑–Ω–∞—á–∏—Ç –≤—Å—ë —Ä–∞–±–æ—Ç–∞–µ—Ç!

---

## üìê –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è

### –§–æ—Ä–º–∞—Ç –§–∞–π–ª–æ–≤

- **–§–æ—Ä–º–∞—Ç:** PNG —Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é (alpha channel)
- **–ö–æ–¥–∏—Ä–æ–≤–∫–∞:** sRGB
- **–ö–æ–º–ø—Ä–µ—Å—Å–∏—è:** –õ—é–±–∞—è (–º–æ–∂–Ω–æ —Å–∂–∞—Ç—å –≤ TinyPNG –¥–ª—è –º–µ–Ω—å—à–µ–≥–æ —Ä–∞–∑–º–µ—Ä–∞)

### –†–∞–∑–º–µ—Ä—ã

| –ö–∞—Ç–µ–≥–æ—Ä–∏—è | –†–∞–∑–º–µ—Ä | –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ |
|-----------|--------|------------|
| –¢–∞–π–ª—ã –æ–∫—Ä—É–∂–µ–Ω–∏—è | 64x64 px | –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ |
| –ë–∞—à–Ω–∏ –∏ —Ç—É—Ä–µ–ª–∏ | 64x64 px | –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã |
| –ú–æ–¥—É–ª–∏ | 24x24 px | –ú–∞–ª–µ–Ω—å–∫–∏–µ |
| –í—Ä–∞–≥–∏ | 48x48 px | –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã |
| Props | 32x32 px | –°—Ä–µ–¥–Ω–∏–µ |
| –°–Ω–∞—Ä—è–¥—ã | 16x16 px | –û—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∏–µ |

### –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ

**‚ö†Ô∏è –û—á–µ–Ω—å –≤–∞–∂–Ω–æ –¥–ª—è —Ç—É—Ä–µ–ª–µ–π:**

- –¢—É—Ä–µ–ª–∏ –¥–æ–ª–∂–Ω—ã "—Å–º–æ—Ç—Ä–µ—Ç—å" **–í–ü–†–ê–í–û** (–Ω–∞ –≤–æ—Å—Ç–æ–∫ ‚Üí)
- –ï—Å–ª–∏ —Ç—É—Ä–µ–ª—å —Å–º–æ—Ç—Ä–∏—Ç –Ω–µ –≤–ø—Ä–∞–≤–æ, –æ–Ω–∞ –±—É–¥–µ—Ç —Å—Ç—Ä–∞–Ω–Ω–æ –≤—Ä–∞—â–∞—Ç—å—Å—è –≤ –∏–≥—Ä–µ!

---

## üé® –ì–¥–µ –ù–∞–π—Ç–∏ –°–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏

–î–µ—Ç–∞–ª—å–Ω—ã–µ –æ–ø–∏—Å–∞–Ω–∏—è –∫–∞–∂–¥–æ–≥–æ –∞—Å—Å–µ—Ç–∞ —Å —Ü–≤–µ—Ç–∞–º–∏ –∏ —Å—Ç–∏–ª–µ–º:

üìÑ **–§–∞–π–ª:** `graphics_report.md` (–≤ –ø–∞–ø–∫–µ brain)

–¢–∞–º —É–∫–∞–∑–∞–Ω–æ:

- –¢–æ—á–Ω—ã–µ —Ü–≤–µ—Ç–æ–≤—ã–µ –∫–æ–¥—ã
- –û–ø–∏—Å–∞–Ω–∏–µ –≤–Ω–µ—à–Ω–µ–≥–æ –≤–∏–¥–∞
- –ü—Ä–æ–º–ø—Ç—ã –¥–ª—è AI –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
- –ü—Ä–∏–º–µ—Ä—ã —Å—Ç–∏–ª–∏—Å—Ç–∏–∫–∏

---

## üîÑ Workflow (–ü–æ—Ä—è–¥–æ–∫ –î–µ–π—Å—Ç–≤–∏–π)

### –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–∞—è –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å

**–§–∞–∑–∞ 1: –ö—Ä–∏—Ç–∏—á–Ω—ã–µ (–Ω–∞—á–Ω–∏—Ç–µ —Å —ç—Ç–∏—Ö)**

1. ‚úÖ `grass.png` - –ì–æ—Ç–æ–≤–æ!
2. ‚¨ú `path.png` - –î–æ—Ä–æ–≥–∞
3. ‚¨ú `turret_standard.png` - –ë–∞–∑–æ–≤–∞—è –±–∞—à–Ω—è
4. ‚¨ú `skeleton.png` - –ë–∞–∑–æ–≤—ã–π –≤—Ä–∞–≥
5. ‚¨ú `standard.png` - –ë–∞–∑–æ–≤—ã–π —Å–Ω–∞—Ä—è–¥

**–§–∞–∑–∞ 2: –ò–≥—Ä–æ–≤—ã–µ –≠–ª–µ–º–µ–Ω—Ç—ã**
6. ‚¨ú –í—Å–µ —Ç—É—Ä–µ–ª–∏ (ice, fire, sniper, split, minigun)
7. ‚¨ú –í—Å–µ –≤—Ä–∞–≥–∏ (wolf, troll, spider)
8. ‚¨ú –í—Å–µ —Å–Ω–∞—Ä—è–¥—ã

**–§–∞–∑–∞ 3: –î–µ–∫–æ—Ä–∞—Ü–∏–∏**
9. ‚¨ú –î–µ–∫–æ—Ä–∞—Ü–∏–∏ (tree, rock, stone, wheat, flowers)
10. ‚¨ú –ú–æ–¥—É–ª–∏ –±–∞—à–µ–Ω
11. ‚¨ú Props –≤—Ä–∞–≥–æ–≤

**–§–∞–∑–∞ 4: –¢—É–º–∞–Ω**
12. ‚¨ú 16 —Ñ–∞–π–ª–æ–≤ fog (fog_0.png ... fog_15.png)

### –ü–æ—Å–ª–µ –ö–∞–∂–¥–æ–≥–æ –î–æ–±–∞–≤–ª–µ–Ω–∏—è

1. –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ —Ñ–∞–π–ª –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –ø–∞–ø–∫—É
2. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤ –±—Ä–∞—É–∑–µ—Ä–µ (**Ctrl+R**)
3. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å (F12) - –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å `Loaded: X` (X —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è)
4. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤ –∏–≥—Ä–µ - –Ω–æ–≤–∞—è –≥—Ä–∞—Ñ–∏–∫–∞ –¥–æ–ª–∂–Ω–∞ –ø–æ—è–≤–∏—Ç—å—Å—è

---

## ‚ùì –ß–∞—Å—Ç—ã–µ –í–æ–ø—Ä–æ—Å—ã

### –ß—Ç–æ –µ—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è?

**–ü—Ä–æ–≤–µ—Ä—å—Ç–µ:**

1. ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞ (—Ä–µ–≥–∏—Å—Ç—Ä –≤–∞–∂–µ–Ω! `Grass.png` ‚â† `grass.png`)
2. ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø–∞–ø–∫–∞
3. ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä (64x64 –¥–ª—è —Ç–∞–π–ª–æ–≤)
4. ‚úÖ –§–æ—Ä–º–∞—Ç PNG (–Ω–µ JPG!)

### –ú–æ–∂–Ω–æ –ª–∏ –Ω–µ –¥–µ–ª–∞—Ç—å –≤—Å–µ —Ñ–∞–π–ª—ã?

**–î–∞!** –°–∏—Å—Ç–µ–º–∞ –≥–∏–±—Ä–∏–¥–Ω–∞—è:

- –ï—Å–ª–∏ —Ñ–∞–π–ª–∞ –ù–ï–¢ ‚Üí –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è (–∫–∞–∫ —Å–µ–π—á–∞—Å)
- –ï—Å–ª–∏ —Ñ–∞–π–ª –ï–°–¢–¨ ‚Üí –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–∞—à–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∞

–ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–ª—è—Ç—å –ø–æ –æ–¥–Ω–æ–º—É —Ñ–∞–π–ª—É –∏ —Å—Ä–∞–∑—É –≤–∏–¥–µ—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç!

### –ù—É–∂–Ω–æ –ª–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—Ç—å —Å–µ—Ä–≤–µ—Ä?

**–ù–µ—Ç!** –ü—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤ –±—Ä–∞—É–∑–µ—Ä–µ (**Ctrl+R**).

### –ö–∞–∫ —É–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª?

–ü—Ä–æ—Å—Ç–æ —É–¥–∞–ª–∏—Ç–µ PNG —Ñ–∞–π–ª –∏–∑ –ø–∞–ø–∫–∏, –∏ –∏–≥—Ä–∞ –≤–µ—Ä–Ω—ë—Ç—Å—è –∫ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–ª—è —ç—Ç–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞.

---

## üìä –ü—Ä–æ–≥—Ä–µ—Å—Å

### –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –í–∞—à–∏—Ö –ê—Å—Å–µ—Ç–æ–≤

**–¢–µ–∫—É—â–∏–π –ø—Ä–æ–≥—Ä–µ—Å—Å:** 1 / 56 –±–∞–∑–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤ (1.8%)

| –ö–∞—Ç–µ–≥–æ—Ä–∏—è | –ì–æ—Ç–æ–≤–æ | –í—Å–µ–≥–æ | –ü—Ä–æ–≥—Ä–µ—Å—Å |
|-----------|--------|-------|----------|
| –û–∫—Ä—É–∂–µ–Ω–∏–µ | 1 | 23 | ‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 4% |
| –ë–∞—à–Ω–∏ | 0 | 12 | ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% |
| –ú–æ–¥—É–ª–∏ | 0 | 5 | ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% |
| –í—Ä–∞–≥–∏ | 0 | 4 | ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% |
| Props | 0 | 4 | ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% |
| –°–Ω–∞—Ä—è–¥—ã | 0 | 6 | ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% |
| –≠—Ñ—Ñ–µ–∫—Ç—ã | 0 | 2 | ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0% |

**–°–ª–µ–¥—É—é—â–∏–π —Ñ–∞–π–ª:** `path.png` (–¥–æ—Ä–æ–≥–∞, 64x64px)

---

## ‚ú® –ü–æ–ª–µ–∑–Ω—ã–µ –°–æ–≤–µ—Ç—ã

1. **–ù–∞—á–Ω–∏—Ç–µ —Å –º–∞–ª–æ–≥–æ**: –î–æ–±–∞–≤—å—Ç–µ 3-5 —Ñ–∞–π–ª–æ–≤, –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç
2. **–ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ –∫–æ–Ω—Å–æ–ª—å**: F12 –ø–æ–∫–∞–∂–µ—Ç –≤—Å–µ –æ—à–∏–±–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏
3. **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã**: –î–∞–∂–µ 2-3 –≤–∞—Ä–∏–∞–Ω—Ç–∞ —Ç—Ä–∞–≤—ã —Å–æ–∑–¥–∞–¥—É—Ç –±–æ–ª—å—à–æ–µ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ
4. **–ù–µ —Å–ø–µ—à–∏—Ç–µ —Å fog**: 16 —Ñ–∞–π–ª–æ–≤ —Ç—É–º–∞–Ω–∞ - —ç—Ç–æ —Å–ª–æ–∂–Ω–æ, –æ—Å—Ç–∞–≤—å—Ç–µ –Ω–∞ –ø–æ—Ç–æ–º
5. **–¢—É—Ä–µ–ª–∏ –≤–∞–∂–Ω—ã**: –û–Ω–∏ —Å–∞–º—ã–µ –∑–∞–º–µ—Ç–Ω—ã–µ, –Ω–∞—á–Ω–∏—Ç–µ —Å –Ω–∏—Ö –ø–æ—Å–ª–µ –±–∞–∑–æ–≤—ã—Ö —Ç–∞–π–ª–æ–≤

---

**–í–∞—à –ø–µ—Ä–≤—ã–π —Ñ–∞–π–ª `grass.png` –æ—Ç–ª–∏—á–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–ª! –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ!** üéâ

**–°–ª–µ–¥—É—é—â–∏–π —à–∞–≥:** –î–æ–±–∞–≤—å—Ç–µ `path.png` –≤ –ø–∞–ø–∫—É `tiles/` –∏ –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –∫–∞–∫ –∏–∑–º–µ–Ω–∏—Ç—Å—è –¥–æ—Ä–æ–≥–∞!
</file>

<file path="__tests__/Card.test.d.ts">
export {};
//# sourceMappingURL=Card.test.d.ts.map
</file>

<file path="__tests__/Card.test.ts">
import { Card, CardType } from '../src/Card';

describe('Card System', () => {
    const testConfig = {
        id: 't1',
        name: 'Test Tower',
        description: 'Desc',
        cost: 100,
        type: CardType.TOWER,
        value: 10
    };

    test('Upgrade mechanic works', () => {
        const card = new Card(testConfig);
        card.upgrade();
        expect(card.level).toBe(2);
        expect(card.cost).toBe(150); // 100 * 1.5
    });
});
</file>

<file path="__tests__/demo.test.d.ts">
export {};
//# sourceMappingURL=demo.test.d.ts.map
</file>

<file path="__tests__/demo.test.ts">
describe('–°–∏—Å—Ç–µ–º–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞', () => {
  test('–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç (2 + 2 = 4)', () => {
    expect(2 + 2).toBe(4);
  });
});
</file>

<file path="__tests__/Enemy.test.d.ts">
export {};
//# sourceMappingURL=Enemy.test.d.ts.map
</file>

<file path=".prettierrc">
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 120,
  "tabWidth": 4
}
</file>

<file path="{">

</file>

<file path="eslint.config.js">
const typescriptParser = require("@typescript-eslint/parser");
const typescriptPlugin = require("@typescript-eslint/eslint-plugin");
const prettierPlugin = require("eslint-plugin-prettier");

module.exports = [
    {
        files: ["src/**/*.ts"],
        languageOptions: {
            parser: typescriptParser,
            parserOptions: {
                ecmaVersion: 2020,
                sourceType: "module"
            }
        },
        plugins: {
            "@typescript-eslint": typescriptPlugin,
            "prettier": prettierPlugin
        },
        rules: {
            ...typescriptPlugin.configs.recommended.rules,
            "prettier/prettier": "error",
            "@typescript-eslint/no-explicit-any": "warn",
            "@typescript-eslint/explicit-module-boundary-types": "off"
        }
    }
];
</file>

<file path="implementation_plan.md">
# Implementation Plan - Ink Style Evolution (Visual Upgrade)

**Status:** PLANNING
**Goal:** Evolve the current "Ink on Paper" style into a polished, high-quality "Living Illustration" aesthetic (Watercolor, Dynamic Hatching, Paper UI) without breaking existing functionality.

## 1. Core Principles (Roadmap)

1. **Strict Backward Compatibility:**
    * `CONFIG.VISUAL_STYLE` controls the engine. `INK_EVO` mode is added as a new option (or replaces `INK` while keeping `SPRITE` fallback).
    * All new renderers must check this flag.
2. **Performance First:**
    * Heavy effects (watercolor generation, hatching) are cached on canvas layers, not drawn every frame.
    * Particles are pooled.
3. **Modular Evolution:**
    * Changes are split into isolated phases (Environment, Object Volume, Particles, UI).

---

## Phase 1: Environment & Watercolor (Atmosphere)

**Goal:** Transform the static paper background into a living, textured surface with watercolor washes for context (grass, path, special zones).

### 1.1 `InkConfig.ts` Update

* **Add:** `WATERCOLOR_PALETTE` (transparent RGBA colors for washes).
* **Add:** `PAPER_NOISE_CONFIG` (settings for procedural grain).

### 1.2 `InkMapRenderer.ts` Upgrade

* **Dynamic Paper Texture:**
  * Implement `generatePaperTexture(ctx, width, height)`: Adds subtle grain/noise and vignette to the base layer.
* **Watercolor Zones:**
  * Update `draw` method to render "Biomes" (Grass, Water/Ice) using a "Wet Brush" technique.
  * *Technique:* Draw multiple overlapping polygons with low opacity and `simplex` noise offset for organic edges.

### 1.3 Path & Grid Refinement

* **Path:** Replace the solid ink fill with a "Coffee Stain" or "Wash" effect (darker edges, lighter center).
* **Grid:** Ensure grid lines look like faint pencil sketches (reduce opacity, add slight breaks).

---

## Phase 2: Structures & Volume (Dynamic Hatching)

**Goal:** Give 3D volume to 2D towers using algorithmic cross-hatching (shading) that reacts to the global light direction.

### 2.1 `InkUtils.ts` - New Logic

* **Add:** `drawHatching(ctx, shape, lightDir, density)`
  * Algorithm: Calculates which side of a circle/rect is away from light.
  * Draws angled parallel lines in that area.
  * Uses masking (clipping) to keep lines inside the object.

### 2.2 `InkTowerRenderer.ts` Update

* **Tower Volumetric pass:**
  * Instead of just outlines, call `drawHatching` for the tower body.
  * Cast shadows: Draw a slanted "ink smudge" shadow on the ground layer (cached).

---

## Phase 3: Living Ink (Particles & Effects)

**Goal:** Make the action feel "juicy". Explosions and impacts should look like ink splattering on the paper.

### 3.1 `InkEffectRenderer.ts`

* **Ink Splatters:**
  * When an enemy dies, spawn 3-5 "Ink Blot" particles.
  * *Behavior:* They scale up quickly, then "dry" (fade out) slowly over 5-10 seconds.
  * *Visual:* Irregular black shapes.
* **Projectile Trails:**
  * Add a `TrailRenderer` that draws a fading ink stroke behind fast projectiles.

### 3.2 Enemy Visuals Consistency

* Ensure all enemies (even sprites) have an "Ink Filter" applied or strictly use the Ink render path.
* *Optimization:* If using sprite sheets, apply a "Threshold" filter or "Edge Detection" once at startup to generate specific ink versions. (Or just stick to the current vector drawing for consistency).

---

## Phase 4: UI Immersion (Paper Notes)

**Goal:** Integrate the floating DOM elements into the paper world.

### 4.1 CSS & Asset Reskin

* **Mains:**
  * `#game-ui`, `#shop-container`, `#card-hand`.
* **Style Changes:**
  * **Backgrounds:** Use a repeatable "torn paper" texture or CSS `mask-image` to create ragged edges.
  * **Pins:** Add visual "Push Pins" (svg/img) to the corners of UI elements.
  * **Fonts:** Switch headers to `Amatic SC` or similar handwritten font (if available/loadable), keep body text readable.
  * **Shadows:** Add `box-shadow` to simulate paper lifting off the table.

### 4.2 `ShopUI.ts` & `CardSystem.ts`

* Update card rendering to look like "Sketch Cards" (rough borders, monochrome icons with one accent color).

---

## Verification Plan

1. **Toggle Check:** Verify `CONFIG.VISUAL_STYLE = 'SPRITE'` still looks 100% like the old version.
2. **Performance:** Check FPS on wave 10+ with many ink particles. (Target > 50 FPS).
3. **Visual Audit:** Compare screen capture with the Concept Art (review.md).

## New File Structure (Partial)

* `src/graphics/InkWatercolor.ts` (New module for wash logic)
* `src/graphics/InkHatching.ts` (New module for shading)
* `assets/paper_texture.png` (Optional, or generated procedurally)
</file>

<file path="js/card.js">
import { CONFIG } from './config.js';
import { generateUUID } from './utils.js';

export class CardSystem {
    constructor(game) {
        this.game = game;
        this.hand = [];
        this.forgeSlots = [null, null];
        this.isForging = false; 

        this.handContainer = document.getElementById('hand');
        this.forgeContainers = [document.getElementById('forge-slot-0'), document.getElementById('forge-slot-1')];
        
        // –°—Ç–∞—Ä—Ç–æ–≤—ã–µ –∫–∞—Ä—Ç—ã
        this.addCard('FIRE', 1); this.addCard('ICE', 1); this.addCard('SNIPER', 1);
    }
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç true, –µ—Å–ª–∏ –∫–∞—Ä—Ç–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞, false - –µ—Å–ª–∏ –Ω–µ—Ç –º–µ—Å—Ç–∞ –∏–ª–∏ –æ—à–∏–±–∫–∞
    addCard(typeKey, level, anim=false) {
        // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–µ—Å—Ç–∞
        if (this.hand.length >= CONFIG.PLAYER.HAND_LIMIT) return false;

        // 2. –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Ç–∏–ø–∞
        const type = CONFIG.CARD_TYPES[typeKey];
        if (!type) {
            console.warn(`CardSystem: –ü–æ–ø—ã—Ç–∫–∞ –¥–æ–±–∞–≤–∏—Ç—å –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –∫–∞—Ä—Ç—ã '${typeKey}'`);
            return false;
        }

        // 3. –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã —Å –Ω–∞–¥–µ–∂–Ω—ã–º ID
        const card = { 
            id: generateUUID(), 
            type: type, 
            level: level, 
            isDragging: false 
        };
        
        this.hand.push(card);
        this.render();
        
        if(anim) {
            const lastEl = this.handContainer.lastElementChild;
            if(lastEl) lastEl.classList.add('spawn-pop');
        }
        
        return true;
    }
    
    putInForge(idx, card) {
        if (this.isForging) return; 

        if(this.forgeSlots[idx]) {
            const returned = this.forgeSlots[idx];
            returned.isDragging = false;
            this.hand.push(returned);
        }
        this.forgeSlots[idx] = card;
        this.hand = this.hand.filter(c=>c.id!==card.id);
        
        this.render();
        this.game.updateUI(); 
    }

    canForge() {
        if (this.isForging) return false;
        const [c1, c2] = this.forgeSlots;
        return c1 && c2 && c1.type.id === c2.type.id && c1.level === c2.level && c1.level < 3;
    }

    tryForge() {
        if (!this.canForge()) return;
        if (this.game.money < CONFIG.FORGE.COST) return;

        this.game.money -= CONFIG.FORGE.COST;
        this.game.updateUI();
        this.isForging = true;

        const el1 = this.forgeContainers[0].firstElementChild;
        const el2 = this.forgeContainers[1].firstElementChild;

        if (el1) el1.classList.add('shaking');
        if (el2) el2.classList.add('shaking');

        setTimeout(() => {
            if (el1) { el1.classList.remove('shaking'); el1.classList.add('merging'); el1.style.transform = 'translateX(42px) scale(0.8)'; }
            if (el2) { el2.classList.remove('shaking'); el2.classList.add('merging'); el2.style.transform = 'translateX(-42px) scale(0.8)'; }

            setTimeout(() => {
                const c1 = this.forgeSlots[0];
                // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –∫–ª—é—á–∞ –¥–ª—è –Ω–æ–≤–æ–π –∫–∞—Ä—Ç—ã (—á–µ—Ä–µ–∑ –ø–æ–∏—Å–∫ –≤ –∫–æ–Ω—Ñ–∏–≥–µ –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ Uppercase id)
                const newTypeKey = c1.type.id.toUpperCase(); 
                const newLevel = c1.level + 1;

                const fRect = document.getElementById('forge-panel').getBoundingClientRect();
                this.game.addEffect({
                    type: 'explosion', 
                    x: fRect.left + fRect.width/2, 
                    y: window.innerHeight - 80, 
                    radius: 60, life: 15, color: '#fff'
                });

                this.forgeSlots = [null, null];
                this.isForging = false;
                this.render();
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Ä—Ç—É. –ï—Å–ª–∏ –≤–¥—Ä—É–≥ –º–µ—Å—Ç–∞ –Ω–µ—Ç (–º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω–æ –ø—Ä–∏ –∫–æ–≤–∫–µ, –Ω–æ –≤—Å–µ –∂–µ) - –¥–µ–Ω—å–≥–∏ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º, —Å—á–∏—Ç–∞–µ–º —á—Ç–æ —Å–≥–æ—Ä–µ–ª–∞ :)
                // –•–æ—Ç—è –ø–æ –ª–æ–≥–∏–∫–µ –∫–æ–≤–∫–∏ –º–µ—Å—Ç–æ –æ—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç—Å—è (2 —É—à–ª–∏, 1 –ø—Ä–∏—à–ª–∞).
                this.addCard(newTypeKey, newLevel, true); 
                this.game.updateUI();

            }, 300); 
        }, 500); 
    }

    render() {
        // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞
        if(!this.handContainer) return;
        this.handContainer.innerHTML='';
        
        this.hand.forEach(c => {
            const el = this.createEl(c);
            if(c.isDragging) el.classList.add('dragging-placeholder');
            this.handContainer.appendChild(el);
        });
        
        this.forgeContainers.forEach((el,i)=>{
            el.innerHTML=''; 
            if(this.forgeSlots[i]) el.appendChild(this.createEl(this.forgeSlots[i], true, i));
        });
    }
    
    createEl(card, isForge=false, idx=-1) {
        const el=document.createElement('div');
        // –ó–∞—â–∏—Ç–∞ –æ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è card.type
        if (!card.type) return el;

        el.className=`card type-${card.type.id} lvl-${card.level}`;
        el.innerHTML=`<div class="card-level">${card.level}</div><div class="card-icon">${card.type.icon}</div>`;
        el.onmousedown=(e)=>{
            if (this.isForging) return; 

            if(isForge) { 
                this.forgeSlots[idx]=null; 
                this.render(); 
                this.game.updateUI(); 
                this.game.startDragging(card,e);
            }
            else {
                card.isDragging = true;
                this.render();
                this.game.startDragging(card,e);
            }
        };
        return el;
    }
}
</file>

<file path="js/config.js">
export const CONFIG = {
    TILE_SIZE: 64,
    COLORS: { 
        GRASS: '#8bc34a', PATH: '#ded29e', BASE: '#3f51b5', SPAWN: '#d32f2f', 
        TOWER_BASE: '#9e9e9e', DECOR_BG: '#558b2f', DECOR_TREE: '#2e7d32', DECOR_ROCK: '#78909c'
    },
    
    PLAYER: {
        START_MONEY: 125, START_LIVES: 20, HAND_LIMIT: 7
    },
    
    FORGE: {
        COST: 50, ANIMATION_DURATION: 600
    },
    
    TOWER: {
        COST: 55, BASE_DMG: 10, BASE_RANGE: 150, BASE_CD: 40
    },
    
    ENEMY: {
        BASE_HP: 30, HP_GROWTH: 1.15, DROP_CHANCE: 0.08
    },

    ENEMY_TYPES: {
        GRUNT: { id: 'grunt', symbol: 'üëæ', hpMod: 1.1, speed: 1.5, reward: 5, color: '#9c27b0' },
        SCOUT: { id: 'scout', symbol: 'ü¶á', hpMod: 0.6, speed: 3.1, reward: 3, color: '#ffeb3b' },
        TANK:  { id: 'tank',  symbol: 'üêó', hpMod: 2.5, speed: 1.2, reward: 10, color: '#795548' },
        BOSS:  { 
            id: 'boss', symbol: 'üëπ', hpMod: 15.0, speed: 0.6, reward: 150, color: '#ff0000',
            ability: 'summon', summonType: 'SCOUT', summonCd: 180 
        }
    },
    
    WAVES: [
        [ { type: 'GRUNT', count: 15, interval: 80 } ],
        [ { type: 'GRUNT', count: 12, interval: 60 }, { type: 'SCOUT', count: 7, interval: 40 } ],
        [ { type: 'GRUNT', count: 30, interval: 25 } ],
        [ { type: 'GRUNT', count: 12, interval: 50 }, { type: 'TANK', count: 5, interval: 120 }, { type: 'GRUNT', count: 15, interval: 50 } ],
        [ { type: 'SCOUT', count: 18, interval: 30 }, { type: 'TANK', count: 6, interval: 100 } ],
        [ { type: 'TANK', count: 7, interval: 90 }, { type: 'SCOUT', count: 20, interval: 20 } ],
        [ { type: 'GRUNT', count: 30, interval: 20 }, { type: 'BOSS', count: 1, interval: 200 } ]
    ],

    CARD_TYPES: {
        FIRE: { id: 'fire', name: '–°–ø–ª—ç—à', icon: 'üî•', color: '#f44336' },
        ICE: { id: 'ice', name: '–•–æ–ª–æ–¥', icon: '‚ùÑÔ∏è', color: '#00bcd4' },
        SNIPER: { id: 'sniper', name: '–°–Ω–∞–π–ø–µ—Ä', icon: 'üéØ', color: '#4caf50' },
        // –ù–û–í–ê–Ø –ö–ê–†–¢–ê
        MULTISHOT: { id: 'multi', name: '–ó–∞–ª–ø', icon: 'üí•', color: '#ff9800' }
    }
};
</file>

<file path="js/enemy.js">
import { CONFIG } from './config.js';

export class Enemy {
    constructor(path, wave, typeKey = 'GRUNT', startOpts = null) {
        this.path = path;
        if (startOpts) {
            this.idx = startOpts.idx; this.x = startOpts.x; this.y = startOpts.y;
        } else {
            this.idx = 0; this.x = path[0].x * 64 + 32; this.y = path[0].y * 64 + 32;
        }
        
        this.type = CONFIG.ENEMY_TYPES[typeKey];
        const waveScaling = Math.pow(CONFIG.ENEMY.HP_GROWTH, Math.max(0, wave - 1));
        this.maxHp = Math.floor(CONFIG.ENEMY.BASE_HP * this.type.hpMod * waveScaling);
        this.hp = this.maxHp;
        this.baseSpeed = this.type.speed;
        this.reward = this.type.reward;
        
        this.alive = true; 
        this.dying = false; 
        this.deathTimer = 0; 
        
        this.status = []; 
        this.radius = this.type.id === 'boss' ? 24 : 16;
        this.abilityCd = this.type.summonCd || 0;
        
        this.hitFlashTimer = 0; 
    }

    applyStatus(t, d) { this.status.push({type: t, dur: d}); }
    
    update(dt, game) { 
        if (!this.alive) return;
        const timeScale = dt * 60;

        // --- –õ–û–ì–ò–ö–ê –°–ú–ï–†–¢–ò ---
        if (this.dying) {
            this.deathTimer += timeScale;
            if (this.deathTimer > 15) { 
                this.alive = false; 
            }
            return; 
        }

        if (this.hitFlashTimer > 0) this.hitFlashTimer -= timeScale;

        // –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
        if (this.type.ability === 'summon') {
            this.abilityCd -= timeScale;
            if (this.abilityCd <= 0) {
                this.abilityCd = this.type.summonCd;
                game.spawnEnemy(this.type.summonType, { x: this.x, y: this.y, idx: this.idx }, true); 
                game.addEffect({ type: 'explosion', x: this.x, y: this.y, radius: 40, life: 20, color: '#purple' });
            }
        }

        let currentSpeed = this.baseSpeed;
        this.status = this.status.filter(s => s.dur > 0);
        this.status.forEach(s => { 
            s.dur -= timeScale; 
            if (s.type === 'slow') currentSpeed *= 0.6; 
        });

        const t = this.path[this.idx + 1]; 
        if (!t) { 
            this.alive = false; 
            game.hitBase(); 
            return; 
        }

        const dx = (t.x * 64 + 32) - this.x; 
        const dy = (t.y * 64 + 32) - this.y; 
        const dist = Math.hypot(dx, dy);
        const moveDist = currentSpeed * timeScale;

        if (dist < moveDist) {
            this.idx++; 
        } else { 
            this.x += (dx / dist) * moveDist; 
            this.y += (dy / dist) * moveDist; 
        }
    }
    
    takeDamage(amount, game) {
        if (this.dying) return; 

        this.hp -= amount;
        this.hitFlashTimer = 8; // –£–≤–µ–ª–∏—á–∏–ª –≤—Ä–µ–º—è –≤—Å–ø—ã—à–∫–∏ —Å 5 –¥–æ 8 –∫–∞–¥—Ä–æ–≤
        
        if (this.hp <= 0) { 
            this.dying = true;
            this.deathTimer = 0;
            this.hitFlashTimer = 0; // –£–±–∏—Ä–∞–µ–º –≤—Å–ø—ã—à–∫—É –ø—Ä–∏ —Å–º–µ—Ä—Ç–∏

            game.money += this.reward; 
            game.updateUI(); 
            
            const pColor = this.type.color;
            for(let i=0; i<6; i++) {
                game.addEffect({
                    type: 'particle', x: this.x, y: this.y, 
                    vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, color: pColor, life: 30
                });
            }
            game.addEffect({ type: 'text', x: this.x, y: this.y, text: `+${this.reward}$`, color: '#ffd700', life: 40, vy: -1 });
            
            if (Math.random() < CONFIG.ENEMY.DROP_CHANCE) game.spawnLoot(this.x, this.y); 
            if (this.type.id === 'boss' && game.wave === CONFIG.WAVES.length) setTimeout(() => alert("–ü–û–ë–ï–î–ê! –í—ã –æ–¥–æ–ª–µ–ª–∏ –î–µ–º–æ–Ω–∞!"), 100);
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);

        // –≠—Ñ—Ñ–µ–∫—Ç —É–¥–∞—Ä–∞ (–£—Å–∏–ª–µ–Ω–Ω–∞—è —Ç—Ä—è—Å–∫–∞ + —É–≤–µ–ª–∏—á–µ–Ω–∏–µ)
        if (this.hitFlashTimer > 0 && !this.dying) {
            // –¢—Ä—è—Å–∫–∞ —Å—Ç–∞–ª–∞ —Å–∏–ª—å–Ω–µ–µ (–±—ã–ª–æ *4, —Å—Ç–∞–ª–æ *6)
            ctx.translate((Math.random()-0.5)*6, (Math.random()-0.5)*6);
            ctx.scale(1.2, 1.2); 
            
            // –†–ò–°–£–ï–ú –ë–ï–õ–£–Æ –ü–û–î–õ–û–ñ–ö–£ –ü–†–ò –£–î–ê–†–ï (–í—Å–ø—ã—à–∫–∞)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(0, 0, this.radius * 1.5, 0, Math.PI*2);
            ctx.fill();
        }

        // –ê–Ω–∏–º–∞—Ü–∏—è —Å–º–µ—Ä—Ç–∏
        if (this.dying) {
            const scale = 1 - (this.deathTimer / 15);
            ctx.scale(scale, scale);
            ctx.rotate(this.deathTimer * 0.5);
        }

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ë–æ—Å—Å–∞
        if (this.type.id === 'boss') {
            ctx.fillStyle = `rgba(255, 0, 0, ${0.2 + Math.sin(Date.now()/200)*0.1})`;
            ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI*2); ctx.fill();
        }

        ctx.font = (this.type.id === 'boss' ? '48px' : '32px') + ' Segoe UI, sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        
        // –¢–µ–Ω—å
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillText(this.type.symbol, 0, 2);
        
        // –û—Å–Ω–æ–≤–Ω–æ–π —Å–∏–º–≤–æ–ª
        ctx.fillStyle = '#fff';
        if (this.status.some(s => s.type === 'slow')) ctx.fillStyle = '#81d4fa';
        
        // –ï—Å–ª–∏ —É–¥–∞—Ä - –¥–µ–ª–∞–µ–º —ç–º–æ–¥–∑–∏ –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º, —á—Ç–æ–±—ã –±—ã–ª–æ –≤–∏–¥–Ω–æ –±–µ–ª—É—é –ø–æ–¥–ª–æ–∂–∫—É
        if (this.hitFlashTimer > 0 && !this.dying) ctx.globalAlpha = 0.5;
        
        ctx.fillText(this.type.symbol, 0, 0);
        ctx.globalAlpha = 1.0;

        // –ü–æ–ª–æ—Å–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è
        if (!this.dying) {
            const hpPct = Math.max(0, this.hp / this.maxHp);
            const barW = this.type.id === 'boss' ? 50 : 24;
            const barY = - (this.type.id === 'boss' ? 35 : 22);
            
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(-barW/2, barY, barW, 4);
            
            // –ü–æ–ª–æ—Å–∫–∞ —Ç–æ–∂–µ —Ç—Ä—è—Å–µ—Ç—Å—è –∏ –º–µ–Ω—è–µ—Ç —Ü–≤–µ—Ç
            ctx.fillStyle = hpPct > 0.5 ? '#4caf50' : '#f44336';
            if (this.hitFlashTimer > 0) ctx.fillStyle = '#fff'; // –ë–µ–ª–∞—è –ø–æ–ª–æ—Å–∫–∞ –ø—Ä–∏ —É–¥–∞—Ä–µ
            
            ctx.fillRect(-barW/2, barY, barW * hpPct, 4);
        }
        
        ctx.restore();
    }
}
</file>

<file path="js/events.js">
export class EventEmitter {
    constructor() {
        this.events = {};
    }

    on(event, listener) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
    }

    off(event, listener) {
        if (!this.events[event]) return;
        this.events[event] = this.events[event].filter(l => l !== listener);
    }

    emit(event, data) {
        if (!this.events[event]) return;
        this.events[event].forEach(listener => listener(data));
    }
}
</file>

<file path="js/game.js">
import { CONFIG } from './config.js';
import { MapManager } from './map.js';
import { CardSystem } from './card.js';
import { Tower } from './tower.js';
import { Enemy } from './enemy.js';
import { Projectile } from './projectile.js'; 
import { ObjectPool } from './utils.js';
import { EventEmitter } from './events.js'; // +
import { UIManager } from './ui.js';       // +

class Game {
    constructor() {
        this.canvas=document.getElementById('gameCanvas'); this.ctx=this.canvas.getContext('2d');
        this.effectsLayer = document.getElementById('effects-layer');
        this.resize();
        
        // 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –°–æ–±—ã—Ç–∏–π –∏ UI
        this.events = new EventEmitter();
        
        this.money= CONFIG.PLAYER.START_MONEY; 
        this.lives= CONFIG.PLAYER.START_LIVES; 
        this.wave=0; 
        
        this.enemies=[]; this.towers=[]; this.effects=[]; this.projectiles=[];
        this.projectilePool = new ObjectPool(() => new Projectile());

        this.map = new MapManager(Math.floor(this.canvas.width/64), Math.floor((this.canvas.height-160)/64));
        this.cardSys = new CardSystem(this);
        
        // 2. –ü–æ–¥–∫–ª—é—á–∞–µ–º UI –ú–µ–Ω–µ–¥–∂–µ—Ä –ü–û–°–õ–ï —Å–æ–∑–¥–∞–Ω–∏—è —Å–∏—Å—Ç–µ–º (—á—Ç–æ–±—ã –æ–Ω –º–æ–≥ —á–∏—Ç–∞—Ç—å cardSys)
        this.ui = new UIManager(this);

        this.clouds = [];
        for(let i=0; i<12; i++) {
            this.clouds.push({
                x: Math.random() * this.canvas.width, y: Math.random() * this.canvas.height,
                speed: 0.1 + Math.random() * 0.15, size: 60 + Math.random() * 120
            });
        }
        
        this.holdStart = 0; this.isHolding = false;
        this.holdCol = -1; this.holdRow = -1; this.holdDuration = 800; 
        this.isWavePerfect = true; 

        this.canvas.addEventListener('mousedown',e=>this.onMouseDown(e));
        this.canvas.addEventListener('mousemove',e=>this.move(e));
        window.addEventListener('mouseup',e=>this.onMouseUp(e));
        
        // UI —Å–∞–º —Å–ª—É—à–∞–µ—Ç –∫–Ω–æ–ø–∫—É, –Ω–∞–º —Ç—É—Ç –ª–∏—Å—Ç–µ–Ω–µ—Ä –Ω–µ –Ω—É–∂–µ–Ω, –Ω–æ –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–∏–º —Å—Ç–∞—Ä—Ç —á–µ—Ä–µ–∑ –º–µ—Ç–æ–¥
        document.getElementById('start-wave-btn').addEventListener('click',()=>this.startWave());
        
        this.forgeBtn = document.getElementById('forge-btn'); // –û—Å—Ç–∞–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è CardSystem –ø–æ–∫–∞ —á—Ç–æ
        this.forgeBtn.addEventListener('click', () => { this.cardSys.tryForge(); });
        
        this.ghost=document.getElementById('drag-ghost');
        this.infoEl = document.getElementById('tower-info');
        
        // –ü–µ—Ä–≤–∏—á–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
        this.updateUI(); 
        
        this.lastTime = 0;
        requestAnimationFrame((t) => this.loop(t));
    }
    
    resize(){ this.canvas.width=window.innerWidth; this.canvas.height=window.innerHeight; }
    
    // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    updateUI() {
        // –í–º–µ—Å—Ç–æ –ø—Ä—è–º–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è DOM, –º—ã –ø—Ä–æ—Å—Ç–æ –∫—Ä–∏—á–∏–º "–û–±–Ω–æ–≤–∏—Å—å!"
        this.events.emit('ui-update');
    }

    startWave() { 
        if(this.active) return;
        if (this.wave >= CONFIG.WAVES.length) { alert("–í—Å–µ –≤–æ–ª–Ω—ã –ø—Ä–æ–π–¥–µ–Ω—ã!"); return; }

        this.wave++;
        this.active = true;
        this.isWavePerfect = true;
        
        // –°–æ–±—ã—Ç–∏–µ —Å—Ç–∞—Ä—Ç–∞ –≤–æ–ª–Ω—ã
        this.events.emit('wave-start'); 
        this.updateUI();

        this.currentWaveData = CONFIG.WAVES[this.wave - 1]; 
        this.groupIndex = 0;      
        this.groupSpawned = 0;    
        this.spawnTimer = 60;     
    }

    spawnEnemy(typeKey, startOpts = null) {
        this.enemies.push(new Enemy(this.map.path, this.wave, typeKey, startOpts));
    }
    
    spawnLoot(x, y) {
        const typeKeys = Object.keys(CONFIG.CARD_TYPES);
        const randKey = typeKeys[Math.floor(Math.random()*typeKeys.length)];
        const cardType = CONFIG.CARD_TYPES[randKey];
        
        const panelRect = document.getElementById('hand-panel').getBoundingClientRect();
        this.addEffect({
            type: 'loot', startX: x, startY: y,
            endX: panelRect.left + 200, endY: panelRect.top + panelRect.height/2,
            controlX: (x + panelRect.left + 200)/2, controlY: y - 200, 
            progress: 0, 
            cardType: cardType, 
            cardKey: randKey,
            el: null
        });
    }
    
    hitBase() { 
        this.lives--; 
        this.isWavePerfect = false; 
        this.updateUI(); 
        if(this.lives<=0) this.gameOver(); 
        
        this.canvas.style.transform = 'translate(5px, 5px)';
        setTimeout(() => this.canvas.style.transform = 'none', 50);
    }
    
    gameOver() {
        this.active = false;
        // –°–æ–±—ã—Ç–∏–µ –∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã
        this.events.emit('game-over', this.wave);
    }

    addEffect(eff) { this.effects.push(eff); }
    
    move(e) {
        const r=this.canvas.getBoundingClientRect();
        this.mouseX = e.clientX - r.left; this.mouseY = e.clientY - r.top;
        const c = Math.floor(this.mouseX/64); const r_row = Math.floor(this.mouseY/64);
        this.hoverCol = c; this.hoverRow = r_row;
        if(this.dragCard) {
             this.ghost.style.left=(e.pageX - 35)+'px'; this.ghost.style.top=(e.pageY - 50)+'px';
        }
        if (this.isHolding && (c !== this.holdCol || r_row !== this.holdRow)) this.isHolding = false;
        const t = this.towers.find(t=>t.col===c && t.row===r_row);
        if (t && !this.dragCard) this.showInfo(t); else this.hideInfo();
    }

    onMouseDown(e) {
        if (this.dragCard) return;
        const c = this.hoverCol; const rw = this.hoverRow;
        if (this.map.isBuildable(c, rw) && !this.towers.find(t=>t.col===c && t.row===rw)) {
            this.isHolding = true; this.holdStart = performance.now(); this.holdCol = c; this.holdRow = rw;
        }
    }

    onMouseUp(e) {
        if (this.dragCard) { this.dragEnd(e); return; }
        this.isHolding = false;
    }

    tryBuild() {
        if (this.money >= CONFIG.TOWER.COST) {
            this.money -= CONFIG.TOWER.COST;
            const newTower = new Tower(this.holdCol, this.holdRow);
            this.towers.push(newTower);
            this.updateUI();
            this.addEffect({type: 'explosion', x: newTower.x, y: newTower.y, radius: 30, life: 20, color: '#fff'});
            this.isHolding = false; 
        }
    }

    startDragging(c,e) { 
        this.dragCard=c; 
        this.ghost.style.display='flex'; 
        this.ghost.className=`card type-${c.type.id} lvl-${c.level}`; 
        this.ghost.innerHTML=`<div class="card-icon">${c.type.icon}</div><div class="card-level">${c.level}</div>`; 
        this.ghost.style.left=(e.pageX - 35)+'px'; this.ghost.style.top=(e.pageY - 50)+'px';
        this.hideInfo();
    }
    
    dragEnd(e) {
        if(!this.dragCard) return;
        this.ghost.style.display='none';
        let dropped = false;
        const fRect=document.getElementById('forge-panel').getBoundingClientRect();
        if(e.clientX>=fRect.left && e.clientX<=fRect.right && e.clientY>=fRect.top && e.clientY<=fRect.bottom) {
            const idx = e.clientX<fRect.left+fRect.width/2?0:1;
            this.cardSys.putInForge(idx, this.dragCard); dropped = true;
        } else {
            const r=this.canvas.getBoundingClientRect();
            if(e.clientY<r.bottom) {
                const c=Math.floor((e.clientX-r.left)/64), rw=Math.floor((e.clientY-r.top)/64);
                const t=this.towers.find(t=>t.col===c && t.row===rw);
                if(t && t.addCard(this.dragCard)) { 
                    this.cardSys.hand = this.cardSys.hand.filter(c=>c.id!==this.dragCard.id);
                    dropped = true;
                    if (this.hoverCol === t.col && this.hoverRow === t.row) this.showInfo(t);
                }
            }
        }
        if(!dropped) this.dragCard.isDragging = false;
        this.cardSys.render(); this.dragCard=null;
    }

    showInfo(t) {
        const stats = t.getStats();
        this.infoEl.style.display = 'block';
        this.infoEl.style.left = t.x + 'px'; this.infoEl.style.top = (t.y - 40) + 'px';
        document.getElementById('info-dmg').innerText = stats.dmg;
        document.getElementById('info-spd').innerText = (60/stats.cd).toFixed(1) + '/—Å–µ–∫';
        document.getElementById('info-rng').innerText = stats.range;
        const cardsContainer = document.getElementById('info-cards');
        cardsContainer.innerHTML = '';
        t.cards.forEach(c => {
            const mc = document.createElement('div');
            mc.className = 'mini-card'; mc.style.backgroundColor = c.type.color; mc.innerText = c.level;
            cardsContainer.appendChild(mc);
        });
        if(t.cards.length === 0) cardsContainer.innerHTML = '<span style="font-size:10px; color:#888">–ü—É—Å—Ç–æ</span>';
    }

    hideInfo() { this.infoEl.style.display = 'none'; }

    loop(timestamp) {
        try {
            if (!this.lastTime) this.lastTime = timestamp;
            let dt = (timestamp - this.lastTime) / 1000;
            if (dt > 0.1) dt = 0.1; 
            this.lastTime = timestamp;
            const timeScale = dt * 60;

            this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
            this.map.draw(this.ctx);
            
            if(this.hoverCol!==undefined && this.map.isBuildable(this.hoverCol, this.hoverRow)) {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                this.ctx.fillRect(this.hoverCol*64, this.hoverRow*64, 64, 64);
                if (this.isHolding) {
                    const progress = (performance.now() - this.holdStart) / this.holdDuration;
                    const px = this.hoverCol * 64 + 10; const py = this.hoverRow * 64 - 10;
                    this.ctx.fillStyle = '#333'; this.ctx.fillRect(px, py, 44, 8); 
                    this.ctx.fillStyle = '#00ff00'; this.ctx.fillRect(px+1, py+1, 42 * Math.min(progress, 1), 6); 
                    if (progress >= 1) this.tryBuild();
                }
            }
            
            this.towers.forEach(t=>t.draw(this.ctx));
            
            if (this.infoEl.style.display === 'block') {
                const t = this.towers.find(t=>t.col===this.hoverCol && t.row===this.hoverRow);
                if(t) {
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; 
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.beginPath(); this.ctx.arc(t.x, t.y, t.getStats().range, 0, Math.PI*2); this.ctx.fill(); this.ctx.stroke();
                }
            }
            
            this.enemies.forEach(e=>e.draw(this.ctx));
            
            this.projectiles.forEach(p => p.update(dt, this.enemies, this));
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                if (!this.projectiles[i].alive) {
                    this.projectilePool.free(this.projectiles[i]);
                    this.projectiles.splice(i, 1);
                }
            }
            this.projectiles.forEach(p => p.draw(this.ctx));
            
            this.clouds.forEach(c => {
                c.x += c.speed * timeScale; 
                if(c.x > this.canvas.width + c.size) c.x = -c.size;
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; 
                this.ctx.beginPath();
                this.ctx.arc(c.x, c.y, c.size, 0, Math.PI*2);
                this.ctx.arc(c.x + c.size*0.6, c.y + c.size*0.2, c.size*0.8, 0, Math.PI*2);
                this.ctx.fill();
            });

            this.effects=this.effects.filter(e=>e.life===undefined || e.life>0);
            this.effects.forEach(e=>{ 
                if (e.type === 'explosion') {
                    e.life -= timeScale;
                    this.ctx.fillStyle=`rgba(255,100,0,${Math.max(0, e.life/20)})`;
                    this.ctx.beginPath(); this.ctx.arc(e.x,e.y,e.radius,0,Math.PI*2); this.ctx.fill();
                }
                else if (e.type === 'particle') {
                    e.life -= timeScale;
                    e.x += e.vx * timeScale; e.y += e.vy * timeScale; e.vx *= 0.9; e.vy *= 0.9;
                    this.ctx.fillStyle = e.color; this.ctx.globalAlpha = Math.max(0, e.life / 30);
                    this.ctx.fillRect(e.x, e.y, 4, 4); this.ctx.globalAlpha = 1;
                }
                else if (e.type === 'text') {
                    e.life -= timeScale;
                    e.y += e.vy * timeScale;
                    this.ctx.fillStyle = e.color; this.ctx.font = "bold 16px Arial";
                    this.ctx.globalAlpha = Math.max(0, e.life / 40);
                    this.ctx.fillText(e.text, e.x - 10, e.y);
                    this.ctx.globalAlpha = 1;
                    this.ctx.lineWidth = 1; this.ctx.strokeStyle = 'black'; this.ctx.strokeText(e.text, e.x - 10, e.y);
                }
                else if (e.type === 'loot') {
                    e.progress += 0.02 * timeScale;
                    if(!e.el) {
                        e.el = document.createElement('div'); 
                        e.el.className = `loot-item card type-${e.cardType ? e.cardType.id : 'unknown'}`;
                        e.el.style.background = e.cardType ? e.cardType.color : '#ccc'; 
                        e.el.innerHTML = e.cardType ? e.cardType.icon : '?';
                        this.effectsLayer.appendChild(e.el);
                    }
                    if(e.progress >= 1) {
                        e.life = 0; 
                        e.el.remove(); 
                        
                        const success = this.cardSys.addCard(e.cardKey, 1, true);
                        if (!success) {
                            this.money += 15;
                            this.updateUI();
                            const panelRect = document.getElementById('hand-panel').getBoundingClientRect();
                            this.addEffect({
                                type: 'text', x: panelRect.left + 80, y: panelRect.top - 20, 
                                text: "HAND FULL!", color: '#f44336', life: 60, vy: -1
                            });
                            this.addEffect({
                                type: 'text', x: panelRect.left + 80, y: panelRect.top + 10, 
                                text: "+15üí∞", color: '#ffd700', life: 60, vy: -1
                            });
                        }
                    } else {
                        const t = e.progress; const invT = 1 - t;
                        const curX = invT*invT * e.startX + 2*invT*t * e.controlX + t*t * e.endX;
                        const curY = invT*invT * e.startY + 2*invT*t * e.controlY + t*t * e.endY;
                        e.el.style.left = (curX - 20) + 'px'; e.el.style.top = (curY - 28) + 'px';
                        e.el.style.transform = `scale(${0.5 + t*0.5}) rotate(${t*360}deg)`;
                    }
                }
            });
            this.effects = this.effects.filter(e => {
                if (e.type === 'loot' && e.life <= 0 && e.el) e.el.remove();
                return e.life === undefined || e.life > 0;
            });
            
            if(this.active) {
                if (this.currentWaveData && this.groupIndex < this.currentWaveData.length) {
                    this.spawnTimer += timeScale; 
                    const group = this.currentWaveData[this.groupIndex];
                    
                    if (this.spawnTimer >= group.interval) {
                        this.spawnEnemy(group.type);
                        this.spawnTimer = 0;
                        this.groupSpawned++;
                        if (this.groupSpawned >= group.count) {
                            this.groupIndex++;
                            this.groupSpawned = 0;
                            this.spawnTimer = -60; 
                        }
                    }
                }
                else if(this.enemies.length === 0) { 
                    this.active = false; 
                    // –°–æ–±—ã—Ç–∏–µ –∫–æ–Ω—Ü–∞ –≤–æ–ª–Ω—ã
                    this.events.emit('wave-end');
                    
                    let waveReward = 25 + 5 * this.wave;
                    let text = `Wave Clear: +${waveReward}`;
                    let color = '#fff';

                    if (this.isWavePerfect) {
                        const perfectBonus = 15 + 5 * this.wave;
                        waveReward += perfectBonus;
                        text += `\nPERFECT! +${perfectBonus}`;
                        color = '#ffd700';
                    }
                    
                    this.money += waveReward;
                    this.updateUI();

                    this.addEffect({ 
                        type: 'text', x: this.canvas.width/2, y: this.canvas.height/2, 
                        text: text, color: color, life: 120, vy: -0.5 
                    });
                }

                this.enemies.forEach(e=>e.update(dt, this)); 
                this.enemies=this.enemies.filter(e=>e.alive);
                this.towers.forEach(t=>t.update(dt, this.enemies,this));
            }
        } catch (err) { console.error("Loop Error:", err); this.active = false; }
        requestAnimationFrame((t)=>this.loop(t));
    }
}
new Game();
</file>

<file path="js/map.js">
import { CONFIG } from './config.js';

export class MapManager {
    constructor(cols, rows) {
        this.cols = cols; this.rows = rows; 
        this.grid = []; 
        this.path = []; 
        this.initMap();
    }

    initMap() {
        // 1. –ó–∞–ª–∏–≤–∞–µ–º –≤—Å–µ –¥–µ–∫–æ—Ä–æ–º (–õ–µ—Å)
        for(let y=0; y<this.rows; y++) {
            const row=[]; 
            for(let x=0; x<this.cols; x++) {
                let decorType = 'grass';
                const r = Math.random();
                if(r < 0.3) decorType = 'tree';
                else if(r < 0.4) decorType = 'rock';
                
                // type: 2 = DECOR (–Ω–µ–ª—å–∑—è —Å—Ç—Ä–æ–∏—Ç—å)
                row.push({type: 2, x, y, decor: decorType});
            }
            this.grid.push(row);
        }

        // 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ê–ö–¢–ò–í–ù–£–Æ –ó–û–ù–£ (–¶–µ–Ω—Ç—Ä)
        // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –æ—Ç—Å—Ç—É–ø—ã –ø–æ –±–æ–∫–∞–º, —á—Ç–æ–±—ã –∫–∞—Ä—Ç–∞ –±—ã–ª–∞ –º–µ–Ω—å—à–µ –∏ "–∫—É—á–Ω–µ–µ"
        const activeMarginX = 5; // –ë—ã–ª–æ 2, —Å—Ç–∞–ª–æ 5 (—Å—É–∂–∞–µ–º –ø–æ–ª–µ –±–æ—è)
        const activeMarginY = 2; // –°–≤–µ—Ä—Ö—É –∏ —Å–Ω–∏–∑—É –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
        
        // –ó–∞—á–∏—â–∞–µ–º —Ü–µ–Ω—Ç—Ä –ø–æ–¥ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ (Type 0 = Buildable)
        for(let y=activeMarginY; y<this.rows-activeMarginY; y++) {
            for(let x=activeMarginX; x<this.cols-activeMarginX; x++) {
                this.grid[y][x].type = 0;
            }
        }

        // 3. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ü—É—Ç–∏ (Smart Snake)
        let curX = 0;
        let curY = Math.floor(this.rows / 2); // –°—Ç–∞—Ä—Ç –ø–æ —Ü–µ–Ω—Ç—Ä—É –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
        
        const addToPath = (x, y) => {
            if(x >= 0 && x < this.cols && y >= 0 && y < this.rows) {
                this.path.push({x,y});
                this.grid[y][x].type = 1; // 1 = –î–æ—Ä–æ–≥–∞
                this.grid[y][x].decor = null; // –£–±–∏—Ä–∞–µ–º –µ–ª–∫–∏ —Å –¥–æ—Ä–æ–≥–∏
            }
        };

        // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º —Å—Ç–∞—Ä—Ç
        addToPath(curX, curY);

        // –í–µ–¥–µ–º –ø—Ä—è–º—É—é –ª–∏–Ω–∏—é –æ—Ç –∫—Ä–∞—è –¥–æ –∞–∫—Ç–∏–≤–Ω–æ–π –∑–æ–Ω—ã
        while(curX < activeMarginX) {
            curX++;
            addToPath(curX, curY);
        }

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∑–º–µ–π–∫—É –≤–Ω—É—Ç—Ä–∏ –∞–∫—Ç–∏–≤–Ω–æ–π –∑–æ–Ω—ã
        let goingUp = true;
        const zigZagWidth = 3; // –®–∏—Ä–∏–Ω–∞ –ø–µ—Ç–ª–∏
        
        // –ü–æ–∫–∞ –Ω–µ –¥–æ–π–¥–µ–º –¥–æ –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è –∞–∫—Ç–∏–≤–Ω–æ–π –∑–æ–Ω—ã
        while(curX < this.cols - activeMarginX) {
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Å–µ–≥–º–µ–Ω—Ç
            const targetY = goingUp ? activeMarginY + 1 : this.rows - activeMarginY - 2;
            const dir = goingUp ? -1 : 1;
            
            while(curY !== targetY) {
                curY += dir;
                addToPath(curX, curY);
            }
            
            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Å–µ–≥–º–µ–Ω—Ç
            for(let i=0; i<zigZagWidth && curX < this.cols - activeMarginX; i++) {
                curX++;
                addToPath(curX, curY);
            }
            
            goingUp = !goingUp; // –ú–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        }

        // –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä—è–º–∞—è –¥–æ –ø—Ä–∞–≤–æ–≥–æ –∫—Ä–∞—è –∫–∞—Ä—Ç—ã (–≤—ã—Ö–æ–¥)
        while(curX < this.cols) { 
            curX++;
            addToPath(curX, curY); 
        }
    }

    draw(ctx) {
        ctx.lineWidth = 1;
        for(let y=0; y<this.rows; y++) for(let x=0; x<this.cols; x++) {
            const c = this.grid[y][x]; const px=x*64, py=y*64;
            
            if (c.type === 2) { // DECOR
                ctx.fillStyle = CONFIG.COLORS.DECOR_BG;
                ctx.fillRect(px, py, 64, 64);
                
                if(c.decor === 'tree') {
                    ctx.fillStyle = CONFIG.COLORS.DECOR_TREE;
                    ctx.beginPath();
                    ctx.moveTo(px + 32, py + 10);
                    ctx.lineTo(px + 10, py + 54);
                    ctx.lineTo(px + 54, py + 54);
                    ctx.fill();
                } else if (c.decor === 'rock') {
                    ctx.fillStyle = CONFIG.COLORS.DECOR_ROCK;
                    ctx.beginPath();
                    ctx.ellipse(px + 32, py + 40, 15, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = 'rgba(0,0,0,0.1)'; // –¢–µ–Ω—å
                ctx.fillRect(px, py, 64, 64);
                
            } else if (c.type === 1) { // PATH
                ctx.fillStyle = CONFIG.COLORS.PATH;
                ctx.fillRect(px, py, 64, 64);
            } else { // BUILDABLE
                ctx.fillStyle = CONFIG.COLORS.GRASS;
                ctx.fillRect(px, py, 64, 64);
                ctx.strokeStyle = 'rgba(0,0,0,0.05)'; ctx.beginPath(); ctx.rect(px, py, 64, 64); ctx.stroke();
            }
        }
        
        const s=this.path[0], e=this.path[this.path.length-1];
        if(s) this.drawCave(ctx, s);
        if(e) this.drawFortress(ctx, e);
    }

    drawCave(ctx, p) {
        const x = p.x * 64 + 32;
        const y = p.y * 64 + 32;
        ctx.fillStyle = '#222';
        ctx.beginPath(); ctx.arc(x, y + 10, 25, Math.PI, 0); ctx.fill();
        ctx.strokeStyle = '#555'; ctx.lineWidth = 4; ctx.stroke();
        ctx.fillStyle = '#fff'; ctx.font = '20px Arial'; ctx.fillText('‚ò†Ô∏è', x - 12, y + 15);
    }

    drawFortress(ctx, p) {
        const x = p.x * 64;
        const y = p.y * 64;
        ctx.fillStyle = '#555'; ctx.fillRect(x + 10, y + 10, 44, 44);
        ctx.fillStyle = '#333';
        ctx.fillRect(x + 10, y + 5, 10, 10); ctx.fillRect(x + 27, y + 5, 10, 10); ctx.fillRect(x + 44, y + 5, 10, 10);
        ctx.fillStyle = '#3e2723'; ctx.beginPath(); ctx.arc(x + 32, y + 54, 15, Math.PI, 0); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = '20px Arial'; ctx.fillText('üè∞', x + 22, y + 40);
    }

    isBuildable(c,r) { return c>=0 && c<this.cols && r>=0 && r<this.rows && this.grid[r][c].type===0; }
}
</file>

<file path="js/projectile.js">
export class Projectile {
    constructor() {
        this.reset();
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è (–≤–º–µ—Å—Ç–æ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ —á–µ—Ä–µ–∑ new)
    init(x, y, target, stats) {
        this.x = x; this.y = y; 
        this.radius = 4; 
        this.alive = true;
        this.damage = stats.dmg; 
        this.speed = stats.speed;
        this.color = stats.color; 
        this.effects = stats.effects;
        this.pierce = stats.pierce || 0; 
        this.hitList = [];
        
        const angle = Math.atan2(target.y - y, target.x - x);
        this.vx = Math.cos(angle) * this.speed; 
        this.vy = Math.sin(angle) * this.speed;
        this.life = 100; // –ñ–∏–∑–Ω—å –≤ –∫–∞–¥—Ä–∞—Ö (–±—É–¥–µ–º –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å)
    }

    reset() {
        this.x = 0; this.y = 0;
        this.hitList = [];
        this.alive = false;
    }

    update(dt, enemies, game) {
        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏: —É–º–Ω–æ–∂–∞–µ–º –Ω–∞ 60, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å –∫–æ–Ω—Ñ–∏–≥–∞
        const timeScale = dt * 60;

        this.x += this.vx * timeScale; 
        this.y += this.vy * timeScale; 
        
        this.life -= timeScale;
        
        if(this.life <= 0 || this.x<0 || this.x>game.canvas.width || this.y<0 || this.y>game.canvas.height) {
            this.alive = false;
        }

        for(let e of enemies) {
            if(this.hitList.includes(e)) continue;
            // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–∏
            if (Math.hypot(e.x - this.x, e.y - this.y) < (e.radius + this.radius)) {
                this.hit(e, game);
                if(this.pierce > 0) { 
                    this.pierce--; 
                    this.hitList.push(e); 
                } else { 
                    this.alive = false; 
                    break; 
                }
            }
        }
    }

    hit(target, game) {
        const splash = this.effects.find(e => e.type === 'splash');
        if (splash) {
            game.addEffect({type: 'explosion', x: target.x, y: target.y, radius: splash.radius, life: 20});
            game.enemies.forEach(o => { 
                if(Math.hypot(o.x - target.x, o.y - target.y) < splash.radius) 
                    o.takeDamage(this.damage, game); 
            });
        } else {
            target.takeDamage(this.damage, game);
        }
        
        const slow = this.effects.find(e => e.type === 'slow');
        if (slow) target.applyStatus('slow', slow.dur);
    }
    
    draw(ctx) {
        ctx.fillStyle = this.color; 
        ctx.beginPath(); 
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); 
        ctx.fill();
    }
}
</file>

<file path="js/tower.js">
import { CONFIG } from './config.js';

export class Tower {
    constructor(c,r) {
        this.col=c; this.row=r; this.x=c*64+32; this.y=r*64+32;
        this.cards=[]; this.cooldown=0; this.angle=0;
    }

    getStats() {
        let s = { 
            range: CONFIG.TOWER.BASE_RANGE, 
            dmg: CONFIG.TOWER.BASE_DMG, 
            cd: CONFIG.TOWER.BASE_CD, 
            speed: 8, 
            color: '#ffd700', effects:[], pierce: 0,
            projCount: 1, // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 1 –≤—ã—Å—Ç—Ä–µ–ª
            spread: 0     // –†–∞–∑–±—Ä–æ—Å –≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö
        };

        // –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –æ –∫–∞—Ä—Ç–∞—Ö
        let multiCards = [];
        
        this.cards.forEach(c => {
            const lvl = c.level;
            
            if(c.type.id === 'sniper') { 
                s.range += 60*lvl; 
                s.dmg += 8*lvl; 
                s.speed = 15; 
                s.cd += 10; 
                s.color = '#4caf50'; 
                if(lvl >= 3) s.pierce = 1; 
            }
            if(c.type.id === 'fire') { 
                s.effects.push({type:'splash', radius:40+(lvl*20)}); 
                s.color = '#f44336'; 
                s.dmg += 5*lvl; 
                s.speed = 6; 
            }
            if(c.type.id === 'ice') { 
                s.effects.push({type:'slow', dur:60*lvl}); 
                s.color = '#00bcd4'; 
                s.speed = 10; 
            }
            if(c.type.id === 'multi') {
                multiCards.push(c);
                s.color = '#ff9800';
            }
        });

        // –õ–û–ì–ò–ö–ê –ú–£–õ–¨–¢–ò–í–´–°–¢–†–ï–õ–ê
        if (multiCards.length > 0) {
            // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –∫–∞—Ä—Ç—ã, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–∂–∏–º —Å—Ç—Ä–µ–ª—å–±—ã
            const maxLvl = Math.max(...multiCards.map(c => c.level));
            let dmgMod = 1.0;
            let cdMod = 1.0;

            if (maxLvl === 1) {
                s.projCount = 2; dmgMod = 0.6; cdMod = 1.1; // 10% –º–µ–¥–ª–µ–Ω–Ω–µ–µ
            } else if (maxLvl === 2) {
                s.projCount = 3; dmgMod = 0.45; cdMod = 1.1; 
            } else if (maxLvl >= 3) {
                s.projCount = 3; dmgMod = 0.5; cdMod = 1.0; // –ë–µ–∑ —à—Ç—Ä–∞—Ñ–∞ –∫ —Å–∫–æ—Ä–æ—Å—Ç–∏
            }

            // –ë–æ–Ω—É—Å—ã –∑–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã (Stacking)
            // –ï—Å–ª–∏ –∫–∞—Ä—Ç > 1, –¥–æ–±–∞–≤–ª—è–µ–º –±–æ–Ω—É—Å—ã –∑–∞ –∫–∞–∂–¥—É—é –õ–ò–®–ù–Æ–Æ
            const extraCards = multiCards.length - 1;
            if (extraCards > 0) {
                dmgMod += 0.15 * extraCards; // +15% –∑–∞ –∫–æ–ø–∏—é
                cdMod -= 0.07 * extraCards;  // +7% –∫ —Å–∫–æ—Ä–æ—Å—Ç–∏ (—É–º–µ–Ω—å—à–µ–Ω–∏–µ CD)
            }

            s.dmg = Math.floor(s.dmg * dmgMod);
            s.cd = Math.floor(s.cd * cdMod);
            s.spread = 0.3; // –†–∞–∑–±—Ä–æ—Å –æ–∫–æ–ª–æ 17 –≥—Ä–∞–¥—É—Å–æ–≤
        }

        return s;
    }

    addCard(c) { if(this.cards.length<3) { this.cards.push(c); return true; } return false; }
    
    update(dt, enemies, game) {
        const s = this.getStats();
        const timeScale = dt * 60;
        
        if(this.cooldown > 0) this.cooldown -= timeScale;
        
        let target=null, min=Infinity;
        // –ù–µ —Å—Ç—Ä–µ–ª—è–µ–º –ø–æ —É–º–∏—Ä–∞—é—â–∏–º –≤—Ä–∞–≥–∞–º (dying)
        for(let e of enemies) {
            if (e.dying) continue; 
            const d = Math.hypot(e.x-this.x, e.y-this.y);
            if(d<=s.range && d<min) { min=d; target=e; }
        }
        
        if(target) {
            this.angle = Math.atan2(target.y-this.y, target.x-this.x);
            
            if(this.cooldown <= 0) { 
                // –¶–∏–∫–ª –¥–ª—è –º—É–ª—å—Ç–∏–≤—ã—Å—Ç—Ä–µ–ª–∞
                const startAngle = this.angle - (s.spread * (s.projCount - 1)) / 2;
                
                for(let i = 0; i < s.projCount; i++) {
                    const currentAngle = startAngle + i * s.spread;
                    
                    // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ç–∞—Ä–≥–µ—Ç-–æ–±—ä–µ–∫—Ç –¥–ª—è –∑–∞–¥–∞–Ω–∏—è —É–≥–ª–∞
                    // (–¢–∞–∫ –∫–∞–∫ Projectile —Å—á–∏—Ç–∞–µ—Ç —É–≥–æ–ª –æ—Ç —Ü–µ–ª–∏, –º—ã "–æ–±–º–∞–Ω—ã–≤–∞–µ–º" –µ–≥–æ)
                    const fakeTarget = {
                        x: this.x + Math.cos(currentAngle) * 100,
                        y: this.y + Math.sin(currentAngle) * 100
                    };

                    const p = game.projectilePool.obtain();
                    p.init(this.x, this.y, fakeTarget, s);
                    game.projectiles.push(p);
                }
                
                this.cooldown = s.cd; 
            }
        }
    }
    
    draw(ctx) {
        ctx.fillStyle=CONFIG.COLORS.TOWER_BASE; ctx.beginPath(); ctx.arc(this.x,this.y,20,0,Math.PI*2); ctx.fill();
        for(let i=0;i<3;i++) {
            const a=(i*(Math.PI*2/3))-Math.PI/2;
            ctx.beginPath(); ctx.arc(this.x+Math.cos(a)*12,this.y+Math.sin(a)*12,4,0,Math.PI*2);
            ctx.fillStyle=this.cards[i]?this.cards[i].type.color:'#444'; ctx.fill(); ctx.stroke();
        }
        ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
        ctx.fillStyle='#333'; ctx.fillRect(-5,-5,25,10);
        
        // –í–∏–∑—É–∞–ª—å–Ω–æ–µ –æ—Ç–ª–∏—á–∏–µ –¥–ª—è –ú—É–ª—å—Ç–∏–≤—ã—Å—Ç—Ä–µ–ª–∞ (—à–∏—Ä–æ–∫–æ–µ –¥—É–ª–æ)
        if (this.cards.some(c => c.type.id === 'multi')) {
             ctx.fillStyle='#ff9800'; 
             ctx.fillRect(-8, -8, 25, 4); // –î–æ–ø —Å—Ç–≤–æ–ª—ã
             ctx.fillRect(-8, 4, 25, 4);
        }

        ctx.fillStyle='#666'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
        ctx.restore();
    }
}
</file>

<file path="js/ui.js">
import { CONFIG } from './config.js';

export class UIManager {
    constructor(game) {
        this.game = game;
        
        // –ö—ç—à–∏—Ä—É–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã, —á—Ç–æ–±—ã –Ω–µ –∏—Å–∫–∞—Ç—å –∏—Ö –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä
        this.elMoney = document.getElementById('money');
        this.elWave = document.getElementById('wave');
        this.elLives = document.getElementById('lives');
        this.elForgeBtn = document.getElementById('forge-btn');
        this.elStartBtn = document.getElementById('start-wave-btn');
        this.elGameOver = document.getElementById('game-over');
        this.elFinalWave = document.getElementById('final-wave');

        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏—è –∏–≥—Ä—ã
        const evt = game.events;

        evt.on('ui-update', () => this.renderStats());
        evt.on('wave-start', () => this.toggleStartBtn(false));
        evt.on('wave-end', () => this.toggleStartBtn(true));
        evt.on('game-over', (wave) => this.showGameOver(wave));
    }

    renderStats() {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç
        this.elMoney.innerText = this.game.money;
        this.elWave.innerText = this.game.wave + "/" + CONFIG.WAVES.length;
        this.elLives.innerText = this.game.lives;

        // –õ–æ–≥–∏–∫–∞ –∫–Ω–æ–ø–∫–∏ –ö—É–∑–Ω–∏—Ü—ã
        const cardSys = this.game.cardSys;
        const canForge = cardSys && cardSys.canForge();
        const hasMoney = this.game.money >= CONFIG.FORGE.COST;

        if (canForge && hasMoney) {
            this.elForgeBtn.disabled = false;
            this.elForgeBtn.innerHTML = `<span>‚öíÔ∏è</span>–ö–û–í–ê–¢–¨`;
        } else {
            this.elForgeBtn.disabled = true;
            this.elForgeBtn.innerHTML = `<span>‚öíÔ∏è</span>${CONFIG.FORGE.COST}üí∞`;
        }
    }

    toggleStartBtn(active) {
        this.elStartBtn.disabled = !active;
    }

    showGameOver(wave) {
        this.elGameOver.style.display = 'flex';
        this.elFinalWave.innerText = wave;
    }
}
</file>

<file path="js/utils.js">
export function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

export class ObjectPool {
    constructor(createFn) {
        this.createFn = createFn;
        this.pool = [];
    }

    obtain() {
        return this.pool.length > 0 ? this.pool.pop() : this.createFn();
    }

    free(obj) {
        if (obj.reset) obj.reset();
        this.pool.push(obj);
    }
}
</file>

<file path="Math.random()">

</file>

<file path="public/assets/README.md">
# Asset Integration Guide

## üìÅ Folder Structure

Assets should be placed in the following directories:

```
public/assets/images/
‚îú‚îÄ‚îÄ tiles/          # Environment tiles (grass, path, fog, decorations)
‚îú‚îÄ‚îÄ towers/         # Tower bases and turrets
‚îú‚îÄ‚îÄ modules/        # Tower upgrade modules
‚îú‚îÄ‚îÄ enemies/        # Enemy sprites
‚îú‚îÄ‚îÄ props/          # Enemy props (shields, weapons, etc.)
‚îú‚îÄ‚îÄ projectiles/    # Projectile sprites
‚îî‚îÄ‚îÄ effects/        # Visual effects (kept procedural for now)
```

---

## üé® Asset Naming Convention

### Basic Assets

Use the exact name from the game (see list below):

```
grass.png
path.png
turret_ice.png
enemy_skeleton.png
```

### Multi-Variant Assets (for randomization)

To add multiple variants of the same asset, use `_1`, `_2`, `_3`, etc.:

```
grass.png        # Main variant (always required)
grass_1.png      # Variant 1 (optional, will be randomly chosen)
grass_2.png      # Variant 2 (optional)
grass_3.png      # Variant 3 (optional)
```

**The system will:**

1. Try to load the main file (grass.png)
2. Then try loading variants (grass_1.png, grass_2.png, ... up to grass_5.png)
3. Randomly select one variant each time `Assets.get('grass')` is called

**Max variants:** Configured per asset (see below)

---

## üìã Complete Asset List

### Environment Tiles (folder: `tiles/`)

| Asset Name | Variants Support | Max Variants | Description |
|------------|------------------|--------------|-------------|
| `grass.png` | ‚úÖ Yes | 5 | Ground grass tile |
| `path.png` | ‚úÖ Yes | 3 | Road/path tile |
| `fog_0.png` ... `fog_15.png` | ‚ùå No | 0 | Fog tiles (16 bitmask variants) |
| `tree.png` | ‚úÖ Yes | 3 | Tree decoration |
| `rock.png` | ‚úÖ Yes | 5 | Large rock decoration |
| `stone.png` | ‚úÖ Yes | 3 | Small stones |
| `wheat.png` | ‚úÖ Yes | 2 | Wheat field |
| `flowers.png` | ‚úÖ Yes | 3 | Flowering grass |

**Note:** Fog tiles are numbered 0-15 for bitmask system. DO NOT add variants for  fog tiles.

---

### Towers (folder: `towers/`)

| Asset Name | Variants | Description |
|------------|----------|-------------|
| `base.png` | No | Tower platform (old name) |
| `base_default.png` | No | Tower platform |
| `gun.png` | No | Basic gun (old name) |
| `turret_standard.png` | No | Standard turret |
| `turret_ice.png` | No | Ice turret |
| `turret_fire.png` | No | Fire/Mortar turret |
| `turret_sniper.png` | No | Sniper turret |
| `turret_split.png` | No | Multishot turret |
| `turret_minigun.png` | No | Minigun turret |

---

### Modules (folder: `modules/`)

| Asset Name | Description |
|------------|-------------|
| `ice.png` | Ice module overlay |
| `fire.png` | Fire module overlay |
| `sniper.png` | Sniper module overlay |
| `split.png` | Split module overlay |
| `minigun.png` | Minigun module overlay |

---

### Enemies (folder: `enemies/`)

| Asset Name | Variants Support | Max Variants | Description |
|------------|------------------|--------------|-------------|
| `skeleton.png` | ‚úÖ Yes | 3 | Skeleton enemy |
| `wolf.png` | ‚úÖ Yes | 2 | Wolf enemy |
| `troll.png` | ‚úÖ Yes | 2 | Troll enemy |
| `spider.png` | ‚úÖ Yes | 2 | Spider boss |

---

### Enemy Props (folder: `props/`)

| Asset Name | Description |
|------------|-------------|
| `shield.png` | Shield prop |
| `helmet.png` | Helmet prop |
| `weapon.png` | Weapon prop |
| `barrier.png` | Energy barrier prop |

---

### Projectiles (folder: `projectiles/`)

| Asset Name | Description |
|------------|-------------|
| `standard.png` | Standard projectile |
| `ice.png` | Ice shard projectile |
| `fire.png` | Fireball projectile |
| `sniper.png` | Sniper bullet |
| `split.png` | Multishot pellet |
| `minigun.png` | Minigun tracer |

---

### Effects (folder: `effects/`)

**Note:** Effects are kept procedural for performance. PNG loading disabled for these.

---

## üîÑ How It Works

### 1. Loading Priority

1. **Try PNG**: System attempts to load PNG from `/assets/images/`
2. **Fallback**: If PNG not found, generates procedural texture
3. **Variants**: If multiple variants exist, stores all for random selection

### 2. Variant Example

If you have:

```
public/assets/images/tiles/
  ‚îú‚îÄ‚îÄ grass.png       # Will be loaded ‚úì
  ‚îú‚îÄ‚îÄ grass_1.png     # Will be loaded as variant ‚úì
  ‚îú‚îÄ‚îÄ grass_2.png     # Will be loaded as variant ‚úì
  ‚îî‚îÄ‚îÄ grass_3.png     # Will be loaded as variant ‚úì
```

Result: `Assets.get('grass')` will randomly return one of  4 variants

### 3. Missing Assets

If `grass.png` is missing, the system will:

1. Log: `"grass.png not found, will use procedural fallback"`
2. Generate procedural grass texture automatically
3. Game continues running normally

---

## üéØ Asset Specifications

See `graphics_report.md` for detailed specifications of each asset:

- Exact dimensions (64x64px, 48x48px, etc.)
- Color schemes
- Visual style guidelines
- Generation prompts for AI tools

---

## üöÄ Getting Started

### Minimal Setup (Test hybrid system)

Just add these 3 files to test:

```
public/assets/images/tiles/grass.png
public/assets/images/enemies/skeleton.png
public/assets/images/projectiles/standard.png
```

The rest will use procedural fallback.

### Full Art Pass

Generate all assets from `graphics_report.md` and place them in respective folders.

---

## üîß Configuration

### Enable/Disable PNG Loading

In `Assets.ts` line 13:

```typescript
private static USE_EXTERNAL_ASSETS = true;  // Use PNG files
private static USE_EXTERNAL_ASSETS = false; // Only procedural
```

### Change Max Variants

In `Assets.ts` `loadExternalAssets()` method, modify the numbers:

```typescript
loadTasks.push(this.loadImage('grass', 'tiles/grass.png', 5));  // 5 = up to 5 variants
loadTasks.push(this.loadImage('grass', 'tiles/grass.png', 10)); // Change to 10
```

---

## üìä Loading Statistics

The console will display loading stats:

```
Assets: External loading complete! Loaded: 42, Failed: 14
Assets: Found 4 variants for "grass"
Assets: Found 2 variants for "enemy_skeleton"
Assets: Loading complete! Total: 180 assets (42 PNG, 138 procedural)
```

---

## ‚úÖ Testing

1. Start the game: `npm run dev`
2. Check browser console for asset loading logs
3. Missing assets will use procedural fallback (game won't break)
4. Any errors will be visible in console

---

## üìù Notes

- **File format:** PNG with transparency (alpha channel)
- **Sizes:** Must match specifications in `graphics_report.md`
- **Direction:** Turrets should face **RIGHT** (East) in the image
- **Tiles:** Must be seamless/tileable for grass, path
- **Naming:** Case-sensitive, use exact names from lists above

---

**Status:** Hybrid system active ‚úì  
**Fallback:** Procedural generation enabled ‚úì  
**Variants:** Multi-variant randomization supported ‚úì
</file>

<file path="review.md">
# Visual Review: –≠–≤–æ–ª—é—Ü–∏—è Ink Style

–≠—Ç–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –∫–æ–Ω—Ü–µ–ø—Ç **–≠–≤–æ–ª—é—Ü–∏–∏** —Ç–µ–∫—É—â–µ–≥–æ –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Å—Ç–∏–ª—è ("Ink on Paper"). –ú—ã –æ—Ç–∫–∞–∑—ã–≤–∞–µ–º—Å—è –æ—Ç —Ä–∞–¥–∏–∫–∞–ª—å–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π (–ù–µ–æ–Ω, –ß–µ—Ä—Ç–µ–∂) –≤ –ø–æ–ª—å–∑—É –ø–æ–ª–∏—Ä–æ–≤–∫–∏, –≥–ª—É–±–∏–Ω—ã –∏ "—Å–æ—á–Ω–æ—Å—Ç–∏" (Juice) —Ç–µ–∫—É—â–µ–π –∞—Ç–º–æ—Å—Ñ–µ—Ä—ã.

![Koncept Evolution Style](/C:/Users/Luisa/.gemini/antigravity/brain/9a7d1c1a-6dbe-46d2-a8bc-489cb5627d48/ink_style_evolution_concept_1769433126532.png)

## –ö–ª—é—á–µ–≤—ã–µ –≠–ª–µ–º–µ–Ω—Ç—ã "–≠–≤–æ–ª—é—Ü–∏–∏"

1. **–ê–∫–≤–∞—Ä–µ–ª—å–Ω–∞—è –ó–∞–ª–∏–≤–∫–∞ (Watercolor Wash):**
    * **–°–µ–π—á–∞—Å:** –û–¥–Ω–æ—Ç–æ–Ω–Ω—ã–µ –ª–∏–Ω–∏–∏ –∏ –ø—É—Å—Ç–æ—Ç–∞.
    * **–ë—É–¥–µ—Ç:** –õ–µ–≥–∫–∏–µ, –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ –ø—è—Ç–Ω–∞ —Ü–≤–µ—Ç–∞ (–∑–µ–ª–µ–Ω—ã–π –¥–ª—è —Ç—Ä–∞–≤—ã, —Å–∏–Ω–∏–π –¥–ª—è –ª—å–¥–∞), –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ–±—Ä–µ–∂–Ω–æ –≤—ã—Ö–æ–¥—è—Ç –∑–∞ –∫–æ–Ω—Ç—É—Ä—ã. –≠—Ç–æ –¥–æ–±–∞–≤–∏—Ç –∂–∏–∑–Ω–∏, –Ω–µ –ø–µ—Ä–µ–≥—Ä—É–∂–∞—è –∫–∞—Ä—Ç–∏–Ω–∫—É.
    * *–¢–µ—Ö–Ω–∏–∫–∞:* –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–ª–æ–µ–≤ –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã—Ö –ø–æ–ª–∏–≥–æ–Ω–æ–≤ —Å —à—É–º–æ–º –ø–µ—Ä–ª–∏–Ω–∞ –¥–ª—è –∫—Ä–∞–µ–≤.

2. **–ì–ª—É–±–∏–Ω–∞ –®—Ç—Ä–∏—Ö–∞ (Dynamic Hatching):**
    * **–°–µ–π—á–∞—Å:** –ü—Ä–æ—Å—Ç–æ –∫–æ–Ω—Ç—É—Ä—ã.
    * **–ë—É–¥–µ—Ç:** –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —à—Ç—Ä–∏—Ö–æ–≤–∫–∞ (hatching) –≤ —Ç–µ–Ω—è—Ö –±–∞—à–µ–Ω –∏ —Å—Ç–µ–Ω. –ì—É—Å—Ç–æ—Ç–∞ —à—Ç—Ä–∏—Ö–æ–≤–∫–∏ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —É–≥–ª–∞ –æ—Å–≤–µ—â–µ–Ω–∏—è.

3. **–ß–µ—Ä–Ω–∏–ª—å–Ω–∞—è –§–∏–∑–∏–∫–∞ (Liquid Ink):**
    * **–≠—Ñ—Ñ–µ–∫—Ç—ã:** –í–∑—Ä—ã–≤—ã ‚Äî —ç—Ç–æ —Ä–∞–∑–ª–µ—Ç–∞—é—â–∏–µ—Å—è –∫–∞–ø–ª–∏ —á–µ—Ä–Ω–∏–ª.
    * **–°–ª–µ–¥:** –í—Ä–∞–≥–∏ –æ—Å—Ç–∞–≤–ª—è—é—Ç –∑–∞ —Å–æ–±–æ–π –∏—Å—á–µ–∑–∞—é—â–∏–π —á–µ—Ä–Ω–∏–ª—å–Ω—ã–π —Å–ª–µ–¥.
    * *Safe Mode:* –ï—Å–ª–∏ —Å–ª–∏—à–∫–æ–º –Ω–∞–≥—Ä—É–∂–∞–µ—Ç —Å–∏—Å—Ç–µ–º—É, –æ—Ç–∫–ª—é—á–∞–µ—Ç—Å—è –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.

4. **UI "–ó–∞–ø–∏—Å–∫–∏ –Ω–∞ –ø–æ–ª—è—Ö":**
    * –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø–µ—Ä–µ—Å—Ç–∞–Ω–µ—Ç –±—ã—Ç—å –ø—Ä–æ—Å—Ç–æ "–∫–æ—Ä–æ–±–∫–∞–º–∏ –ø–æ–≤–µ—Ä—Ö —ç–∫—Ä–∞–Ω–∞". –ö–Ω–æ–ø–∫–∏ –∏ –ø–∞–Ω–µ–ª–∏ –±—É–¥—É—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å –∫–∞–∫ –æ–±—Ä—ã–≤–∫–∏ –±—É–º–∞–≥–∏, –ø—Ä–∏–∫–æ–ª–æ—Ç—ã–µ –∫–Ω–æ–ø–∫–∞–º–∏ –∫ –∫–∞—Ä—Ç–µ, –∏–ª–∏ –∑–∞–º–µ—Ç–∫–∏ –Ω–∞ –ø–æ–ª—è—Ö.

---

## –ü–ª–∞–Ω –†–µ–∞–ª–∏–∑–∞—Ü–∏–∏ (–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å)

–ú—ã —Å—Ç—Ä–æ–≥–æ —Å–æ–±–ª—é–¥–∞–µ–º –ø—Ä–∏–Ω—Ü–∏–ø –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏. –í–µ—Å—å –Ω–æ–≤—ã–π —Ä–µ–Ω–¥–µ—Ä –±—É–¥–µ—Ç –∂–∏—Ç—å –≤–Ω—É—Ç—Ä–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã, –Ω–µ –ª–æ–º–∞—è —Å—Ç–∞—Ä—ã–π `SPRITE` —Ä–µ–∂–∏–º.

### 1. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è

–í `Config.ts` —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è —Ñ–ª–∞–≥:

```typescript
export const CONFIG = {
    VISUAL_STYLE: 'INK_EVO', // –í–∞—Ä–∏–∞–Ω—Ç—ã: 'SPRITE' | 'INK_LEGACY' | 'INK_EVO'
    // ...
}
```

* –í—Å–µ –Ω–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã (–∞–∫–≤–∞—Ä–µ–ª—å, —á–∞—Å—Ç–∏—Ü—ã) –æ–±–æ—Ä–∞—á–∏–≤–∞—é—Ç—Å—è –≤ –ø—Ä–æ–≤–µ—Ä–∫–∏.
* –ü—Ä–∏ –æ—à–∏–±–∫–µ –∏–ª–∏ –∂–µ–ª–∞–Ω–∏–∏ –∏–≥—Ä–æ–∫–∞ –º–æ–∂–Ω–æ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ —Å—Ç–∞—Ä—ã–π –≤–∏–¥.

### 2. –≠—Ç–∞–ø—ã –í–Ω–µ–¥—Ä–µ–Ω–∏—è

1. **Phase 1: Watercolor & Paper Update.** –ó–∞–º–µ–Ω–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ñ–æ–Ω–∞ –Ω–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—É—é –±—É–º–∞–≥—É + –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ª–æ—è –∞–∫–≤–∞—Ä–µ–ª–∏ –¥–ª—è –∑–æ–Ω (—Ç—Ä–∞–≤–∞, –≤–æ–¥–∞).
2. **Phase 2: Advanced Ink Renderer.** –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —à—Ç—Ä–∏—Ö–æ–≤–∫–∏ (Hatching) –¥–ª—è –±–∞—à–µ–Ω –∏ —Å—Ç–µ–Ω.
3. **Phase 3: Ink Particles.** –°–∏—Å—Ç–µ–º–∞ —á–∞—Å—Ç–∏—Ü –¥–ª—è –≤–∑—Ä—ã–≤–æ–≤ –∏ —Å–Ω–∞—Ä—è–¥–æ–≤.
4. **Phase 4: UI Paper Skin.** –†–µ—Å–∫–∏–Ω –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –ø–æ–¥ –±—É–º–∞–∂–Ω—ã–µ –∑–∞–º–µ—Ç–∫–∏.

---
**–í–µ—Ä–¥–∏–∫—Ç:** –≠—Ç–æ—Ç –ø–ª–∞–Ω –¥–µ–ª–∞–µ—Ç –∫–∞—Ä—Ç–∏–Ω–∫—É —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π, –¥–æ—Ä–æ–≥–æ–π –∏ —Ü–µ–ª–æ—Å—Ç–Ω–æ–π, —Å–æ—Ö—Ä–∞–Ω—è—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å "—Ä–∏—Å–æ–≤–∞–Ω–Ω–æ–≥–æ" —Å—Ç–∏–ª—è.
</file>

<file path="scripts/verify.js">
const { execSync } = require('child_process');

console.log('Running Type Check...');
try {
    execSync('npx tsc --noEmit', { stdio: 'inherit' });
    console.log('‚úÖ Type Check Passed');
} catch (error) {
    console.error('‚ùå Type Check Failed');
    process.exit(1);
}
</file>

<file path="src/BaseScene.ts">
import { Scene } from './Scene';

export class BaseScene implements Scene {
    protected listeners: Array<{ target: EventTarget; type: string; handler: EventListener }> = [];

    public onEnter(): void { }

    public onExit(): void {
        this.dispose();
    }

    public update(): void { }

    public draw(_ctx: CanvasRenderingContext2D): void { }

    public on(target: EventTarget, type: string, handler: EventListener) {
        target.addEventListener(type, handler);
        this.listeners.push({ target, type, handler });
    }

    public dispose() {
        this.listeners.forEach((l) => l.target.removeEventListener(l.type, l.handler));
        this.listeners = [];
    }
}
</file>

<file path="src/CardStackingSystem.ts">
import { ICard } from './CardSystem';
import { ICardModifiers, ICardEffect } from './cards/CardType';
import { getCardUpgrade } from './cards';

/**
 * Card Stacking System
 * 
 * Implements the advanced card stacking logic where:
 * - Different card types: All bonuses sum normally
 * - Same card types: Highest level = 100%, others contribute by level:
 *   - Level 3: 70% of stats
 *   - Level 2: 50% of stats
 *   - Level 1: 35% of stats
 */

/**
 * Get stacking bonus percentage based on card level
 */
export function getStackingBonus(level: number): number {
    switch (level) {
        case 3: return 0.70;
        case 2: return 0.50;
        case 1: return 0.35;
        default: return 0.35;
    }
}

/**
 * Group cards by type ID
 */
function groupCardsByType(cards: ICard[]): Map<string, ICard[]> {
    const grouped = new Map<string, ICard[]>();

    for (const card of cards) {
        const typeId = card.type.id;
        if (!grouped.has(typeId)) {
            grouped.set(typeId, []);
        }
        grouped.get(typeId)!.push(card);
    }

    return grouped;
}

export interface MergedCardData {
    modifiers: ICardModifiers;
    effects: ICardEffect[];
}

/**
 * Merge modifiers and effects from cards with advanced stacking rules
 */
export function mergeCardsWithStacking(cards: ICard[]): MergedCardData {
    const result: ICardModifiers = {
        damage: 0,
        damageMultiplier: undefined,
        attackSpeedMultiplier: 1.0,
        range: 0,
        rangeMultiplier: 1.0,
        critChance: 0,
    };
    const allEffects: ICardEffect[] = [];

    // Group cards by type
    const grouped = groupCardsByType(cards);

    // Process each card type group
    for (const [typeId, typeCards] of grouped) {
        // Sort by level (highest first)
        typeCards.sort((a, b) => b.level - a.level);

        if (typeId === 'minigun') {
            // Special handling for Minigun
            processMinigunGroup(typeCards, result, allEffects);
        } else if (typeId === 'multi') {
            // Multishot doesn't add modifiers, skip in this loop
            // (handled separately in Tower.ts)
            continue;
        } else if (typeCards.length === 1) {
            // Single card of this type: 100% bonus
            const upgrade = getCardUpgrade(typeId, typeCards[0].level);
            if (upgrade) {
                applyModifiers(result, upgrade.modifiers, 1.0);
                allEffects.push(...upgrade.effects);
            }
        } else {
            // Multiple cards of same type: use stacking rules
            processSameTypeGroup(typeCards, result, allEffects);
        }
    }

    return { modifiers: result, effects: allEffects };
}

/**
 * Process multiple cards of the same type (non-minigun)
 */
function processSameTypeGroup(
    cards: ICard[],
    result: ICardModifiers,
    allEffects: ICardEffect[]
) {
    // Already sorted by level (highest first)

    // First card (highest level): 100%
    const mainCard = cards[0];
    const mainUpgrade = getCardUpgrade(mainCard.type.id, mainCard.level);
    if (mainUpgrade) {
        applyModifiers(result, mainUpgrade.modifiers, 1.0);
        allEffects.push(...mainUpgrade.effects);
    }

    // Rest of the cards: apply stacking bonus
    for (let i = 1; i < cards.length; i++) {
        const card = cards[i];
        const upgrade = getCardUpgrade(card.type.id, card.level);
        if (!upgrade) continue;

        const bonus = getStackingBonus(card.level);

        // Apply modifiers with bonus percentage
        applyModifiers(result, upgrade.modifiers, bonus);

        // Apply effects with bonus (if they have numeric values)
        applyEffectsWithBonus(upgrade.effects, allEffects, bonus);
    }
}

/**
 * Special processing for Minigun cards
 * 
 * - Takes highest level card for base damageMultiplier
 * - Additional minigun cards add penalties:
 *   - LVL 1: -5% damage
 *   - LVL 2: -7% damage
 *   - LVL 3: -9% damage
 *   - Penalties are summed
 */
function processMinigunGroup(
    cards: ICard[],
    result: ICardModifiers,
    allEffects: ICardEffect[]
) {
    // Already sorted by level
    const mainCard = cards[0];
    const mainUpgrade = getCardUpgrade('minigun', mainCard.level);

    if (!mainUpgrade) return;

    // Start with main card's damageMultiplier
    let baseDamageMultiplier = mainUpgrade.modifiers.damageMultiplier || 0.30;

    // Calculate penalties from additional minigun cards
    let totalPenalty = 0;
    for (let i = 1; i < cards.length; i++) {
        const level = cards[i].level;
        switch (level) {
            case 1:
                totalPenalty += 0.05; // 5%
                break;
            case 2:
                totalPenalty += 0.07; // 7%
                break;
            case 3:
                totalPenalty += 0.09; // 9%
                break;
        }
    }

    // Apply penalty to damageMultiplier (subtract from multiplier)
    baseDamageMultiplier -= totalPenalty;

    // Ensure minimum multiplier (can't go below 10%)
    baseDamageMultiplier = Math.max(0.10, baseDamageMultiplier);

    // Apply to result
    result.damageMultiplier = baseDamageMultiplier;
    result.attackSpeedMultiplier! *= mainUpgrade.modifiers.attackSpeedMultiplier || 1.0;

    // Add effects from main card only
    allEffects.push(...mainUpgrade.effects);
}

/**
 * Apply modifiers with a bonus multiplier
 */
function applyModifiers(
    result: ICardModifiers,
    modifiers: ICardModifiers,
    bonus: number
) {
    // Flat bonuses: multiply by bonus percentage
    if (modifiers.damage !== undefined) {
        result.damage! += modifiers.damage * bonus;
    }

    if (modifiers.range !== undefined) {
        result.range! += modifiers.range * bonus;
    }

    // Multipliers: scale the effect
    if (modifiers.attackSpeedMultiplier !== undefined) {
        // Effect = (multiplier - 1.0), e.g., 0.85 -> effect = -0.15
        const effect = modifiers.attackSpeedMultiplier - 1.0;
        const scaledEffect = effect * bonus;
        const finalMultiplier = 1.0 + scaledEffect;
        result.attackSpeedMultiplier! *= finalMultiplier;
    }

    if (modifiers.rangeMultiplier !== undefined) {
        const effect = modifiers.rangeMultiplier - 1.0;
        const scaledEffect = effect * bonus;
        const finalMultiplier = 1.0 + scaledEffect;
        result.rangeMultiplier! *= finalMultiplier;
    }

    // Crit chance: sum with bonus (not just max)
    if (modifiers.critChance !== undefined) {
        result.critChance! += modifiers.critChance * bonus;
    }

    // DamageMultiplier: only used by Minigun, handled specially
    // Don't merge here
}

/**
 * Apply effects with bonus percentage and deduplication
 */
function applyEffectsWithBonus(
    effects: ICardEffect[],
    allEffects: ICardEffect[],
    bonus: number
) {
    // Add effects with deduplication - only keep strongest version of each effect type
    for (const effect of effects) {
        const existing = allEffects.find(e => e.type === effect.type);

        if (!existing) {
            // New effect type - add it
            allEffects.push({ ...effect });
        } else {
            // Effect already exists - update to maximum values
            if (effect.splashRadius !== undefined && existing.splashRadius !== undefined) {
                existing.splashRadius = Math.max(existing.splashRadius, effect.splashRadius);
            }
            if (effect.slowDuration !== undefined && existing.slowDuration !== undefined) {
                existing.slowDuration = Math.max(existing.slowDuration, effect.slowDuration);
            }
            if (effect.slowPower !== undefined && existing.slowPower !== undefined) {
                existing.slowPower = Math.max(existing.slowPower, effect.slowPower);
            }
            if (effect.damageToSlowed !== undefined && existing.damageToSlowed !== undefined) {
                existing.damageToSlowed = Math.max(existing.damageToSlowed, effect.damageToSlowed);
            }
            if (effect.pierceCount !== undefined && existing.pierceCount !== undefined) {
                existing.pierceCount = Math.max(existing.pierceCount, effect.pierceCount);
            }
            if (effect.explosionDamagePercent !== undefined && existing.explosionDamagePercent !== undefined) {
                existing.explosionDamagePercent = Math.max(existing.explosionDamagePercent, effect.explosionDamagePercent);
            }
            if (effect.explosionRadius !== undefined && existing.explosionRadius !== undefined) {
                existing.explosionRadius = Math.max(existing.explosionRadius, effect.explosionRadius);
            }
            if (effect.chainRadius !== undefined && existing.chainRadius !== undefined) {
                existing.chainRadius = Math.max(existing.chainRadius, effect.chainRadius);
            }
            // Spinup effects - keep from main card (already handled in processMinigunGroup)
        }
    }
}
</file>

<file path="src/editor/EditorHistory.ts">
interface IEditorAction {
    type: 'tile' | 'waypoint' | 'fog';
    undo: () => void;
    redo: () => void;
}

export class EditorHistory {
    private undoStack: IEditorAction[] = [];
    private redoStack: IEditorAction[] = [];
    private readonly maxSize = 50;

    public push(action: IEditorAction): void {
        this.undoStack.push(action);

        // Clear redo stack when new action is added
        this.redoStack = [];

        // Maintain max size
        if (this.undoStack.length > this.maxSize) {
            this.undoStack.shift();
        }
    }

    public undo(): boolean {
        const action = this.undoStack.pop();
        if (!action) return false;

        action.undo();
        this.redoStack.push(action);

        return true;
    }

    public redo(): boolean {
        const action = this.redoStack.pop();
        if (!action) return false;

        action.redo();
        this.undoStack.push(action);

        return true;
    }

    public clear(): void {
        this.undoStack = [];
        this.redoStack = [];
    }

    public canUndo(): boolean {
        return this.undoStack.length > 0;
    }

    public canRedo(): boolean {
        return this.redoStack.length > 0;
    }
}

// Action factory helpers
export class EditorActions {
    /**
     * Create a tile change action
     */
    static createTileAction(
        grid: any[][],
        col: number,
        row: number,
        oldType: number,
        newType: number
    ): IEditorAction {
        return {
            type: 'tile',
            undo: () => {
                grid[row][col].type = oldType;
            },
            redo: () => {
                grid[row][col].type = newType;
            }
        };
    }

    /**
     * Create a fog change action
     */
    static createFogAction(
        fog: any,
        col: number,
        row: number,
        oldDensity: number,
        newDensity: number
    ): IEditorAction {
        return {
            type: 'fog',
            undo: () => {
                fog.setFog(col, row, oldDensity);
            },
            redo: () => {
                fog.setFog(col, row, newDensity);
            }
        };
    }

    /**
     * Create a waypoint action
     */
    static createWaypointAction(
        waypointMgr: any,
        actionType: 'addWaypoint' | 'setStart' | 'setEnd',
        position: { x: number; y: number },
        oldState?: any
    ): IEditorAction {
        return {
            type: 'waypoint',
            undo: () => {
                // Restore old state (for simplicity, clear and rebuild)
                if (oldState) {
                    waypointMgr.clearAll();
                    if (oldState.start) waypointMgr.setStart(oldState.start);
                    if (oldState.end) waypointMgr.setEnd(oldState.end);
                    oldState.waypoints?.forEach((wp: any) => waypointMgr.addWaypoint(wp));
                }
            },
            redo: () => {
                if (actionType === 'addWaypoint') {
                    waypointMgr.addWaypoint(position);
                } else if (actionType === 'setStart') {
                    waypointMgr.setStart(position);
                } else if (actionType === 'setEnd') {
                    waypointMgr.setEnd(position);
                }
            }
        };
    }
}
</file>

<file path="src/editor/WaypointManager.ts">
import { CONFIG } from '../Config';

export class WaypointManager {
    private start: { x: number; y: number } | null = null;
    private waypoints: { x: number; y: number }[] = [];
    private end: { x: number; y: number } | null = null;

    /**
     * Strict ordering: Start ‚Üí WP1 ‚Üí WP2 ‚Üí ... ‚Üí End
     */

    public setStart(pos: { x: number; y: number }): void {
        this.start = pos;
    }

    public setEnd(pos: { x: number; y: number }): void {
        this.end = pos;
    }

    public canAddWaypoint(): boolean {
        // Can only add waypoints if Start is set
        return this.start !== null;
    }

    public addWaypoint(pos: { x: number; y: number }): void {
        if (!this.canAddWaypoint()) {
            console.warn('Cannot add waypoint: Start point not set');
            return;
        }

        this.waypoints.push(pos);
    }

    public removeLastWaypoint(): void {
        this.waypoints.pop();
    }

    public clearAll(): void {
        this.start = null;
        this.waypoints = [];
        this.end = null;
    }

    public clearWaypoints(): void {
        this.waypoints = [];
    }

    public getStart(): { x: number; y: number } | null {
        return this.start;
    }

    public getEnd(): { x: number; y: number } | null {
        return this.end;
    }

    public getWaypoints(): { x: number; y: number }[] {
        return [...this.waypoints];
    }

    /**
     * Get full path: Start ‚Üí WP1 ‚Üí WP2 ‚Üí ... ‚Üí End
     */
    public getFullPath(): { x: number; y: number }[] {
        const path: { x: number; y: number }[] = [];

        if (this.start) path.push(this.start);
        path.push(...this.waypoints);
        if (this.end) path.push(this.end);

        return path;
    }

    public isValid(): boolean {
        // Valid if at least Start and End are set
        return this.start !== null && this.end !== null;
    }

    /**
     * Draw waypoints with lines and arrows
     */
    public draw(ctx: CanvasRenderingContext2D): void {
        const fullPath = this.getFullPath();

        if (fullPath.length < 2) {
            // Draw only start/end markers if they exist
            if (this.start) this.drawMarker(ctx, this.start, 'üèÅ', '#00bcd4', 0);
            if (this.end) this.drawMarker(ctx, this.end, 'üõë', '#e91e63', -1);
            return;
        }

        // Draw connecting lines with arrows
        ctx.strokeStyle = '#00ff00';
        ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
        ctx.lineWidth = 3;

        ctx.beginPath();
        for (let i = 0; i < fullPath.length; i++) {
            const wp = fullPath[i];
            const wpX = wp.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
            const wpY = wp.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

            if (i === 0) {
                ctx.moveTo(wpX, wpY);
            } else {
                ctx.lineTo(wpX, wpY);
            }
        }
        ctx.stroke();

        // Draw arrows between points
        for (let i = 0; i < fullPath.length - 1; i++) {
            const from = fullPath[i];
            const to = fullPath[i + 1];
            this.drawArrow(ctx, from, to);
        }

        // Draw numbered waypoint markers
        fullPath.forEach((wp, idx) => {
            let label: string;
            let color: string;

            if (idx === 0) {
                // Start
                label = 'üèÅ';
                color = '#00bcd4';
            } else if (idx === fullPath.length - 1) {
                // End
                label = 'üõë';
                color = '#e91e63';
            } else {
                // Waypoint
                label = (idx).toString();
                color = '#9c27b0';
            }

            this.drawMarker(ctx, wp, label, color, idx);
        });
    }

    private drawMarker(
        ctx: CanvasRenderingContext2D,
        pos: { x: number; y: number },
        label: string,
        color: string,
        index: number
    ): void {
        const wpX = pos.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const wpY = pos.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        // Circle
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(wpX, wpY, 14, 0, Math.PI * 2);
        ctx.fill();

        // White border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Label
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, wpX, wpY);
    }

    private drawArrow(
        ctx: CanvasRenderingContext2D,
        from: { x: number; y: number },
        to: { x: number; y: number }
    ): void {
        const fromX = from.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const fromY = from.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const toX = to.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const toY = to.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        // Calculate angle
        const angle = Math.atan2(toY - fromY, toX - fromX);

        // Arrow position (midpoint)
        const midX = (fromX + toX) / 2;
        const midY = (fromY + toY) / 2;

        // Arrow size
        const arrowSize = 12;

        ctx.save();
        ctx.translate(midX, midY);
        ctx.rotate(angle);

        // Draw arrow head
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-arrowSize, -arrowSize / 2);
        ctx.lineTo(-arrowSize, arrowSize / 2);
        ctx.closePath();
        ctx.fill();

        // Arrow outline
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
    }
}
</file>

<file path="src/EventBus.ts">
/**
 * Event Bus Module
 * Decouples game systems using the Observer pattern.
 */

export type EventCallback<T = any> = (data: T) => void;

interface IEventSubscription {
    id: number;
    event: string;
    callback: EventCallback;
}

export class EventBus {
    private static instance: EventBus;
    private subscribers: Map<string, IEventSubscription[]> = new Map();
    private nextId: number = 0;

    private constructor() { }

    public static getInstance(): EventBus {
        if (!EventBus.instance) {
            EventBus.instance = new EventBus();
        }
        return EventBus.instance;
    }

    /**
     * Subscribe to an event
     * @param event Event name (use constants from Events object)
     * @param callback Function to call when event is emitted
     * @returns Subscription ID (can be used to unsubscribe)
     */
    public on<T = any>(event: string, callback: EventCallback<T>): number {
        const id = this.nextId++;
        if (!this.subscribers.has(event)) {
            this.subscribers.set(event, []);
        }
        this.subscribers.get(event)!.push({ id, event, callback });
        return id;
    }

    /**
     * Unsubscribe using the ID returned by on()
     */
    public off(id: number): void {
        this.subscribers.forEach((subs, event) => {
            const index = subs.findIndex(s => s.id === id);
            if (index !== -1) {
                subs.splice(index, 1);
            }
        });
    }

    /**
     * Emit an event with data
     */
    public emit<T = any>(event: string, data?: T): void {
        if (!this.subscribers.has(event)) return;
        this.subscribers.get(event)!.forEach(sub => sub.callback(data));
    }

    /**
     * Clear all subscribers (useful for scene transitions)
     */
    public clear(): void {
        this.subscribers.clear();
    }
}

// Define Event Constants for type safety type feeling
export const Events = {
    // Economy
    MONEY_CHANGED: 'MONEY_CHANGED', // data: number (new amount)
    LIVES_CHANGED: 'LIVES_CHANGED', // data: number (new amount)

    // Wave
    WAVE_STARTED: 'WAVE_STARTED',   // data: number (wave index)
    WAVE_COMPLETED: 'WAVE_COMPLETED', // data: number (wave index)

    // Game State
    GAME_OVER: 'GAME_OVER',         // data: number (final wave)
    GAME_RESTART: 'GAME_RESTART',   // void

    // UI
    TOGGLE_PAUSE: 'TOGGLE_PAUSE',   // data: boolean (isPaused)
};
</file>

<file path="src/FogRenderer.ts">
import { SimplexNoise } from './SimplexNoise';
import { FogStructure } from './FogStructure';
import { CONFIG } from './Config';

/**
 * Fog Renderer - handles animated procedural fog rendering
 */
export class FogRenderer {
    private noise: SimplexNoise;
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;

    // Animation parameters - increased for more visible movement
    private readonly DRIFT_SPEED = 0.0012; // 4x faster (was 0.0003)
    private readonly ROTATION_SPEED = 0.0004; // 4x faster (was 0.0001)
    private readonly NOISE_SCALE = 0.01;
    private readonly MAX_DRIFT = CONFIG.TILE_SIZE * 0.3; // Increased from 0.2
    private readonly MAX_ROTATION = 0.08; // Increased from 0.05 (~4.5¬∞)

    // Visual parameters
    private readonly FOG_COLOR = { r: 200, g: 215, b: 230 };
    private readonly BASE_ALPHA = 0.18;

    constructor(width: number, height: number, seed?: number) {
        this.noise = new SimplexNoise(seed);
        this.canvas = document.createElement('canvas');
        this.canvas.width = width;
        this.canvas.height = height;

        const context = this.canvas.getContext('2d');
        if (!context) throw new Error('Failed to create fog render context');
        this.ctx = context;
    }

    /**
     * Render fog structures
     */
    public render(structures: FogStructure[], time: number): void {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        for (const structure of structures) {
            this.renderStructure(structure, time);
        }
    }

    private renderStructure(structure: FogStructure, time: number): void {
        const TS = CONFIG.TILE_SIZE;
        const ctx = this.ctx;

        for (const tile of structure.tiles) {
            if (tile.density === 0) continue;

            // Calculate drift offset using noise
            const noiseX = this.noise.noise2D(
                time * this.DRIFT_SPEED + structure.noiseOffsetX,
                0
            );
            const noiseY = this.noise.noise2D(
                0,
                time * this.DRIFT_SPEED + structure.noiseOffsetY
            );

            const driftX = noiseX * this.MAX_DRIFT;
            const driftY = noiseY * this.MAX_DRIFT;

            // Calculate rotation (subtle swirl effect)
            const rotation = this.noise.noise2D(
                time * this.ROTATION_SPEED + structure.noiseOffsetRot,
                tile.x * this.NOISE_SCALE + tile.y * this.NOISE_SCALE
            ) * this.MAX_ROTATION;

            // Tile center with drift
            const cx = tile.x * TS + TS / 2 + driftX;
            const cy = tile.y * TS + TS / 2 + driftY;

            // Calculate alpha based on density (1-5 -> 20%-100%)
            const alpha = tile.density * this.BASE_ALPHA;

            // Draw fog cloud with gradient
            // Increased radius for better overlap and blending
            const radius = TS * 1.1; // Increased from 0.85 to 1.1

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(rotation);
            ctx.translate(-cx, -cy);

            // Outer gradient (soft edges, wider spread)
            const gradient = ctx.createRadialGradient(
                cx, cy, 0,
                cx, cy, radius
            );

            gradient.addColorStop(0, `rgba(${this.FOG_COLOR.r}, ${this.FOG_COLOR.g}, ${this.FOG_COLOR.b}, ${alpha})`);
            gradient.addColorStop(0.5, `rgba(${this.FOG_COLOR.r}, ${this.FOG_COLOR.g}, ${this.FOG_COLOR.b}, ${alpha * 0.8})`);
            gradient.addColorStop(0.8, `rgba(${this.FOG_COLOR.r}, ${this.FOG_COLOR.g}, ${this.FOG_COLOR.b}, ${alpha * 0.4})`);
            gradient.addColorStop(1, `rgba(${this.FOG_COLOR.r}, ${this.FOG_COLOR.g}, ${this.FOG_COLOR.b}, 0)`);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();

            // Add detail layer for higher densities
            if (tile.density >= 3) {
                const detailNoise = this.noise.noise2D(
                    cx * 0.02 + time * 0.0002,
                    cy * 0.02
                );
                const detailAlpha = (detailNoise * 0.5 + 0.5) * alpha * 0.3;

                ctx.fillStyle = `rgba(${this.FOG_COLOR.r - 20}, ${this.FOG_COLOR.g - 20}, ${this.FOG_COLOR.b - 20}, ${detailAlpha})`;
                ctx.beginPath();
                ctx.arc(cx, cy, radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }
    }

    /**
     * Get the rendered canvas
     */
    public getCanvas(): HTMLCanvasElement {
        return this.canvas;
    }

    /**
     * Resize the render canvas
     */
    public resize(width: number, height: number): void {
        this.canvas.width = width;
        this.canvas.height = height;
    }
}
</file>

<file path="src/FogStructure.ts">
/**
 * Fog Structure - represents a connected region of fog tiles
 */
export interface FogTile {
    x: number;
    y: number;
    density: number; // 0-5
}

export interface FogStructure {
    id: number;
    tiles: FogTile[];
    bounds: {
        minX: number;
        maxX: number;
        minY: number;
        maxY: number;
    };
    // Animation state
    noiseOffsetX: number;
    noiseOffsetY: number;
    noiseOffsetRot: number;
}

/**
 * Build fog structures using flood-fill algorithm
 */
export function buildFogStructures(
    fogData: number[],
    width: number,
    height: number
): FogStructure[] {
    const structures: FogStructure[] = [];
    const visited = new Set<number>();
    let structureId = 0;

    const getIndex = (x: number, y: number) => y * width + x;
    const isValid = (x: number, y: number) =>
        x >= 0 && x < width && y >= 0 && y < height;

    // Flood fill from a starting point
    const floodFill = (startX: number, startY: number): FogTile[] => {
        const tiles: FogTile[] = [];
        const queue: { x: number; y: number }[] = [{ x: startX, y: startY }];
        const startIndex = getIndex(startX, startY);
        visited.add(startIndex);

        while (queue.length > 0) {
            const { x, y } = queue.shift()!;
            const density = fogData[getIndex(x, y)];

            tiles.push({ x, y, density });

            // Check 4 neighbors (N, S, E, W)
            const neighbors = [
                { x: x, y: y - 1 },
                { x: x, y: y + 1 },
                { x: x + 1, y: y },
                { x: x - 1, y: y },
            ];

            for (const neighbor of neighbors) {
                if (!isValid(neighbor.x, neighbor.y)) continue;

                const nIndex = getIndex(neighbor.x, neighbor.y);
                if (visited.has(nIndex)) continue;
                if (fogData[nIndex] === 0) continue; // No fog

                visited.add(nIndex);
                queue.push(neighbor);
            }
        }

        return tiles;
    };

    // Find all structures
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = getIndex(x, y);
            if (visited.has(index)) continue;
            if (fogData[index] === 0) continue; // No fog

            const tiles = floodFill(x, y);
            if (tiles.length === 0) continue;

            // Calculate bounds
            let minX = Infinity,
                maxX = -Infinity;
            let minY = Infinity,
                maxY = -Infinity;

            for (const tile of tiles) {
                minX = Math.min(minX, tile.x);
                maxX = Math.max(maxX, tile.x);
                minY = Math.min(minY, tile.y);
                maxY = Math.max(maxY, tile.y);
            }

            structures.push({
                id: structureId++,
                tiles,
                bounds: { minX, maxX, minY, maxY },
                noiseOffsetX: Math.random() * 1000,
                noiseOffsetY: Math.random() * 1000,
                noiseOffsetRot: Math.random() * 1000,
            });
        }
    }

    return structures;
}
</file>

<file path="src/graphics/InkFogRenderer.ts">
import { FogStructure } from '../FogStructure';
import { CONFIG } from '../Config';
import { InkUtils } from './InkUtils';
import { INK_CONFIG } from './InkConfig';

/**
 * Ink Fog Renderer - Draws fog as "scribbled out" areas on top of the map.
 * OPTIMIZED: Uses pre-rendered Hatch Pattern to avoid thousands of line draws per frame.
 */
export class InkFogRenderer {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private patternCanvas: HTMLCanvasElement;
    private pattern: CanvasPattern | null = null;

    constructor(width: number, height: number, seed?: number) {
        this.canvas = document.createElement('canvas');
        this.canvas.width = width;
        this.canvas.height = height;

        const context = this.canvas.getContext('2d');
        if (!context) throw new Error('Failed to create ink fog render context');
        this.ctx = context;

        // Create the hatch pattern once (64x64 tileableish)
        this.patternCanvas = document.createElement('canvas');
        this.patternCanvas.width = 64;
        this.patternCanvas.height = 64;
        this.generateHatchPattern();
    }

    private generateHatchPattern() {
        const pCtx = this.patternCanvas.getContext('2d')!;
        pCtx.strokeStyle = INK_CONFIG.PALETTE.INK;
        pCtx.lineWidth = 1.5;
        pCtx.lineCap = 'round';

        // Clear
        pCtx.clearRect(0, 0, 64, 64);

        // Draw dense scribbles
        for (let i = 0; i < 30; i++) {
            const x = Math.random() * 64;
            const y = Math.random() * 64;
            const len = 10 + Math.random() * 20;
            const angle = (Math.PI / 4) + (Math.random() - 0.5) * 0.5; // Mostly diagonal

            pCtx.beginPath();
            pCtx.moveTo(x, y);
            pCtx.lineTo(x + Math.cos(angle) * len, y + Math.sin(angle) * len);
            pCtx.stroke();
        }

        this.pattern = this.ctx.createPattern(this.patternCanvas, 'repeat');
    }

    public render(structures: FogStructure[], time: number): void {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        const TS = CONFIG.TILE_SIZE;

        if (!this.pattern) return;

        ctx.save();
        ctx.fillStyle = this.pattern;

        // We can shift the pattern slightly with time to make it feel alive without redrawing lines
        // Translate matrix for pattern
        const matrix = new DOMMatrix();
        // Slow drift or jitter
        matrix.translateSelf(Math.sin(time * 0.05) * 5, Math.cos(time * 0.03) * 5);
        this.pattern.setTransform(matrix);

        ctx.beginPath();
        for (const structure of structures) {
            for (const tile of structure.tiles) {
                if (tile.density === 0) continue;

                const cx = tile.x * TS;
                const cy = tile.y * TS;

                // Draw a rect for the tile
                // We overlap slightly to avoid gaps
                ctx.rect(cx - 2, cy - 2, TS + 4, TS + 4);
            }
        }
        ctx.fill();
        ctx.restore();
    }

    public getCanvas(): HTMLCanvasElement {
        return this.canvas;
    }

    public resize(width: number, height: number): void {
        this.canvas.width = width;
        this.canvas.height = height;
    }
}
</file>

<file path="src/graphics/InkHatching.ts">
import { INK_CONFIG } from './InkConfig';

/**
 * Generates hatching (shading) patterns for objects.
 * Caches complex patterns to avoid per-frame generation.
 */
export class InkHatching {
    private static cache: Map<string, HTMLCanvasElement> = new Map();

    /**
     * Draws basic diagonal hatching (for shadows).
     * @param ctx - Canvas context
     * @param x - Top left X
     * @param y - Top left Y
     * @param w - Width
     * @param h - Height
     * @param density - Pixel spacing between lines
     * @param angle - Radians
     */
    static drawHatching(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number, density: number = 4) {
        ctx.save();
        ctx.beginPath();
        // Clipping region is assumed to be set by caller before calling this, 
        // OR we just draw a rect of hatching.
        // Usually, you clip to a circle/shape, then call this.

        ctx.strokeStyle = INK_CONFIG.PALETTE.SHADOW;
        ctx.lineWidth = 1;

        // Simple 45 degree lines
        for (let i = -h; i < w; i += density) {
            ctx.moveTo(x + i, y);
            ctx.lineTo(x + i + h, y + h);
        }
        ctx.stroke();
        ctx.restore();
    }

    /**
     * Generates a circular shadow layer with dynamic hatching based on light direction.
     * @param radius - Size of the circle
     * @param lightAngle - Direction of light (in radians)
     */
    static getCircularHatching(radius: number, lightAngle: number): HTMLCanvasElement {
        // Cache key based on radius and rough angle (quantized to 8 directions for efficiency)
        const angleStep = Math.PI / 4;
        const quantizedAngle = Math.round(lightAngle / angleStep) * angleStep;
        const key = `circle_${radius}_${quantizedAngle}`;

        if (this.cache.has(key)) {
            return this.cache.get(key)!;
        }

        // Create cached canvas
        const size = radius * 2;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d')!;

        const Cx = radius;
        const Cy = radius;

        // 1. Define Shadow Area (Crescent)
        // Everything opposite to light
        const shadowDir = lightAngle + Math.PI;

        ctx.save();
        ctx.beginPath();
        ctx.arc(Cx, Cy, radius, 0, Math.PI * 2);
        ctx.clip(); // Clip to circle

        // Draw hatching lines
        ctx.strokeStyle = INK_CONFIG.PALETTE.SHADOW;
        ctx.lineWidth = 1;

        // Rotate context to align with shadow direction for easier math
        // Actually, let's keep it simple: Draw lines perpendicular to shadow dir?
        // Standard cross-hatching is usually diagonal relative to page, not object.
        // Let's stick to standard 45 deg page-relative hatching for consistency.

        // We need to mask the "lit" side.
        // Simple dot product check? or a gradient mask?

        // Let's use a gradient opacity mask for smooth shadow falloff!
        const grad = ctx.createLinearGradient(
            Cx + Math.cos(lightAngle) * radius,
            Cy + Math.sin(lightAngle) * radius,
            Cx + Math.cos(shadowDir) * radius,
            Cy + Math.sin(shadowDir) * radius
        );
        grad.addColorStop(0, 'rgba(0,0,0,0)');   // Lit side - transparent
        grad.addColorStop(0.3, 'rgba(0,0,0,0)');
        grad.addColorStop(1, 'rgba(0,0,0,1)');   // Shadow side - opaque

        ctx.fillStyle = grad;
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillRect(0, 0, size, size);

        // Now we have a gradient alpha mask. We want lines ONLY where alpha is high.
        // "source-in" keeps the source (new drawing) only where destination (existing gradient) is opaque.
        ctx.globalCompositeOperation = 'source-in';

        // Draw infinite hatching over the rect
        ctx.beginPath();
        const density = 4;
        for (let i = -size; i < size * 2; i += density) {
            ctx.moveTo(i, 0);
            ctx.lineTo(i - size, size); // 135 deg slant
        }
        ctx.stroke();

        ctx.restore();

        this.cache.set(key, canvas);
        return canvas;
    }

    static clearCache() {
        this.cache.clear();
    }
}
</file>

<file path="src/graphics/InkLightingSystem.ts">
import { INK_CONFIG } from './InkConfig';

/**
 * Ink Lighting System - Atmospheric lighting for the Paper world.
 * 
 * Philosophy:
 * - Day: Paper is natural color.
 * - Night: Paper is tinted "Moonlight Blue" (Multiply blend).
 * - Torch/Light: Paper is bleached/warmed (Soft Light / Screen blend).
 * 
 * We do NOT use a black overlay. We dye the paper.
 */
export class InkLightingSystem {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private width: number;
    private height: number;

    // Ambient darkness level (0 = glorious day, 1 = pitch black ink)
    public ambientLight: number = 1.0;

    // Lights list
    private lights: { x: number, y: number, radius: number, color: string, intensity: number }[] = [];

    constructor(width: number, height: number) {
        this.width = width;
        this.height = height;
        this.canvas = document.createElement('canvas');
        this.canvas.width = width;
        this.canvas.height = height;
        const context = this.canvas.getContext('2d');
        if (!context) throw new Error('Failed to create ink light context');
        this.ctx = context;
    }

    public resize(width: number, height: number) {
        this.width = width;
        this.height = height;
        this.canvas.width = width;
        this.canvas.height = height;
    }

    public clear() {
        this.lights = [];
    }

    public addLight(x: number, y: number, radius: number, color: string, intensity: number = 1.0) {
        this.lights.push({ x, y, radius, color, intensity });
    }

    public render(targetCtx: CanvasRenderingContext2D) {
        // If it's full day (ambientLight ~ 1.0), we might skip rendering for performance,
        // UNLESS there are colored lights that need to be seen.
        // But in Ink mode, lights are visible even in day (like ink blooming).

        const w = this.width;
        const h = this.height;

        this.ctx.clearRect(0, 0, w, h);

        // 1. NIGHT TINT (Multiply)
        // Unlike standard mode where ambientLight 1.0 means "No darkness", 
        // here we map ambient to tint opacity.
        // ambientLight 0.0 -> Darkness (Full tint)
        // ambientLight 1.0 -> Daylight (No tint)

        const nightOpacity = 1.0 - Math.max(0, Math.min(1, this.ambientLight));

        if (nightOpacity > 0.05) {
            targetCtx.save();
            targetCtx.globalCompositeOperation = 'multiply';
            targetCtx.fillStyle = `rgba(10, 20, 40, ${nightOpacity * 0.6})`; // Deep Navy Ink
            targetCtx.fillRect(0, 0, w, h);
            targetCtx.restore();
        }

        // 2. LIGHT SOURCES (Soft Light / Screen)
        // We render lights to our offscreen canvas first to blend them

        // Draw lights
        this.lights.forEach(light => {
            // Gradient for soft edges
            const g = this.ctx.createRadialGradient(light.x, light.y, 0, light.x, light.y, light.radius);

            // "Bleach" effect: White center -> Transparent
            // Use tinted color for magic lights
            g.addColorStop(0, light.color);
            g.addColorStop(1, 'rgba(0,0,0,0)');

            this.ctx.save();
            this.ctx.globalAlpha = light.intensity * 0.7;
            this.ctx.fillStyle = g;
            this.ctx.beginPath();
            this.ctx.arc(light.x, light.y, light.radius, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        });

        // Composite lights onto the game world
        targetCtx.save();
        targetCtx.globalCompositeOperation = 'screen';
        targetCtx.drawImage(this.canvas, 0, 0);
        targetCtx.restore();

        // 3. VIGNETTE (Subtle dark corners)
        // User requested to "reduce" it (assuming they saw the global tint as vignette or wanted a new one)
        // We add a subtle one now for depth.
        const gradient = targetCtx.createRadialGradient(w / 2, h / 2, h * 0.4, w / 2, h / 2, h * 0.8);
        gradient.addColorStop(0, 'rgba(0,0,0,0)');
        gradient.addColorStop(1, 'rgba(10, 5, 0, 0.3)'); // Reduced opacity (was likely too dark in user's mind)

        targetCtx.save();
        targetCtx.fillStyle = gradient;
        targetCtx.globalCompositeOperation = 'multiply'; // Ink darkening
        targetCtx.fillRect(0, 0, w, h);
        targetCtx.restore();
    }
}
</file>

<file path="src/graphics/InkParticles.ts">
import { INK_CONFIG } from './InkConfig';

/**
 * Handles "Living Ink" particle effects.
 */
export class InkParticles {

    /**
     * Draws an expanding ink splatter (explosion).
     * @param ctx 
     * @param x Center X
     * @param y Center Y
     * @param radius Current radius
     * @param lifePct 0.0 to 1.0 (1.0 = full life/birth, 0.0 = dead)
     * @param color Ink color
     */
    static drawSplatter(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, lifePct: number, color: string = INK_CONFIG.PALETTE.INK) {
        ctx.save();
        ctx.fillStyle = color;

        // Ink dries (= opacity drops)
        ctx.globalAlpha = Math.min(1, lifePct * 1.5);

        // Draw main blob
        const r = radius;

        // Use a static seed based on position to make the shape consistent over frames
        // (Simulate per-particle shape without storing it, assuming x/y doesn't change much for explosion center)
        const seed = Math.floor(x * y);

        ctx.beginPath();
        const spikes = 8 + (seed % 5);
        const rotation = (seed % 360) * Math.PI / 180;

        for (let i = 0; i <= spikes * 2; i++) {
            const angle = rotation + (i / (spikes * 2)) * Math.PI * 2;
            const isSpike = i % 2 === 0;
            // Spikes are longer when fresh (explosive force), then retract? 
            // Better: Spikes are just irregular.
            const len = isSpike ? r : r * 0.4;
            // Add some "wobble" based on life to make it boil
            const wobble = Math.sin(lifePct * 10 + i) * (r * 0.1);

            const px = x + Math.cos(angle) * (len + wobble);
            const py = y + Math.sin(angle) * (len + wobble);

            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        // Droplets (Satellites)
        if (lifePct > 0.5) {
            const dropletCount = 4 + (seed % 4);
            for (let i = 0; i < dropletCount; i++) {
                const angle = rotation + (i / dropletCount) * Math.PI * 2 + 0.5;
                const dist = r * 1.5 + (1 - lifePct) * r; // Move outward
                const size = r * 0.15 * lifePct;

                const dx = x + Math.cos(angle) * dist;
                const dy = y + Math.sin(angle) * dist;

                ctx.beginPath();
                ctx.arc(dx, dy, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.restore();
    }
}
</file>

<file path="src/graphics/InkWatercolor.ts">
import { INK_CONFIG } from './InkConfig';

/**
 * Handles watercolor "wash" effects.
 * Simulates liquid paint spreading on paper with irregular edges.
 */
export class InkWatercolor {

    /**
     * Draws a rectangular wash effect (e.g. for tiles).
     * @param ctx Context to draw on
     * @param x Top-left x
     * @param y Top-left y
     * @param w Width
     * @param h Height
     * @param color Base color string (hex or rgba)
     * @param seed Random seed for edge variation
     */
    static drawRectWash(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number, color: string, seed: number) {
        const layers = INK_CONFIG.WATERCOLOR.LAYERS;
        const opacity = INK_CONFIG.WATERCOLOR.OPACITY_LOW;
        const spread = INK_CONFIG.WATERCOLOR.SPREAD;

        // Convert strict hex to rgba with low opacity if needed, 
        // but it's easier to just use globalAlpha with the passed color.

        ctx.save();
        ctx.fillStyle = color;

        // Use multiply blend for "soaking in" effect
        ctx.globalCompositeOperation = 'multiply';

        for (let i = 0; i < layers; i++) {
            ctx.globalAlpha = opacity;

            // Each layer is slightly offset and has different noise
            const layerSeed = seed + i * 132;
            this.drawBlob(ctx, x, y, w, h, spread, layerSeed);
        }

        ctx.restore();
    }

    /**
     * Draws a single organic blob roughly fitting the rect
     */
    private static drawBlob(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number, spread: number, seed: number) {
        ctx.beginPath();

        // We'll draw a polygon with randomized points around the perimeter
        const points = [];
        const steps = 8; // Number of points per side roughly

        // Top
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const nx = x + w * t;
            const ny = y + (Math.sin(t * 10 + seed) * spread * 0.5) - (Math.random() * spread * 0.5);
            points.push({ x: nx, y: ny });
        }
        // Right
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const nx = x + w + (Math.cos(t * 10 + seed) * spread * 0.5) + (Math.random() * spread * 0.5);
            const ny = y + h * t;
            points.push({ x: nx, y: ny });
        }
        // Bottom
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const nx = x + w - (w * t); // going back
            const ny = y + h + (Math.sin(t * 12 + seed) * spread * 0.5) + (Math.random() * spread * 0.5);
            points.push({ x: nx, y: ny });
        }
        // Left
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const nx = x - (Math.cos(t * 8 + seed) * spread * 0.5) - (Math.random() * spread * 0.5);
            const ny = y + h - (h * t); // going up
            points.push({ x: nx, y: ny });
        }

        if (points.length > 0) {
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                // Use quadratic curves for smoother liquid look
                const p = points[i];
                const prev = points[i - 1];
                const midX = (prev.x + p.x) / 2;
                const midY = (prev.y + p.y) / 2;
                ctx.quadraticCurveTo(prev.x, prev.y, midX, midY);
            }
            ctx.closePath();
        }

        ctx.fill();
    }
}
</file>

<file path="src/graphics/PaperTexture.ts">
import { INK_CONFIG } from './InkConfig';

/**
 * Generates a procedural paper texture for the game background.
 * Uses noise and vignette to simulate aged parchment.
 */
export class PaperTexture {
    private static cacheCanvas: HTMLCanvasElement | null = null;

    /**
     * returns a pattern or canvas capable of being drawn as the background
     */
    static generate(width: number, height: number): HTMLCanvasElement {
        if (this.cacheCanvas && this.cacheCanvas.width === width && this.cacheCanvas.height === height) {
            return this.cacheCanvas;
        }

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d')!;

        // 1. Base Paper Color
        ctx.fillStyle = INK_CONFIG.PALETTE.PAPER;
        ctx.fillRect(0, 0, width, height);

        // 2. Grain / Noise
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        const grainStrength = INK_CONFIG.PAPER_TEXTURE.GRAIN_INTENSITY * 255;

        for (let i = 0; i < data.length; i += 4) {
            // Random offset: -strength to +strength
            const noise = (Math.random() - 0.5) * grainStrength;

            // Apply to RGB, keep Alpha
            data[i] = Math.min(255, Math.max(0, data[i] + noise));     // R
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise)); // G
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise)); // B
        }
        ctx.putImageData(imageData, 0, 0);

        // 3. Subtle Vignette
        const vignette = ctx.createRadialGradient(width / 2, height / 2, height * 0.3, width / 2, height / 2, height * 0.8);
        vignette.addColorStop(0, 'rgba(0,0,0,0)');
        vignette.addColorStop(1, `rgba(45, 27, 14, ${INK_CONFIG.PAPER_TEXTURE.VIGNETTE_STRENGTH})`);

        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, width, height);

        // 4. Stains (Optional: Adding a few random coffee stains)
        this.drawStains(ctx, width, height);

        this.cacheCanvas = canvas;
        return canvas;
    }

    private static drawStains(ctx: CanvasRenderingContext2D, w: number, h: number) {
        // Simple ring stains
        const count = 3;
        ctx.strokeStyle = 'rgba(60, 40, 20, 0.05)';
        ctx.lineWidth = 4;

        for (let i = 0; i < count; i++) {
            const x = Math.random() * w;
            const y = Math.random() * h;
            const r = 30 + Math.random() * 50;

            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}
</file>

<file path="src/ProceduralPatterns.ts">
import { SimplexNoise } from './SimplexNoise';

/**
 * Procedural Pattern Generation Library
 * Provides algorithms for creating organic and technical textures
 * Used by Assets.ts for layered texture generation
 */
export class ProceduralPatterns {
    private static noise = new SimplexNoise();

    /**
     * Perlin Noise overlay (uses existing SimplexNoise)
     * Adds subtle texture variation to surfaces
     */
    static perlinNoise(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        scale: number = 0.05,
        opacity: number = 0.1
    ): void {
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const value = this.noise.noise2D(x * scale, y * scale); // -1 to 1
                const brightness = Math.floor(value * 25); // -25 to 25

                const idx = (y * width + x) * 4;
                // Darken/lighten based on noise
                data[idx] = Math.max(0, Math.min(255, data[idx] + brightness));     // R
                data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + brightness)); // G
                data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + brightness)); // B
            }
        }

        ctx.putImageData(imageData, 0, 0);
    }

    /**
     * Organic Veins (Dark Fantasy)
     * Draws wandering lines like roots or cracks
     */
    static organicVeins(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        density: number = 0.3,
        seed: number = 0
    ): void {
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 1;
        ctx.lineCap = 'round';

        const veinCount = Math.floor(width * height * density / 1000);

        for (let i = 0; i < veinCount; i++) {
            // Pseudo-random based on seed + index
            const s = seed + i * 137;

            // Simple deterministic random function for this scope
            const rnd = (mod: number) => {
                const x = Math.sin(s + mod) * 10000;
                return x - Math.floor(x);
            };

            let x = rnd(1) * width;
            let y = rnd(2) * height;
            let angle = rnd(3) * Math.PI * 2;

            ctx.beginPath();
            ctx.moveTo(x, y);

            // Wandering path
            const steps = 15 + Math.floor(rnd(4) * 10);
            for (let step = 0; step < steps; step++) {
                angle += (rnd(step * 5) - 0.5) * 0.6; // Slight turns
                x += Math.cos(angle) * 3;
                y += Math.sin(angle) * 3;

                // Keep within bounds
                if (x < 0 || x > width || y < 0 || y > height) break;

                ctx.lineTo(x, y);
            }

            ctx.stroke();
        }

        ctx.restore();
    }

    /**
     * Voronoi Grid (Techno)
     * Creates cell-like patterns mimicking circuits/microchips
     */
    static voronoiGrid(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        cellCount: number = 10
    ): void {
        // Generate random points
        const points: { x: number; y: number }[] = [];
        for (let i = 0; i < cellCount; i++) {
            points.push({
                x: Math.random() * width,
                y: Math.random() * height
            });
        }

        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        // For each pixel, find closest point
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                let minDist = Infinity;
                let closestIdx = 0;

                for (let i = 0; i < points.length; i++) {
                    const dist = Math.hypot(points[i].x - x, points[i].y - y);
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = i;
                    }
                }

                // Color by cell index
                const idx = (y * width + x) * 4;
                const shade = 30 + (closestIdx % 5) * 15; // Subtle variation
                data[idx] = Math.max(0, Math.min(255, data[idx] + shade));
                data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + shade));
                data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + shade));
            }
        }

        ctx.putImageData(imageData, 0, 0);

        // Draw cell borders
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 1;

        for (let y = 0; y < height; y += 2) { // Sample every 2 pixels for performance
            for (let x = 0; x < width - 1; x++) {
                let minDist1 = Infinity, minDist2 = Infinity;
                let closest1 = 0, closest2 = 0;

                // Find closest point for current and next pixel
                for (let i = 0; i < points.length; i++) {
                    const dist1 = Math.hypot(points[i].x - x, points[i].y - y);
                    const dist2 = Math.hypot(points[i].x - (x + 1), points[i].y - y);

                    if (dist1 < minDist1) {
                        minDist1 = dist1;
                        closest1 = i;
                    }
                    if (dist2 < minDist2) {
                        minDist2 = dist2;
                        closest2 = i;
                    }
                }

                // Draw border if different cells
                if (closest1 !== closest2) {
                    ctx.beginPath();
                    ctx.moveTo(x + 0.5, y);
                    ctx.lineTo(x + 0.5, y + 1);
                    ctx.stroke();
                }
            }
        }

        ctx.restore();
    }

    /**
     * Bioluminescent Spots (Dark Fantasy accent)
     * Adds glowing spots using deterministic seed
     */
    static biolumSpots(
        ctx: CanvasRenderingContext2D,
        width: number,
        height: number,
        color: string,
        density: number = 0.2,
        seed: number = 0
    ): void {
        ctx.save();
        ctx.fillStyle = color;
        ctx.shadowBlur = 3;  // Reduced from 8 for subtler glow
        ctx.shadowColor = color;

        // Deterministic spot placement (–∑–∞–º–µ—á–∞–Ω–∏–µ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ #3!)
        const spotCount = Math.floor(width * height * density / 1000);

        for (let i = 0; i < spotCount; i++) {
            // Pseudo-random –Ω–æ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
            const pseudoX = ((seed + i) * 73) % width;
            const pseudoY = ((seed + i) * 137) % height;
            const size = 0.5 + ((seed + i) % 2) * 0.5;  // Reduced from 1-3px to 0.5-1.5px

            ctx.beginPath();
            ctx.arc(pseudoX, pseudoY, size, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }
}
</file>

<file path="src/RendererFactory.ts">
import { CONFIG } from './Config';
import { Tower } from './Tower';
import { Enemy } from './Enemy';
import { MapManager } from './Map';
import { Projectile } from './Projectile';
import { TowerRenderer } from './renderers/TowerRenderer';
import { EnemyRenderer } from './renderers/EnemyRenderer';
import { SpriteProjectileRenderer } from './renderers/SpriteProjectileRenderer';
import { InkMapRenderer } from './renderers/InkMapRenderer';
import { InkProjectileRenderer } from './renderers/InkProjectileRenderer';
import { InkTowerRenderer } from './renderers/InkTowerRenderer';
import { InkEnemyRenderer } from './renderers/InkEnemyRenderer';
import { InkEffectRenderer } from './renderers/InkEffectRenderer';
import { IEffect } from './EffectSystem';
// SpriteEffectRenderer is currently inline in EffectSystem.ts, we will handle that there.

export class RendererFactory {
    static drawTower(ctx: CanvasRenderingContext2D, tower: Tower) {
        if (CONFIG.VISUAL_STYLE === 'INK') {
            InkTowerRenderer.draw(ctx, tower);
        } else {
            // Default SPRITE style
            TowerRenderer.draw(ctx, tower);
        }
    }

    static drawEnemy(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        if (CONFIG.VISUAL_STYLE === 'INK') {
            InkEnemyRenderer.draw(ctx, enemy);
        } else {
            // Default SPRITE style
            EnemyRenderer.draw(ctx, enemy);
        }
    }

    static drawMap(ctx: CanvasRenderingContext2D, map: MapManager) {
        if (CONFIG.VISUAL_STYLE === 'INK') {
            InkMapRenderer.draw(ctx, map);
        } else {
            map.draw(ctx);
        }
    }

    static drawProjectile(ctx: CanvasRenderingContext2D, projectile: Projectile) {
        if (CONFIG.VISUAL_STYLE === 'INK') {
            InkProjectileRenderer.draw(ctx, projectile);
        } else {
            SpriteProjectileRenderer.draw(ctx, projectile);
        }
    }

    static drawEffect(ctx: CanvasRenderingContext2D, effect: IEffect) {
        if (CONFIG.VISUAL_STYLE === 'INK') {
            InkEffectRenderer.draw(ctx, effect);
            return true; // Return true to signal we handled it
        }
        return false; // Return false to fallback to default logic in EffectSystem
    }
}
</file>

<file path="src/renderers/InkDecorRenderer.ts">
import { CONFIG } from '../Config';
import { InkUtils } from '../graphics/InkUtils';
import { INK_CONFIG } from '../graphics/InkConfig';
import { ObjectType } from '../ObjectRenderer';

export class InkDecorRenderer {

    static draw(ctx: CanvasRenderingContext2D, type: string, x: number, y: number, size: number = 1) {
        const TS = CONFIG.TILE_SIZE;
        const centerX = x + (TS * size) / 2;
        const centerY = y + (TS * size) / 2;
        const seed = x * 101 + y * 73; // Deterministic seed

        ctx.save();
        ctx.strokeStyle = INK_CONFIG.PALETTE.INK;
        ctx.fillStyle = '#fff';
        ctx.lineWidth = 1.5;

        // Add subtle constant wobble for "alive" feel
        const time = Date.now() * 0.001;

        if (type === 'tree') {
            this.drawTree(ctx, centerX, y + TS, seed, time);
        } else if (type === 'rock' || type === 'stone') {
            this.drawRock(ctx, centerX, centerY, size * TS, seed);
        } else if (type === 'wheat') {
            this.drawWheat(ctx, x, y, TS, seed, time);
        } else if (type === 'flowers') {
            this.drawFlowers(ctx, x, y, TS, seed, time);
        }

        ctx.restore();
    }

    private static drawTree(ctx: CanvasRenderingContext2D, x: number, bottomY: number, seed: number, time: number) {
        // STYLE: Architectural Sketch / Minimalist
        // Simple distinct trunk line, loose minimal loop for foliage.

        const trunkHeight = 20 + (seed % 10);

        ctx.strokeStyle = INK_CONFIG.PALETTE.INK;
        ctx.lineWidth = 1.5;
        ctx.fillStyle = '#fff';

        // 1. Trunk: Single clean stroke (slightly thicker at bottom)
        ctx.beginPath();
        ctx.moveTo(x, bottomY);
        // Slight curve
        const bend = (seed % 5) - 2;
        ctx.quadraticCurveTo(x + bend, bottomY - trunkHeight / 2, x, bottomY - trunkHeight);
        ctx.stroke();

        // 2. Foliage: "Cloud on a stick" - Minimalist loop
        // Instead of many circles, one or two loose "sketchy" circles
        const radius = 14 + (seed % 6);
        const topY = bottomY - trunkHeight;

        ctx.beginPath();
        // Main foliage circle (wobbly but singular)
        InkUtils.drawWobbleCircle(ctx, x, topY - radius / 2, radius, 0);

        // Optional second offset circle for variety (50% chance)
        if (seed % 2 === 0) {
            InkUtils.drawWobbleCircle(ctx, x + (radius * 0.4), topY - radius * 0.2, radius * 0.7, 0);
        }

        // No fill, just outline, or maybe a very light hatch at the bottom of foliage
        // Hatching (Shadow side)
        ctx.lineWidth = 1;
        ctx.beginPath();
        const hatchY = topY + radius / 4;
        ctx.moveTo(x - radius / 2, hatchY);
        ctx.lineTo(x, hatchY + 5);
        ctx.stroke();
    }

    private static drawRock(ctx: CanvasRenderingContext2D, x: number, y: number, diameter: number, seed: number) {
        // STYLE: Zen Garden Rock / Schematic
        // Less vertices, smoother but angular.

        const radius = diameter * 0.3;
        ctx.strokeStyle = INK_CONFIG.PALETTE.INK;
        ctx.lineWidth = 1.5;
        ctx.fillStyle = '#fff'; // Paper inside

        ctx.beginPath();
        // 5-6 points for a simple stone shape
        const points = 5 + (seed % 2);
        for (let i = 0; i <= points; i++) {
            const angle = (i / points) * Math.PI * 2;
            // Less random variance for cleaner look
            const r = radius + ((seed * (i + 1) * 13) % 4) - 2;
            const px = x + Math.cos(angle) * r;
            const py = y + Math.sin(angle) * r * 0.8; // Flattened slightly
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill(); // Fill white to hide ground lines behind
        ctx.stroke();

        // Minimal hatching (just 2-3 lines on one side)
        ctx.lineWidth = 1;
        ctx.beginPath();
        const side = (seed % 2 === 0) ? 1 : -1;
        for (let i = 0; i < 3; i++) {
            const lx = x + (i * 3) * side;
            ctx.moveTo(lx, y + radius * 0.2);
            ctx.lineTo(lx, y + radius * 0.6);
        }
        ctx.stroke();
    }

    private static drawWheat(ctx: CanvasRenderingContext2D, x: number, y: number, size: number, seed: number, time: number) {
        // Minimal vertical strokes
        const count = 3 + (seed % 3);
        const sway = Math.sin(time + seed) * 2;

        ctx.beginPath();
        for (let i = 0; i < count; i++) {
            const ox = x + size / 2 + ((seed * i * 7) % 20) - 10;
            const oy = y + size - 5;
            const h = 10 + ((seed * i) % 5);

            ctx.moveTo(ox, oy);
            ctx.lineTo(ox + sway, oy - h);
        }
        ctx.stroke();
    }

    private static drawFlowers(ctx: CanvasRenderingContext2D, x: number, y: number, size: number, seed: number, time: number) {
        // Just small dots
        const count = 3 + (seed % 4);
        ctx.fillStyle = INK_CONFIG.PALETTE.INK; // Black dots like stiffle

        for (let i = 0; i < count; i++) {
            const fx = x + size / 2 + ((seed * i * 17) % 24) - 12;
            const fy = y + size / 2 + ((seed * i * 29) % 24) - 12;

            ctx.beginPath();
            ctx.arc(fx, fy, 1.5, 0, Math.PI * 2); // Tiny dots
            ctx.fill();
        }
    }
}
</file>

<file path="src/renderers/InkEffectRenderer.ts">
import { IEffect } from '../EffectSystem';
import { InkUtils } from '../graphics/InkUtils';
import { INK_CONFIG } from '../graphics/InkConfig';
import { Assets } from '../Assets';

export class InkEffectRenderer {
    static draw(ctx: CanvasRenderingContext2D, effect: IEffect) {
        const progress = effect.life / (effect.maxLife || 1);

        ctx.save();
        ctx.globalAlpha = progress;

        if (effect.type === 'text') {
            const fontSize = effect.fontSize || 16;
            ctx.fillStyle = effect.color || INK_CONFIG.PALETTE.INK;
            // Use a handwriting-style font if loaded, or serif
            ctx.font = `bold ${fontSize}px "MedievalSharp", "Courier New", serif`;
            ctx.textAlign = 'center';
            ctx.fillText(effect.text || '', effect.x, effect.y);
            // No heavy stroke, maybe slight shadow
            // ctx.shadowBlur = 2;
            // ctx.shadowColor = '#fff';
            // ctx.strokeText(effect.text || '', effect.x, effect.y);

        } else if (effect.type === 'particle') {
            // Ink dot
            ctx.fillStyle = effect.color || INK_CONFIG.PALETTE.INK;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius || 2, 0, Math.PI * 2);
            ctx.fill();

        } else if (effect.type === 'debris') {
            // Paper scrap
            ctx.translate(effect.x, effect.y);
            if (effect.rotation) ctx.rotate(effect.rotation);
            ctx.fillStyle = effect.color || '#fff';
            ctx.strokeStyle = INK_CONFIG.PALETTE.INK;
            ctx.lineWidth = 1;
            const s = effect.size || 4;
            ctx.fillRect(-s / 2, -s / 2, s, s);
            ctx.strokeRect(-s / 2, -s / 2, s, s);

        } else if (effect.type === 'muzzle_flash') {
            // Quick scratch
            const r = effect.radius || 12;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(effect.x, effect.y);
            ctx.lineTo(effect.x + (Math.random() - 0.5) * r * 2, effect.y + (Math.random() - 0.5) * r * 2);
            ctx.stroke();

        } else if (effect.type === 'scale_pop') {
            // DEATH POOF (Smoke Cloud)
            // Instead of scaling sprite, we draw a disappearing smoke cloud
            const smokeRadius = (effect.radius || 20) * (1 + progress * 0.5);
            const alpha = 1 - progress;

            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#111'; // Dark smoke
            ctx.beginPath();
            InkUtils.drawWobbleCircle(ctx, effect.x, effect.y, smokeRadius, Date.now() * 0.001);
            ctx.fill();

            // Internal turbulence lines
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const time = Date.now() * 0.005;
            InkUtils.drawWobbleLine(ctx, effect.x - 10, effect.y, effect.x + 10, effect.y, time);
            InkUtils.drawWobbleLine(ctx, effect.x, effect.y - 10, effect.x, effect.y + 10, time + 1);
            ctx.stroke();

        } else if (effect.type === 'explosion') {
            // Enhanced Ink Splat
            const splatRadius = effect.radius || 30;
            const color = effect.color === 'orange' ? INK_CONFIG.PALETTE.INK : (effect.color || '#000');

            // 1. Main blot
            InkUtils.drawInkSplat(ctx, effect.x, effect.y, splatRadius * progress, color, Date.now() * 0.001);

            // 2. Secondary droplets (flying out)
            if (progress < 0.5) {
                const dropletCount = 6;
                ctx.fillStyle = color;
                for (let i = 0; i < dropletCount; i++) {
                    const angle = (i / dropletCount) * Math.PI * 2 + Math.random();
                    const dist = splatRadius * (1 + progress * 4);
                    const r = 2 * (1 - progress * 2);
                    if (r > 0) {
                        ctx.beginPath();
                        ctx.arc(effect.x + Math.cos(angle) * dist, effect.y + Math.sin(angle) * dist, r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

        } else if (effect.type === 'screen_flash') {
            // Paper burn from edges? Or just tint.
            // Let's stick to tint for safety.
            const flashAlpha = progress * 0.4;
            ctx.fillStyle = effect.flashColor || 'rgba(255,0,0,1)';
            ctx.globalAlpha = flashAlpha;
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        }

        ctx.restore();
    }
}
</file>

<file path="src/renderers/InkProjectileRenderer.ts">
import { Projectile } from '../Projectile';
import { InkUtils } from '../graphics/InkUtils';
import { INK_CONFIG } from '../graphics/InkConfig';

export class InkProjectileRenderer {
    static draw(ctx: CanvasRenderingContext2D, projectile: Projectile) {
        if (!projectile.alive) return;

        const type = projectile.projectileType || 'standard';

        // --- Critical Hit Halo ---
        if (projectile.isCrit) {
            ctx.save();
            ctx.strokeStyle = '#ffd700'; // Gold ink
            ctx.lineWidth = 2;
            ctx.beginPath();
            // A quick scribbled circle
            const r = projectile.radius + 5;
            InkUtils.drawWobbleCircle(ctx, projectile.x, projectile.y, r, Date.now() * 0.01);
            ctx.restore();
        }

        // --- Projectile Body ---
        ctx.save();
        ctx.translate(projectile.x, projectile.y);

        if (type === 'fire') {
            // Watercolor Wash (Orange/Red)
            // Wet, undefined edges
            InkUtils.drawWatercolorFill(ctx, 0, 0, projectile.radius * 2, 'rgba(255, 87, 34, 0.8)');
            // Darker core
            InkUtils.drawInkSplat(ctx, 0, 0, projectile.radius, 'rgba(191, 54, 12, 0.9)');

        } else if (type === 'ice') {
            // Sharp Crystal Shards (Cyan)
            // Rotate to face movement
            const angle = Math.atan2(projectile.vy, projectile.vx);
            ctx.rotate(angle);

            ctx.strokeStyle = '#00acc1'; // Cyan ink
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Diamond shape sketch
            const len = 12;
            const wid = 6;
            ctx.moveTo(len, 0);
            ctx.lineTo(0, wid);
            ctx.lineTo(-len, 0);
            ctx.lineTo(0, -wid);
            ctx.closePath();
            ctx.stroke();

            // Inner hatching
            ctx.beginPath();
            ctx.moveTo(-4, -2);
            ctx.lineTo(4, 2);
            ctx.stroke();

        } else if (type === 'sniper') {
            // Pencil Line (Green/Black)
            const angle = Math.atan2(projectile.vy, projectile.vx);
            ctx.rotate(angle);

            ctx.strokeStyle = '#2e7d32'; // Green pencil
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            // Long, thin stroke
            InkUtils.drawWobbleLine(ctx, -20, 0, 10, 0);

        } else if (type === 'minigun') {
            // Small fast dots
            ctx.fillStyle = '#9c27b0';
            ctx.beginPath();
            ctx.arc(0, 0, 3, 0, Math.PI * 2);
            ctx.fill();
            // Motion blur line
            const angle = Math.atan2(projectile.vy, projectile.vx);
            ctx.rotate(angle);
            ctx.strokeStyle = 'rgba(156, 39, 176, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-10, 0);
            ctx.stroke();

        } else {
            // Standard / Multi: Ink Blob
            // Black/Sepia ink
            InkUtils.drawInkSplat(ctx, 0, 0, projectile.radius, INK_CONFIG.PALETTE.INK);
        }

        ctx.restore();
    }
}
</file>

<file path="src/renderers/ProceduralGrass.ts">
import { CONFIG } from '../Config';
import { VISUALS } from '../VisualConfig';

/**
 * –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∂–∏–≤–æ–π —Ç—Ä–∞–≤—ã
 * –î–æ–±–∞–≤–ª—è–µ—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ç—Ä–∞–≤–∏–Ω–∫–∏, –∫–∞–º–µ—à–∫–∏ –∏ –º–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏ –ø–æ–≤–µ—Ä—Ö –±–∞–∑–æ–≤–æ–≥–æ —Å–ª–æ—è
 * 
 * –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:
 * - –¢—Ä–∞–≤–∏–Ω–∫–∏: 12-18 –Ω–∞ —Ç–∞–π–ª, –≤—ã—Å–æ—Ç–∞ 4-8px, –Ω–∞–∫–ª–æ–Ω ¬±15¬∞
 * - –ö–∞–º–µ—à–∫–∏: 1-3 –Ω–∞ —Ç–∞–π–ª (60% —Ç–∞–π–ª–æ–≤)
 * - –¶–≤–µ—Ç–æ—á–∫–∏: 0-1 –Ω–∞ —Ç–∞–π–ª (5% —à–∞–Ω—Å)
 * 
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ö–ê–ñ–î–û–ì–û –≤–∞—Ä–∏–∞–Ω—Ç–∞ grass_0...grass_3
 */
export class ProceduralGrass {
    /**
     * –†–µ–Ω–¥–µ—Ä–∏—Ç —Å–ª–æ–π –¥–µ—Ç–∞–ª–µ–π –Ω–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –±–∞–∑—É
     * @param ctx Canvas context
     * @param x Pixel X (–æ–±—ã—á–Ω–æ 0 –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ Assets)
     * @param y Pixel Y (–æ–±—ã—á–Ω–æ 0 –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤ Assets)
     * @param size –†–∞–∑–º–µ—Ä —Ç–∞–π–ª–∞ (64px)
     * @param seed –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –¥–ª—è –≤–∞—Ä–∏–∞—Ü–∏–π
     */
    public static draw(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // 1. –¢—Ä–∞–≤–∏–Ω–∫–∏ (–æ—Å–Ω–æ–≤–Ω–æ–π –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç)
        this.drawGrassBlades(ctx, x, y, size, seed);

        // 2. –ú–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏ (–∫–∞–º–µ—à–∫–∏)
        this.drawPebbles(ctx, x, y, size, seed);

        // 3. –¶–≤–µ—Ç–æ—á–∫–∏ (–æ—á–µ–Ω—å —Ä–µ–¥–∫–æ)
        this.drawTinyFlowers(ctx, x, y, size, seed);
    }

    /**
     * –°–ª–æ–π 1: –û—Ç–¥–µ–ª—å–Ω—ã–µ —Ç—Ä–∞–≤–∏–Ω–∫–∏
     */
    private static drawGrassBlades(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–∞–≤–∏–Ω–æ–∫: 12-18
        const bladeCount = 12 + (seed % 7); // 12-18

        ctx.strokeStyle = VISUALS.ENVIRONMENT.GRASS.BLADE; // #8bc34a
        ctx.lineWidth = 1;

        for (let i = 0; i < bladeCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const bx = x + ((seed * 7 + i * 13) % size);
            const by = y + ((seed * 11 + i * 19) % size);

            // –í—ã—Å–æ—Ç–∞ —Ç—Ä–∞–≤–∏–Ω–∫–∏: 4-8px
            const height = 4 + ((seed + i * 3) % 5); // 4-8px

            // –ù–∞–∫–ª–æ–Ω: ¬±15¬∞
            const angleVariation = ((seed + i * 7) % 30) - 15; // -15 to +15
            const angle = angleVariation * Math.PI / 180;

            // –†–∏—Å—É–µ–º —Ç—Ä–∞–≤–∏–Ω–∫—É
            ctx.save();
            ctx.translate(bx, by);
            ctx.rotate(angle);

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -height); // –í–≤–µ—Ä—Ö –æ—Ç —Ç–æ—á–∫–∏
            ctx.stroke();

            ctx.restore();
        }
    }

    /**
     * –°–ª–æ–π 2: –ú–µ–ª–∫–∏–µ –∫–∞–º–µ—à–∫–∏
     */
    private static drawPebbles(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –ù–µ –Ω–∞ –≤—Å–µ—Ö —Ç–∞–π–ª–∞—Ö –µ—Å—Ç—å –∫–∞–º–µ—à–∫–∏ (60% —à–∞–Ω—Å)
        if (seed % 5 === 0 || seed % 5 === 1) {
            return; // –ù–µ—Ç –∫–∞–º–µ—à–∫–æ–≤ –Ω–∞ —ç—Ç–æ–º —Ç–∞–π–ª–µ
        }

        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–º–µ—à–∫–æ–≤: 1-3
        const pebbleCount = 1 + (seed % 3); // 1-3

        ctx.fillStyle = VISUALS.ENVIRONMENT.GRASS.DETAIL; // #757575

        for (let i = 0; i < pebbleCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const px = x + ((seed * 17 + i * 23) % size);
            const py = y + ((seed * 19 + i * 29) % size);

            // –†–∞–∑–º–µ—Ä: 1-2px
            const pebbleSize = 1 + ((seed + i) % 2);

            ctx.fillRect(px, py, pebbleSize, pebbleSize);
        }
    }

    /**
     * –°–ª–æ–π 3: –ú–µ–ª–∫–∏–µ —Ü–≤–µ—Ç–æ—á–∫–∏ (–æ—á–µ–Ω—å —Ä–µ–¥–∫–æ)
     */
    private static drawTinyFlowers(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –û—á–µ–Ω—å —Ä–µ–¥–∫–æ: 5% —à–∞–Ω—Å
        if (seed % 20 !== 0) {
            return; // –ù–µ—Ç —Ü–≤–µ—Ç–æ—á–∫–∞ –Ω–∞ —ç—Ç–æ–º —Ç–∞–π–ª–µ
        }

        // –ü–æ–∑–∏—Ü–∏—è: –±–ª–∏–∂–µ –∫ –∫—Ä–∞—è–º —Ç–∞–π–ª–∞
        const edge = seed % 4; // 0=top, 1=right, 2=bottom, 3=left
        let fx = x;
        let fy = y;

        switch (edge) {
            case 0: // Top
                fx = x + size / 2 + ((seed % 20) - 10);
                fy = y + 5 + (seed % 10);
                break;
            case 1: // Right
                fx = x + size - 10 - (seed % 10);
                fy = y + size / 2 + ((seed % 20) - 10);
                break;
            case 2: // Bottom
                fx = x + size / 2 + ((seed % 20) - 10);
                fy = y + size - 10 - (seed % 10);
                break;
            case 3: // Left
                fx = x + 5 + (seed % 10);
                fy = y + size / 2 + ((seed % 20) - 10);
                break;
        }

        // –†–∞–∑–º–µ—Ä: 2-3px
        const flowerSize = 2 + (seed % 2);

        // –Ø—Ä–∫–∞—è —Ç–æ—á–∫–∞
        ctx.fillStyle = VISUALS.ENVIRONMENT.GRASS.FLOWER; // #ffeb3b
        ctx.beginPath();
        ctx.arc(fx, fy, flowerSize, 0, Math.PI * 2);
        ctx.fill();

        // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –±–ª–∏–∫ (–µ—â–µ —è—Ä—á–µ)
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(fx, fy, flowerSize / 2, 0, Math.PI * 2);
        ctx.fill();
    }
}
</file>

<file path="src/renderers/ProceduralRoad.ts">
import { CONFIG } from '../Config';
import { VISUALS } from '../VisualConfig';

/**
 * –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∫–∞–º–µ–Ω–Ω–æ–π –¥–æ—Ä–æ–≥–∏
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –±–∏—Ç–º–∞—Å–∫–∏–Ω–≥ –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ø–ª–∏—Ç
 * 
 * –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:
 * - –°–≤–µ—Ç–ª–æ-–±–µ–∂–µ–≤—ã–π –∫–∞–º–µ–Ω—å —Å –≤–∞—Ä–∏–∞—Ü–∏—è–º–∏
 * - –¢—Ä–µ—â–∏–Ω—ã (2-4 –Ω–∞ –ø–ª–∏—Ç—É)
 * - –ó–µ—Ä–Ω–∏—Å—Ç–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ (–∫—Ä–∞–ø–∏–Ω–∫–∏)
 * - –¢—ë–º–Ω—ã–µ –∫—Ä–∞—è –º–µ–∂–¥—É –ø–ª–∏—Ç–∞–º–∏
 * - –†–µ–¥–∫–∏–µ –º–æ—Ö–æ–≤—ã–µ –ø—è—Ç–Ω–∞
 */
export class ProceduralRoad {
    /**
     * –†–µ–Ω–¥–µ—Ä–∏—Ç –æ–¥–Ω—É –∫–∞–º–µ–Ω–Ω—É—é –ø–ª–∏—Ç—É —Å —É—á—ë—Ç–æ–º —Å–æ—Å–µ–¥–µ–π
     * @param ctx Canvas context
     * @param x Pixel X (–∫—Ä–∞—Ç–Ω–æ TILE_SIZE)
     * @param y Pixel Y (–∫—Ä–∞—Ç–Ω–æ TILE_SIZE)
     * @param bitmask –ë–∏—Ç–º–∞—Å–∫–∞ —Å–æ—Å–µ–¥–µ–π 0-15 (NORTH|WEST|EAST|SOUTH)
     */
    public static draw(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        bitmask: number
    ): void {
        const TS = CONFIG.TILE_SIZE;
        const col = Math.floor(x / TS);
        const row = Math.floor(y / TS);

        // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –¥–ª—è –≤–∞—Ä–∏–∞—Ü–∏–π
        const seed = col * 73 + row * 37;

        // 1. –ë–∞–∑–æ–≤–∞—è –ø–ª–∏—Ç–∞ (—Å –≤–∞—Ä–∏–∞—Ü–∏—è–º–∏)
        this.drawBaseTile(ctx, x, y, TS, seed);

        // 2. –ö—Ä–∞—è/–≥—Ä–∞–Ω–∏—Ü—ã (—Ç–æ–ª—å–∫–æ —Ç–∞–º –≥–¥–µ –Ω–µ—Ç —Å–æ—Å–µ–¥–µ–π)
        this.drawEdges(ctx, x, y, TS, bitmask, seed);

        // 3. –î–µ—Ç–∞–ª–∏ (—Ç—Ä–µ—â–∏–Ω—ã, –∫—Ä–∞–ø–∏–Ω–∫–∏)
        this.drawDetails(ctx, x, y, TS, seed);
    }

    /**
     * –°–ª–æ–π 1: –ë–∞–∑–æ–≤–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ –∫–∞–º–Ω—è
     */
    private static drawBaseTile(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –í–∞—Ä–∏–∞—Ü–∏—è —è—Ä–∫–æ—Å—Ç–∏: ¬±10%
        const brightness = 0.9 + (seed % 20) * 0.01; // 0.9 - 1.09

        // –í—ã–±—Ä–∞—Ç—å –±–∞–∑–æ–≤—ã–π –æ—Ç—Ç–µ–Ω–æ–∫
        const baseColors = [
            VISUALS.ENVIRONMENT.PATH.STONE_BASE,   // #c5b8a1
            VISUALS.ENVIRONMENT.PATH.STONE_LIGHT,  // #d4c5a9
            VISUALS.ENVIRONMENT.PATH.STONE_DARK    // #b6a890
        ];
        const colorIndex = seed % 3;
        let baseColor = baseColors[colorIndex];

        // –ü—Ä–∏–º–µ–Ω–∏—Ç—å –≤–∞—Ä–∏–∞—Ü–∏—é —è—Ä–∫–æ—Å—Ç–∏
        baseColor = this.adjustBrightness(baseColor, brightness);

        // –ó–∞–ø–æ–ª–Ω–∏—Ç—å –ø–ª–∏—Ç—É
        ctx.fillStyle = baseColor;
        ctx.fillRect(x, y, size, size);

        // –¢–µ–∫—Å—Ç—É—Ä–∞: –º–µ–ª–∫–æ–∑–µ—Ä–Ω–∏—Å—Ç–∞—è (–∫—Ä–∞–ø–∏–Ω–∫–∏)
        this.drawGrainTexture(ctx, x, y, size, seed);
    }

    /**
     * –ó–µ—Ä–Ω–∏—Å—Ç–∞—è —Ç–µ–∫—Å—Ç—É—Ä–∞ (–º–µ–ª–∫–∏–µ –∫—Ä–∞–ø–∏–Ω–∫–∏)
     */
    private static drawGrainTexture(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        const speckCount = 8 + (seed % 8); // 8-15 –∫—Ä–∞–ø–∏–Ω–æ–∫

        ctx.fillStyle = '#5a5a5a'; // –¢—ë–º–Ω–æ-—Å–µ—Ä—ã–π

        for (let i = 0; i < speckCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const sx = x + ((seed * 7 + i * 13) % size);
            const sy = y + ((seed * 11 + i * 19) % size);
            const speckSize = 1 + ((seed + i) % 3); // 1-3px

            ctx.fillRect(sx, sy, speckSize, speckSize);
        }
    }

    /**
     * –°–ª–æ–π 2: –ö—Ä–∞—è –º–µ–∂–¥—É –ø–ª–∏—Ç–∞–º–∏
     * –†–∏—Å—É–µ–º —Ç–µ–º–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–æ–ª—å–∫–æ —Ç–∞–º, –≥–¥–µ –ù–ï–¢ —Å–æ—Å–µ–¥–µ–π
     */
    private static drawEdges(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        bitmask: number,
        seed: number
    ): void {
        const NORTH = (bitmask & 1) !== 0;
        const WEST = (bitmask & 2) !== 0;
        const EAST = (bitmask & 4) !== 0;
        const SOUTH = (bitmask & 8) !== 0;

        ctx.strokeStyle = VISUALS.ENVIRONMENT.PATH.EDGE; // #9a8d7a
        ctx.lineWidth = 2;

        // –°–µ–≤–µ—Ä–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!NORTH) {
            ctx.beginPath();
            ctx.moveTo(x, y + 1);
            ctx.lineTo(x + size, y + 1);
            ctx.stroke();
        }

        // –Æ–∂–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!SOUTH) {
            ctx.beginPath();
            ctx.moveTo(x, y + size - 1);
            ctx.lineTo(x + size, y + size - 1);
            ctx.stroke();
        }

        // –ó–∞–ø–∞–¥–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!WEST) {
            ctx.beginPath();
            ctx.moveTo(x + 1, y);
            ctx.lineTo(x + 1, y + size);
            ctx.stroke();
        }

        // –í–æ—Å—Ç–æ—á–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
        if (!EAST) {
            ctx.beginPath();
            ctx.moveTo(x + size - 1, y);
            ctx.lineTo(x + size - 1, y + size);
            ctx.stroke();
        }
    }

    /**
     * –°–ª–æ–π 3: –î–µ—Ç–∞–ª–∏ (—Ç—Ä–µ—â–∏–Ω—ã, –º–æ—Ö)
     */
    private static drawDetails(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –¢—Ä–µ—â–∏–Ω—ã: 2-4 –Ω–∞ –ø–ª–∏—Ç—É
        const crackCount = 2 + (seed % 3); // 2-4

        ctx.strokeStyle = VISUALS.ENVIRONMENT.PATH.CRACK; // #8b7e6a
        ctx.lineWidth = 1 + (seed % 2); // 1-2px

        for (let i = 0; i < crackCount; i++) {
            this.drawCrack(ctx, x, y, size, seed + i * 100);
        }

        // –ú–æ—Ö (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, —Ä–µ–¥–∫–æ): 0-1 –ø—è—Ç–Ω–æ
        if (seed % 5 === 0) { // 20% —à–∞–Ω—Å
            this.drawMoss(ctx, x, y, size, seed);
        }
    }

    /**
     * –†–∏—Å—É–µ—Ç –æ–¥–Ω—É —Ç—Ä–µ—â–∏–Ω—É
     */
    private static drawCrack(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –°—Ç–∞—Ä—Ç–æ–≤–∞—è —Ç–æ—á–∫–∞ (–∫—Ä–∞–π –ø–ª–∏—Ç—ã –∏–ª–∏ —Ü–µ–Ω—Ç—Ä)
        const startX = x + ((seed * 3) % size);
        const startY = y + ((seed * 7) % size);

        // –î–ª–∏–Ω–∞ —Ç—Ä–µ—â–∏–Ω—ã: 20-40px
        const length = 20 + (seed % 21);
        const angle = (seed % 360) * Math.PI / 180;

        // –ö–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞
        const endX = startX + Math.cos(angle) * length;
        const endY = startY + Math.sin(angle) * length;

        ctx.beginPath();
        ctx.moveTo(startX, startY);

        // –õ–æ–º–∞–Ω–∞—è –ª–∏–Ω–∏—è (3-5 —Å–µ–≥–º–µ–Ω—Ç–æ–≤)
        const segments = 3 + (seed % 3);
        for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            const midX = startX + (endX - startX) * t;
            const midY = startY + (endY - startY) * t;

            // –°–ª—É—á–∞–π–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ ¬±5px
            const offsetX = ((seed * i * 11) % 11) - 5;
            const offsetY = ((seed * i * 13) % 11) - 5;

            ctx.lineTo(midX + offsetX, midY + offsetY);
        }

        ctx.stroke();
    }

    /**
     * –†–∏—Å—É–µ—Ç –º–æ—Ö–æ–≤–æ–µ –ø—è—Ç–Ω–æ
     */
    private static drawMoss(
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        size: number,
        seed: number
    ): void {
        // –ü–æ–∑–∏—Ü–∏—è: —É–≥–æ–ª –ø–ª–∏—Ç—ã
        const corner = seed % 4; // 0=NW, 1=NE, 2=SW, 3=SE
        let mossX = x;
        let mossY = y;

        switch (corner) {
            case 0: mossX = x + 5; mossY = y + 5; break;         // NW
            case 1: mossX = x + size - 10; mossY = y + 5; break; // NE
            case 2: mossX = x + 5; mossY = y + size - 10; break; // SW
            case 3: mossX = x + size - 10; mossY = y + size - 10; break; // SE
        }

        const mossSize = 3 + (seed % 4); // 3-6px

        ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.MOSS; // #7a8f63
        ctx.globalAlpha = 0.6; // –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π
        ctx.beginPath();
        ctx.arc(mossX, mossY, mossSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0; // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å
    }

    /**
     * –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –∏–∑–º–µ–Ω–µ–Ω–∏–µ —è—Ä–∫–æ—Å—Ç–∏ —Ü–≤–µ—Ç–∞
     */
    private static adjustBrightness(color: string, factor: number): string {
        // –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è: –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å HEX ‚Üí RGB ‚Üí —É–º–Ω–æ–∂–∏—Ç—å ‚Üí HEX
        const hex = color.replace('#', '');
        const r = Math.min(255, Math.round(parseInt(hex.substr(0, 2), 16) * factor));
        const g = Math.min(255, Math.round(parseInt(hex.substr(2, 2), 16) * factor));
        const b = Math.min(255, Math.round(parseInt(hex.substr(4, 2), 16) * factor));

        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }
}
</file>

<file path="src/renderers/SpriteProjectileRenderer.ts">
import { Assets } from '../Assets';
import { Projectile } from '../Projectile';

export class SpriteProjectileRenderer {
    static draw(ctx: CanvasRenderingContext2D, projectile: Projectile) {
        if (!projectile.alive) return;

        // Enhanced visual for critical hits
        if (projectile.isCrit) {
            // Enhanced visual for critical hits (kept dynamic for glow intensity)
            ctx.save();
            // Outer glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff3300'; // Orange-red glow
            ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius + 6, 0, Math.PI * 2);
            ctx.fill();

            // Inner core glow
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffff00';
            ctx.fillStyle = '#ffffaa';
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius + 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Inner bright core
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // --- BAKED PROJECTILES ---
            const type = projectile.projectileType || 'standard';
            const img = Assets.get(`projectile_${type}`);

            if (img) {
                const size = 16;
                ctx.save();
                ctx.translate(projectile.x, projectile.y);

                // Rotate if needed
                if (type === 'ice' || type === 'sniper') {
                    const angle = Math.atan2(projectile.vy, projectile.vx);
                    ctx.rotate(angle);
                }

                ctx.drawImage(img, -size / 2, -size / 2);

                // Level-based trail effects
                if (projectile.towerLevel >= 2) {
                    const angle = Math.atan2(projectile.vy, projectile.vx);

                    // Fade in trail over first 30 frames (0.5 seconds)
                    const trailOpacity = Math.min(1, (120 - projectile.life) / 30);

                    ctx.save();
                    ctx.rotate(angle);

                    if (projectile.towerLevel === 2) {
                        // LVL 2: Light trail
                        ctx.strokeStyle = projectile.color;
                        ctx.globalAlpha = 0.4 * trailOpacity;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-size * 1.2, 0);
                        ctx.stroke();
                    } else if (projectile.towerLevel === 3) {
                        // LVL 3: Bright trail with glow
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = projectile.color;
                        ctx.strokeStyle = projectile.color;
                        ctx.globalAlpha = 0.7 * trailOpacity;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-size * 2, 0);
                        ctx.stroke();

                        // Inner bright core trail
                        ctx.shadowBlur = 5;
                        ctx.strokeStyle = '#fff';
                        ctx.globalAlpha = 0.9 * trailOpacity;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-size * 1.5, 0);
                        ctx.stroke();
                    }

                    ctx.restore();
                }

                // Sniper Trail (original, still works)
                if (type === 'sniper') {
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = projectile.color;
                    // Draw line relative to rotated context (backing up)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-size * 1.5, 0);
                    ctx.stroke();
                }

                ctx.restore();
            } else {
                // Fallback
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
}
</file>

<file path="src/renderers/TowerRenderer.ts">
import { Assets } from '../Assets';
import { CONFIG } from '../Config';
import { VISUALS } from '../VisualConfig';
import type { Tower } from '../Tower';

export class TowerRenderer {
    static draw(ctx: CanvasRenderingContext2D, tower: Tower) {
        const size = CONFIG.TILE_SIZE;
        const drawX = tower.col * size;
        const drawY = tower.row * size;

        if (tower.isBuilding) {
            TowerRenderer.drawBuildingState(ctx, tower, drawX, drawY, size);
        } else {
            TowerRenderer.drawActiveState(ctx, tower, size);
            // Draw Heat Haze (outside rotation context to rise UP)
            if (tower.spinupFrames > 0) {
                // We need to confirm it's minigun, but drawActiveState encapsulates that logic mostly.
                // Actually, drawActiveState draws the bar, let's look closer.
                // Helper method call in drawActiveState is better.
            }
        }
    }

    private static drawBuildingState(ctx: CanvasRenderingContext2D, tower: Tower, drawX: number, drawY: number, size: number) {
        // Enhanced building animation - base emerges from below with opacity
        const pct = tower.buildProgress / tower.maxBuildProgress;
        const emergeOffset = (1 - pct) * 15; // Starts 15px below, rises to 0
        const halfSize = size / 2;

        ctx.save();

        // Clip to only show portion based on progress (reveal from bottom)
        ctx.beginPath();
        const clipHeight = size * pct;
        ctx.rect(drawX, drawY + size - clipHeight - emergeOffset, size, clipHeight + 5);
        ctx.clip();

        // Draw actual base with reduced opacity
        ctx.globalAlpha = 0.5 + pct * 0.5; // 50% -> 100% opacity
        const baseImg = Assets.get('base_default');
        if (baseImg) {
            ctx.drawImage(baseImg, drawX, drawY - emergeOffset);
        } else {
            // Fallback circle
            ctx.fillStyle = CONFIG.COLORS.TOWER_BASE;
            ctx.beginPath();
            ctx.arc(tower.x, tower.y - emergeOffset, size * 0.35, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();

        // Holographic construction lines overlay
        ctx.save();
        ctx.globalAlpha = 0.3 * (1 - pct); // Fade out as progress increases
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(tower.x, tower.y, size * 0.35, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        // Progress bar
        const barWidth = size - 10;
        ctx.fillStyle = VISUALS.TOWER.BUILDING.BAR_BG;
        ctx.fillRect(drawX + 5, drawY + size - 10, barWidth, 5);
        ctx.fillStyle = '#4caf50'; // Green progress
        ctx.fillRect(drawX + 5, drawY + size - 10, barWidth * pct, 5);
    }

    private static drawActiveState(ctx: CanvasRenderingContext2D, tower: Tower, size: number) {
        // 1. Draw Base
        const halfSize = size / 2;
        const baseImg = Assets.get('base_default');
        if (baseImg) {
            ctx.drawImage(baseImg, tower.x - halfSize, tower.y - halfSize);
        }

        // 2. Determine Turret Asset based on Main Card (First Slot)
        let turretName = 'turret_standard';
        const mainCard = tower.cards[0];
        if (mainCard) {
            if (mainCard.type.id === 'ice') turretName = 'turret_ice';
            else if (mainCard.type.id === 'fire') turretName = 'turret_fire';
            else if (mainCard.type.id === 'sniper') turretName = 'turret_sniper';
            else if (mainCard.type.id === 'multi') turretName = 'turret_split';
            else if (mainCard.type.id === 'minigun') turretName = 'turret_minigun';
        }

        // 3. Draw Turret (Rotated) with Level Visuals
        const turretImg = Assets.get(turretName);
        if (turretImg) {
            ctx.save();
            ctx.translate(tower.x, tower.y);
            ctx.rotate(tower.angle);

            // Progressive scaling based on HIGHEST card level (not just first card)
            const cardLevel = tower.cards.length > 0
                ? Math.max(...tower.cards.map(c => c.level))
                : 1;
            const scaleMultiplier = 1.0 + ((cardLevel - 1) * 0.15); // LVL2=1.15, LVL3=1.30
            ctx.scale(scaleMultiplier, scaleMultiplier);

            // Recoil offset
            if (tower.recoilFrames > 0) {
                const recoilOffset = Math.sin(tower.recoilFrames * 0.5) * tower.recoilIntensity;
                ctx.translate(0, recoilOffset);
                tower.recoilFrames--;
            }

            ctx.drawImage(turretImg, -halfSize, -halfSize);

            // 4. Draw Modules (Attachments)
            TowerRenderer.drawModules(ctx, tower);

            // Laser Sight for Sniper (Only if Turret is Sniper)
            if (turretName === 'turret_sniper') {
                TowerRenderer.drawLaserSight(ctx, tower);
            }

            ctx.restore();

            // Level-based visual effects (outside rotation context)
            TowerRenderer.drawLevelVisuals(ctx, tower, cardLevel, mainCard);

            // 5. Minigun Overheat Bar & Heat Haze
            if (turretName === 'turret_minigun' && tower.spinupFrames > 0) {
                TowerRenderer.drawOverheatBar(ctx, tower);
                TowerRenderer.drawHeatHaze(ctx, tower);
            }
        }
    }

    private static drawModules(ctx: CanvasRenderingContext2D, tower: Tower) {
        tower.cards.forEach((card, index) => {
            // Slot 0 Defines Turret Body. Modules are for Index > 0
            if (index > 0) {
                let modName = '';
                if (card.type.id === 'ice') modName = 'mod_ice';
                else if (card.type.id === 'fire') modName = 'mod_fire';
                else if (card.type.id === 'sniper') modName = 'mod_sniper';
                else if (card.type.id === 'multi') modName = 'mod_split';
                else if (card.type.id === 'minigun') modName = 'mod_minigun';

                const modImg = Assets.get(modName);
                if (modImg) {
                    let offX = 0;
                    let offY = 0;

                    if (index === 1) {
                        offX = -5; offY = 12; // Side 1
                    } else if (index === 2) {
                        offX = -5; offY = -12; // Side 2
                    } else {
                        offX = -12; offY = 0; // Back
                    }

                    ctx.save();
                    ctx.translate(offX, offY);
                    ctx.drawImage(modImg, -12, -12);
                    ctx.restore();
                }
            }
        });
    }

    private static drawLaserSight(ctx: CanvasRenderingContext2D, tower: Tower) {
        // Draw faint red line
        const stats = tower.getStats();
        // Pulse effect
        const opacity = 0.4 + Math.sin(Date.now() * 0.005) * 0.2; // 0.2 to 0.6

        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.strokeStyle = VISUALS.TOWER.LASER;
        ctx.globalAlpha = opacity;
        ctx.lineWidth = 1.5;

        ctx.beginPath();
        ctx.moveTo(10, 0); // Start from end of barrel approx
        ctx.lineTo(stats.range, 0); // extend to max range
        ctx.stroke();

        // Dot at the end
        ctx.fillStyle = VISUALS.TOWER.LASER;
        ctx.globalAlpha = opacity * 1.5;
        ctx.beginPath();
        ctx.arc(stats.range, 0, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    private static drawLevelVisuals(ctx: CanvasRenderingContext2D, tower: Tower, visualLevel: number, mainCard: any) {
        if (visualLevel > 1) {
            ctx.save();
            ctx.translate(tower.x, tower.y);

            if (visualLevel === 2) {
                // LVL 2: Pulse Glow
                const pulse = 0.3 + Math.sin(Date.now() * 0.003) * 0.1;
                const cardColor = mainCard?.type.color || '#fff';
                const gradient = ctx.createRadialGradient(0, 0, 10, 0, 0, 25);
                gradient.addColorStop(0, `${cardColor}00`);
                gradient.addColorStop(1, `${cardColor}${Math.floor(pulse * 255).toString(16).padStart(2, '0')}`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, 25, 0, Math.PI * 2);
                ctx.fill();
            } else if (visualLevel === 3) {
                // LVL 3: Rotating Aura Ring
                const rotation = (Date.now() * 0.002) % (Math.PI * 2);
                const cardColor = mainCard?.type.color || '#fff';
                ctx.strokeStyle = cardColor;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;

                // Draw rotating arc segments
                for (let i = 0; i < 3; i++) {
                    const angle = rotation + (i * Math.PI * 2 / 3);
                    ctx.beginPath();
                    ctx.arc(0, 0, 28, angle, angle + Math.PI / 3);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1.0;
            }

            // Level counter badge
            ctx.fillStyle = '#ffd700'; // Gold
            ctx.font = 'bold 14px Arial';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText(visualLevel.toString(), 20, -20);
            ctx.fillText(visualLevel.toString(), 20, -20);

            ctx.restore();
        }
    }

    private static drawOverheatBar(ctx: CanvasRenderingContext2D, tower: Tower) {
        // Calculate heat percentage
        const maxFrames = tower.maxHeat || 420;
        let pct = tower.spinupFrames / maxFrames;
        if (pct > 1) pct = 1;

        // Visual flash if overheated
        if (tower.isOverheated) {
            pct = 1; // Full bar
        }

        const barW = 4;
        const barH = 20;
        const barX = tower.x + 20; // Right of tower
        const barY = tower.y - 10;

        // Bg
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(barX, barY, barW, barH);

        // Fill
        // Color gradient from yellow to red
        if (tower.isOverheated) {
            ctx.fillStyle = (Math.floor(Date.now() / 100) % 2 === 0) ? '#ff0000' : '#ffffff'; // Flash
        } else {
            const r = 255;
            const g = Math.floor(255 * (1 - pct));
            ctx.fillStyle = `rgb(${r},${g},0)`;
        }

        // Draw from bottom up
        const fillH = barH * pct;
        ctx.fillRect(barX, barY + (barH - fillH), barW, fillH);

        // Border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barW, barH);
    }

    private static drawHeatHaze(ctx: CanvasRenderingContext2D, tower: Tower) {
        // Heat rises from the barrel
        // Calculate barrel tip world position
        const barrelLen = 30;
        const tipX = tower.x + Math.cos(tower.angle) * barrelLen;
        const tipY = tower.y + Math.sin(tower.angle) * barrelLen;

        ctx.save();
        // Use time for animation
        const time = Date.now() * 0.005;

        // Draw multiple rising heat puffs
        for (let i = 0; i < 3; i++) {
            // Oscillating offset
            // Cycle 0..50 pixels UP
            const cycleDur = 50;
            const offset = (time * 20 + i * (cycleDur / 3)) % cycleDur;

            // Fade out as it goes up (1.0 at bottom, 0.0 at top)
            const alpha = Math.max(0, (1 - (offset / cycleDur)) * 0.2);

            // Sway left/right
            const sway = Math.sin(time + i) * 5;
            const dist = offset; // rising

            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.beginPath();
            // Circle grows as it rises
            const size = 5 + (offset * 0.2);
            ctx.arc(tipX + sway, tipY - dist, size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
}
</file>

<file path="src/renderers/units/SkeletonUnitRenderer.ts">
import { UnitRenderer } from './UnitRenderer';
import type { Enemy } from '../../Enemy';

export class SkeletonUnitRenderer implements UnitRenderer {
    // Palette
    private static readonly BONE_LIGHT = '#e0d0b0';
    private static readonly BONE_DARK = '#a89070';
    private static readonly BONE_OUTLINE = '#5d4037';
    private static readonly RED_GLOW = '#d32f2f';
    private static readonly ARMOR_DARK = '#2d2d2d';
    private static readonly ARMOR_LIGHT = '#546e7a';

    // Config
    private static readonly HEAD_RADIUS = 5.5;

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        const time = Date.now() * 0.005;
        const walkCycle = time * (enemy.baseSpeed * 2);
        const isMoving = !enemy.finished && enemy.currentHealth > 0;

        let facing: 'DOWN' | 'UP' | 'SIDE' = 'SIDE';

        // Rotation Logic
        const r = rotation;
        if (r > -2.35 && r < -0.78) facing = 'UP';
        else if (r > 0.78 && r < 2.35) facing = 'DOWN';
        else facing = 'SIDE';

        ctx.save();

        if (facing === 'SIDE') {
            // Flip for Left Facing
            if (Math.abs(rotation) > Math.PI / 2) {
                ctx.scale(-1, 1);
            }
            this.drawSide(ctx, scale, walkCycle, isMoving);
        } else if (facing === 'UP') {
            this.drawBack(ctx, scale, walkCycle, isMoving);
        } else {
            this.drawFront(ctx, scale, walkCycle, isMoving);
        }

        ctx.restore();
    }

    // === FRONT VIEW (Walking Down) ===
    private drawFront(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;

        // Feet
        const leftFootY = isMoving ? Math.sin(walkCycle) * 4 * scale + (8 * scale) : 8 * scale;
        const rightFootY = isMoving ? Math.sin(walkCycle + Math.PI) * 4 * scale + (8 * scale) : 8 * scale;
        this.drawFoot(ctx, -5 * scale, leftFootY, scale);
        this.drawFoot(ctx, 5 * scale, rightFootY, scale);

        ctx.translate(0, -bounce);

        // Torso/Armor (Layer 1 - Behind items)
        this.drawTorsoFront(ctx, scale);

        // Arms (Swaying)
        const armSway = isMoving ? Math.sin(walkCycle) * 0.2 : 0;

        // Left (Shield)
        ctx.save();
        ctx.translate(-11 * scale, 0 + armSway * 5 * scale);
        // Arm Bone
        this.drawBoneArm(ctx, scale, 0);
        // Shield facing camera
        ctx.translate(0, 6 * scale);
        this.drawShieldFront(ctx, scale);
        ctx.restore();

        // Right (Sword)
        ctx.save();
        ctx.translate(11 * scale, 0 - armSway * 5 * scale);
        this.drawBoneArm(ctx, scale, 0);
        ctx.translate(0, 6 * scale);
        this.drawSwordFront(ctx, scale);
        ctx.restore();

        // Head
        ctx.translate(0, -5 * scale); // Neck height
        this.drawSkullFront(ctx, scale);
    }

    // === BACK VIEW (Walking Up) ===
    private drawBack(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;

        // Feet
        const leftFootY = isMoving ? Math.sin(walkCycle) * 4 * scale : 0;
        const rightFootY = isMoving ? Math.sin(walkCycle + Math.PI) * 4 * scale : 0;
        this.drawFoot(ctx, -5 * scale, leftFootY - 2 * scale, scale);
        this.drawFoot(ctx, 5 * scale, rightFootY - 2 * scale, scale);

        ctx.translate(0, -bounce);

        // Arms (Layer 0 - Before Body)
        const armSway = isMoving ? Math.sin(walkCycle) * 0.2 : 0;

        // Left Item (Shield - Back view)
        ctx.save();
        ctx.translate(-11 * scale, 0 - armSway * 5 * scale);
        this.drawBoneArm(ctx, scale, 0);
        ctx.translate(0, 6 * scale);
        this.drawShieldBack(ctx, scale);
        ctx.restore();

        // Right Item (Sword - Back view)
        ctx.save();
        ctx.translate(11 * scale, 0 + armSway * 5 * scale);
        this.drawBoneArm(ctx, scale, 0);
        ctx.translate(0, 6 * scale);
        this.drawSwordBack(ctx, scale);
        ctx.restore();

        // Torso Back 
        this.drawTorsoBack(ctx, scale);

        // Head
        ctx.translate(0, -5 * scale);
        this.drawSkullBack(ctx, scale);
    }

    // === SIDE VIEW (Walking Right) ===
    private drawSide(ctx: CanvasRenderingContext2D, scale: number, walkCycle: number, isMoving: boolean) {
        const bounce = isMoving ? Math.abs(Math.sin(walkCycle)) * 2 * scale : 0;

        // Feet (Scissor)
        const stride = 5 * scale;
        const leftFootX = isMoving ? Math.sin(walkCycle) * stride : 0;
        const rightFootX = isMoving ? -Math.sin(walkCycle) * stride : 0;
        this.drawFoot(ctx, leftFootX, 8 * scale, scale);
        this.drawFoot(ctx, rightFootX, 8 * scale, scale);

        ctx.translate(0, -bounce);

        // Back Arm (Shield) - Behind Torso
        const armSway = isMoving ? Math.cos(walkCycle) * 0.6 : 0;
        ctx.save();
        ctx.translate(-3 * scale, 0 - armSway * 5 * scale);
        ctx.rotate(-0.2); // Angle back
        this.drawBoneArm(ctx, scale, 0);
        ctx.translate(0, 6 * scale);
        // Shield Profile (Edge)
        this.drawShieldSide(ctx, scale);
        ctx.restore();

        // Torso Side
        this.drawTorsoSide(ctx, scale);

        // Front Arm (Sword) - In Front of Torso
        ctx.save();
        ctx.translate(3 * scale, 1 * scale + armSway * 5 * scale);
        ctx.rotate(0.2); // Angle forward
        this.drawBoneArm(ctx, scale, 0);
        ctx.translate(0, 6 * scale);
        this.drawSwordSide(ctx, scale);
        ctx.restore();

        // Head
        ctx.translate(1 * scale, -5 * scale); // Shift fwd slightly
        this.drawSkullSide(ctx, scale);
    }

    // --- BODY PARTS ---

    private drawTorsoFront(ctx: CanvasRenderingContext2D, scale: number) {
        // Ribcage / Armor Plate
        ctx.fillStyle = SkeletonUnitRenderer.ARMOR_DARK;
        ctx.beginPath();
        // Trapezoid shape
        ctx.moveTo(-7 * scale, -7 * scale); // Shoulders
        ctx.lineTo(7 * scale, -7 * scale);
        ctx.lineTo(5 * scale, 5 * scale); // Waist
        ctx.lineTo(-5 * scale, 5 * scale);
        ctx.fill();

        // Rib details
        ctx.strokeStyle = SkeletonUnitRenderer.BONE_LIGHT;
        ctx.lineWidth = 2 * scale;
        ctx.beginPath();
        ctx.moveTo(-4 * scale, -2 * scale); ctx.lineTo(4 * scale, -2 * scale);
        ctx.moveTo(-3 * scale, 1 * scale); ctx.lineTo(3 * scale, 1 * scale);
        ctx.stroke();
    }

    private drawTorsoBack(ctx: CanvasRenderingContext2D, scale: number) {
        // Spine / Armor Plate
        ctx.fillStyle = SkeletonUnitRenderer.ARMOR_DARK;
        ctx.beginPath();
        ctx.moveTo(-7 * scale, -7 * scale);
        ctx.lineTo(7 * scale, -7 * scale);
        ctx.lineTo(5 * scale, 5 * scale);
        ctx.lineTo(-5 * scale, 5 * scale);
        ctx.fill();

        // Spine details
        ctx.strokeStyle = SkeletonUnitRenderer.BONE_DARK;
        ctx.lineWidth = 3 * scale;
        ctx.beginPath();
        ctx.moveTo(0, -6 * scale);
        ctx.lineTo(0, 4 * scale);
        ctx.stroke();
    }

    private drawTorsoSide(ctx: CanvasRenderingContext2D, scale: number) {
        ctx.fillStyle = SkeletonUnitRenderer.ARMOR_DARK;
        ctx.beginPath();
        ctx.ellipse(0, -1 * scale, 4 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawBoneArm(ctx: CanvasRenderingContext2D, scale: number, angle: number) {
        ctx.strokeStyle = SkeletonUnitRenderer.BONE_LIGHT;
        ctx.lineWidth = 2.5 * scale;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, 6 * scale);
        ctx.stroke();
    }

    private drawFoot(ctx: CanvasRenderingContext2D, x: number, y: number, scale: number) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = SkeletonUnitRenderer.BONE_DARK;
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.5 * scale, 3.5 * scale, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    // --- HEADS ---

    private drawSkullFront(ctx: CanvasRenderingContext2D, scale: number) {
        const r = SkeletonUnitRenderer.HEAD_RADIUS * scale;
        // Cranium
        ctx.fillStyle = SkeletonUnitRenderer.BONE_LIGHT;
        ctx.beginPath();
        ctx.arc(0, -2 * scale, r, 0, Math.PI * 2);
        ctx.fill();
        // Jaw
        ctx.beginPath();
        ctx.rect(-2.5 * scale, 2 * scale, 5 * scale, 2.5 * scale);
        ctx.fill();

        // Eyes
        const eyeY = 0 * scale;
        const eyeX = 2 * scale;
        const eyeSize = 1.8 * scale;
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(-eyeX, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeX, eyeY, eyeSize, 0, Math.PI * 2); ctx.fill();

        // Glow
        ctx.fillStyle = SkeletonUnitRenderer.RED_GLOW;
        const glowSize = 0.6 * scale;
        ctx.beginPath(); ctx.arc(-eyeX, eyeY, glowSize, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeX, eyeY, glowSize, 0, Math.PI * 2); ctx.fill();
    }

    private drawSkullBack(ctx: CanvasRenderingContext2D, scale: number) {
        const r = SkeletonUnitRenderer.HEAD_RADIUS * scale;
        ctx.fillStyle = SkeletonUnitRenderer.BONE_LIGHT;
        ctx.beginPath();
        ctx.arc(0, -2 * scale, r, 0, Math.PI * 2);
        ctx.fill();
    }

    private drawSkullSide(ctx: CanvasRenderingContext2D, scale: number) {
        const r = SkeletonUnitRenderer.HEAD_RADIUS * scale;
        ctx.fillStyle = SkeletonUnitRenderer.BONE_LIGHT;
        ctx.beginPath();
        ctx.arc(-1 * scale, -2 * scale, r, 0, Math.PI * 2); // Shift back
        ctx.fill();

        // Snout
        ctx.beginPath();
        ctx.fillRect(1 * scale, 0, 3 * scale, 3 * scale);

        // Eye (One)
        const eyeX = 3 * scale;
        const eyeY = -0.5 * scale;
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.ellipse(eyeX, eyeY, 1.5 * scale, 2 * scale, 0, 0, Math.PI * 2); ctx.fill();

        ctx.fillStyle = SkeletonUnitRenderer.RED_GLOW;
        ctx.beginPath(); ctx.arc(eyeX + 0.5 * scale, eyeY, 0.6 * scale, 0, Math.PI * 2); ctx.fill();
    }

    // --- ITEMS ---

    private drawSwordFront(ctx: CanvasRenderingContext2D, scale: number) {
        // Pointing down/forward
        ctx.fillStyle = '#cfd8dc';
        ctx.beginPath();
        ctx.moveTo(-1 * scale, 0); ctx.lineTo(1 * scale, 0);
        ctx.lineTo(0, 14 * scale);
        ctx.fill();
        // Hilt
        ctx.fillStyle = SkeletonUnitRenderer.ARMOR_LIGHT;
        ctx.fillRect(-3 * scale, -1 * scale, 6 * scale, 1 * scale);
    }

    private drawSwordSide(ctx: CanvasRenderingContext2D, scale: number) {
        // Held forward (horizontalish)
        ctx.save();
        ctx.rotate(-Math.PI / 4); // Angle up slightly
        ctx.fillStyle = '#cfd8dc';
        ctx.fillRect(0, -1 * scale, 14 * scale, 2 * scale); // Blade
        ctx.fillStyle = SkeletonUnitRenderer.ARMOR_LIGHT;
        ctx.fillRect(0, -3 * scale, 2 * scale, 6 * scale); // Guard
        ctx.restore();
    }

    private drawSwordBack(ctx: CanvasRenderingContext2D, scale: number) {
        // Same as front but maybe darker?
        this.drawSwordFront(ctx, scale);
    }

    private drawShieldFront(ctx: CanvasRenderingContext2D, scale: number) {
        ctx.fillStyle = '#5d4037';
        ctx.beginPath(); ctx.arc(0, 3 * scale, 6 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = '#8d6e63';
        ctx.lineWidth = 2 * scale;
        ctx.stroke();
    }

    private drawShieldSide(ctx: CanvasRenderingContext2D, scale: number) {
        // Thin profile
        ctx.fillStyle = '#5d4037';
        ctx.beginPath();
        ctx.ellipse(0, 3 * scale, 1.5 * scale, 6 * scale, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#8d6e63';
        ctx.lineWidth = 1 * scale;
        ctx.stroke();
    }

    private drawShieldBack(ctx: CanvasRenderingContext2D, scale: number) {
        // Back of shield (wood planks, straps)
        ctx.fillStyle = '#3e2723'; // Darker wood
        ctx.beginPath(); ctx.arc(0, 3 * scale, 6 * scale, 0, Math.PI * 2); ctx.fill();
        // Handle strap
        ctx.fillStyle = '#111';
        ctx.fillRect(-2 * scale, 2 * scale, 4 * scale, 2 * scale);
    }
}
</file>

<file path="src/renderers/units/UnitRenderer.ts">
import { Assets } from '../../Assets';
import { CONFIG } from '../../Config';
import type { Enemy } from '../../Enemy';

/**
 * Interface for specific unit renderers (Strategy Pattern).
 * Draws ONLY the body/components of the unit. 
 * Coordinate system is already transformed to unit center (0,0) 
 * and rotated by the parent EnemyRenderer.
 */
export interface UnitRenderer {
    /**
     * Draw the unit body.
     * @param ctx Canvas context (pre-translated to 0,0)
     * @param enemy The enemy instance
     * @param scale Visual scale factor
     * @param rotation Rotation in radians (direction of movement)
     */
    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void;
}

/**
 * Default renderer for generic enemies (fallback).
 * Implements the classic "Sprite or Circle" logic.
 */
export class DefaultUnitRenderer implements UnitRenderer {

    drawBody(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number, rotation: number): void {
        // Legacy behavior: rotate sprite to face movement
        ctx.save();
        ctx.rotate(rotation + Math.PI / 2);

        const safeType = enemy.typeId ? enemy.typeId.toLowerCase() : 'grunt';

        // Lookup config using typeId
        const typeConf = Object.values(CONFIG.ENEMY_TYPES).find(t => t.id === safeType);

        const archetype = typeConf?.archetype || 'GRUNT';
        // @ts-ignore - tint is optional in IEnemyTypeConfig but union type might confuse TS
        const tint = typeConf?.tint;

        const bodyImgName = `enemy_${archetype.toLowerCase()}`;
        const bodyImg = Assets.get(bodyImgName);

        if (bodyImg) {
            const size = 48 * scale;
            const half = size / 2;

            ctx.drawImage(bodyImg, -half, -half, size, size);

            if (tint) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = tint;
                ctx.globalAlpha = 0.5;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }

            // Hit Flash
            if (enemy.hitFlashTimer > 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.8;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }

            // Status Tints
            if (enemy.statuses.some(s => s.type === 'slow')) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = CONFIG.AMBIENT.LIGHTING.ICE || '#00e5ff';
                ctx.globalAlpha = 0.4;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }
            if (enemy.statuses.some(s => s.type === 'burn')) {
                ctx.save();
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = CONFIG.AMBIENT.LIGHTING.FIRE || '#ff3d00';
                ctx.globalAlpha = 0.4;
                ctx.fillRect(-half, -half, size, size);
                ctx.restore();
            }
        } else {
            // Fallback (Circle)
            ctx.fillStyle = tint || '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 16 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }
}
</file>

<file path="src/SaveManager.ts">
import { ICard } from './CardSystem';
import { CONFIG } from './Config';

export interface IGlobalSaveData {
    totalMoneyEarned: number;
    enemiesKilled: number;
    wavesCleared: number;
    unlockedCards: string[]; // keys like 'FIRE', 'ICE'
    maxWaveReached: number;
}

export const DEFAULT_SAVE_DATA: IGlobalSaveData = {
    totalMoneyEarned: 0,
    enemiesKilled: 0,
    wavesCleared: 0,
    unlockedCards: ['FIRE', 'ICE', 'SNIPER'], // Default starters
    maxWaveReached: 0,
};

export class SaveManager {
    private static STORAGE_KEY = 'NEWTOWER_CAMPAIGN';

    public static load(): IGlobalSaveData {
        try {
            const raw = localStorage.getItem(this.STORAGE_KEY);
            if (raw) {
                const data = JSON.parse(raw);
                return { ...DEFAULT_SAVE_DATA, ...data };
            }
        } catch (e) {
            console.error('Failed to load save', e);
        }
        return { ...DEFAULT_SAVE_DATA };
    }

    public static save(data: IGlobalSaveData) {
        try {
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
        } catch (e) {
            console.error('Failed to save progress', e);
        }
    }

    public static updateProgress(stats: { money: number; kills: number; waves: number; maxWave: number }) {
        const data = this.load();
        data.totalMoneyEarned += stats.money;
        data.enemiesKilled += stats.kills;
        data.wavesCleared += stats.waves;
        if (stats.maxWave > data.maxWaveReached) {
            data.maxWaveReached = stats.maxWave;
        }
        this.save(data);
        console.log('Campaign Progress Saved', data);
    }
}
</file>

<file path="src/SimplexNoise.ts">
/**
 * Simple Simplex Noise implementation for fog animation
 * Based on Stefan Gustavson's SimplexNoise
 */
export class SimplexNoise {
    private perm: number[] = [];
    private grad3: number[][] = [
        [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
        [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
        [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
    ];

    constructor(seed: number = Math.random()) {
        // Initialize permutation table with seed
        const p: number[] = [];
        for (let i = 0; i < 256; i++) {
            p[i] = i;
        }

        // Shuffle using seed-based random
        let n, q;
        for (let i = 255; i > 0; i--) {
            seed = (seed * 9301 + 49297) % 233280;
            n = Math.floor((seed / 233280.0) * (i + 1));
            q = p[i];
            p[i] = p[n];
            p[n] = q;
        }

        // Extend to 512 for wrapping
        for (let i = 0; i < 512; i++) {
            this.perm[i] = p[i & 255];
        }
    }

    private dot(g: number[], x: number, y: number): number {
        return g[0] * x + g[1] * y;
    }

    /**
     * 2D Simplex Noise
     * @param x X coordinate
     * @param y Y coordinate
     * @returns value between -1 and 1
     */
    public noise2D(x: number, y: number): number {
        const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
        const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;

        // Skew the input space
        const s = (x + y) * F2;
        const i = Math.floor(x + s);
        const j = Math.floor(y + s);

        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = x - X0;
        const y0 = y - Y0;

        // Determine simplex
        let i1, j1;
        if (x0 > y0) {
            i1 = 1;
            j1 = 0;
        } else {
            i1 = 0;
            j1 = 1;
        }

        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1.0 + 2.0 * G2;
        const y2 = y0 - 1.0 + 2.0 * G2;

        // Hash coordinates
        const ii = i & 255;
        const jj = j & 255;
        const gi0 = this.perm[ii + this.perm[jj]] % 12;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
        const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;

        // Calculate contributions
        let t0 = 0.5 - x0 * x0 - y0 * y0;
        let n0 = 0.0;
        if (t0 >= 0) {
            t0 *= t0;
            n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
        }

        let t1 = 0.5 - x1 * x1 - y1 * y1;
        let n1 = 0.0;
        if (t1 >= 0) {
            t1 *= t1;
            n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
        }

        let t2 = 0.5 - x2 * x2 - y2 * y2;
        let n2 = 0.0;
        if (t2 >= 0) {
            t2 *= t2;
            n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
        }

        // Sum and scale to [-1, 1]
        return 70.0 * (n0 + n1 + n2);
    }
}
</file>

<file path="src/SpatialGrid.ts">
/**
 * Spatial Grid for efficient proximity queries
 * Reduces collision detection from O(P √ó E) to O(P √ó avgCandidates)
 */

export interface IGridEntity {
    x: number;
    y: number;
}

export class SpatialGrid<T extends IGridEntity> {
    private cellSize: number;
    private grid: Map<string, T[]>;
    private cols: number;
    private rows: number;

    constructor(worldWidth: number, worldHeight: number, cellSize: number = 128) {
        this.cellSize = cellSize;
        this.cols = Math.ceil(worldWidth / cellSize);
        this.rows = Math.ceil(worldHeight / cellSize);
        this.grid = new Map();
    }

    /**
     * Clear all entities from the grid
     */
    public clear(): void {
        this.grid.clear();
    }

    /**
     * Register an entity in the grid based on its position
     */
    public register(entity: T): void {
        const cellKey = this.getCellKey(entity.x, entity.y);
        
        if (!this.grid.has(cellKey)) {
            this.grid.set(cellKey, []);
        }
        
        this.grid.get(cellKey)!.push(entity);
    }

    /**
     * Get all entities within radius of the given position
     * Only checks cells that could contain entities within the radius
     */
    public getNearby(x: number, y: number, radius: number): T[] {
        const results: T[] = [];
        
        // Calculate which cells to check
        const minCol = Math.max(0, Math.floor((x - radius) / this.cellSize));
        const maxCol = Math.min(this.cols - 1, Math.floor((x + radius) / this.cellSize));
        const minRow = Math.max(0, Math.floor((y - radius) / this.cellSize));
        const maxRow = Math.min(this.rows - 1, Math.floor((y + radius) / this.cellSize));

        // Check all relevant cells
        for (let col = minCol; col <= maxCol; col++) {
            for (let row = minRow; row <= maxRow; row++) {
                const cellKey = this.makeCellKey(col, row);
                const entities = this.grid.get(cellKey);
                
                if (entities) {
                    results.push(...entities);
                }
            }
        }

        return results;
    }

    /**
     * Get cell key for a position
     */
    private getCellKey(x: number, y: number): string {
        const col = Math.floor(x / this.cellSize);
        const row = Math.floor(y / this.cellSize);
        return this.makeCellKey(col, row);
    }

    /**
     * Create cell key from column and row
     */
    private makeCellKey(col: number, row: number): string {
        return `${col},${row}`;
    }

    /**
     * Debug: Get grid statistics
     */
    public getStats(): { totalCells: number; occupiedCells: number; totalEntities: number } {
        let totalEntities = 0;
        for (const entities of this.grid.values()) {
            totalEntities += entities.length;
        }

        return {
            totalCells: this.cols * this.rows,
            occupiedCells: this.grid.size,
            totalEntities,
        };
    }
}
</file>

<file path="src/systems/NotificationSystem.ts">
import { EffectSystem } from '../EffectSystem';
import { EventBus, Events } from '../EventBus';
import { SoundManager, SoundPriority } from '../SoundManager';

/**
 * NotificationSystem - Visual notifications for game events
 * Wave start, wave clear, boss spawn, etc.
 */
export class NotificationSystem {
    private effects: EffectSystem;
    private canvas: HTMLCanvasElement;

    // Active notifications queue
    private notifications: INotification[] = [];

    constructor(effects: EffectSystem, canvas: HTMLCanvasElement) {
        this.effects = effects;
        this.canvas = canvas;

        this.initSubscriptions();
    }

    private initSubscriptions() {
        const bus = EventBus.getInstance();

        bus.on(Events.WAVE_STARTED, (wave: number) => {
            this.showWaveStart(wave);
        });

        bus.on(Events.WAVE_COMPLETED, (wave: number) => {
            this.showWaveClear(wave);
        });
    }

    /**
     * Wave Start notification - big zoom-in text
     */
    public showWaveStart(waveNum: number) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;

        // Main wave text with zoom effect
        this.effects.add({
            type: 'text',
            text: `WAVE ${waveNum}`,
            x: cx,
            y: cy,
            life: 90,
            color: '#fff',
            fontSize: 48,
            vy: 0
        });

        // Subtitle
        this.effects.add({
            type: 'text',
            text: 'INCOMING',
            x: cx,
            y: cy + 50,
            life: 70,
            color: '#ff5722',
            fontSize: 24,
            vy: 0
        });

        // Screen flash (red tint)
        this.effects.add({
            type: 'screen_flash',
            x: 0,
            y: 0,
            life: 25,
            flashColor: 'rgba(255, 50, 50, '
        });

        // Sound
        SoundManager.play('boss_spawn', SoundPriority.HIGH);
    }

    /**
     * Wave Clear notification - gold flash + confetti
     */
    public showWaveClear(waveNum: number) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;

        // Victory text
        this.effects.add({
            type: 'text',
            text: 'WAVE CLEARED!',
            x: cx,
            y: cy - 30,
            life: 80,
            color: '#ffd700',
            fontSize: 36,
            vy: -0.5
        });

        // Gold screen flash
        this.effects.add({
            type: 'screen_flash',
            x: 0,
            y: 0,
            life: 20,
            flashColor: 'rgba(255, 215, 0, '
        });

        // Confetti particles
        this.spawnConfetti(cx, cy);

        // Sound
        SoundManager.play('click', SoundPriority.HIGH);
    }

    /**
     * Boss Spawn notification - dramatic darkening + spotlight
     */
    public showBossSpawn(bossName: string, x: number, y: number) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;

        // Warning text
        this.effects.add({
            type: 'text',
            text: '‚ö†Ô∏è BOSS ‚ö†Ô∏è',
            x: cx,
            y: cy - 100,
            life: 120,
            color: '#ff0000',
            fontSize: 42,
            vy: 0
        });

        // Boss name
        this.effects.add({
            type: 'text',
            text: bossName.toUpperCase(),
            x: cx,
            y: cy - 50,
            life: 100,
            color: '#fff',
            fontSize: 28,
            vy: 0
        });

        // Dark flash
        this.effects.add({
            type: 'screen_flash',
            x: 0,
            y: 0,
            life: 40,
            flashColor: 'rgba(0, 0, 0, '
        });

        // Sound
        SoundManager.play('boss_spawn', SoundPriority.HIGH);
    }

    /**
     * Spawn confetti particles
     */
    private spawnConfetti(cx: number, cy: number) {
        const colors = ['#ffd700', '#ff5722', '#4caf50', '#2196f3', '#e91e63'];

        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 4;
            const color = colors[Math.floor(Math.random() * colors.length)];

            this.effects.add({
                type: 'particle',
                x: cx + (Math.random() - 0.5) * 100,
                y: cy,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 2, // Bias upward
                life: 40 + Math.random() * 30,
                color: color,
                radius: 3 + Math.random() * 3
            });
        }
    }

    /**
     * Custom notification (for special events)
     */
    public showCustom(text: string, color: string = '#fff', duration: number = 60) {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;

        this.effects.add({
            type: 'text',
            text: text,
            x: cx,
            y: cy,
            life: duration,
            color: color,
            fontSize: 32,
            vy: -0.5
        });
    }
}

interface INotification {
    type: 'wave_start' | 'wave_clear' | 'boss_spawn' | 'custom';
    text: string;
    life: number;
    maxLife: number;
}
</file>

<file path="src/types.ts">
/**
 * Central type definitions for the Tower Defense game
 */

// ============================================
// Card System Types
// ============================================

export interface ICardTypeConfig {
    id: string;
    name: string;
    icon: string;
    color: string;
    desc: string;
}

// ============================================
// Enemy System Types
// ============================================

export interface IEnemyTypeConfig {
    id: string;
    name: string;
    symbol: string;
    hpMod: number;
    speed: number;
    reward: number;
    color: string;
    desc: string;
    // Modular Visuals
    archetype?: 'SKELETON' | 'WOLF' | 'TROLL' | 'SPIDER';
    scale?: number;
    props?: string[]; // IDs of props
    tint?: string;    // Hex color override
}

// ============================================
// Configuration Types
// ============================================

export type CardTypeKey = 'FIRE' | 'ICE' | 'SNIPER' | 'MULTISHOT';
export type EnemyTypeKey = 'GRUNT' | 'SCOUT' | 'TANK' | 'BOSS';

// ============================================
// Utility Types
// ============================================

/**
 * Type-safe accessor for card types
 */
export function getCardTypeConfig(key: string): ICardTypeConfig | undefined {
    return undefined; // Implementation will be in Config.ts
}

/**
 * Type-safe accessor for enemy types
 */
export function getEnemyTypeConfig(key: string): IEnemyTypeConfig | undefined {
    return undefined; // Implementation will be in Config.ts
}
</file>

<file path="src/ui/DevConsole.ts">
import { GameScene } from '../scenes/GameScene';
import { Logger, LogLevel, LogChannel, LogEntry } from '../utils/Logger';
import { SafeJson } from '../utils/SafeJson';

export class DevConsole {
    private scene: GameScene;
    private container!: HTMLElement;
    private contentLog!: HTMLElement;
    private contentState!: HTMLElement;
    private contentTools!: HTMLElement;
    private toggleBtn!: HTMLElement;

    // State
    private isVisible: boolean = false;
    private activeTab: 'log' | 'state' | 'tools' = 'log';
    private autoScroll: boolean = true;
    private stateUpdateInterval: any = null;

    // Filters
    private showInfo: boolean = true;
    private showWarn: boolean = true;
    private showError: boolean = true;
    private showVerbose: boolean = false;

    constructor(scene: GameScene) {
        this.scene = scene;
        this.createUI();
        this.setupLogger();

        Logger.info(LogChannel.SYSTEM, 'DevConsole initialized');
    }

    private setupLogger() {
        Logger.subscribe((entry) => {
            this.appendLog(entry);
            // Indication logic: if console is closed and error occurs, flash the button
            if (!this.isVisible && entry.level === LogLevel.ERROR) {
                this.flashButton();
            }
        });
    }

    private flashButton() {
        if (this.toggleBtn) {
            this.toggleBtn.style.background = '#ff0000';
            setTimeout(() => {
                if (!this.isVisible) this.toggleBtn.style.background = 'rgba(0,0,0,0.8)';
            }, 500);
        }
    }

    private createUI() {
        // --- Toggle Button ---
        this.toggleBtn = document.createElement('div');
        this.toggleBtn.innerText = 'üêû';
        this.toggleBtn.title = 'Dev Console (~)';
        Object.assign(this.toggleBtn.style, {
            position: 'absolute',
            top: '10px',
            right: '10px',
            width: '32px',
            height: '32px',
            background: 'rgba(0,0,0,0.8)',
            border: '1px solid #444',
            borderRadius: '50%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            cursor: 'pointer',
            zIndex: '20000',
            userSelect: 'none',
            fontSize: '16px'
        });
        this.toggleBtn.onclick = () => this.toggle();
        document.body.appendChild(this.toggleBtn);

        // --- Main Container ---
        this.container = document.createElement('div');
        Object.assign(this.container.style, {
            position: 'absolute',
            top: '50px',
            right: '10px',
            width: '400px',
            height: '500px',
            background: 'rgba(10, 10, 10, 0.95)',
            border: '1px solid #444',
            borderRadius: '4px',
            display: 'none',
            flexDirection: 'column',
            zIndex: '20000',
            fontFamily: 'Consolas, monospace',
            fontSize: '12px',
            color: '#ccc',
            boxShadow: '0 4px 12px rgba(0,0,0,0.5)'
        });
        document.body.appendChild(this.container);

        // --- Header (Tabs) ---
        const header = document.createElement('div');
        Object.assign(header.style, {
            display: 'flex',
            borderBottom: '1px solid #333',
            background: '#1a1a1a',
            padding: '0 5px'
        });

        ['log', 'state', 'tools'].forEach(tab => {
            const btn = document.createElement('button');
            btn.innerText = tab.toUpperCase();
            Object.assign(btn.style, {
                background: 'transparent',
                border: 'none',
                color: '#888',
                padding: '8px 12px',
                cursor: 'pointer',
                fontWeight: 'bold'
            });
            btn.onclick = () => this.switchTab(tab as any);
            header.appendChild(btn);
            // active style for 'log' handled in switchTab
        });

        // Close Btn
        const closeBtn = document.createElement('button');
        closeBtn.innerText = '‚úï';
        Object.assign(closeBtn.style, {
            marginLeft: 'auto',
            background: 'transparent',
            border: 'none',
            color: '#666',
            cursor: 'pointer',
            padding: '0 10px'
        });
        closeBtn.onclick = () => this.toggle();
        header.appendChild(closeBtn);

        this.container.appendChild(header);

        // --- Content Areas ---
        this.contentLog = document.createElement('div');
        Object.assign(this.contentLog.style, { flex: '1', overflowY: 'auto', padding: '5px', display: 'block' });

        // Log Filters
        const filters = document.createElement('div');
        Object.assign(filters.style, { padding: '5px', background: '#111', borderBottom: '1px solid #222', display: 'flex', gap: '8px' });
        filters.innerHTML = `
            <label><input type="checkbox" id="chk-info" checked> Info</label>
            <label><input type="checkbox" id="chk-warn" checked> Warn</label>
            <label><input type="checkbox" id="chk-err" checked> Err</label>
            <label><input type="checkbox" id="chk-verb"> Verbose</label>
            <button id="btn-clear" style="margin-left:auto; font-size:10px;">CLEAR</button>
        `;
        this.container.appendChild(filters); // Insert filters before log content
        this.container.appendChild(this.contentLog);

        this.contentState = document.createElement('div');
        Object.assign(this.contentState.style, { flex: '1', overflowY: 'auto', padding: '10px', display: 'none', whiteSpace: 'pre-wrap', color: '#8f8' });
        this.container.appendChild(this.contentState);

        this.contentTools = document.createElement('div');
        Object.assign(this.contentTools.style, { flex: '1', overflowY: 'auto', padding: '10px', display: 'none' });
        this.createToolsContent();
        this.container.appendChild(this.contentTools);

        // Filter Logic
        this.container.querySelector('#chk-info')!.addEventListener('change', (e: any) => { this.showInfo = e.target.checked; this.refreshLogs(); });
        this.container.querySelector('#chk-warn')!.addEventListener('change', (e: any) => { this.showWarn = e.target.checked; this.refreshLogs(); });
        this.container.querySelector('#chk-err')!.addEventListener('change', (e: any) => { this.showError = e.target.checked; this.refreshLogs(); });
        this.container.querySelector('#chk-verb')!.addEventListener('change', (e: any) => { this.showVerbose = e.target.checked; this.refreshLogs(); });
        this.container.querySelector('#btn-clear')!.addEventListener('click', () => {
            this.contentLog.innerHTML = '';
            // Note: we don't clear Logger history, just view. Or we could implemented clear in Logger.
        });

        // Global Key
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Backquote') {
                e.preventDefault();
                this.toggle();
            }
        });
    }

    private createToolsContent() {
        // Buttons for common debugging tasks
        const addBtn = (label: string, action: () => void) => {
            const btn = document.createElement('button');
            btn.innerText = label;
            Object.assign(btn.style, {
                display: 'block',
                width: '100%',
                padding: '8px',
                marginBottom: '5px',
                background: '#333',
                color: '#fff',
                border: '1px solid #555',
                cursor: 'pointer'
            });
            btn.onclick = action;
            this.contentTools.appendChild(btn);
        };

        addBtn('üí∞ +1000 Gold', () => { this.scene.addMoney(1000); Logger.info(LogChannel.GAME, 'Added 1000 gold'); });
        addBtn('‚è© Skip Wave', () => {
            this.scene.wave++;
            Logger.info(LogChannel.GAME, `Skipped to wave ${this.scene.wave}`);
        });
        addBtn('üíÄ Kill All', () => {
            this.scene.enemies.forEach(e => e.takeDamage(999999));
            Logger.info(LogChannel.GAME, 'Killed all enemies');
        });
        addBtn('üóë Garbage Collect (Sim)', () => {
            // Can't force GC in JS, but we can clear some internal pools if we had them or reload textures
            Logger.warn(LogChannel.SYSTEM, 'GC Simulation - clearing loose refs not implemented');
        });
        addBtn('üìã Copy Full Report', () => {
            // This will link to CrashHandler later, for now simple dump
            const dump = SafeJson.stringify({ scene: this.scene }, 2);
            navigator.clipboard.writeText(dump);
            Logger.info(LogChannel.SYSTEM, 'State copied to clipboard');
        });
    }

    public toggle() {
        this.isVisible = !this.isVisible;
        this.container.style.display = this.isVisible ? 'flex' : 'none';

        if (this.isVisible) {
            this.startStateUpdater();
            this.refreshLogs(); // Refresh just in case filters changed
            // Reset flash
            this.toggleBtn.style.background = 'rgba(0,0,0,0.8)';
        } else {
            this.stopStateUpdater();
        }
    }

    private switchTab(tab: 'log' | 'state' | 'tools') {
        this.activeTab = tab;
        this.contentLog.style.display = tab === 'log' ? 'block' : 'none';
        this.contentState.style.display = tab === 'state' ? 'block' : 'none';
        this.contentTools.style.display = tab === 'tools' ? 'block' : 'none';
    }

    private startStateUpdater() {
        if (this.stateUpdateInterval) clearInterval(this.stateUpdateInterval);
        this.stateUpdateInterval = setInterval(() => this.updateStateView(), 500);
        this.updateStateView();
    }

    private stopStateUpdater() {
        if (this.stateUpdateInterval) clearInterval(this.stateUpdateInterval);
        this.stateUpdateInterval = null;
    }

    private updateStateView() {
        if (this.activeTab !== 'state' || !this.isVisible) return;

        const state = {
            game: {
                fps: this.scene.gameState?.frames || 0,
                // time: this.scene.gameState?.time || 0, // Removed invalid property
                money: this.scene.money,
                wave: this.scene.wave,
                lives: 100 // Example, should get real lives
            },
            entities: {
                enemies: this.scene.enemies.length,
                towers: this.scene.towers.length,
                projectiles: this.scene.projectiles?.length || 0
            },
            input: {
                mouse: { x: this.scene.input?.mouseX || 0, y: this.scene.input?.mouseY || 0 }
            }
        };

        this.contentState.innerText = SafeJson.stringify(state, 2, true);
    }

    private refreshLogs() {
        this.contentLog.innerHTML = '';
        Logger.getHistory().forEach(entry => this.appendLog(entry));
    }

    private appendLog(entry: LogEntry) {
        if (!this.isVisible) return; // Lazy rendering

        // Check filters
        if (entry.level === LogLevel.INFO && !this.showInfo) return;
        if (entry.level === LogLevel.WARN && !this.showWarn) return;
        if (entry.level === LogLevel.ERROR && !this.showError) return;
        if (entry.level === LogLevel.VERBOSE && !this.showVerbose) return;

        const row = document.createElement('div');
        const time = new Date(entry.timestamp).toISOString().split('T')[1].slice(0, -5);

        let color = '#ccc';
        if (entry.level === LogLevel.WARN) color = '#fc0';
        if (entry.level === LogLevel.ERROR) color = '#f44';
        if (entry.level === LogLevel.VERBOSE) color = '#666';

        row.style.color = color;
        row.style.fontFamily = 'monospace';
        row.style.fontSize = '11px';
        row.style.padding = '2px 0';
        row.style.borderBottom = '1px solid #222';

        const countStr = entry.count > 1 ? ` <span style="background:#555; color:#fff; padding:0 4px; border-radius:4px;">x${entry.count}</span>` : '';

        row.innerHTML = `<span style="color:#666">[${time}]</span> <span style="color:#888">[${entry.channel}]</span> ${entry.message}${countStr}`;

        if (entry.data) {
            const sub = document.createElement('div');
            sub.style.paddingLeft = '20px';
            sub.style.fontSize = '10px';
            sub.style.color = '#888';
            // Simple preview
            try {
                sub.innerText = typeof entry.data === 'object' ? JSON.stringify(entry.data) : String(entry.data);
            } catch (e) { sub.innerText = '[Unserializable Data]'; }
            row.appendChild(sub);
        }

        this.contentLog.appendChild(row);
        if (this.autoScroll) this.contentLog.scrollTop = this.contentLog.scrollHeight;
    }
}
</file>

<file path="src/ui/GameOverUI.ts">
import { IGameScene } from '../scenes/IGameScene';

export class GameOverUI {
    private scene: IGameScene;
    private elGameOver: HTMLElement;
    private elFinalWave: HTMLElement;
    private elRestartBtn: HTMLButtonElement;

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.elGameOver = document.getElementById('game-over')!;
        this.elFinalWave = document.getElementById('final-wave')!;
        this.elRestartBtn = document.getElementById('restart-btn') as HTMLButtonElement;

        this.initListeners();
    }

    private initListeners() {
        this.elRestartBtn.addEventListener('click', () => {
            this.scene.restart();
            this.hide();
        });
    }

    public show(wave: number) {
        this.elFinalWave.innerText = wave.toString();
        this.elGameOver.style.display = 'flex';
    }

    public hide() {
        this.elGameOver.style.display = 'none';
    }
}
</file>

<file path="src/UIUtils.ts">
export interface IButtonOptions {
    background?: string;
    color?: string;
    fontSize?: string;
    padding?: string;
    border?: string;
    borderRadius?: string;
    width?: string;
    zIndex?: string;
    fontFamily?: string;
    cursor?: string;
    position?: string;
    top?: string;
    right?: string;
    bottom?: string;
    left?: string;
    title?: string;
    pointerEvents?: string;
    fontWeight?: string;
    marginTop?: string;
    id?: string;
    height?: string;
    boxShadow?: string;
    display?: string;
    alignItems?: string;
    justifyContent?: string;
    marginLeft?: string;
    flex?: string;
    flexShrink?: string;
    flexGrow?: string;
}

export interface IContainerOptions {
    position?: string;
    top?: string;
    left?: string;
    bottom?: string;
    right?: string;
    width?: string;
    height?: string;
    display?: string;
    flexDirection?: string;
    alignItems?: string;
    justifyContent?: string;
    gap?: string;
    background?: string;
    color?: string;
    padding?: string;
    border?: string;
    borderRadius?: string;
    zIndex?: string;
    pointerEvents?: string;
    maxWidth?: string;
    maxHeight?: string;
    overflowY?: string;
    overflowX?: string;
    transform?: string;
}

export class UIUtils {
    /**
     * Creates a styled button and appends it to the parent.
     */
    public static createButton(
        parent: HTMLElement,
        text: string,
        onClick: (e: MouseEvent) => void,
        options: IButtonOptions = {}
    ): HTMLButtonElement {
        const btn = document.createElement('button');
        btn.innerHTML = text;

        // Defaults
        const defaults: Partial<CSSStyleDeclaration> = {
            padding: '10px 20px',
            fontSize: '16px',
            cursor: 'pointer',
            background: '#333',
            color: '#fff',
            border: '2px solid #555',
            borderRadius: '8px',
            fontFamily: 'Segoe UI, sans-serif',
            pointerEvents: 'auto'
        };

        // Merge options
        Object.assign(btn.style, defaults);

        // Apply overrides
        if (options.background) btn.style.background = options.background;
        if (options.color) btn.style.color = options.color;
        if (options.fontSize) btn.style.fontSize = options.fontSize;
        if (options.padding) btn.style.padding = options.padding;
        if (options.border) btn.style.border = options.border;
        if (options.borderRadius) btn.style.borderRadius = options.borderRadius;
        if (options.width) btn.style.width = options.width;
        if (options.zIndex) btn.style.zIndex = options.zIndex;
        if (options.fontFamily) btn.style.fontFamily = options.fontFamily;
        if (options.cursor) btn.style.cursor = options.cursor;
        if (options.position) btn.style.position = options.position;
        if (options.top) btn.style.top = options.top;
        if (options.right) btn.style.right = options.right;
        if (options.bottom) btn.style.bottom = options.bottom;
        if (options.left) btn.style.left = options.left;
        if (options.title) btn.title = options.title;
        if (options.pointerEvents) btn.style.pointerEvents = options.pointerEvents;
        if (options.fontWeight) btn.style.fontWeight = options.fontWeight;
        if (options.marginTop) btn.style.marginTop = options.marginTop;
        if (options.id) btn.id = options.id;
        if (options.height) btn.style.height = options.height;
        if (options.boxShadow) btn.style.boxShadow = options.boxShadow;
        if (options.display) btn.style.display = options.display;
        if (options.alignItems) btn.style.alignItems = options.alignItems;
        if (options.justifyContent) btn.style.justifyContent = options.justifyContent;
        if (options.marginLeft) btn.style.marginLeft = options.marginLeft;
        if (options.flex) btn.style.flex = options.flex;
        if (options.flexShrink) btn.style.flexShrink = options.flexShrink;
        if (options.flexGrow) btn.style.flexGrow = options.flexGrow;

        btn.onclick = onClick;

        // Simple hover effect
        const originalBg = btn.style.background;
        btn.onmouseover = () => {
            btn.style.filter = 'brightness(1.2)';
        };
        btn.onmouseout = () => {
            btn.style.filter = 'none';
        };

        parent.appendChild(btn);
        return btn;
    }

    /**
     * Creates a container (div) with standard styling options.
     */
    public static createContainer(options: IContainerOptions = {}): HTMLElement {
        const div = document.createElement('div');

        // Apply options
        if (options.position) div.style.position = options.position;
        if (options.top) div.style.top = options.top;
        if (options.left) div.style.left = options.left;
        if (options.bottom) div.style.bottom = options.bottom;
        if (options.right) div.style.right = options.right;
        if (options.width) div.style.width = options.width;
        if (options.height) div.style.height = options.height;
        if (options.display) div.style.display = options.display;
        if (options.flexDirection) div.style.flexDirection = options.flexDirection;
        if (options.alignItems) div.style.alignItems = options.alignItems;
        if (options.justifyContent) div.style.justifyContent = options.justifyContent;
        if (options.gap) div.style.gap = options.gap;
        if (options.background) div.style.background = options.background;
        if (options.color) div.style.color = options.color;
        if (options.padding) div.style.padding = options.padding;
        if (options.border) div.style.border = options.border;
        if (options.borderRadius) div.style.borderRadius = options.borderRadius;
        if (options.zIndex) div.style.zIndex = options.zIndex;
        if (options.pointerEvents) div.style.pointerEvents = options.pointerEvents;
        if (options.maxWidth) div.style.maxWidth = options.maxWidth;
        if (options.maxHeight) div.style.maxHeight = options.maxHeight;
        if (options.overflowY) div.style.overflowY = options.overflowY;
        if (options.overflowX) div.style.overflowX = options.overflowX;
        if (options.transform) div.style.transform = options.transform;

        return div;
    }

    /**
     * Creates a full-screen overlay for menus/modals.
     */
    public static createOverlay(id?: string): HTMLElement {
        const overlay = document.createElement('div');
        if (id) overlay.id = id;
        Object.assign(overlay.style, {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0,0,0,0.8)',
            zIndex: '2000',
            display: 'none',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            color: 'white',
            fontFamily: 'Segoe UI, sans-serif'
        });
        document.body.appendChild(overlay);
        return overlay;
    }

    /**
     * Animates an element with a flash effect.
     */
    public static flashElement(el: HTMLElement, color: string, durationMs: number = 200) {
        const originalColor = el.style.color;
        const originalTransform = el.style.transform;

        el.style.transition = `color ${durationMs / 2}ms, transform ${durationMs / 2}ms`;
        el.style.color = color;
        el.style.transform = 'scale(1.3)';

        setTimeout(() => {
            el.style.color = originalColor;
            el.style.transform = originalTransform || 'scale(1)';
        }, durationMs);
    }
}
</file>

<file path="src/utils/Logger.ts">
export enum LogLevel {
    VERBOSE = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3,
    NONE = 99
}

export enum LogChannel {
    SYSTEM = 'SYS',
    GAME = 'GAME',
    RENDER = 'RNDR',
    AUDIO = 'AUDIO',
    INPUT = 'INPT',
    NETWORK = 'NET'
}

export interface LogEntry {
    timestamp: number;
    level: LogLevel;
    channel: LogChannel;
    message: string;
    data?: any;
    count: number; // For collapsed logs
}

export class Logger {
    private static instance: Logger;

    // Configuration
    public minLevel: LogLevel = LogLevel.INFO;
    public maxHistory: number = 200; // Keep last 200 logs

    // State
    private history: LogEntry[] = [];
    private listeners: ((entry: LogEntry) => void)[] = [];

    // Throttling / De-duplication
    private lastLogSignature: string = '';
    private lastLogEntry: LogEntry | null = null;
    private lastLogTime: number = 0;
    private throttleTimeMs: number = 1000; // Reset "count" logic if spam stops for 1 second

    private constructor() {
        console.log('%c Logger Initialized ', 'background: #222; color: #bada55');
    }

    public static getInstance(): Logger {
        if (!Logger.instance) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }

    // --- Public API ---

    public static verbose(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.VERBOSE, channel, msg, data);
    }

    public static info(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.INFO, channel, msg, data);
    }

    public static warn(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.WARN, channel, msg, data);
    }

    public static error(channel: LogChannel, msg: string, data?: any) {
        Logger.getInstance().log(LogLevel.ERROR, channel, msg, data);
    }

    public static getHistory(): LogEntry[] {
        return Logger.getInstance().history;
    }

    public static subscribe(callback: (entry: LogEntry) => void) {
        Logger.getInstance().listeners.push(callback);
    }

    public static unsubscribe(callback: (entry: LogEntry) => void) {
        const i = Logger.getInstance().listeners.indexOf(callback);
        if (i > -1) Logger.getInstance().listeners.splice(i, 1);
    }

    // --- Internal Logic ---

    private log(level: LogLevel, channel: LogChannel, msg: string, data?: any) {
        if (level < this.minLevel) return;

        const now = Date.now();
        const signature = `${level}:${channel}:${msg}`;

        // Check for spam/throttling (same message repeated)
        if (this.lastLogEntry && this.lastLogSignature === signature && (now - this.lastLogTime < this.throttleTimeMs)) {
            this.lastLogEntry.count++;
            this.lastLogEntry.timestamp = now; // Update time to latest occurrence
            this.lastLogTime = now;
            // Notify listeners about update (optional, usually listeners just append, so this might be tricky for UI 
            // - UI should re-render or handle updates. For now we rely on UI refreshing or ignoring updates to existing objects)
            return;
        }

        const entry: LogEntry = {
            timestamp: now,
            level,
            channel,
            message: msg,
            data,
            count: 1
        };

        // Add to history
        this.history.push(entry);
        if (this.history.length > this.maxHistory) {
            this.history.shift(); // Remove oldest
        }

        // Update state
        this.lastLogEntry = entry;
        this.lastLogSignature = signature;
        this.lastLogTime = now;

        // Output to Browser Console (Dual Output)
        this.printToConsole(entry);

        // Notify subscribers (The In-Game Console)
        this.listeners.forEach(l => l(entry));
    }

    private printToConsole(entry: LogEntry) {
        const time = new Date(entry.timestamp).toISOString().split('T')[1].slice(0, -1); // HH:MM:SS.ms
        const css = this.getLevelCSS(entry.level);
        const prefix = `%c[${time}] [${entry.channel}]`;

        // Use native console methods for proper stack tracing and object inspection in F12
        switch (entry.level) {
            case LogLevel.ERROR:
                console.error(prefix, css, entry.message, entry.data || '');
                break;
            case LogLevel.WARN:
                console.warn(prefix, css, entry.message, entry.data || '');
                break;
            case LogLevel.INFO:
                console.log(prefix, css, entry.message, entry.data || '');
                break;
            case LogLevel.VERBOSE:
                console.debug(prefix, css, entry.message, entry.data || '');
                break;
        }
    }

    private getLevelCSS(level: LogLevel): string {
        switch (level) {
            case LogLevel.ERROR: return 'color: #ff4444; font-weight: bold;';
            case LogLevel.WARN: return 'color: #ffbb33; font-weight: bold;';
            case LogLevel.INFO: return 'color: #33b5e5; font-weight: bold;';
            case LogLevel.VERBOSE: return 'color: #999;';
            default: return 'color: #fff;';
        }
    }
}
</file>

<file path="src/utils/SafeJson.ts">
export class SafeJson {
    /**
     * Safely serializes an object to JSON, handling circular references and limiting depth.
     * @param data The object to serialize
     * @param maxDepth Maximum recursion depth (default 3)
     * @param pretty Whether to separate lines (default false)
     */
    public static stringify(data: any, maxDepth: number = 3, pretty: boolean = false): string {
        const seen = new WeakSet();

        const replacer = (key: string, value: any) => {
            // Handle primitives
            if (value === null || typeof value !== 'object') {
                return value;
            }

            // Handle circular references
            if (seen.has(value)) {
                return '[Circular]';
            }
            seen.add(value);

            // Handle DOM elements (too heavy to serialize)
            if (value instanceof HTMLElement) {
                return `[HTMLElement: ${value.tagName}]`;
            }

            // Handle depth manually if needed, but WeakSet handles recursion loops.
            // For true depth limiting, we'd need a recursive custom serializer, 
            // but JSON.stringify compliant replacer is harder to limit by depth directly.
            // So we rely on a custom recursive function instead of standard JSON.stringify if we want strict depth.

            return value;
        };

        // For strict depth control and safety, we implement a custom walker instead of just JSON.stringify
        const sanitized = SafeJson.sanitize(data, maxDepth, new WeakSet());
        return JSON.stringify(sanitized, null, pretty ? 2 : 0);
    }

    private static sanitize(obj: any, depth: number, visited: WeakSet<any>): any {
        // Base cases
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }

        // Check loops
        if (visited.has(obj)) {
            return '[Circular]';
        }

        // Check depth
        if (depth < 0) {
            return '[MaxDepth]';
        }

        // Special types
        if (obj instanceof HTMLElement) return `[HTMLElement: ${obj.tagName}]`;
        if (obj instanceof Function) return `[Function: ${obj.name || 'anonymous'}]`;
        if (obj instanceof Error) return { message: obj.message, stack: obj.stack };

        // Add to visited
        visited.add(obj);

        // Arrays
        if (Array.isArray(obj)) {
            return obj.map(item => SafeJson.sanitize(item, depth - 1, visited));
        }

        // Objects
        const res: any = {};
        for (const key in obj) {
            // Skip large numeric keys usually found in huge lookup tables or large arrays treated as objects
            // Also skip private keys like _private
            if (key.startsWith('_')) continue;

            try {
                res[key] = SafeJson.sanitize(obj[key], depth - 1, visited);
            } catch (e) {
                res[key] = '[Error accessing property]';
            }
        }
        return res;
    }
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="style_analysis_and_roadmap.md">
# –û—Ç—á–µ—Ç –ø–æ –≤–∏–∑—É–∞–ª—å–Ω–æ–º—É —Å—Ç–∏–ª—é –∏ –ø–ª–∞–Ω—ã —Ä–∞–∑–≤–∏—Ç–∏—è

**–ü—Ä–æ–µ–∫—Ç:** NewTower 1.4 Alpha (Ink Style Update)
**–î–∞—Ç–∞:** 26 –Ø–Ω–≤–∞—Ä—è 2026

## 1. –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è

–¢–µ–∫—É—â–∏–π –≤–∏–∑—É–∞–ª—å–Ω—ã–π —Å—Ç–∏–ª—å ("Ink" / "–ß–µ—Ä–Ω–∏–ª–∞ –∏ –ü–µ—Ä–≥–∞–º–µ–Ω—Ç") —è–≤–ª—è–µ—Ç—Å—è **—Å–∏–ª—å–Ω–æ–π –∏ —É–Ω–∏–∫–∞–ª—å–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω–æ–π –ø—Ä–æ–µ–∫—Ç–∞**. –û–Ω –≤—ã–¥–µ–ª—è–µ—Ç –∏–≥—Ä—É –Ω–∞ —Ñ–æ–Ω–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö "–ø–∏–∫—Å–µ–ª—å–Ω—ã—Ö" –∏–ª–∏ "–≤–µ–∫—Ç–æ—Ä–Ω—ã—Ö" Tower Defense.

### –ß—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ö–æ—Ä–æ—à–æ

* **¬´–ñ–∏–≤–∞—è¬ª –ª–∏–Ω–∏—è (Draw Wobble):** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –¥—Ä–æ–∂–∞—â–µ–π –ª–∏–Ω–∏–∏ (`InkUtils.drawWobbleLine`) —Å–æ–∑–¥–∞–µ—Ç –ø—Ä–∏—è—Ç–Ω—É—é —ç—Å—Ç–µ—Ç–∏–∫—É —Ä—É—á–Ω–æ–≥–æ —Ä–∏—Å—É–Ω–∫–∞.
* **–ê—Ç–º–æ—Å—Ñ–µ—Ä–∞ (Lighting):** –°–∏—Å—Ç–µ–º–∞ –æ—Å–≤–µ—â–µ–Ω–∏—è (`InkLightingSystem`), –∫–æ—Ç–æ—Ä–∞—è –Ω–µ –ø—Ä–æ—Å—Ç–æ –∑–∞—Ç–µ–º–Ω—è–µ—Ç —ç–∫—Ä–∞–Ω, –∞ "—Ç–æ–Ω–∏—Ä—É–µ—Ç" –±—É–º–∞–≥—É (Night Tint) –∏ "–≤—ã–∂–∏–≥–∞–µ—Ç" –µ—ë —Å–≤–µ—Ç–æ–º (Bleach/Screen blend), –≤—ã–≥–ª—è–¥–∏—Ç –æ—á–µ–Ω—å –æ—Ä–≥–∞–Ω–∏—á–Ω–æ.
* **–ß–∏—Ç–∞–µ–º–æ—Å—Ç—å:** –°–µ—Ç–∫–∞ –∏ –ø—É—Ç–∏ —á–µ—Ç–∫–æ –≤–∏–¥–Ω—ã, –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Å—Ç–∏–ª–∏–∑–∞—Ü–∏—é. –ö–æ–Ω—Ç—Ä–∞—Å—Ç –º–µ–∂–¥—É –ø–µ—Ä–≥–∞–º–µ–Ω—Ç–æ–º –∏ —Ç–µ–º–Ω—ã–º–∏ —á–µ—Ä–Ω–∏–ª–∞–º–∏ –æ—Ç–ª–∏—á–Ω—ã–π.
* **UI (–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å):** –ö–∞—Ä—Ç–æ—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –≤—ã–≥–ª—è–¥–∏—Ç –∞–∫–∫—É—Ä–∞—Ç–Ω–æ, —à—Ä–∏—Ñ—Ç—ã —á–∏—Ç–∞–µ–º—ã.

### –ó–æ–Ω—ã –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è (Potentials)

* **–°–≤—è–∑–Ω–æ—Å—Ç—å (Consistency):** –í—Ä–∞–≥–∏ –∏ —ç—Ñ—Ñ–µ–∫—Ç—ã (—Å–Ω–∞—Ä—è–¥—ã) –¥–æ–ª–∂–Ω—ã —Å—Ç—Ä–æ–≥–æ —Å–ª–µ–¥–æ–≤–∞—Ç—å "—á–µ—Ä–Ω–∏–ª—å–Ω–æ–º—É" —Å—Ç–∏–ª—é. –ï—Å–ª–∏ –æ–Ω–∏ –≤—ã–≥–ª—è–¥—è—Ç –∫–∞–∫ –æ–±—ã—á–Ω—ã–µ —Å–ø—Ä–∞–π—Ç—ã, —ç—Ç–æ —Ä–∞–∑—Ä—É—à–∞–µ—Ç –∏–ª–ª—é–∑–∏—é.
* **–î–∏–Ω–∞–º–∏–∫–∞ —Ñ–æ–Ω–∞:** "–ë—É–º–∞–≥–∞" —Å–µ–π—á–∞—Å —Å—Ç–∞—Ç–∏—á–Ω–∞. –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ñ—Ñ–µ–∫—Ç—ã —Å—Ç–∞—Ä–µ–Ω–∏—è, –ø—è—Ç–Ω–∞, –∏–ª–∏ –ª–µ–≥–∫–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç—É—Ä—ã.
* **UI –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è:** –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å–µ–π—á–∞—Å –≤—ã–≥–ª—è–¥–∏—Ç –Ω–µ–º–Ω–æ–≥–æ ¬´–ø–æ–≤–µ—Ä—Ö¬ª –º–∏—Ä–∞. –ï–≥–æ –º–æ–∂–Ω–æ –≤–∏–∑—É–∞–ª—å–Ω–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å, —Å–¥–µ–ª–∞–≤ –ø–∞–Ω–µ–ª–∏ —á–∞—Å—Ç—å—é —á–µ—Ä—Ç–µ–∂–∞ (—Ä–∏—Å–æ–≤–∞–Ω–Ω—ã–µ —Ä–∞–º–∫–∏, —Ç–µ–∫—Å—Ç—É—Ä–∞ –±—É–º–∞–≥–∏ –Ω–∞ –∫–Ω–æ–ø–∫–∞—Ö).

---

## 2. –í–∞—Ä–∏–∞–Ω—Ç—ã —Ä–∞–∑–≤–∏—Ç–∏—è —Å—Ç–∏–ª—è (Roadmap Options)

–ü—Ä–µ–¥–ª–∞–≥–∞—é —Ç—Ä–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∞–∑–≤–∏—Ç–∏—è. –ö–∞–∂–¥–æ–µ –∏–∑ –Ω–∏—Ö –±–∞–∑–∏—Ä—É–µ—Ç—Å—è –Ω–∞ —Ç–µ–∫—É—â–µ–º –∫–æ–¥–µ, –Ω–æ —Å–º–µ—â–∞–µ—Ç –∞–∫—Ü–µ–Ω—Ç—ã.

### –í–∞—Ä–∏–∞–Ω—Ç –ê: ¬´–ù–µ–æ–Ω–æ–≤—ã–π –ì—Ä–∏–º—É–∞—Ä¬ª (Neon Grimoire)

**–ö–æ–Ω—Ü–µ–ø—Ü–∏—è:** –°–º–µ—Å—å –¥—Ä–µ–≤–Ω–µ–π –º–∞–≥–∏–∏ –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π. –°—Ç–∞—Ä—ã–π –ø–µ—Ä–≥–∞–º–µ–Ω—Ç, –Ω–æ —á–µ—Ä–Ω–∏–ª–∞ —Å–≤–µ—Ç—è—Ç—Å—è –Ω–µ–æ–Ω–æ–º.

* **–í–∏–∑—É–∞–ª:** –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–µ–∂–µ–≤—ã–π —Ñ–æ–Ω, –Ω–æ –ª–∏–Ω–∏–∏ –±–∞—à–µ–Ω –∏ –≤—Ä–∞–≥–æ–≤ —Å–≤–µ—Ç—è—Ç—Å—è (Cyan, Magenta, Bright Orange).
* **–≠—Ñ—Ñ–µ–∫—Ç—ã:** –ü—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏ —Å–Ω–∞—Ä—è–¥–æ–≤ ‚Äî –≤—Å–ø–ª–µ—Å–∫–∏ —Å–≤–µ—Ç—è—â–∏—Ö—Å—è —á–µ—Ä–Ω–∏–ª.
* **UI:** –¢–µ–º–Ω—ã–µ –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–µ –ø–∞–Ω–µ–ª–∏ —Å –Ω–µ–æ–Ω–æ–≤–æ–π –æ–∫–∞–Ω—Ç–æ–≤–∫–æ–π.
* **–î–ª—è –∫–æ–≥–æ:** –ï—Å–ª–∏ —Ö–æ—á–µ—Ç—Å—è –ø–æ–¥—á–µ—Ä–∫–Ω—É—Ç—å "Techno" —á–∞—Å—Ç—å —Å–µ—Ç—Ç–∏–Ω–≥–∞.

### –í–∞—Ä–∏–∞–Ω—Ç –ë: ¬´–ñ–∏–≤–æ–π –ß–µ—Ä—Ç–µ–∂¬ª (Living Blueprint)

**–ö–æ–Ω—Ü–µ–ø—Ü–∏—è:** –ò–≥—Ä–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –Ω–∞ —Å—Ç–æ–ª–µ –∏–Ω–∂–µ–Ω–µ—Ä–∞ –ø—Ä—è–º–æ –≤ –º–æ–º–µ–Ω—Ç –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.

* **–í–∏–∑—É–∞–ª:** –°–º–µ—â–µ–Ω–∏–µ –ø–∞–ª–∏—Ç—Ä—ã –≤ —Å—Ç–æ—Ä–æ–Ω—É —Å–∏–Ω—å–∫–∏ (Blueprint) –∏–ª–∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π –±—É–º–∞–≥–∏ (–º–∏–ª–ª–∏–º–µ—Ç—Ä–æ–≤–∫–∞). –õ–∏–Ω–∏–∏ –±–µ–ª—ã–µ –∏–ª–∏ —Ç–µ–º–Ω–æ-—Å–∏–Ω–∏–µ.
* **–ê–Ω–∏–º–∞—Ü–∏–∏:** –ë–∞—à–Ω–∏ –ø—Ä–∏ –ø–æ—Å—Ç—Ä–æ–π–∫–µ "—Ä–∏—Å—É—é—Ç—Å—è" –±—ã—Å—Ç—Ä—ã–º–∏ —à—Ç—Ä–∏—Ö–∞–º–∏ (–∞–Ω–∏–º–∞—Ü–∏—è –Ω–∞–±—Ä–æ—Å–∫–∞). –í—Ä–∞–≥–∏ ‚Äî —ç—Ç–æ –Ω–µ–±—Ä–µ–∂–Ω—ã–µ –∫–∞—Ä–∞–∫—É–ª–∏, –∫–æ—Ç–æ—Ä—ã–µ —Å—Ç–∏—Ä–∞—é—Ç—Å—è –ª–∞—Å—Ç–∏–∫–æ–º –ø—Ä–∏ —Å–º–µ—Ä—Ç–∏.
* **UI:** –í—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —á–µ—Ä—Ç–µ–∂–Ω–∏–∫–∞ (–ª–∏–Ω–µ–π–∫–∏, –∫–∞—Ä–∞–Ω–¥–∞—à–Ω—ã–µ –ø–æ–º–µ—Ç–∫–∏ –Ω–∞ –ø–æ–ª—è—Ö).
* **–î–ª—è –∫–æ–≥–æ:** –ï—Å–ª–∏ –≤–∞–∂–Ω–∞ —Ç–∞–∫—Ç–∏—á–µ—Å–∫–∞—è –∞—Ç–º–æ—Å—Ñ–µ—Ä–∞ –∏ –æ—â—É—â–µ–Ω–∏–µ "—Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞".

### –í–∞—Ä–∏–∞–Ω—Ç –í: ¬´–¢–∞–∫—Ç–∏—á–µ—Å–∫–∞—è –ö–∞—Ä—Ç–∞¬ª (Tactical Map) ‚Äî *–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π*

**–ö–æ–Ω—Ü–µ–ø—Ü–∏—è:** –†–∞–∑–≤–∏—Ç–∏–µ —Ç–µ–∫—É—â–µ–≥–æ "Ink" —Å—Ç–∏–ª—è –≤ —Å—Ç–æ—Ä–æ–Ω—É –±–æ–ª—å—à–µ–π "—Ñ–∏–∑–∏—á–Ω–æ—Å—Ç–∏" –∏ –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏.

* **–í–∏–∑—É–∞–ª:** –£–≥–ª—É–±–ª–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ —Å—Ç–∏–ª—è. –î–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–µ—á–Ω—ã–µ —Ç–µ–Ω–∏ (—à—Ç—Ä–∏—Ö–æ–≤–∫–∞) –¥–ª—è –ø—Ä–∏–¥–∞–Ω–∏—è –æ–±—ä–µ–º–∞ –±–∞—à–Ω—è–º.
* **–û–∫—Ä—É–∂–µ–Ω–∏–µ:** –î–æ–±–∞–≤–∏—Ç—å –Ω–∞ –∫–∞—Ä—Ç—É –ø–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ –ø—Ä–µ–¥–º–µ—Ç—ã "—Å —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Å—Ç–æ–ª–∞" (–º–æ–Ω–µ—Ç—ã, –∫—Ä—É–∂–∫–∞ —á–∞—è, —Ç–µ–Ω—å –æ—Ç —Ä—É–∫–∏ –∏–≥—Ä–æ–∫–∞), —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å —ç—Ñ—Ñ–µ–∫—Ç "–∏–≥—Ä—ã –Ω–∞ —Å—Ç–æ–ª–µ".
* **UI:** –°—Ç–∏–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥ –±—É–º–∞–∂–Ω—ã–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –∏ –∑–∞–º–µ—Ç–∫–∏, –ø—Ä–∏–∫–æ–ª–æ—Ç—ã–µ –∫ –∫–∞—Ä—Ç–µ.
* **–î–ª—è –∫–æ–≥–æ:** –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –∞—Ç–º–æ—Å—Ñ–µ—Ä—ã —Å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º "—É—é—Ç–∞" –∏ –≥–ª—É–±–∏–Ω—ã.

---

## 3. –ü–ª–∞–Ω –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —É–ª—É—á—à–µ–Ω–∏–π (Action Plan)

–ù–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞, —Å–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏ –ø–æ–¥–Ω–∏–º—É—Ç –∫–∞—á–µ—Å—Ç–≤–æ –≤–∏–∑—É–∞–ª–∞ –Ω–∞ –Ω–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å:

### –≠—Ç–∞–ø 1: "Juice" (–°–æ—á–Ω–æ—Å—Ç—å) –∏ –ß–∞—Å—Ç–∏—Ü—ã

* **–ß–µ—Ä–Ω–∏–ª—å–Ω—ã–µ –±—Ä—ã–∑–≥–∏:** –ü—Ä–∏ —Å–º–µ—Ä—Ç–∏ –≤—Ä–∞–≥–∞ –æ–Ω –Ω–µ –ø—Ä–æ—Å—Ç–æ –∏—Å—á–µ–∑–∞–µ—Ç, –∞ –æ—Å—Ç–∞–≤–ª—è–µ—Ç –∫–ª—è–∫—Å—É, –∫–æ—Ç–æ—Ä–∞—è –º–µ–¥–ª–µ–Ω–Ω–æ –≤—ã—Å—ã—Ö–∞–µ—Ç (–∏—Å—á–µ–∑–∞–µ—Ç —á–µ—Ä–µ–∑ 5-10 —Å).
* **–ü—ã–ª—å –∏ –î—ã–º:** –î–æ–±–∞–≤–∏—Ç—å –ª–µ–≥–∫–∏–µ —á–∞—Å—Ç–∏—Ü—ã –ø—ã–ª–∏, –ª–µ—Ç—è—â–∏–µ –Ω–∞–¥ –∫–∞—Ä—Ç–æ–π (–ø–∞—Ä–∞–ª–ª–∞–∫—Å —ç—Ñ—Ñ–µ–∫—Ç), –∏ –¥—ã–º–æ–∫ –æ—Ç –±–∞—à–µ–Ω.
* **Screen Shake:** –õ–µ–≥–∫–∞—è —Ç—Ä—è—Å–∫–∞ –∫–∞–º–µ—Ä—ã –ø—Ä–∏ –≤–∑—Ä—ã–≤–∞—Ö –∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —É—Ä–æ–Ω–∞ –±–∞–∑–æ–π.

### –≠—Ç–∞–ø 2: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è UI

* **–†–∏—Å–æ–≤–∞–Ω–Ω—ã–µ —Ä–∞–º–∫–∏:** –ó–∞–º–µ–Ω–∏—Ç—å CSS `border: 1px solid` –Ω–∞ SVG-–º–∞—Å–∫–∏ –∏–ª–∏ `border-image` —Å –Ω–µ—Ä–æ–≤–Ω—ã–º–∏ –∫—Ä–∞—è–º–∏, –∫–∞–∫ —É –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–Ω—ã—Ö —á–µ—Ä–Ω–∏–ª–∞–º–∏ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤.
* **–®—Ä–∏—Ñ—Ç—ã:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —à—Ä–∏—Ñ—Ç, –∏–º–∏—Ç–∏—Ä—É—é—â–∏–π –ø–æ—á–µ—Ä–∫ –∏–ª–∏ —Å—Ç–∞—Ä—É—é –ø–µ—á–∞—Ç—å, –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ (—Å–æ—Ö—Ä–∞–Ω—è—è —á–∏—Ç–∞–µ–º—ã–π sans-serif –¥–ª—è –º–µ–ª–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞).

### –≠—Ç–∞–ø 3: –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è –ö–∞—Ä—Ç—ã

* **–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —à—Ç—Ä–∏—Ö–æ–≤–∫–∞:** –î–æ–±–∞–≤–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Ç–µ–Ω–µ–π-—à—Ç—Ä–∏—Ö–æ–≤–∫–∏ (hatching) –æ—Ç —Å—Ç–µ–Ω –∏ –±–∞—à–µ–Ω –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏, –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–º –∏—Å—Ç–æ—á–Ω–∏–∫—É —Å–≤–µ—Ç–∞.
* **–í–∏–Ω—å–µ—Ç–∫–∞ –∏ –§–æ–∫—É—Å:** –£—Å–∏–ª–∏—Ç—å –≤–∏–Ω—å–µ—Ç–∫—É –ø–æ –∫—Ä–∞—è–º —ç–∫—Ä–∞–Ω–∞, —á—Ç–æ–±—ã —Ñ–æ–∫—É—Å –±—ã–ª –Ω–∞ —Ü–µ–Ω—Ç—Ä–µ —Å—Ä–∞–∂–µ–Ω–∏—è.

## 4. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

1. **–®–µ–π–¥–µ—Ä—ã (–ø–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏):** –î–ª—è "—Ä–∞—Å—Ç–µ–∫–∞–Ω–∏—è" —á–µ—Ä–Ω–∏–ª –∏–¥–µ–∞–ª—å–Ω–æ –ø–æ–¥–æ—à–µ–ª –±—ã –ø—Ä–æ—Å—Ç–æ–π —Ñ—Ä–∞–≥–º–µ–Ω—Ç–Ω—ã–π —à–µ–π–¥–µ—Ä, –Ω–æ —Ç–µ–∫—É—â–∞—è Canvas 2D —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç–æ–∂–µ —Å–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è.
2. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è:** –ü—Ä–æ–¥–æ–ª–∂–∞—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã –∫–∞—Ä—Ç—ã (–∫–∞–∫ —Å–¥–µ–ª–∞–Ω–æ –≤ `InkMapRenderer`), —Ç–∞–∫ –∫–∞–∫ –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ç—ã—Å—è—á –ª–∏–Ω–∏–π –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä "—É–±—å–µ—Ç" FPS.

---
**–ò—Ç–æ–≥:** –ë–∞–∑–∞ –æ—Ç–ª–∏—á–Ω–∞—è. –†–µ–∫–æ–º–µ–Ω–¥—É—é –¥–≤–∏–≥–∞—Ç—å—Å—è –ø–æ **–í–∞—Ä–∏–∞–Ω—Ç—É –í (–¢–∞–∫—Ç–∏—á–µ—Å–∫–∞—è –ö–∞—Ä—Ç–∞)** —Å —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ **–í–∞—Ä–∏–∞–Ω—Ç–∞ –ê (—Å–≤–µ—Ç—è—â–∏–µ—Å—è —ç—Ñ—Ñ–µ–∫—Ç—ã)** –¥–ª—è –º–∞–≥–∏–∏. –≠—Ç–æ —Å–æ–∑–¥–∞—Å—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π "Magicpunk on Paper" —Å—Ç–∏–ª—å.
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite';
import checker from 'vite-plugin-checker';

export default defineConfig({
    root: './',
    base: './', // Use relative paths for assets
    build: {
        outDir: 'dist',
        emptyOutDir: true,
        sourcemap: true,
    },
    plugins: [
        checker({ typescript: true }), // Type check on build/dev
    ],
    server: {
        open: true, // Open browser on start
        port: 8080,
    },
    preview: {
        port: 8080,
    },
});
</file>

<file path=".gitignore">
#############################################
# Node / NPM
#############################################
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
package-lock.json
# (–µ—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ —Ö–æ—á–µ—Ç —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –≤–µ—Ä—Å–∏–∏ ‚Äî –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å package-lock.json)

#############################################
# Build / Distribution folders
#############################################
dist/
build/
out/
cache/
.tmp/
.temp/

# Vite / Webpack / Rollup caches
.vite/
.vite/deps/
webpack-stats.json
.rspack/

#############################################
# TypeScript
#############################################
*.tsbuildinfo
tsconfig.tsbuildinfo
# Backups created by TS server
*.tscbackup

#############################################
# Logs / Debug
#############################################
logs/
*.log
*.log.*
debug.log
error.log

#############################################
# Testing (Jest / Playwright / Vitest)
#############################################
coverage/
.vitest/
.playwright/
test-results/
*.test.js.map
*.test.ts.map
jest-cache/
jest-html-reporters-*/ 

#############################################
# IDE / Editors
#############################################
# VSCode
.vscode/
.history/
*.code-workspace

# JetBrains IDEs
.idea/
*.iml

#############################################
# Cache / Temporary system files
#############################################
.DS_Store
Thumbs.db
Desktop.ini

# Windows recycle bin (–∏–Ω–æ–≥–¥–∞ –ø–æ–ø–∞–¥–∞–µ—Ç)
$RECYCLE.BIN/

#############################################
# Environment variables
#############################################
.env
.env.*
!.env.example    # –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–∏–º–µ—Ä

#############################################
# Browser bundles / generated assets
#############################################
*.bundle.js
*.bundle.js.map
*.min.js
*.min.css
*.map
*.cache

#############################################
# Compiled assets (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ TexturePacker/Spine)
#############################################
*.atlas
*.skel.json
*.json.bak

#############################################
# Images (–µ—Å–ª–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
#############################################
*.png.bak
*.jpg.bak
*.jpeg.bak

#############################################
# Runtime data (–µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –≤–æ –≤—Ä–µ–º—è –∏–≥—Ä—ã)
#############################################
save_data/
replays/
temp_data/

#############################################
# OS-level files
#############################################
ehthumbs.db
Icon?
.fseventsd
.Trashes

#############################################
# Lockfiles (–µ—Å–ª–∏ –Ω–µ —Ö–æ—Ç–∏—Ç–µ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –≤–µ—Ä—Å–∏—é –º–µ–Ω–µ–¥–∂–µ—Ä–∞)
#############################################
*.lock
</file>

<file path="jest.config.js">
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/__tests__/**/*.test.ts'],
  moduleFileExtensions: ['ts', 'js', 'json', 'node'],
};
</file>

<file path="src/Card.ts">
export enum CardType {
    TOWER = 'tower',
    SPELL = 'spell',
}

export interface ICardConfig {
    id: string;
    name: string;
    description: string;
    cost: number;
    type: CardType;
    value: number;
}

export class Card {
    public id: string;
    public name: string;
    public cost: number;
    public level: number = 1;
    private config: ICardConfig;

    constructor(config: ICardConfig) {
        this.id = config.id;
        this.name = config.name;
        this.cost = config.cost;
        this.config = config;
    }

    public upgrade(): void {
        this.level += 1;
        this.cost = Math.floor(this.cost * 1.5);
    }
}
</file>

<file path="src/cards/index.ts">
/**
 * Card System Module
 * Central export point for all card upgrade definitions
 */

import { IUpgradeCard, ICardModifiers, ICardEffect, mergeModifiers, mergeEffects } from './CardType';
import { FIRE_UPGRADES } from './FireCard';
import { ICE_UPGRADES } from './IceCard';
import { SNIPER_UPGRADES } from './SniperCard';
import { MULTISHOT_UPGRADES, getMultishotConfig } from './MultishotCard';
import { MINIGUN_UPGRADES } from './MinigunCard';

// Export types
export type { IUpgradeCard, ICardModifiers, ICardEffect };
export { mergeModifiers, mergeEffects };

// Export card upgrade data
export { FIRE_UPGRADES, ICE_UPGRADES, SNIPER_UPGRADES, MULTISHOT_UPGRADES, MINIGUN_UPGRADES, getMultishotConfig };

/**
 * Card upgrade registry
 */
const CARD_REGISTRY: Record<string, Record<number, IUpgradeCard>> = {
    'fire': FIRE_UPGRADES,
    'ice': ICE_UPGRADES,
    'sniper': SNIPER_UPGRADES,
    'multi': MULTISHOT_UPGRADES,
    'minigun': MINIGUN_UPGRADES,
};

/**
 * Get upgrade data for a specific card type and level
 * @param cardTypeId - The card type ID (e.g., 'fire', 'ice', 'sniper', 'multi')
 * @param level - The card level (1-3)
 * @returns The upgrade data or null if not found
 */
export function getCardUpgrade(cardTypeId: string, level: number): IUpgradeCard | null {
    const cardUpgrades = CARD_REGISTRY[cardTypeId];
    if (!cardUpgrades) {
        console.warn(`Unknown card type: ${cardTypeId}`);
        return null;
    }

    const upgrade = cardUpgrades[level];
    if (!upgrade) {
        console.warn(`Unknown level ${level} for card type ${cardTypeId}`);
        return null;
    }

    return upgrade;
}
</file>

<file path="src/CardSelectionUI.ts">
import { CONFIG } from './Config';

/**
 * Card Selection System
 * Shows overlay where player select s 3 starting cards
 */
export class CardSelectionUI {
    private overlay: HTMLElement;
    private grid: HTMLElement;
    private counter: HTMLElement;
    private startButton: HTMLButtonElement;
    private selectedCards: string[] = [];
    private onComplete: (cards: string[]) => void;

    constructor(onComplete: (cards: string[]) => void) {
        this.onComplete = onComplete;
        console.log('CardSelectionUI: Constructor called');

        // Don't check elements here - they might not exist yet
        // Elements will be checked in show() method
    }

    public show() {
        console.log('CardSelectionUI.show() called');

        // FIXED: Check elements HERE, not in constructor
        this.overlay = document.getElementById('card-selection-overlay')!;
        this.grid = document.getElementById('card-selection-grid')!;
        this.counter = document.getElementById('selected-count')!;
        this.startButton = document.getElementById('start-game-btn') as HTMLButtonElement;

        if (!this.overlay || !this.grid || !this.counter || !this.startButton) {
            console.error('CardSelectionUI: Required DOM elements not found!');
            console.error('overlay:', this.overlay);
            console.error('grid:', this.grid);
            console.error('counter:', this.counter);
            console.error('startButton:', this.startButton);
            alert('ERROR: Card selection UI elements not found. Check console.');
            return;
        }

        // Add click listener (only once)
        if (!this.startButton.onclick) {
            this.startButton.addEventListener('click', () => this.complete());
        }

        console.log('CardSelectionUI: All elements found successfully');

        this.selectedCards = [];
        this.overlay.classList.add('show');
        this.render();
    }

    public hide() {
        this.overlay.classList.remove('show');
    }

    private render() {
        console.log('CardSelectionUI.render() called');
        this.grid.innerHTML = '';

        // Get all base card types
        const baseCards = Object.keys(CONFIG.CARD_TYPES);
        console.log('Base cards available:', baseCards);

        // Add 2 random cards
        const randomCards = [
            baseCards[Math.floor(Math.random() * baseCards.length)],
            baseCards[Math.floor(Math.random() * baseCards.length)],
        ];

        const availableCards = [...baseCards, ...randomCards];
        console.log('Total cards to display:', availableCards);

        // Render cards
        availableCards.forEach((cardKey, index) => {
            const config = CONFIG.CARD_TYPES[cardKey];
            if (!config) {
                console.warn(`Card config not found for key: ${cardKey}`);
                return;
            }

            const cardEl = document.createElement('div');
            // Use same structure as CardSystem
            cardEl.className = `card type-${config.id} level-1`;
            cardEl.style.animationDelay = `${index * 0.05}s`;
            cardEl.style.cursor = 'pointer';

            // Get stats HTML for level 1
            const statsHTML = this.getCardStatsHTML(config.id);

            cardEl.innerHTML = `
                <div class="card-level">‚òÖ</div>
                <div class="card-icon">${config.icon}</div>
                <div class="card-stats">${statsHTML}</div>
            `;

            cardEl.addEventListener('click', () => this.selectCard(cardKey, cardEl));
            this.grid.appendChild(cardEl);
        });

        console.log(`Rendered ${availableCards.length} cards`);

        // Update counter and button
        this.updateUI();
    }

    private selectCard(cardKey: string, cardEl: HTMLElement) {
        if (cardEl.classList.contains('selected')) {
            // Deselect
            cardEl.classList.remove('selected');
            const index = this.selectedCards.indexOf(cardKey);
            if (index !== -1) {
                this.selectedCards.splice(index, 1);
            }
        } else {
            // Select (if not full)
            if (this.selectedCards.length < 5) {
                cardEl.classList.add('selected');
                this.selectedCards.push(cardKey);
            }
        }

        this.updateUI();
    }

    private updateUI() {
        this.counter.textContent = this.selectedCards.length.toString();
        this.startButton.disabled = this.selectedCards.length !== 5;
    }

    private complete() {
        if (this.selectedCards.length === 5) {
            this.hide();
            this.onComplete(this.selectedCards);
        }
    }

    private getCardStatsHTML(typeId: string): string {
        // Same logic as CardSyst em, but always level 1
        switch (typeId) {
            case 'fire':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +15</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 50</div>`;
            case 'ice':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +3</div><div class="card-stat-line">‚ùÑÔ∏è 30%</div>`;
            case 'sniper':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +14</div><div class="card-stat-line">üéØ +80</div>`;
            case 'multi':
                return `<div class="card-stat-primary">2 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.8x —É—Ä–æ–Ω</div>`;
            case 'minigun':
                return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+3 —É—Ä–æ–Ω/—Å</div>`;
            default:
                return `<div class="card-stat-line">–ö–∞—Ä—Ç–∞</div>`;
        }
    }
}
</file>

<file path="src/DayNightCycle.ts">
/**
 * Day/Night cycle system - simple and configurable
 */
export interface IDayNightConfig {
    cycleDuration: number; // seconds for full cycle
    startTime: number; // 0-1, where to start (0=dawn, 0.5=dusk, 1=midnight)
}

export class DayNightCycle {
    private time: number = 0; // 0-1
    private config: IDayNightConfig;

    constructor(config?: Partial<IDayNightConfig>) {
        this.config = {
            cycleDuration: 240, // 4 minutes default (was reduced from original by 30%)
            startTime: 0.15, // Start closer to dawn for brighter initial lighting
            ...config
        };

        this.time = this.config.startTime;
    }

    /**
     * Update the cycle
     * @param deltaTime - time in seconds since last update
     */
    public update(deltaTime: number): void {
        const increment = deltaTime / this.config.cycleDuration;
        this.time = (this.time + increment) % 1;
    }

    /**
     * Get current time of day
     * @returns 0-1 value (0=dawn, 0.25=noon, 0.5=dusk, 0.75=midnight, 1=dawn again)
     */
    public getTimeOfDay(): number {
        return this.time;
    }

    /**
     * Check if it's currently day time
     */
    public isDay(): boolean {
        return this.time < 0.5;
    }

    /**
     * Check if it's currently night time
     */
    public isNight(): boolean {
        return this.time >= 0.5;
    }

    /**
     * Set time manually (for testing/debugging)
     */
    public setTime(time: number): void {
        this.time = Math.max(0, Math.min(1, time));
    }

    /**
     * Get human-readable time string
     */
    public getTimeString(): string {
        if (this.time < 0.25) return 'Morning';
        if (this.time < 0.5) return 'Afternoon';
        if (this.time < 0.75) return 'Evening';
        return 'Night';
    }

    /**
     * Update configuration at runtime
     */
    public updateConfig(newConfig: Partial<IDayNightConfig>): void {
        this.config = { ...this.config, ...newConfig };
    }
}
</file>

<file path="src/editor/EditorToolbar.ts">
import { UIUtils } from '../UIUtils';

export type EditorMode =
    | 'paint_road'
    | 'paint_grass'
    | 'set_start'
    | 'set_end'
    | 'place_waypoint'
    | 'eraser'
    | 'paint_fog'
    | 'place_stone'
    | 'place_rock'
    | 'place_tree'
    | 'place_wheat'
    | 'place_flowers';

interface ITool {
    id: EditorMode;
    label: string;
    icon: string;
    color: string;
    hotkey?: string;
}

interface IToolCategory {
    id: string;
    name: string;
    icon: string;
    tools: ITool[];
}

export class EditorToolbar {
    private container: HTMLElement;
    private categoriesContainer: HTMLElement;
    private toolsContainer: HTMLElement;

    private categories: IToolCategory[] = [];
    private selectedCategory: number = 0;
    private onModeChange: (mode: EditorMode) => void;

    constructor(onModeChange: (mode: EditorMode) => void) {
        this.onModeChange = onModeChange;

        // Define categories
        this.categories = [
            {
                id: 'environment',
                name: '–û–∫—Ä—É–∂–µ–Ω–∏–µ',
                icon: 'üå≤',
                tools: [
                    { id: 'paint_grass', label: '–¢—Ä–∞–≤–∞', icon: 'üå≤', color: '#388e3c' },
                    { id: 'paint_road', label: '–î–æ—Ä–æ–≥–∞', icon: 'üü´', color: '#795548' },
                    { id: 'paint_fog', label: '–¢—É–º–∞–Ω', icon: 'üå´Ô∏è', color: '#607d8b' },
                ]
            },
            {
                id: 'path',
                name: '–ü—É—Ç—å',
                icon: 'üö©',
                tools: [
                    { id: 'set_start', label: '–°—Ç–∞—Ä—Ç', icon: 'üèÅ', color: '#00bcd4' },
                    { id: 'set_end', label: '–§–∏–Ω–∏—à', icon: 'üõë', color: '#e91e63' },
                    { id: 'place_waypoint', label: '–¢–æ—á–∫–∞', icon: 'üìç', color: '#9c27b0' },
                ]
            },
            {
                id: 'objects',
                name: '–û–±—ä–µ–∫—Ç—ã',
                icon: 'ü™®',
                tools: [
                    { id: 'place_stone', label: '–ö–∞–º–Ω–∏', icon: 'ü™®', color: '#757575' },
                    { id: 'place_rock', label: '–°–∫–∞–ª—ã', icon: '‚õ∞Ô∏è', color: '#616161' },
                    { id: 'place_tree', label: '–õ–µ—Å', icon: 'üå≤', color: '#2e7d32' },
                    { id: 'place_wheat', label: '–ü—à–µ–Ω–∏—Ü–∞', icon: 'üåæ', color: '#f9a825' },
                    { id: 'place_flowers', label: '–¶–≤–µ—Ç—ã', icon: 'üå∏', color: '#c2185b' },
                ]
            },
            {
                id: 'erase',
                name: '–°—Ç–µ—Ä–µ—Ç—å',
                icon: 'üßπ',
                tools: [
                    { id: 'eraser', label: '–õ–∞—Å—Ç–∏–∫', icon: 'üßπ', color: '#ff6600', hotkey: 'E' },
                ]
            }
        ];

        this.container = this.createContainer();
        this.categoriesContainer = this.createCategoriesView();
        this.toolsContainer = this.createToolsView();

        this.container.appendChild(this.categoriesContainer);
        this.container.appendChild(this.toolsContainer);

        document.body.appendChild(this.container);

        this.selectCategory(0);
    }

    private createContainer(): HTMLElement {
        return UIUtils.createContainer({
            position: 'absolute',
            bottom: '20px',
            left: '50%',
            transform: 'translateX(-50%)',
            display: 'flex',
            flexDirection: 'column',
            gap: '8px',
            padding: '12px',
            background: 'rgba(0,0,0,0.85)',
            borderRadius: '10px',
            zIndex: '1000'
        });
    }

    private createCategoriesView(): HTMLElement {
        const container = document.createElement('div');
        Object.assign(container.style, {
            display: 'flex',
            gap: '6px',
            borderBottom: '2px solid #444',
            paddingBottom: '8px'
        });

        this.categories.forEach((cat, idx) => {
            const btn = document.createElement('button');
            btn.textContent = `${cat.icon} ${cat.name}`;
            btn.dataset.categoryIndex = idx.toString();

            Object.assign(btn.style, {
                background: '#333',
                color: '#fff',
                border: '2px solid #555',
                padding: '8px 16px',
                borderRadius: '6px',
                cursor: 'pointer',
                fontSize: '14px',
                fontWeight: 'bold',
                transition: 'all 0.2s'
            });

            btn.onclick = () => this.selectCategory(idx);
            container.appendChild(btn);
        });

        return container;
    }

    private createToolsView(): HTMLElement {
        const container = document.createElement('div');
        Object.assign(container.style, {
            display: 'flex',
            gap: '8px',
            flexWrap: 'wrap'
        });

        return container;
    }

    public selectCategory(index: number): void {
        if (index < 0 || index >= this.categories.length) return;

        this.selectedCategory = index;

        // Update category button states
        const categoryBtns = this.categoriesContainer.querySelectorAll('button');
        categoryBtns.forEach((btn, idx) => {
            if (idx === index) {
                Object.assign((btn as HTMLElement).style, {
                    background: '#1976d2',
                    borderColor: '#2196f3',
                    transform: 'translateY(-2px)'
                });
            } else {
                Object.assign((btn as HTMLElement).style, {
                    background: '#333',
                    borderColor: '#555',
                    transform: 'translateY(0)'
                });
            }
        });

        // Update tools display
        this.renderTools();
    }

    private renderTools(): void {
        this.toolsContainer.innerHTML = '';

        const category = this.categories[this.selectedCategory];

        category.tools.forEach(tool => {
            const btn = document.createElement('button');
            btn.textContent = `${tool.icon} ${tool.label}`;
            if (tool.hotkey) {
                btn.textContent += ` (${tool.hotkey})`;
            }

            Object.assign(btn.style, {
                background: tool.color,
                color: '#fff',
                border: '1px solid rgba(255,255,255,0.3)',
                padding: '10px 18px',
                borderRadius: '6px',
                cursor: 'pointer',
                fontSize: '14px',
                fontWeight: 'bold',
                transition: 'transform 0.1s, box-shadow 0.1s'
            });

            btn.onmouseenter = () => {
                btn.style.transform = 'scale(1.05)';
                btn.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
            };

            btn.onmouseleave = () => {
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = 'none';
            };

            btn.onclick = () => this.onModeChange(tool.id);

            this.toolsContainer.appendChild(btn);
        });
    }

    public show(): void {
        this.container.style.display = 'flex';
    }

    public hide(): void {
        this.container.style.display = 'none';
    }

    public destroy(): void {
        if (this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
    }
}
</file>

<file path="src/Events.ts">
type Listener = (data?: any) => void;

export class EventEmitter {
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –ø–æ–¥–ø–∏—Å–æ–∫: '–Ω–∞–∑–≤–∞–Ω–∏–µ_—Å–æ–±—ã—Ç–∏—è' -> [—Å–ø–∏—Å–æ–∫ —Ñ—É–Ω–∫—Ü–∏–π]
    private events: { [key: string]: Listener[] };

    constructor() {
        this.events = {};
    }

    // –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏–µ
    public on(event: string, listener: Listener): void {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);
    }

    // –û—Ç–ø–∏—Å–∞—Ç—å—Å—è
    public off(event: string, listener: Listener): void {
        if (!this.events[event]) return;
        this.events[event] = this.events[event].filter((l) => l !== listener);
    }

    // –ö—Ä–∏–∫–Ω—É—Ç—å –Ω–∞ –≤—Å—é –∏–≥—Ä—É: "–ü—Ä–æ–∏–∑–æ—à–ª–æ —Å–æ–±—ã—Ç–∏–µ!"
    public emit(event: string, data?: any): void {
        if (!this.events[event]) return;
        this.events[event].forEach((listener) => listener(data));
    }
}
</file>

<file path="src/graphics/InkConfig.ts">
export const INK_CONFIG = {
    PALETTE: {
        INK: '#2d1b0e',      // Dark Sepia (Main contours)
        PAPER: '#f4e4bc',    // Aged Parchment (Background)
        WASH_RED: '#c62828', // Fire/Enemy
        WASH_BLUE: '#0288d1',// Ice/Magic
        WASH_GREEN: '#558b2f',// Nature/Poison
        WASH_GOLD: '#ffb300', // Gold/Special
        SHADOW: 'rgba(45, 27, 14, 0.5)', // Hatching/Shadow color (Increased from 0.2 for visibility)
    },
    WATERCOLOR: {
        OPACITY_LOW: 0.1,
        OPACITY_MED: 0.3,
        LAYERS: 3,
        SPREAD: 8, // How far wash bleeds outside logic boundaries
    },
    PAPER_TEXTURE: {
        GRAIN_INTENSITY: 0.05,
        VIGNETTE_STRENGTH: 0.4,
    },
    LINE_WIDTH: {
        THIN: 1,
        NORMAL: 2,
        THICK: 3,
    },
    WOBBLE: {
        FREQUENCY: 0.1,    // How fast the line boils
        AMPLITUDE: 1.5,    // How far it deviates
        SEGMENT_LENGTH: 5, // Pixels between wobble points
    }
};
</file>

<file path="src/graphics/InkUtils.ts">
import { INK_CONFIG } from './InkConfig';

export class InkUtils {
    /**
     * Draws a line that "wobbles" organically.
     * @param ctx Canvas Context
     * @param x1 Start X
     * @param y1 Start Y
     * @param x2 End X
     * @param y2 End Y
     * @param time Global time for animation (optional, defaults to 0 for static)
     */
    static drawWobbleLine(ctx: CanvasRenderingContext2D, x1: number, y1: number, x2: number, y2: number, time: number = 0) {
        const dist = Math.hypot(x2 - x1, y2 - y1);
        const steps = Math.ceil(dist / INK_CONFIG.WOBBLE.SEGMENT_LENGTH);

        ctx.beginPath();
        ctx.moveTo(x1, y1);

        for (let i = 1; i < steps; i++) {
            const t = i / steps;
            const tx = x1 + (x2 - x1) * t;
            const ty = y1 + (y2 - y1) * t;

            // Simple noise simulation using sine waves
            // In a real AA production, we might use Perlin Noise, but this is efficient
            const offset = Math.sin(t * 10 + time * INK_CONFIG.WOBBLE.FREQUENCY)
                * Math.cos(t * 5 + time * 0.5)
                * INK_CONFIG.WOBBLE.AMPLITUDE;

            // Perpendicular vector for offset
            const angle = Math.atan2(y2 - y1, x2 - x1) + Math.PI / 2;
            const ox = Math.cos(angle) * offset;
            const oy = Math.sin(angle) * offset;

            ctx.lineTo(tx + ox, ty + oy);
        }

        ctx.lineTo(x2, y2);
        ctx.stroke();
    }

    /**
     * Draws a rough circle/blob outline
     */
    static drawWobbleCircle(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, time: number = 0) {
        const steps = 12; // Number of points
        ctx.beginPath();

        for (let i = 0; i <= steps; i++) {
            const angle = (i / steps) * Math.PI * 2;

            // Wobble radius
            const rOffset = Math.sin(angle * 3 + time * INK_CONFIG.WOBBLE.FREQUENCY) * INK_CONFIG.WOBBLE.AMPLITUDE;
            const r = radius + rOffset;

            const px = x + Math.cos(angle) * r;
            const py = y + Math.sin(angle) * r;

            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
    }

    /**
     * Simulates watercolor fill
     */
    static drawWatercolorFill(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, color: string) {
        ctx.save();
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.6;

        // Base blob
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        // Second uneven layer for "pooling" effect
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(x + 2, y + 3, radius * 0.8, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    /**
     * Draws a dynamic ink splat
     */
    static drawInkSplat(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, color: string, time: number = 0) {
        ctx.save();
        ctx.fillStyle = color;

        const numBlobs = 5;
        const baseRadius = radius * 0.6;

        ctx.beginPath();
        // Central sloppy circle
        ctx.arc(x, y, baseRadius, 0, Math.PI * 2);

        // Random droplets around
        // Use pseudo-random based on position to keep it deterministic per frame if needed, 
        // or let it jitter if time is used.
        for (let i = 0; i < numBlobs; i++) {
            const angle = (i / numBlobs) * Math.PI * 2 + time;
            const dist = radius * (0.8 + Math.sin(i * 132 + x) * 0.3);
            const r = baseRadius * (0.4 + Math.cos(i * 23 + y) * 0.2);

            ctx.moveTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
            ctx.arc(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist, r, 0, Math.PI * 2);
        }
        ctx.fill();
        ctx.restore();
    }
    /**
     * Draws a polygon with wobbly lines
     */
    static drawSketchPoly(ctx: CanvasRenderingContext2D, points: { x: number, y: number }[], close: boolean = true, time: number = 0) {
        if (points.length < 2) return;

        for (let i = 0; i < points.length; i++) {
            if (i === points.length - 1 && !close) break;

            const p1 = points[i];
            const p2 = points[(i + 1) % points.length];

            this.drawWobbleLine(ctx, p1.x, p1.y, p2.x, p2.y, time);
        }
    }
}
</file>

<file path="src/MetricsSystem.ts">
import { SaveManager } from './SaveManager';

/**
 * Metrics Collection System
 * Collects gameplay statistics for balancing
 */

export interface IGameMetrics {
    gamesPlayed: number;
    wavesReached: number[];         // Array of max waves reached per game
    averageWaveReached: number;
    towersBuilt: number;
    cardsUsed: Record<string, number>; // Count per card type
    moneySpent: number;
    moneyEarned: number;
    enemiesKilled: number;
    livesLost: number;
    gamesWon: number;
}

export class MetricsSystem {
    private metrics: IGameMetrics;
    private currentGameMetrics: {
        waveReached: number;
        towersBuilt: number;
        cardsUsed: Record<string, number>;
        moneySpent: number;
        moneyEarned: number;
        enemiesKilled: number;
        livesLost: number;
    };

    constructor() {
        // Try to load from localStorage
        const saved = localStorage.getItem('towerDefenseMetrics');
        if (saved) {
            this.metrics = JSON.parse(saved);
        } else {
            this.metrics = {
                gamesPlayed: 0,
                wavesReached: [],
                averageWaveReached: 0,
                towersBuilt: 0,
                cardsUsed: {},
                moneySpent: 0,
                moneyEarned: 0,
                enemiesKilled: 0,
                livesLost: 0,
                gamesWon: 0,
            };
        }

        this.currentGameMetrics = {
            waveReached: 0,
            towersBuilt: 0,
            cardsUsed: {},
            moneySpent: 0,
            moneyEarned: 0,
            enemiesKilled: 0,
            livesLost: 0,
        };
    }

    // Track actions
    public trackTowerBuilt() {
        this.currentGameMetrics.towersBuilt++;
    }

    public trackCardUsed(cardType: string) {
        if (!this.currentGameMetrics.cardsUsed[cardType]) {
            this.currentGameMetrics.cardsUsed[cardType] = 0;
        }
        this.currentGameMetrics.cardsUsed[cardType]++;
    }

    public trackMoneySpent(amount: number) {
        this.currentGameMetrics.moneySpent += amount;
    }

    public trackMoneyEarned(amount: number) {
        this.currentGameMetrics.moneyEarned += amount;
    }

    public trackEnemyKilled() {
        this.currentGameMetrics.enemiesKilled++;
    }

    public trackLifeLost() {
        this.currentGameMetrics.livesLost++;
    }

    public trackWaveReached(wave: number) {
        this.currentGameMetrics.waveReached = Math.max(this.currentGameMetrics.waveReached, wave);
    }

    // End game and save metrics
    public endGame(won: boolean) {
        this.metrics.gamesPlayed++;
        this.metrics.wavesReached.push(this.currentGameMetrics.waveReached);
        this.metrics.towersBuilt += this.currentGameMetrics.towersBuilt;
        this.metrics.moneySpent += this.currentGameMetrics.moneySpent;
        this.metrics.moneyEarned += this.currentGameMetrics.moneyEarned;
        this.metrics.enemiesKilled += this.currentGameMetrics.enemiesKilled;
        this.metrics.livesLost += this.currentGameMetrics.livesLost;

        // Merge card usage
        for (const [card, count] of Object.entries(this.currentGameMetrics.cardsUsed)) {
            if (!this.metrics.cardsUsed[card]) {
                this.metrics.cardsUsed[card] = 0;
            }
            this.metrics.cardsUsed[card] += count;
        }

        if (won) {
            this.metrics.gamesWon++;
        }

        // Calculate average wave reached
        const total = this.metrics.wavesReached.reduce((a, b) => a + b, 0);
        this.metrics.averageWaveReached = total / this.metrics.wavesReached.length;

        // Save to localStorage
        this.save();

        // Update Campaign Persistence
        SaveManager.updateProgress({
            money: this.currentGameMetrics.moneyEarned,
            kills: this.currentGameMetrics.enemiesKilled,
            waves: this.currentGameMetrics.waveReached,
            maxWave: this.currentGameMetrics.waveReached
        });

        // Log to console for debugging
        console.log('=== GAME METRICS ===');
        console.log(`Games Played: ${this.metrics.gamesPlayed}`);
        console.log(`Average Wave: ${this.metrics.averageWaveReached.toFixed(1)}`);
        console.log(`Win Rate: ${((this.metrics.gamesWon / this.metrics.gamesPlayed) * 100).toFixed(1)}%`);
        console.log('Card Usage:', this.metrics.cardsUsed);
    }

    public save() {
        localStorage.setItem('towerDefenseMetrics', JSON.stringify(this.metrics));
    }

    public getMetrics(): IGameMetrics {
        return { ...this.metrics };
    }

    public getCardUsagePercentages(): Record<string, number> {
        const total = Object.values(this.metrics.cardsUsed).reduce((a, b) => a + b, 0);
        const percentages: Record<string, number> = {};

        for (const [card, count] of Object.entries(this.metrics.cardsUsed)) {
            percentages[card] = (count / total) * 100;
        }

        return percentages;
    }

    public reset() {
        this.metrics = {
            gamesPlayed: 0,
            wavesReached: [],
            averageWaveReached: 0,
            towersBuilt: 0,
            cardsUsed: {},
            moneySpent: 0,
            moneyEarned: 0,
            enemiesKilled: 0,
            livesLost: 0,
            gamesWon: 0,
        };
        this.save();
    }
}
</file>

<file path="src/renderers/EnemyRenderer.ts">
import { Assets } from '../Assets';
import { CONFIG, getEnemyType } from '../Config';
import type { Enemy } from '../Enemy';
import { UnitRenderer, DefaultUnitRenderer } from './units/UnitRenderer';
import { SkeletonUnitRenderer } from './units/SkeletonUnitRenderer';

export class EnemyRenderer {
    // Registry of specific renderers (Singleton/Stateless instances)
    private static defaultRenderer: UnitRenderer = new DefaultUnitRenderer();
    private static renderers: Record<string, UnitRenderer> = {
        'SKELETON': new SkeletonUnitRenderer(),
    };

    static draw(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        const safeType = enemy.typeId ? enemy.typeId.toLowerCase() : 'grunt';
        const typeConf = getEnemyType(safeType.toUpperCase()) || getEnemyType('GRUNT');

        // Defaults
        const scale = typeConf?.scale || 1.0;
        const archetype = typeConf?.archetype || 'SKELETON';
        const props = typeConf?.props || [];
        const baseColor = typeConf?.color || '#fff';
        const tint = typeConf?.tint;

        ctx.save();
        ctx.translate(enemy.x, enemy.y);

        // === ANIMATIONS ===

        // 1. Rotation towards movement
        const path = enemy.path;
        const pathIndex = enemy.pathIndex;
        let moveAngle = 0;

        if (path && pathIndex < path.length - 1) {
            const next = path[pathIndex];
            const dx = next.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 - enemy.x;
            const dy = next.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 - enemy.y;
            moveAngle = Math.atan2(dy, dx);
            // ctx.rotate moved to individual renderers to support Upright perspective
        }

        // 2. Breathing (pulsation)
        const breathePhase = (Date.now() * 0.001) + (parseInt(enemy.id.slice(-3), 36) * 0.5);
        const breatheScale = 1.0 + Math.sin(breathePhase) * 0.03;
        ctx.scale(breatheScale, breatheScale);

        // 3. Movement arc (vertical bob)
        const walkCycle = (Date.now() * 0.01) % (Math.PI * 2);
        const verticalBob = Math.abs(Math.sin(walkCycle)) * 2;
        ctx.translate(0, -verticalBob);

        // -- VISUAL STACK --

        // 0. RIM LIGHT
        // Disabled per user request (white circle issue)
        // EnemyRenderer.drawRimLight(ctx, tint || baseColor, scale);

        // 1. Shadow Layer
        EnemyRenderer.drawShadow(ctx, scale);

        // 2. Body Layer (STRATEGY PATTERN DELEGATION)
        const renderer = EnemyRenderer.renderers[archetype] || EnemyRenderer.defaultRenderer;
        try {
            renderer.drawBody(ctx, enemy, scale, moveAngle);
        } catch (e) {
            // Fail-safe: fallback to default if custom renderer crashes
            console.error(`Renderer failed for ${archetype}`, e);
            EnemyRenderer.defaultRenderer.drawBody(ctx, enemy, scale, moveAngle);
        }

        // 3. Props Layer
        if (props.length > 0) {
            props.forEach(propId => {
                const propImg = Assets.get(propId);
                if (propImg) {
                    const pSize = 32 * scale;
                    const pHalf = pSize / 2;
                    ctx.drawImage(propImg, -pHalf, -pHalf, pSize, pSize);
                }
            });
        }

        // 3.5. Status Particles Layer
        EnemyRenderer.drawStatusEffects(ctx, enemy);

        // 4. UI Layer (HP Bar)
        EnemyRenderer.drawHealthBar(ctx, enemy, scale);

        ctx.restore();
    }

    private static drawRimLight(ctx: CanvasRenderingContext2D, color: string, scale: number) {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.3;

        const rimSize = (48 * scale) * 1.2;
        ctx.beginPath();
        ctx.arc(0, 0, rimSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    private static drawShadow(ctx: CanvasRenderingContext2D, scale: number) {
        const shadowImg = Assets.get('shadow_small');
        if (shadowImg) {
            const shadowW = 32 * scale;
            const shadowH = 16 * scale;
            ctx.drawImage(shadowImg, -shadowW / 2, -shadowH / 2 + 10 * scale, shadowW, shadowH);
        } else {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            const shadowW = 16 * scale;
            const shadowH = 8 * scale;
            ctx.ellipse(0, 10 * scale, shadowW, shadowH, 0, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    private static drawStatusEffects(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        if (enemy.statuses.some(s => s.type === 'slow')) {
            for (let i = 0; i < 3; i++) {
                const angle = (Date.now() * 0.003) + (i * Math.PI * 2 / 3);
                const orbX = Math.cos(angle) * 20;
                const orbY = Math.sin(angle) * 20;
                ctx.fillStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.arc(orbX, orbY, 3, 0, Math.PI * 2);
                ctx.fill();
                // Inner glow
                ctx.fillStyle = '#e1f5fe';
                ctx.beginPath();
                ctx.arc(orbX, orbY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    private static drawHealthBar(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number) {
        if (enemy.currentHealth < enemy.maxHealth) {
            const barWidth = CONFIG.UI.HP_BAR_WIDTH;
            const barHeight = CONFIG.UI.HP_BAR_HEIGHT;
            const barY = -30 * scale;

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(-barWidth / 2, barY, barWidth, barHeight);

            // Health bar
            const hpPercent = enemy.currentHealth / enemy.maxHealth;
            let hpColor = '#4caf50'; // green
            if (hpPercent < 0.3) hpColor = '#f44336'; // red
            else if (hpPercent < 0.6) hpColor = '#ff9800'; // orange

            ctx.fillStyle = hpColor;
            ctx.fillRect(-barWidth / 2, barY, barWidth * hpPercent, barHeight);
        }
    }
}
</file>

<file path="src/renderers/InkEnemyRenderer.ts">
import { Enemy } from '../Enemy';
import { CONFIG, getEnemyType } from '../Config';
import { InkUtils } from '../graphics/InkUtils';
import { INK_CONFIG } from '../graphics/InkConfig';
import { Assets } from '../Assets';

export class InkEnemyRenderer {
    static draw(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        if (!enemy.isAlive()) return;

        const safeType = enemy.typeId ? enemy.typeId.toLowerCase() : 'grunt';
        const typeConf = getEnemyType(safeType.toUpperCase()) || getEnemyType('GRUNT');

        const scale = typeConf?.scale || 1.0;
        const archetype = typeConf?.archetype || 'SKELETON';
        const baseColor = typeConf?.tint || typeConf?.color || '#000'; // Default ink is black/dark

        ctx.save();
        ctx.translate(enemy.x, enemy.y);

        // 1. Rotation (Face movement)
        const path = enemy.path;
        const pathIndex = enemy.pathIndex;
        if (path && pathIndex < path.length - 1) {
            const next = path[pathIndex];
            const dx = next.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 - enemy.x;
            const dy = next.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 - enemy.y;
            const moveAngle = Math.atan2(dy, dx);
            ctx.rotate(moveAngle + Math.PI / 2);
        }

        // 2. Breathing / Movement Wobble
        const time = Date.now() * 0.005;
        const breathe = 1.0 + Math.sin(time * 2 + parseInt(enemy.id.slice(-3), 36)) * 0.05;
        ctx.scale(scale * breathe, scale * breathe);

        // 3. Draw Body Sketch
        this.drawArchetypeSketch(ctx, archetype, baseColor, time, enemy);

        // 4. Status Effects
        this.drawStatusEffects(ctx, enemy);

        // 5. HP Bar (Ink Style) - Undo rotation first to keep bar horizontal? 
        // Actually, keeping it relative to enemy is fine for now, or we can restore context.
        // Let's restore for HP bar to be always horizontal-ish or relative to screen UP?
        // Standard game renders HP bar passing context. Usually we want HP bar above enemy regardless of rotation.
        ctx.restore();

        // HP Bar needs strictly horizontal alignment usually
        ctx.save();
        ctx.translate(enemy.x, enemy.y); // Translate back without rotation
        this.drawHealthBar(ctx, enemy, scale);
        ctx.restore();
    }

    private static drawArchetypeSketch(ctx: CanvasRenderingContext2D, archetype: string, color: string, time: number, enemy: Enemy) {

        // STYLE: Top-Down Shadow Puppets using Ink Utils

        // Setup style
        if (enemy.hitFlashTimer > 0) {
            ctx.fillStyle = '#ff0000';
            ctx.strokeStyle = '#ff0000';
        } else {
            ctx.fillStyle = '#1a1a1a';
            ctx.strokeStyle = '#1a1a1a';
        }
        ctx.lineWidth = 2;

        if (archetype === 'SKELETON') {
            // Head
            InkUtils.drawWobbleCircle(ctx, 4, 0, 7, time);
            ctx.fill();

            // Shoulders
            InkUtils.drawWobbleLine(ctx, 4, -8, 4, 8, time);

            // Commander Crown
            if (enemy.typeId === 'skeleton_commander') {
                ctx.strokeStyle = '#ffd700'; // Gold
                const crown = [{ x: 0, y: -7 }, { x: 2, y: -12 }, { x: 4, y: -7 }, { x: 6, y: -12 }, { x: 8, y: -7 }];
                InkUtils.drawSketchPoly(ctx, crown, false, time);
                ctx.strokeStyle = enemy.hitFlashTimer > 0 ? '#ff0000' : '#1a1a1a'; // Restore
            }

            // Weapon
            InkUtils.drawWobbleLine(ctx, 4, -8, 20, -10, time);

            // Shield arm
            InkUtils.drawWobbleLine(ctx, 4, 8, 12, 10, time);

        } else if (archetype === 'WOLF' || archetype === 'SCOUT') {
            const body = [
                { x: 20, y: 0 },
                { x: -5, y: 8 },
                { x: -2, y: 0 },
                { x: -5, y: -8 }
            ];

            // Fill
            ctx.beginPath();
            ctx.moveTo(body[0].x, body[0].y);
            body.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.fill();

            // Ink Outline
            InkUtils.drawSketchPoly(ctx, body, true, time);

            // Tail
            const tailWag = Math.sin(time * 20) * 5;
            InkUtils.drawWobbleLine(ctx, -5, 0, -15, tailWag, time);

        } else if (archetype === 'TROLL') {
            // Head
            ctx.beginPath();
            ctx.arc(0, -9, 8, 0, Math.PI * 2);
            ctx.fill();
            InkUtils.drawWobbleCircle(ctx, 0, -9, 8, time);

            // Body
            ctx.beginPath();
            ctx.arc(0, 10, 16, 0, Math.PI * 2);
            ctx.fill();
            InkUtils.drawWobbleCircle(ctx, 0, 10, 16, time + 1);

            // Arms (Thick)
            ctx.lineWidth = 4;
            InkUtils.drawWobbleLine(ctx, -12, 0, -24, 10, time);
            InkUtils.drawWobbleLine(ctx, 12, 0, 24, 10, time + 2);

            // Armored
            if (enemy.id.includes('armored') || enemy.typeId === 'troll_armored') {
                ctx.fillStyle = '#424242';
                ctx.strokeStyle = '#fff';
                const shield = [{ x: 14, y: 0 }, { x: 22, y: 0 }, { x: 22, y: 18 }, { x: 14, y: 18 }];
                ctx.fillRect(14, 0, 8, 18);
                InkUtils.drawSketchPoly(ctx, shield, true, time);
            }

        } else if (archetype === 'SPIDER' || archetype === 'BOSS') {
            // Body
            ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill();
            InkUtils.drawWobbleCircle(ctx, 0, 0, 12, time);

            // Head
            ctx.beginPath(); ctx.arc(0, -12, 6, 0, Math.PI * 2); ctx.fill();
            InkUtils.drawWobbleCircle(ctx, 0, -12, 6, time);

            // Legs
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                const angleL = -Math.PI / 2 - (Math.PI / 6 * i);
                const angleR = -Math.PI / 2 + (Math.PI / 6 * i);
                const len = 28;

                // Draw shaky legs
                const lx = Math.cos(angleL) * len;
                const ly = Math.sin(angleL) * len;
                InkUtils.drawWobbleLine(ctx, -5, 0, lx, ly, time + i);

                const rx = Math.cos(angleR) * len;
                const ry = Math.sin(angleR) * len;
                InkUtils.drawWobbleLine(ctx, 5, 0, rx, ry, time + i + 4);
            }
        }
    }

    private static drawStatusEffects(ctx: CanvasRenderingContext2D, enemy: Enemy) {
        if (enemy.statuses.some(s => s.type === 'slow')) {
            // Ice crystals at feet
            ctx.strokeStyle = CONFIG.AMBIENT.LIGHTING.ICE;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-10, 10); ctx.lineTo(-15, 20);
            ctx.moveTo(10, 10); ctx.lineTo(15, 20);
            ctx.moveTo(0, 15); ctx.lineTo(0, 25);
            ctx.stroke();
        }

        if (enemy.statuses.some(s => s.type === 'burn')) {
            // Smoke rising
            ctx.strokeStyle = CONFIG.AMBIENT.LIGHTING.FIRE;
            ctx.lineWidth = 2;
            const time = Date.now() * 0.005;
            ctx.beginPath();
            InkUtils.drawWobbleLine(ctx, -5, -20, -10, -35, time);
            InkUtils.drawWobbleLine(ctx, 5, -20, 10, -35, time + 1);
            ctx.stroke();
        }
    }

    private static drawHealthBar(ctx: CanvasRenderingContext2D, enemy: Enemy, scale: number) {
        if (enemy.currentHealth < enemy.maxHealth) {
            const barWidth = 30 * scale;
            const barY = -35 * scale;

            // Background line
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(-barWidth / 2, barY);
            ctx.lineTo(barWidth / 2, barY);
            ctx.stroke();

            // Health line
            const pct = enemy.currentHealth / enemy.maxHealth;
            let color = '#4caf50';
            if (pct < 0.3) color = '#f44336';
            else if (pct < 0.6) color = '#ff9800';

            ctx.strokeStyle = color; // Colored ink for HP? Or just black?
            // "Juice" rule: HP should be readable, so color is good.

            ctx.lineWidth = 3;
            ctx.beginPath();
            // Scribbly line for HP
            const endX = -barWidth / 2 + (barWidth * pct);
            ctx.moveTo(-barWidth / 2, barY);
            ctx.lineTo(endX, barY);
            ctx.stroke();
        }
    }
}
</file>

<file path="src/renderers/InkMapRenderer.ts">
import { MapManager } from '../Map';
import { CONFIG } from '../Config';
import { INK_CONFIG } from '../graphics/InkConfig';
import { InkUtils } from '../graphics/InkUtils';
import { PaperTexture } from '../graphics/PaperTexture';
import { InkWatercolor } from '../graphics/InkWatercolor';
import { InkDecorRenderer } from './InkDecorRenderer';

export class InkMapRenderer {
    private static cacheCanvas: HTMLCanvasElement | null = null;
    private static cacheCtx: CanvasRenderingContext2D | null = null;
    private static cachedMapId: string = '';

    /**
     * Draws the map in Ink style. Uses caching to avoid rebuilding the shaky lines every frame.
     */
    static draw(ctx: CanvasRenderingContext2D, map: MapManager) {
        // Init cache if needed
        if (!this.cacheCanvas) {
            this.initCache(map);
            this.redrawCache(map);
        }

        // Draw cached version
        if (this.cacheCanvas) {
            // Draw background (Paper)
            ctx.drawImage(this.cacheCanvas, 0, 0);
        }
    }

    private static initCache(map: MapManager) {
        this.cacheCanvas = document.createElement('canvas');
        this.cacheCanvas.width = map.cols * CONFIG.TILE_SIZE;
        this.cacheCanvas.height = map.rows * CONFIG.TILE_SIZE;
        this.cacheCtx = this.cacheCanvas.getContext('2d');
    }

    /**
     * Generates the static ink map (heavy operation, runs once)
     */
    private static redrawCache(map: MapManager) {
        if (!this.cacheCtx || !this.cacheCanvas) return;

        const ctx = this.cacheCtx;
        const width = this.cacheCanvas.width;
        const height = this.cacheCanvas.height;
        const TS = CONFIG.TILE_SIZE;

        // 1. Paper Background (Procedural Texture)
        const paperPattern = PaperTexture.generate(width, height);
        ctx.drawImage(paperPattern, 0, 0);

        // 2. Watercolor Biomes (Ground)
        // We iterate tiles and apply washes.
        // To avoid excessive overlap darkness, we could group tiles, but for now tile-by-tile is fine for "chaotic" organic look.

        for (let y = 0; y < map.rows; y++) {
            for (let x = 0; x < map.cols; x++) {
                if (map.tiles[y][x] !== 1) { // Ground
                    const seed = x * 101 + y * 13;

                    // Wash effect (Greenish for grass)
                    InkWatercolor.drawRectWash(
                        ctx,
                        x * TS, y * TS, TS, TS,
                        INK_CONFIG.PALETTE.WASH_GREEN,
                        seed
                    );

                    // Details
                    if ((seed % 15) === 0) {
                        this.drawGroundDetail(ctx, x * TS, y * TS, TS, seed);
                    }
                }
            }
        }

        // 3. Grid (Very faint pencil lines)
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(45, 27, 14, 0.03)'; // Even fainter

        for (let x = 0; x <= map.cols; x++) {
            InkUtils.drawWobbleLine(ctx, x * TS, 0, x * TS, height);
        }
        for (let y = 0; y <= map.rows; y++) {
            InkUtils.drawWobbleLine(ctx, 0, y * TS, width, y * TS);
        }

        // 4. Path (Thick ink outlines + Coffee Wash)
        ctx.lineWidth = 2;
        ctx.strokeStyle = INK_CONFIG.PALETTE.INK;

        for (let y = 0; y < map.rows; y++) {
            for (let x = 0; x < map.cols; x++) {
                if (map.tiles[y][x] === 1) { // PATH
                    const px = x * TS;
                    const py = y * TS;
                    const seed = x * 59 + y * 97;

                    // Coffee Wash for path (Brownish/Sepia)
                    // We use a custom color derived from shadow/ink for the 'beaten path' look
                    InkWatercolor.drawRectWash(
                        ctx,
                        px, py, TS, TS,
                        '#8d6e63', // Light Brown 
                        seed
                    );

                    // Borders
                    const top = y > 0 && map.tiles[y - 1][x] !== 1;
                    const bottom = y < map.rows - 1 && map.tiles[y + 1][x] !== 1;
                    const left = x > 0 && map.tiles[y][x - 1] !== 1;
                    const right = x < map.cols - 1 && map.tiles[y][x + 1] !== 1;

                    ctx.beginPath();
                    if (top) InkUtils.drawWobbleLine(ctx, px, py, px + TS, py);
                    if (bottom) InkUtils.drawWobbleLine(ctx, px, py + TS, px + TS, py + TS);
                    if (left) InkUtils.drawWobbleLine(ctx, px, py, px, py + TS);
                    if (right) InkUtils.drawWobbleLine(ctx, px + TS, py, px + TS, py + TS);
                    ctx.stroke();
                }
            }
        }

        // 5. Decorations
        if (map.objects) {
            for (const obj of map.objects) {
                const px = obj.x * TS;
                const py = obj.y * TS;
                InkDecorRenderer.draw(ctx, obj.type, px, py, obj.size || 1);
            }
        }

        // 6. Start/End
        if (map.waypoints.length > 0) {
            const start = map.waypoints[0];
            const end = map.waypoints[map.waypoints.length - 1];

            ctx.font = '30px MedievalSharp, cursive';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = INK_CONFIG.PALETTE.INK;
            ctx.fillText('‚ö°', start.x * TS + TS / 2, start.y * TS + TS / 2);
            ctx.fillText('X', end.x * TS + TS / 2, end.y * TS + TS / 2);
        }

        // 7. Torches
        ctx.fillStyle = '#5d4037';
        for (let y = 0; y < map.rows; y++) {
            for (let x = 0; x < map.cols; x++) {
                if (map.tiles[y][x] === 1) {
                    if (y > 0 && map.tiles[y - 1][x] !== 1 && (x + y * 7) % 4 === 0) {
                        ctx.fillRect(x * TS + TS / 2 - 2, y * TS, 4, 8);
                        ctx.beginPath();
                        ctx.strokeStyle = '#e65100';
                        ctx.lineWidth = 1;
                        ctx.arc(x * TS + TS / 2, y * TS + 2, 3, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            }
        }
    }

    private static drawGroundDetail(ctx: CanvasRenderingContext2D, x: number, y: number, size: number, seed: number) {
        const cx = x + size / 2 + ((seed % 10) - 5);
        const cy = y + size / 2 + ((seed % 11) - 5);

        ctx.beginPath();
        if ((seed % 2) === 0) {
            // Grass Tuft (v shape)
            ctx.moveTo(cx - 2, cy);
            ctx.lineTo(cx, cy - 3);
            ctx.lineTo(cx + 2, cy);
        } else {
            // Pebble (small circle)
            ctx.arc(cx, cy, 1.5, 0, Math.PI * 2);
        }
        ctx.stroke();
    }

    /**
     * Force a cache rebuild (e.g. on resize or level load)
     */
    static invalidateCache() {
        this.cacheCanvas = null;
        this.cacheCtx = null;
    }
}
</file>

<file path="src/renderers/InkTowerRenderer.ts">
import { Tower } from '../Tower';
import { CONFIG } from '../Config';
import { InkUtils } from '../graphics/InkUtils';
import { INK_CONFIG } from '../graphics/InkConfig';
import { InkHatching } from '../graphics/InkHatching';
import { VISUALS } from '../VisualConfig';

/**
 * Renders towers as if they were hand-drawn sketches on the map.
 * Supports all gameplay feedback: Building state, Recoil, Heat, Rotation.
 */
export class InkTowerRenderer {

    static draw(ctx: CanvasRenderingContext2D, tower: Tower) {
        const size = CONFIG.TILE_SIZE;
        const drawX = tower.col * size;
        const drawY = tower.row * size;

        if (tower.isBuilding) {
            this.drawBuildingState(ctx, tower, drawX, drawY, size);
        } else {
            this.drawActiveState(ctx, tower, size);
        }
    }

    private static drawBuildingState(ctx: CanvasRenderingContext2D, tower: Tower, x: number, y: number, size: number) {
        const pct = tower.buildProgress / tower.maxBuildProgress;
        const half = size / 2;
        const centerX = x + half;
        const centerY = y + half;

        // Ink fades in
        ctx.save();
        ctx.globalAlpha = pct;

        // Draw Construction Circle (Rough Sketch)
        ctx.strokeStyle = INK_CONFIG.PALETTE.INK;
        ctx.lineWidth = 1;

        // Draw multiple faint circles to look like a draft
        InkUtils.drawWobbleCircle(ctx, centerX, centerY, size * 0.3, 0);
        if (pct > 0.5) InkUtils.drawWobbleCircle(ctx, centerX, centerY, size * 0.35, 1);

        // Progress Bar (Ink Style)
        const barW = size - 16;
        const barH = 4;
        const barX = x + 8;
        const barY = y + size - 12;

        // Outline
        ctx.strokeStyle = '#5d4037';
        ctx.strokeRect(barX, barY, barW, barH);

        // Fill (Scribble)
        const fillW = barW * pct;
        if (fillW > 2) {
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(barX, barY, fillW, barH);
        }

        ctx.restore();
    }

    private static drawActiveState(ctx: CanvasRenderingContext2D, tower: Tower, size: number) {
        const half = size / 2;

        // 0. Drop Shadow (Slanted Ink Smudge)
        ctx.save();
        const lightAngle = VISUALS.LIGHTING.GLOBAL_LIGHT_ANGLE;
        const shadowDist = 8;
        // Shadow is offset opposite to light
        const sx = tower.x + size / 2 + Math.cos(lightAngle + Math.PI) * shadowDist;
        const sy = tower.y + size / 2 + Math.sin(lightAngle + Math.PI) * shadowDist;

        ctx.translate(sx, sy);
        ctx.rotate(lightAngle); // Rotate to align with light direction
        ctx.fillStyle = 'rgba(45, 27, 14, 0.15)'; // Very faint ink wash

        ctx.beginPath();
        // Elongated irregular shadow
        ctx.ellipse(0, 0, size * 0.4, size * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Inner core of shadow (darker)
        ctx.fillStyle = 'rgba(45, 27, 14, 0.15)';
        ctx.beginPath();
        ctx.ellipse(-2, 0, size * 0.25, size * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // 1. Base (Static Charcoal Sketch)
        this.drawBase(ctx, tower.x, tower.y, size);

        // 2. Turret (Rotated)
        ctx.save();
        ctx.translate(tower.x, tower.y);
        ctx.rotate(tower.angle);

        // Recoil
        if (tower.recoilFrames > 0) {
            const recoil = Math.sin(tower.recoilFrames * 0.5) * tower.recoilIntensity;
            ctx.translate(0, recoil);
            tower.recoilFrames--;
        }

        // Determine style from cards
        const mainCard = tower.cards[0];
        const type = mainCard ? mainCard.type.id : 'standard';

        // Draw the specific turret sketch
        this.drawTurretSketch(ctx, type, size);

        // Modules (Attachments)
        this.drawModules(ctx, tower);

        // Sniper Laser
        if (type === 'sniper') {
            this.drawLaserSight(ctx, tower);
        }

        ctx.restore();

        // 3. Status / Heat (Unrotated)
        if (type === 'minigun' && tower.spinupFrames > 0) {
            this.drawHeatEffects(ctx, tower);
        }

        // 4. Level Visuals
        const maxLevel = tower.cards.length > 0 ? Math.max(...tower.cards.map(c => c.level)) : 1;
        if (maxLevel > 1) {
            this.drawLevelVisuals(ctx, tower, maxLevel);
        }
    }

    private static drawBase(ctx: CanvasRenderingContext2D, x: number, y: number, size: number) {
        // Base Outline
        ctx.strokeStyle = 'rgba(45, 27, 14, 0.4)'; // Faint ink
        ctx.lineWidth = 2;
        const radius = size * 0.35;
        InkUtils.drawWobbleCircle(ctx, x, y, radius, 0); // Inner ring

        // Dynamic Hatching (Volume)
        // Assuming global light is roughly Top-Left (3/4 PI)
        const lightAngle = Math.PI * 0.75;

        const hatching = InkHatching.getCircularHatching(radius, lightAngle);
        ctx.drawImage(hatching, x - radius, y - radius);
    }

    private static drawTurretSketch(ctx: CanvasRenderingContext2D, type: string, size: number) {
        const time = Date.now() * 0.002;
        ctx.strokeStyle = INK_CONFIG.PALETTE.INK;
        ctx.fillStyle = '#fff'; // Paper fill for body
        ctx.lineWidth = 1.5;

        // STYLE: Da Vinci Blueprint
        // Geometric shapes, construction lines, measurement ticks.

        if (type === 'fire') {
            // "Mortar" schematic
            // Main circle
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.stroke();

            // Inner circle (bore)
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.stroke();

            // Nozzle/Chute (Trapezoid)
            ctx.beginPath();
            ctx.moveTo(0, -6);
            ctx.lineTo(8, -8); // Top right
            ctx.lineTo(8, 8);  // Bot right
            ctx.lineTo(0, 6);
            ctx.stroke();

            // Construction marks
            this.drawMeasureTick(ctx, 0, -12, 0, 12); // Vertical axis

        } else if (type === 'ice') {
            // "Prism" schematic
            // Rhombus shape
            ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.lineTo(0, 8);
            ctx.lineTo(-12, 0);
            ctx.lineTo(0, -8);
            ctx.closePath();
            ctx.stroke();

            // Inner cross (Refraction lines)
            ctx.setLineDash([2, 3]);
            ctx.beginPath();
            ctx.moveTo(12, 0); ctx.lineTo(-12, 0);
            ctx.moveTo(0, -8); ctx.lineTo(0, 8);
            ctx.stroke();
            ctx.setLineDash([]);

        } else if (type === 'sniper') {
            // "Ballista/Long Gun" schematic
            // Long barrel rectangle
            ctx.strokeRect(-4, -4, 30, 8);

            // Scope circle
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.stroke();

            // Crosshair in scope
            ctx.beginPath();
            ctx.moveTo(0, -4); ctx.lineTo(0, 4);
            ctx.moveTo(-4, 0); ctx.lineTo(4, 0);
            ctx.stroke();

        } else if (type === 'minigun') {
            // "Gatling" schematic
            // Rotary circle block
            ctx.strokeRect(-6, -8, 12, 16); // Body

            // Barrels (3 lines)
            ctx.beginPath();
            ctx.moveTo(6, -5); ctx.lineTo(20, -5);
            ctx.moveTo(6, 0); ctx.lineTo(22, 0);
            ctx.moveTo(6, 5); ctx.lineTo(20, 5);
            ctx.stroke();

            // Gear teeth hint on body
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.stroke();

        } else if (type === 'multi') {
            // "Tri-shot" schematic
            // Triangle array
            ctx.beginPath();
            ctx.moveTo(10, 0);
            ctx.lineTo(-5, 8);
            ctx.lineTo(-5, -8);
            ctx.closePath();
            ctx.stroke();

            // 3 small circles at corners
            InkUtils.drawWobbleCircle(ctx, 10, 0, 2, 0);
            InkUtils.drawWobbleCircle(ctx, -5, 8, 2, 0);
            InkUtils.drawWobbleCircle(ctx, -5, -8, 2, 0);

        } else {
            // Standard Turret
            ctx.strokeRect(-8, -8, 16, 16);
            // Barrel
            ctx.strokeRect(8, -4, 12, 8);
            // Center rivet
            ctx.beginPath();
            ctx.arc(0, 0, 2, 0, Math.PI * 2);
            ctx.stroke();
        }
    }

    private static drawMeasureTick(ctx: CanvasRenderingContext2D, x1: number, y1: number, x2: number, y2: number) {
        ctx.save();
        ctx.strokeStyle = 'rgba(45, 27, 14, 0.4)'; // Faint ink
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 2]);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
    }

    private static drawModules(ctx: CanvasRenderingContext2D, tower: Tower) {
        tower.cards.forEach((card, index) => {
            if (index === 0) return; // Main card handled by turret sketch

            let ox = 0, oy = 0;
            // Variant 1: Distinct Nodes
            if (index === 1) { ox = -8; oy = -16; } // Top-Left
            else if (index === 2) { ox = -8; oy = 16; } // Bot-Left
            else { ox = -20; oy = 0; } // Back

            ctx.save();
            ctx.translate(ox, oy);

            // Connector line from center
            ctx.save();
            ctx.strokeStyle = INK_CONFIG.PALETTE.INK;
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Draw line back to 0,0 (relative to translation this is -ox, -oy)
            // But we are in turret local space. 
            // Turret center is at 0,0 relative to parent... wait.
            // drawModules is called inside context where 0,0 is Turret Center.
            // So we draw line from (0,0) to (-ox, -oy) ? No, we are translated to module center.
            // So we draw line to (-ox, -oy) which is the turret center.
            ctx.moveTo(0, 0);
            ctx.lineTo(-ox * 0.8, -oy * 0.8); // Connect almost to center
            ctx.stroke();
            ctx.restore();

            // Module Node (Gear / Small Circle)
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = INK_CONFIG.PALETTE.INK;
            ctx.lineWidth = 1.5;

            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Icon hint (Geometric symbol based on type)
            ctx.fillStyle = card.type.color;
            ctx.beginPath();
            if (card.type.id === 'damage') ctx.rect(-2, -2, 4, 4); // Square
            else ctx.arc(0, 0, 2, 0, Math.PI * 2); // Dot
            ctx.fill();

            ctx.restore();
        });
    }

    private static drawLaserSight(ctx: CanvasRenderingContext2D, tower: Tower) {
        const stats = tower.getStats();
        ctx.strokeStyle = 'rgba(200, 0, 0, 0.3)'; // Very faint red ink
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(35, 0); // Start after barrel
        ctx.lineTo(stats.range, 0);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    private static drawHeatEffects(ctx: CanvasRenderingContext2D, tower: Tower) {
        // Heat Haze (Wavy lines rising)
        const time = Date.now() * 0.005;
        const x = tower.x;
        const y = tower.y - 20;

        ctx.save();
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 1;

        for (let i = 0; i < 3; i++) {
            const offset = (Math.sin(time + i) * 10);
            const h = 20 + Math.random() * 10;
            ctx.beginPath();
            ctx.moveTo(x + offset, y);
            ctx.quadraticCurveTo(x + offset + 5, y - h / 2, x + offset, y - h);
            ctx.stroke();
        }
        ctx.restore();
    }

    private static drawLevelVisuals(ctx: CanvasRenderingContext2D, tower: Tower, level: number) {
        if (level >= 2) {
            // Gold Aura Ring
            ctx.save();
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            InkUtils.drawWobbleCircle(ctx, tower.x, tower.y, 25, Date.now() * 0.001);

            if (level >= 3) {
                // Double Ring
                InkUtils.drawWobbleCircle(ctx, tower.x, tower.y, 28, -Date.now() * 0.002);
            }
            ctx.restore();
        }

        // Level Number text
        ctx.fillStyle = INK_CONFIG.PALETTE.INK;
        ctx.font = '12px Courier New';
        ctx.fillText(`LVL ${level}`, tower.x + 15, tower.y - 15);
    }
}
</file>

<file path="src/Scene.ts">
export interface Scene {
    // –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏ –Ω–∞ —ç—Ç—É —Å—Ü–µ–Ω—É
    onEnter(): void;

    // –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —É—Ö–æ–¥–µ —Å–æ —Å—Ü–µ–Ω—ã
    onExit(): void;

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–æ–≥–∏–∫–∏ (60 —Ä–∞–∑ –≤ —Å–µ–∫)
    update(): void;

    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
    draw(ctx: CanvasRenderingContext2D): void;
}
</file>

<file path="src/scenes/GameState.ts">
import { CONFIG } from '../Config';
import { Enemy } from '../Enemy';
import { Tower } from '../Tower';
import { Projectile } from '../Projectile';
import { ObjectPool } from '../Utils';
import { EventBus, Events } from '../EventBus';

/**
 * Manages game state (money, lives, wave, pause) and provides state mutation methods.
 * Emits events when state changes occur.
 */
export class GameState {
    // Core state
    public wave: number = 0;
    public lives: number = CONFIG.PLAYER.START_LIVES;
    public money: number = CONFIG.PLAYER.START_MONEY;
    public paused: boolean = false;
    public isRunning: boolean = true;
    public timeScale: number = 1.0;

    // Entity collections
    public enemies: Enemy[] = [];
    public towers: Tower[] = [];
    public projectiles: Projectile[] = [];

    // Object pools
    public projectilePool: ObjectPool<Projectile>;
    public enemyPool: ObjectPool<Enemy>;

    // Selection state
    public selectedTower: Tower | null = null;

    // Animation state
    public frames: number = 0;
    public shakeTimer: number = 0;
    public shakeIntensity: number = 0;

    private eventBus: EventBus = EventBus.getInstance();

    constructor() {
        this.projectilePool = new ObjectPool(() => new Projectile());
        this.enemyPool = new ObjectPool(() => new Enemy());
    }

    // === Money Management ===
    public addMoney(amount: number): void {
        this.money += amount;
        this.eventBus.emit(Events.MONEY_CHANGED, this.money);
    }

    public spendMoney(amount: number): boolean {
        if (this.money >= amount) {
            this.money -= amount;
            this.eventBus.emit(Events.MONEY_CHANGED, this.money);
            return true;
        }
        return false;
    }

    // === Lives Management ===
    public loseLife(amount: number = 1, effects?: any): void {
        this.lives -= amount;
        this.eventBus.emit(Events.LIVES_CHANGED, this.lives);

        // Red screen flash on damage
        if (effects) {
            effects.add({
                type: 'screen_flash',
                x: 0,
                y: 0,
                life: 15,
                flashColor: 'rgba(255, 0, 0, ',
            });
        }

        if (this.lives <= 0) {
            this.eventBus.emit(Events.GAME_OVER, this.wave);
            this.isRunning = false;
        }
    }

    // === Wave Management ===
    public incrementWave(): void {
        this.wave++;
    }

    // === Pause Management ===
    public togglePause(): void {
        this.paused = !this.paused;
        this.eventBus.emit(Events.TOGGLE_PAUSE, this.paused);
    }

    // === Screen Shake ===
    public triggerShake(duration: number, intensity: number): void {
        this.shakeTimer = duration;
        this.shakeIntensity = intensity;
    }

    public updateShake(): void {
        if (this.shakeTimer > 0) {
            this.shakeTimer--;
        }
    }

    // === Tower Selection ===
    public selectTower(tower: Tower | null): void {
        this.selectedTower = tower;
    }

    // === Time Scale ===
    public setTimeScale(scale: number): void {
        this.timeScale = Math.max(1.0, Math.min(scale, 2.0)); // Clamp between 1x and 2x
    }

    public toggleTimeScale(): void {
        this.timeScale = (this.timeScale === 1.0) ? 2.0 : 1.0;
    }

    // === Game Over ===
    public endGame(): void {
        this.isRunning = false;
    }

    // === Reset (for restart) ===
    public reset(): void {
        this.wave = 0;
        this.lives = CONFIG.PLAYER.START_LIVES;
        this.money = CONFIG.PLAYER.START_MONEY;
        this.paused = false;
        this.isRunning = true;
        this.timeScale = 1.0;
        this.frames = 0;
        this.shakeTimer = 0;
        this.shakeIntensity = 0;
        this.selectedTower = null;

        // Clear entities
        this.enemies = [];
        this.towers = [];
        this.projectiles = [];
    }
}
</file>

<file path="src/systems/AtmosphereSystem.ts">
import { DayNightCycle } from '../DayNightCycle';

/**
 * Configurable atmosphere parameters - easily tunable
 */
interface IAtmosphereConfig {
    // Sunlight settings
    sunRayCount: number;
    sunRayOpacity: number;
    sunRayWidth: number;
    sunRayAngle: number; // degrees from horizontal

    // Cloud shadow settings
    cloudShadowCount: number;
    cloudShadowSpeed: number; // pixels per second in world space
    cloudShadowOpacity: number;
    cloudShadowMinSize: number;
    cloudShadowMaxSize: number;
    cloudShadowDirection: number; // angle in degrees (0 = right, 90 = down)

    // Moonlight settings
    moonlightOpacity: number;
    moonlightColor: string;

    // Color grading
    dayFilter: string;
    nightFilter: string;

    // Stars settings
    enableStars: boolean;
    starCount: number;
    starOpacity: number;
}

interface CloudShadow {
    x: number;        // world X coordinate
    y: number;        // world Y coordinate  
    width: number;    // fixed width
    height: number;   // fixed height
    speed: number;    // individual speed multiplier (0.8 - 1.2)
    vx: number;       // velocity X (calculated from direction)
    vy: number;       // velocity Y (calculated from direction)
}

export class AtmosphereSystem {
    private dayNightCycle: DayNightCycle;
    private config: IAtmosphereConfig;
    private clouds: CloudShadow[] = [];
    private starPositions: { x: number; y: number }[] = [];
    private worldWidth: number = 1280; // will be updated via setWorldSize
    private worldHeight: number = 800;

    constructor(dayNightCycle: DayNightCycle, config?: Partial<IAtmosphereConfig>) {
        this.dayNightCycle = dayNightCycle;

        // Default config - easily modifiable
        this.config = {
            // Sunlight
            sunRayCount: 5,
            sunRayOpacity: 0.08,
            sunRayWidth: 120,
            sunRayAngle: 30,

            // Cloud shadows
            cloudShadowCount: 8,
            cloudShadowSpeed: 20, // pixels/second
            cloudShadowOpacity: 0.06, // Reduced from 0.12 for brighter atmosphere
            cloudShadowMinSize: 180,
            cloudShadowMaxSize: 320,
            cloudShadowDirection: 45, // diagonal movement (top-left to bottom-right)

            // Moonlight
            moonlightOpacity: 0.15,
            moonlightColor: '#4fc3f7',

            // Color grading
            dayFilter: 'sepia(0.05) saturate(1.1)',
            nightFilter: 'hue-rotate(10deg) saturate(0.9)',

            // Stars
            enableStars: true,
            starCount: 50,
            starOpacity: 0.8,

            ...config // Override with provided config
        };

        this.initializeCloudShadows();
        if (this.config.enableStars) {
            this.initializeStars();
        }
    }

    /**
     * Set world dimensions for proper cloud positioning
     * Should be called once when map is loaded
     */
    public setWorldSize(width: number, height: number): void {
        this.worldWidth = width;
        this.worldHeight = height;
        // Re-initialize clouds with new world bounds
        this.clouds = [];
        this.initializeCloudShadows();
    }

    private initializeCloudShadows(): void {
        const directionRad = (this.config.cloudShadowDirection * Math.PI) / 180;

        for (let i = 0; i < this.config.cloudShadowCount; i++) {
            // Random position across entire world
            const x = Math.random() * this.worldWidth;
            const y = Math.random() * this.worldHeight;

            // Random size between min and max
            const sizeRange = this.config.cloudShadowMaxSize - this.config.cloudShadowMinSize;
            const width = this.config.cloudShadowMinSize + Math.random() * sizeRange;
            const height = width * (0.5 + Math.random() * 0.3); // height is 50-80% of width

            // Slight speed variation for more organic movement
            const speedMultiplier = 0.8 + Math.random() * 0.4; // 0.8 to 1.2

            // Calculate velocity from direction
            const speed = this.config.cloudShadowSpeed * speedMultiplier;
            const vx = Math.cos(directionRad) * speed;
            const vy = Math.sin(directionRad) * speed;

            this.clouds.push({ x, y, width, height, speed: speedMultiplier, vx, vy });
        }
    }

    private initializeStars(): void {
        // Random star positions (fixed, not moving)
        for (let i = 0; i < this.config.starCount; i++) {
            this.starPositions.push({
                x: Math.random(),
                y: Math.random() * 0.6 // Stars in upper 60% of screen
            });
        }
    }

    public update(deltaTime: number): void {
        // Update cloud positions in world space
        this.clouds.forEach(cloud => {
            cloud.x += cloud.vx * deltaTime;
            cloud.y += cloud.vy * deltaTime;

            // Wrap around when cloud exits world bounds
            // Add padding to prevent pop-in
            const padding = Math.max(cloud.width, cloud.height);

            if (cloud.x > this.worldWidth + padding) {
                cloud.x = -padding;
            } else if (cloud.x < -padding) {
                cloud.x = this.worldWidth + padding;
            }

            if (cloud.y > this.worldHeight + padding) {
                cloud.y = -padding;
            } else if (cloud.y < -padding) {
                cloud.y = this.worldHeight + padding;
            }
        });
    }

    public draw(ctx: CanvasRenderingContext2D): void {
        const time = this.dayNightCycle.getTimeOfDay(); // 0 (dawn) to 1 (night)
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;

        // Save original state
        ctx.save();

        // Smooth transition calculation
        // 0.0-0.3: Dawn (transitioning to day)
        // 0.3-0.5: Full day
        // 0.5-0.7: Dusk (transitioning to night)
        // 0.7-1.0: Full night

        let dayIntensity = 0;
        let nightIntensity = 0;

        if (time < 0.3) {
            // Dawn
            dayIntensity = time / 0.3; // 0 to 1
        } else if (time < 0.5) {
            // Day
            dayIntensity = 1;
        } else if (time < 0.7) {
            // Dusk
            dayIntensity = 1 - ((time - 0.5) / 0.2); // 1 to 0
            nightIntensity = (time - 0.5) / 0.2; // 0 to 1
        } else {
            // Night
            nightIntensity = 1;
        }

        // Draw clouds (always visible, independent of day/night blend)
        // We draw them here to ensure they are consistent across transition
        this.drawCloudShadows(ctx, 1.0); // Always draw clouds

        // Draw both day and night effects with smooth blending
        if (dayIntensity > 0) {
            this.drawDayEffects(ctx, canvasWidth, canvasHeight, dayIntensity);
        }
        if (nightIntensity > 0) {
            this.drawNightEffects(ctx, canvasWidth, canvasHeight, nightIntensity);
        }

        ctx.restore();
    }

    private drawDayEffects(ctx: CanvasRenderingContext2D, width: number, height: number, intensity: number): void {
        // 1. Sunlight rays (diagonal lines)
        ctx.save();
        ctx.globalAlpha = this.config.sunRayOpacity * intensity;
        const rayAngleRad = (this.config.sunRayAngle * Math.PI) / 180;

        for (let i = 0; i < this.config.sunRayCount; i++) {
            const spacing = width / (this.config.sunRayCount + 1);
            const startX = spacing * (i + 1);
            const gradient = ctx.createLinearGradient(
                startX, 0,
                startX + Math.cos(rayAngleRad) * height,
                height
            );
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(startX - this.config.sunRayWidth / 2, 0, this.config.sunRayWidth, height);
        }
        ctx.restore();

        // 3. Subtle warm tint (removed harsh overlay)
        // Ambient lighting already handles color temperature
        ctx.restore();
    }

    private drawCloudShadows(ctx: CanvasRenderingContext2D, intensity: number): void {
        ctx.save();
        // Base opacity for clouds
        // At night, maybe slightly less opaque? Or darker? 
        // For now constant opacity from config
        ctx.globalAlpha = this.config.cloudShadowOpacity * intensity;

        this.clouds.forEach(cloud => {
            // Create gradient for soft edges
            const gradient = ctx.createRadialGradient(
                cloud.x, cloud.y, 0,
                cloud.x, cloud.y, cloud.width * 0.6
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.2)');   // Reduced from 0.4
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.1)'); // Reduced from 0.2
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;

            // Draw organic cloud shape (multiple overlapping ellipses)
            ctx.beginPath();
            ctx.ellipse(
                cloud.x,
                cloud.y,
                cloud.width * 0.5,
                cloud.height * 0.5,
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // Add secondary ellipse for organic shape
            ctx.beginPath();
            ctx.ellipse(
                cloud.x + cloud.width * 0.2,
                cloud.y - cloud.height * 0.15,
                cloud.width * 0.35,
                cloud.height * 0.4,
                Math.PI * 0.3, 0, Math.PI * 2
            );
            ctx.fill();

            // Add third ellipse
            ctx.beginPath();
            ctx.ellipse(
                cloud.x - cloud.width * 0.15,
                cloud.y + cloud.height * 0.1,
                cloud.width * 0.3,
                cloud.height * 0.35,
                -Math.PI * 0.25, 0, Math.PI * 2
            );
            ctx.fill();
        });
        ctx.restore();
    }

    private drawNightEffects(ctx: CanvasRenderingContext2D, width: number, height: number, intensity: number): void {
        // 1. Moonlight (soft blue glow from top)
        ctx.save();
        ctx.globalAlpha = this.config.moonlightOpacity * intensity;
        const moonGradient = ctx.createLinearGradient(0, 0, 0, height / 2);
        moonGradient.addColorStop(0, this.config.moonlightColor);
        moonGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
        ctx.fillStyle = moonGradient;
        ctx.fillRect(0, 0, width, height / 2);
        ctx.restore();

        // 2. Stars
        if (this.config.enableStars) {
            ctx.save();
            ctx.globalAlpha = this.config.starOpacity * intensity;
            ctx.fillStyle = '#ffffff';

            this.starPositions.forEach(star => {
                const x = star.x * width;
                const y = star.y * height;
                const radius = 0.5 + Math.random();

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Twinkle effect (subtle)
                if (Math.random() > 0.95) {
                    ctx.globalAlpha = this.config.starOpacity * intensity * 0.5;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.restore();
        }

        // 3. Subtle cool tint (removed harsh overlay)
        // Ambient lighting already handles night coloring
        ctx.restore();
    }

    /**
     * Update configuration at runtime
     */
    public updateConfig(newConfig: Partial<IAtmosphereConfig>): void {
        this.config = { ...this.config, ...newConfig };

        // Re-initialize if needed
        if (newConfig.cloudShadowCount !== undefined ||
            newConfig.cloudShadowDirection !== undefined ||
            newConfig.cloudShadowMinSize !== undefined ||
            newConfig.cloudShadowMaxSize !== undefined) {
            this.clouds = [];
            this.initializeCloudShadows();
        }
        if (newConfig.starCount !== undefined || newConfig.enableStars !== undefined) {
            this.starPositions = [];
            if (this.config.enableStars) {
                this.initializeStars();
            }
        }
    }

    public getConfig(): IAtmosphereConfig {
        return { ...this.config };
    }
}
</file>

<file path="src/ui/PauseMenu.ts">
import { IGameScene } from '../scenes/IGameScene';
import { UIUtils } from '../UIUtils';
import { SoundManager, SoundPriority } from '../SoundManager';

export class PauseMenu {
    private scene: IGameScene;
    private elUiLayer: HTMLElement;
    private elPauseMenu: HTMLElement | null = null;

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.elUiLayer = document.getElementById('ui-layer')!;
        this.init();
    }

    private init() {
        // ESCAPE TO PAUSE - bind listener
        this.boundKeyHandler = this.handleKeyDown.bind(this);
        window.addEventListener('keydown', this.boundKeyHandler);

        // Create menu overlay
        this.createOverlay();
    }

    private boundKeyHandler: ((e: KeyboardEvent) => void) | null = null;

    private handleKeyDown(e: KeyboardEvent) {
        if (e.code === 'Escape') {
            this.scene.togglePause();
        }
    }

    public destroy() {
        if (this.boundKeyHandler) {
            window.removeEventListener('keydown', this.boundKeyHandler);
            this.boundKeyHandler = null;
        }
        if (this.elPauseMenu) {
            this.elPauseMenu.remove();
            this.elPauseMenu = null;
        }
    }

    private createOverlay() {
        if (!document.getElementById('pause-menu')) {
            const menu = UIUtils.createOverlay('pause-menu');
            this.elPauseMenu = menu;
            this.renderMainMenu(menu);
        } else {
            this.elPauseMenu = document.getElementById('pause-menu');
        }
    }

    private renderMainMenu(menu: HTMLElement) {
        menu.innerHTML = ''; // Clear
        const content = document.createElement('div');
        Object.assign(content.style, {
            background: '#222',
            padding: '40px',
            borderRadius: '8px',
            border: '2px solid #555',
            textAlign: 'center',
            minWidth: '300px'
        });

        content.innerHTML = `
            <h1 style="margin-top: 0; color: #ffd700; text-transform: uppercase; letter-spacing: 2px;">Paused</h1>
            <p style="color: #aaa; font-size: 14px; margin-top: -10px;">Press ESC to resume</p>
        `;

        // Continue
        UIUtils.createButton(content, 'Continue', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.scene.togglePause();
        }, { background: '#4caf50', width: '100%', padding: '12px', fontSize: '16px', border: 'none' });

        content.appendChild(document.createElement('br'));

        // Settings
        UIUtils.createButton(content, 'Settings', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.renderSettings(menu);
        }, { background: '#2196f3', width: '100%', padding: '12px', fontSize: '16px', border: 'none', marginTop: '10px' });

        // Exit
        UIUtils.createButton(content, 'Exit to Menu', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.scene.togglePause();
            this.scene.game.toMenu();
        }, { background: '#f44336', width: '100%', padding: '12px', fontSize: '16px', border: 'none', marginTop: '10px' });

        menu.appendChild(content);
    }

    private renderSettings(menu: HTMLElement) {
        menu.innerHTML = '';
        const content = document.createElement('div');
        Object.assign(content.style, {
            background: '#222',
            padding: '40px',
            borderRadius: '8px',
            border: '2px solid #555',
            textAlign: 'center',
            minWidth: '300px'
        });

        content.innerHTML = `<h2 style="color:#ffd700; margin:0 0 20px 0;">Audio Settings</h2>`;

        const addSlider = (label: string, val: number, onChange: (v: number) => void) => {
            const row = document.createElement('div');
            row.style.marginBottom = '10px';
            row.style.textAlign = 'left';
            row.innerHTML = `<label style="display:inline-block; width:60px;">${label}</label>`;

            const input = document.createElement('input');
            input.type = 'range';
            input.min = '0';
            input.max = '1';
            input.step = '0.1';
            input.value = val.toString();
            input.oninput = (e) => onChange(parseFloat((e.target as HTMLInputElement).value));

            row.appendChild(input);
            content.appendChild(row);
        };

        addSlider('Master', SoundManager.MASTER_VOLUME, (v) => SoundManager.setVolume(v));
        addSlider('SFX', SoundManager.SFX_VOLUME, (v) => SoundManager.SFX_VOLUME = v);
        addSlider('Music', SoundManager.MUSIC_VOLUME, (v) => SoundManager.MUSIC_VOLUME = v);

        // Back button
        UIUtils.createButton(content, 'Back', () => {
            SoundManager.play('click', SoundPriority.HIGH);
            this.renderMainMenu(menu);
        }, { background: '#555', marginTop: '20px', width: '100%', padding: '10px', border: 'none' });

        menu.appendChild(content);
    }

    public update(paused: boolean) {
        if (this.elPauseMenu) {
            this.elPauseMenu.style.display = paused ? 'flex' : 'none';
        }
    }
}
</file>

<file path="__tests__/WaveManager.test.ts">
import { WaveManager } from '../src/WaveManager';
import { GameScene } from '../src/scenes/GameScene';
import { Enemy } from '../src/Enemy';

// Mock GameScene with new refactored structure
const mockGameState: { enemies: Enemy[]; wave: number } = {
    enemies: [],
    wave: 0
};

const mockScene = {
    get wave() { return mockGameState.wave; },
    set wave(value: number) { mockGameState.wave = value; },
    get enemies() { return mockGameState.enemies; },
    money: 100,
    game: { canvas: { width: 800, height: 600 } },
    ui: { update: jest.fn() },
    showFloatingText: jest.fn(),
    spawnEnemy: jest.fn(),
    giveRandomCard: jest.fn(),
    addMoney: jest.fn(),
    mapData: { waves: [] },
    metrics: {
        trackWaveReached: jest.fn(),
        trackMoneyEarned: jest.fn()
    },
    effects: { add: jest.fn() }
} as unknown as GameScene;

describe('WaveManager', () => {
    let waveManager: WaveManager;

    beforeEach(() => {
        waveManager = new WaveManager(mockScene);
        mockGameState.wave = 0;
        mockGameState.enemies = [];
        // Reset mocks
        (mockScene.ui.update as jest.Mock).mockClear();
        (mockScene.showFloatingText as jest.Mock).mockClear();
        (mockScene.spawnEnemy as jest.Mock).mockClear();
    });

    test('should start wave correctly', () => {
        waveManager.startWave();
        expect(mockScene.wave).toBe(1);
        expect(waveManager.isWaveActive).toBe(true);
        // Wave visuals now handled by NotificationSystem via EventBus
    });

    test('should allow early wave start with bonus', () => {
        waveManager.startWave();
        waveManager.startWave(); // Early start!
        expect(mockScene.wave).toBe(2); // Wave increments
        expect(mockScene.addMoney).toHaveBeenCalled(); // Bonus given
    });

    test('should spawn enemies during update', () => {
        // Setup a wave with 1 enemy
        // We need to mock generateWave logic or just push to enemiesToSpawn manually if it was public
        // Since generateWave is private, we rely on startWave calling it.
        // Let's mock CONFIG if needed, but startWave uses mapData or CONFIG.
        // Assuming mapData is empty, it uses CONFIG.

        waveManager.startWave();

        // Force some enemies to spawn
        // We can't easily access private enemiesToSpawn. 
        // But we can check if spawnEnemy is called after updates.

        // Simulate many frames
        for (let i = 0; i < 100; i++) {
            waveManager.update();
        }

        // If there are enemies in CONFIG for wave 1, spawnEnemy should be called
        // We might need to ensure CONFIG has enemies.
    });
});
</file>

<file path="src/cards/FireCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Fire Card Upgrades
 * 
 * Level 1: Area damage, +15 damage, -15% attack speed
 * Level 2: Larger area, +30 damage, -10% attack speed
 * Level 3: Same as level 2 + enemies explode on death (50% tower damage)
 */
export const FIRE_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damage: 15,
            attackSpeedMultiplier: 0.85, // -15% attack speed
        },
        effects: [
            {
                type: 'splash',
                splashRadius: 50,
            }
        ],
        visualOverrides: {
            projectileType: 'fire',
            projectileColor: '#f44336',
            projectileSpeed: 6,
        }
    },
    2: {
        level: 2,
        modifiers: {
            damage: 30,
            attackSpeedMultiplier: 0.90, // -10% attack speed
        },
        effects: [
            {
                type: 'splash',
                splashRadius: 85,
            }
        ]
    },
    3: {
        level: 3,
        modifiers: {
            damage: 30,
            attackSpeedMultiplier: 0.90, // -10% attack speed
        },
        effects: [
            {
                type: 'splash',
                splashRadius: 90,
            },
            {
                type: 'explodeOnDeath',
                explosionDamagePercent: 0.5, // 50% of tower damage
                explosionRadius: 40,
            }
        ]
    }
};
</file>

<file path="src/cards/MinigunCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Minigun Card Upgrades
 * 
 * Level 1: Percentage damage modifier (-70%), +3 dmg/sec, overheat after 5s (1.5s lockout)
 * Level 2: Same as level 1 (-60%) + 2% crit chance per second
 * Level 3: Stepped damage ramp (-45%), + crit, overheat 3s lockout
 */
export const MINIGUN_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damageMultiplier: 0.30, // 30% of base damage (70% reduction)
            attackSpeedMultiplier: 2.65, // 45 / 17 = 2.65x faster attacks
        },
        effects: [
            {
                type: 'spinup',
                spinupDamagePerSecond: 3, // +3 damage per second
                maxSpinupSeconds: 5, // 5 seconds
                overheatDuration: 90, // 1.5 seconds (lockout)
                overheatExtensionWithIce: 120, // +2 seconds with Ice card
            }
        ],
        visualOverrides: {
            projectileType: 'minigun',
            projectileColor: '#fff',
            projectileSpeed: 12,
        }
    },
    2: {
        level: 2,
        modifiers: {
            damageMultiplier: 0.40, // 40% of base damage (60% reduction)
            attackSpeedMultiplier: 2.75,
        },
        effects: [
            {
                type: 'spinup',
                spinupDamagePerSecond: 3,
                spinupCritPerSecond: 0.02, // +2% crit chance per second
                maxSpinupSeconds: 5,
                overheatDuration: 90,
                overheatExtensionWithIce: 120,
            }
        ]
    },
    3: {
        level: 3,
        modifiers: {
            damageMultiplier: 0.55, // 55% of base damage (45% reduction)
            attackSpeedMultiplier: 2.65,
        },
        effects: [
            {
                type: 'spinup',
                // Stepped damage: 5 steps over 5 seconds
                spinupSteps: [
                    { threshold: 1, damage: 5 },   // 0-1 sec: +5 dmg
                    { threshold: 2, damage: 10 },  // 1-2 sec: +10 dmg
                    { threshold: 3, damage: 15 },  // 2-3 sec: +15 dmg
                    { threshold: 4, damage: 20 },  // 3-4 sec: +20 dmg
                    { threshold: 5, damage: 30 },  // 4-5 sec: +30 dmg (max)
                ],
                spinupCritPerSecond: 0.02, // +2% crit chance per second
                maxSpinupSeconds: 5,
                overheatDuration: 90,
                overheatExtensionWithIce: 120,
            }
        ]
    }
};
</file>

<file path="src/cards/MultishotCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Multishot Card Upgrades
 * 
 * Level 1: 2 projectiles at 60% damage each
 * Level 2: 2 projectiles at 70% damage each
 * Level 3: 3 projectiles at 55% damage each
 * 
 * Note: Multishot is handled differently - it modifies projectile count
 * and damage multiplier rather than using effects system
 */
export const MULTISHOT_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {},
        effects: []
        // Projectile count: 2, damage multiplier: 0.60
    },
    2: {
        level: 2,
        modifiers: {},
        effects: []
        // Projectile count: 2, damage multiplier: 0.70
    },
    3: {
        level: 3,
        modifiers: {},
        effects: []
        // Projectile count: 3, damage multiplier: 0.55
    }
};

/**
 * Get multishot configuration for a given level
 */
export function getMultishotConfig(level: number): { projectileCount: number; damageMultiplier: number; spread: number } {
    switch (level) {
        case 1:
            return { projectileCount: 2, damageMultiplier: 0.60, spread: 0.30 };
        case 2:
            return { projectileCount: 2, damageMultiplier: 0.70, spread: 0.20 };
        case 3:
            return { projectileCount: 3, damageMultiplier: 0.55, spread: 0.25 };
        default:
            return { projectileCount: 1, damageMultiplier: 1.0, spread: 0 };
    }
}
</file>

<file path="src/CrashHandler.ts">
import { Logger, LogChannel, LogLevel } from './utils/Logger';
import { SafeJson } from './utils/SafeJson';

export class CrashHandler {
    constructor() {
        this.init();
        Logger.info(LogChannel.SYSTEM, 'CrashHandler initialized');
    }

    private init() {
        window.onerror = (message, source, lineno, colno, error) => {
            this.handleError(message as string, source, lineno, colno, error);
            return true; // Prevent default browser console spam if we handle it
        };

        window.addEventListener('unhandledrejection', (event) => {
            this.handleError(event.reason ? event.reason.toString() : 'Unhandled Rejection', 'Promise', 0, 0, event.reason);
        });
    }

    private handleError(msg: string, source: string | undefined, line: number, col: number | undefined, error: any) {
        // 1. Log to our internal logger immediately (so it's in history)
        Logger.error(LogChannel.SYSTEM, `CRASH: ${msg}`, { source, line, stack: error?.stack });

        // 2. Stop Game Loop (Global hack or try to find game instance)
        // We can't easily stop requestAnimationFrame from here without reference, but we can cover the screen.

        // 3. Show BSOD
        this.showBSOD(msg, source || 'unknown', line, error);
    }

    private showBSOD(msg: string, source: string, line: number, error: any) {
        // Stop interaction
        const ui = document.getElementById('ui-layer');
        if (ui) ui.style.display = 'none';

        // Create BSOD
        const bsod = document.createElement('div');
        Object.assign(bsod.style, {
            position: 'fixed', top: '0', left: '0', width: '100%', height: '100%',
            background: 'rgba(50, 0, 0, 0.96)', color: '#fff', fontFamily: 'Consolas, monospace',
            padding: '40px', zIndex: '999999', overflow: 'auto', display: 'flex', flexDirection: 'column',
            backdropFilter: 'blur(5px)'
        });

        const report = this.createFullReport(msg, source, line, error);

        bsod.innerHTML = `
            <h1 style="color: #ff5555; margin: 0 0 20px 0;">‚ò†Ô∏è CRITICAL FAILURE</h1>
            <p style="font-size: 16px; color: #ffaaaa; margin-bottom: 30px;">
                The game encountered an unrecoverable error.
            </p>
            
            <div style="background: #220000; padding: 20px; border: 1px solid #ff4444; border-radius: 6px; margin-bottom: 20px;">
                <div style="color: #ff5555; font-weight: bold; margin-bottom: 10px;">EPOCH ERROR: ${msg}</div>
                <div style="color: #999; font-size: 12px;">${source}:${line}</div>
                <pre style="color: #ccc; margin-top: 15px; font-size: 12px; overflow-x: auto;">${error?.stack || 'No stack trace available'}</pre>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="btn-copy-report" style="padding: 12px 24px; background: #fff; color: #800; border: none; font-weight: bold; cursor: pointer; border-radius: 4px;">
                    üìã COPY FULL DEBUG REPORT
                </button>
                <button onclick="location.reload()" style="padding: 12px 24px; background: #444; color: #fff; border: none; cursor: pointer; border-radius: 4px;">
                    üîÑ RELOAD GAME
                </button>
            </div>
            
            <p style="margin-top: 20px; color: #666; font-size: 12px;">
                Please send this report to the developer.
            </p>
        `;

        document.body.appendChild(bsod);

        document.getElementById('btn-copy-report')!.onclick = () => {
            navigator.clipboard.writeText(report).then(() => {
                const btn = document.getElementById('btn-copy-report')!;
                btn.innerText = '‚úÖ COPIED!';
                btn.style.background = '#4f4';
                btn.style.color = '#000';
            });
        };
    }

    private createFullReport(msg: string, source: string, line: number, error: any): string {
        const report = {
            timestamp: new Date().toISOString(),
            error: {
                message: msg,
                source: `${source}:${line}`,
                stack: error?.stack,
            },
            system: {
                ua: navigator.userAgent,
                resolution: `${window.innerWidth}x${window.innerHeight}`,
                time: performance.now().toFixed(2) + 'ms'
            },
            logs: Logger.getHistory(), // Last 200 logs
            // Ideally we would dump GameState here, but we lack reference. 
            // The logs should contain enough info if properly instrumented.
        };

        return JSON.stringify(report, null, 2);
    }
}
</file>

<file path="src/ObjectRenderer.ts">
import { CONFIG } from './Config';
import { VISUALS } from './VisualConfig';
import { ProceduralGrass } from './renderers/ProceduralGrass';

/**
 * ObjectRenderer - programmatic rendering for map objects
 * Supports 5 object types: stone, rock, tree, wheat, flowers
 * Designed to be easily replaced with asset-based rendering later
 */

export type ObjectType = 'stone' | 'rock' | 'tree' | 'wheat' | 'flowers';

export class ObjectRenderer {
    /**
     * Draw an object at specified pixel coordinates
     * @param ctx Canvas rendering context
     * @param type Object type
     * @param x Pixel x coordinate
     * @param y Pixel y coordinate
     * @param size Tile size (1 for most objects, 2-3 for rocks)
     */
    static draw(ctx: CanvasRenderingContext2D, type: ObjectType, x: number, y: number, size: number = 1): void {
        const TS = CONFIG.TILE_SIZE;

        switch (type) {
            case 'stone':
                this.drawStone(ctx, x, y, TS);
                break;
            case 'rock':
                this.drawRock(ctx, x, y, TS, size);
                break;
            case 'tree':
                this.drawTree(ctx, x, y, TS);
                break;
            case 'wheat':
                this.drawWheat(ctx, x, y, TS);
                break;
            case 'flowers':
                this.drawFlowers(ctx, x, y, TS);
                break;
        }
    }

    /**
     * Draw small stones (1 tile)
     * Phase 5: Uses global light direction from VISUALS.LIGHTING
     */
    private static drawStone(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        const centerX = x + TS / 2;
        const centerY = y + TS / 2;

        // Draw 2-3 small gray stones
        const stoneCount = 2 + Math.floor((x + y) % 2);

        for (let i = 0; i < stoneCount; i++) {
            const offsetX = ((x + i * 17) % 30) - 15;
            const offsetY = ((y + i * 23) % 30) - 15;
            const radius = 6 + ((x + y + i) % 4);

            // Stone shadow (uses global light direction)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Slightly darker
            ctx.beginPath();
            ctx.ellipse(
                centerX + offsetX + VISUALS.LIGHTING.SHADOW_OFFSET_X,
                centerY + offsetY + VISUALS.LIGHTING.SHADOW_OFFSET_Y,
                radius, radius * 0.8, 0, 0, Math.PI * 2
            );
            ctx.fill();

            // Stone body
            ctx.fillStyle = '#757575';
            ctx.beginPath();
            ctx.ellipse(centerX + offsetX, centerY + offsetY, radius, radius * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Highlight (opposite direction from shadow)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; // Brighter
            ctx.beginPath();
            ctx.ellipse(
                centerX + offsetX + VISUALS.LIGHTING.HIGHLIGHT_OFFSET_X,
                centerY + offsetY + VISUALS.LIGHTING.HIGHLIGHT_OFFSET_Y,
                radius * 0.4, radius * 0.3, 0, 0, Math.PI * 2
            );
            ctx.fill();
        }
    }

    /**
     * Draw large rocks (2-3 tiles) with varied shapes
     * Phase 5: Uses global light direction
     */
    private static drawRock(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number, size: number): void {
        const width = size * TS;
        const height = size * TS;
        const centerX = x + width / 2;
        const centerY = y + height / 2;

        // More varied vertices based on size and position
        const vertices = 5 + (size - 1) + ((x + y) % 3);

        // Create pseudo-random but deterministic variations
        const seed = x * 73 + y * 137;

        // Shadow with varied shape
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        for (let i = 0; i < vertices; i++) {
            const angle = (i / vertices) * Math.PI * 2;
            const variance = ((seed + i * 43) % 20) - 10; // -10 to +10
            const radius = width * 0.35 + variance;
            const angleOffset = ((seed + i * 23) % 30 - 15) * 0.01; // Small angle variation
            const px = centerX + Math.cos(angle + angleOffset) * radius + 4;
            const py = centerY + Math.sin(angle + angleOffset) * radius + 4;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        // Rock body with varied color
        const grayVariance = ((seed % 30) - 15);
        const grayValue = 97 + grayVariance; // Around #616161
        ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
        ctx.beginPath();
        for (let i = 0; i < vertices; i++) {
            const angle = (i / vertices) * Math.PI * 2;
            const variance = ((seed + i * 43) % 20) - 10;
            const radius = width * 0.35 + variance;
            const angleOffset = ((seed + i * 23) % 30 - 15) * 0.01;
            const px = centerX + Math.cos(angle + angleOffset) * radius;
            const py = centerY + Math.sin(angle + angleOffset) * radius;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        // Add varied texture lines
        ctx.strokeStyle = '#424242';
        ctx.lineWidth = 1 + (size - 1) * 0.5;
        const lineCount = 2 + ((seed % 4));
        for (let i = 0; i < lineCount; i++) {
            const startAngle = ((seed + i * 67) % 360) * Math.PI / 180;
            const endAngle = startAngle + (Math.PI / 4) + ((seed + i) % 20) * 0.05;
            const r1 = width * (0.1 + ((seed + i * 13) % 10) * 0.01);
            const r2 = width * (0.25 + ((seed + i * 17) % 15) * 0.01);
            ctx.beginPath();
            ctx.moveTo(centerX + Math.cos(startAngle) * r1, centerY + Math.sin(startAngle) * r1);
            ctx.lineTo(centerX + Math.cos(endAngle) * r2, centerY + Math.sin(endAngle) * r2);
            ctx.stroke();
        }

        // Varied highlight position
        const highlightX = centerX - width * 0.15 + ((seed % 20) - 10);
        const highlightY = centerY - height * 0.15 + ((seed % 15) - 7);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        ctx.arc(highlightX, highlightY, width * 0.08, 0, Math.PI * 2);
        ctx.fill();
    }

    /**
     * Draw tree (1 tile)
     * Phase 5: Uses global light direction, gradient trunk, layered foliage
     */
    private static drawTree(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        const centerX = x + TS / 2;
        const bottomY = y + TS - 5;

        // Trunk shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(centerX - 6, bottomY - 25, 14, 28);

        // Trunk
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(centerX - 5, bottomY - 25, 10, 25);

        // Foliage shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.arc(centerX + 3, bottomY - 20, 18, 0, Math.PI * 2);
        ctx.fill();

        // Foliage (3 circles for depth)
        const foliageColors = ['#1b5e20', '#2e7d32', '#388e3c'];
        const foliageOffsets = [
            { x: -5, y: -5, r: 14 },
            { x: 5, y: -3, r: 16 },
            { x: 0, y: -10, r: 15 }
        ];

        foliageOffsets.forEach((offset, i) => {
            ctx.fillStyle = foliageColors[i];
            ctx.beginPath();
            ctx.arc(centerX + offset.x, bottomY - 20 + offset.y, offset.r, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    /**
     * Draw wheat field (1 tile)
     */
    private static drawWheat(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        // Background (darker gold)
        ctx.fillStyle = '#f9a825';
        ctx.fillRect(x, y, TS, TS);

        // Wheat stalks pattern
        ctx.strokeStyle = '#fbc02d';
        ctx.lineWidth = 2;

        for (let row = 0; row < 4; row++) {
            for (let col = 0; col < 4; col++) {
                const stalkX = x + col * (TS / 4) + (TS / 8);
                const stalkY = y + row * (TS / 4) + (TS / 8);
                const offset = ((row + col) % 2) * 3;

                // Stalk
                ctx.beginPath();
                ctx.moveTo(stalkX, stalkY + 10);
                ctx.lineTo(stalkX + offset, stalkY - 2);
                ctx.stroke();

                // Wheat head
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.ellipse(stalkX + offset, stalkY - 4, 3, 5, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Border for definition
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, TS, TS);
    }

    /**
     * Draw flowering grass (1 tile) - grass colored with varied flowers
     * –§–ê–ó–ê 3: –û–±–Ω–æ–≤–ª–µ–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ProceduralGrass –¥–ª—è —Ñ–æ–Ω–∞
     */
    private static drawFlowers(ctx: CanvasRenderingContext2D, x: number, y: number, TS: number): void {
        // –®–ê–ì 1: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å ProceduralGrass –¥–ª—è —Ñ–æ–Ω–∞
        // –í–ê–ñ–ù–û: –≠—Ç–æ —Å–æ–∑–¥–∞—ë—Ç –∏–¥–µ–Ω—Ç–∏—á–Ω—ã–π —Ñ–æ–Ω —Å –æ–±—ã—á–Ω–æ–π —Ç—Ä–∞–≤–æ–π

        // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∞–π–ª–∞
        const seed = x * 73 + y * 137;

        // –†–µ–Ω–¥–µ—Ä–∏–º –∂–∏–≤—É—é —Ç—Ä–∞–≤—É –∫–∞–∫ —Ñ–æ–Ω
        try {
            ProceduralGrass.draw(ctx, x, y, TS, seed);
        } catch (error) {
            console.error('[ObjectRenderer] ProceduralGrass.draw failed:', error);
            // Fallback - –ø—Ä–æ—Å—Ç–æ–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
            const gradient = ctx.createLinearGradient(x, y, x, y + TS);
            gradient.addColorStop(0, VISUALS.ENVIRONMENT.GRASS.LIGHT);
            gradient.addColorStop(1, VISUALS.ENVIRONMENT.GRASS.BASE);
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, TS, TS);
        }

        // –®–ê–ì 2: –ú–ù–û–ì–û –º–µ–ª–∫–∏—Ö —Ü–≤–µ—Ç–æ–≤ –ø–æ–≤–µ—Ä—Ö —Ç—Ä–∞–≤—ã
        const flowerCount = 20 + (seed % 11); // 20-30 (–±—ã–ª–æ 10-17)

        // –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –ø–∞–ª–∏—Ç—Ä–∞ (7 —Ü–≤–µ—Ç–æ–≤, –¥–æ–±–∞–≤–ª–µ–Ω –∂—ë–ª—Ç—ã–π)
        const flowerColors = [
            '#e91e63', // –†–æ–∑–æ–≤—ã–π
            '#9c27b0', // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
            '#2196f3', // –°–∏–Ω–∏–π
            '#ff9800', // –û—Ä–∞–Ω–∂–µ–≤—ã–π
            '#ffeb3b', // –ñ—ë–ª—Ç—ã–π (–ù–û–í–´–ô)
            '#f44336', // –ö—Ä–∞—Å–Ω—ã–π
            '#fff'     // –ë–µ–ª—ã–π
        ];

        for (let i = 0; i < flowerCount; i++) {
            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            const fx = x + ((seed * 7 + i * 13) % TS);
            const fy = y + ((seed * 11 + i * 19) % TS);

            // –†–∞–∑–º–µ—Ä: 1.0-1.8px (–º–µ–Ω—å—à–µ —á–µ–º –±—ã–ª–æ 1.5-3px)
            const flowerSize = 1.0 + ((seed + i * 7) % 8) * 0.1; // 1.0-1.8px

            // –¶–≤–µ—Ç –∏–∑ –ø–∞–ª–∏—Ç—Ä—ã
            const colorIdx = (seed + i * 3) % flowerColors.length;

            // –£–ü–†–û–©–Å–ù–ù–ê–Ø –ì–ï–û–ú–ï–¢–†–ò–Ø: –ü—Ä–æ—Å—Ç–æ–π –∫—Ä—É–∂–æ–∫ (–≤–º–µ—Å—Ç–æ –ª–µ–ø–µ—Å—Ç–∫–æ–≤)
            // –í–Ω–µ—à–Ω–∏–π –∫—Ä—É–≥ (—Ü–≤–µ—Ç)
            ctx.fillStyle = flowerColors[colorIdx];
            ctx.beginPath();
            ctx.arc(fx, fy, flowerSize, 0, Math.PI * 2);
            ctx.fill();

            // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –±–ª–∏–∫ (–±–µ–ª—ã–π —Ü–µ–Ω—Ç—Ä)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(fx, fy, flowerSize * 0.5, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}
</file>

<file path="src/Pathfinder.ts">
import { Cell } from './MapData';

export class Pathfinder {
    // –ù–∞—Ö–æ–¥–∏—Ç –ø—É—Ç—å –æ—Ç start –¥–æ end, –∏—Å–ø–æ–ª—å–∑—É—è —Ç–æ–ª—å–∫–æ —Ç–∞–π–ª—ã —Ç–∏–ø–∞ 1 (Path)
    // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç {x, y} –∏–ª–∏ –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤, –µ—Å–ª–∏ –ø—É—Ç–∏ –Ω–µ—Ç
    public static findPath(
        grid: Cell[][],
        start: { x: number; y: number },
        end: { x: number; y: number },
    ): { x: number; y: number }[] {
        const rows = grid.length;
        const cols = grid[0].length;

        // –û—á–µ—Ä–µ–¥—å –¥–ª—è BFS: [ {x, y}, [path_so_far] ]
        const queue: { pos: { x: number; y: number }; path: { x: number; y: number }[] }[] = [];
        queue.push({ pos: start, path: [start] });

        const visited = new Set<string>();
        visited.add(`${start.x},${start.y}`);

        const directions = [
            { dx: 0, dy: -1 }, // Up
            { dx: 1, dy: 0 }, // Right
            { dx: 0, dy: 1 }, // Down
            { dx: -1, dy: 0 }, // Left
        ];

        while (queue.length > 0) {
            const { pos, path } = queue.shift()!;

            if (pos.x === end.x && pos.y === end.y) {
                return path;
            }

            for (const dir of directions) {
                const nx = pos.x + dir.dx;
                const ny = pos.y + dir.dy;
                const key = `${nx},${ny}`;

                if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !visited.has(key)) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –¥–æ—Ä–æ–≥–∞ (type === 1) –ò–õ–ò —ç—Ç–æ –∫–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞ (–¥–∞–∂–µ –µ—Å–ª–∏ –º—ã –µ—ë —Å–ª—É—á–∞–π–Ω–æ –∑–∞–∫—Ä–∞—Å–∏–ª–∏ —Ç—Ä–∞–≤–æ–π, —Ö–æ—Ç—è –ø–æ –ª–æ–≥–∏–∫–µ –æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–∞ –¥–æ—Ä–æ–≥–µ)
                    // –ù–æ –ª—É—á—à–µ —Å—Ç—Ä–æ–≥–æ: —Ö–æ–¥–∏—Ç—å –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –ø–æ –¥–æ—Ä–æ–≥–µ.
                    const cell = grid[ny][nx];
                    if (cell.type === 1) {
                        visited.add(key);
                        queue.push({ pos: { x: nx, y: ny }, path: [...path, { x: nx, y: ny }] });
                    }
                }
            }
        }

        return [];
    }
}
</file>

<file path="src/scenes/GameController.ts">
import { ICard } from '../CardSystem';
import { CONFIG } from '../Config';
import { Tower } from '../Tower';
import { GameState } from './GameState';
import { EntityManager } from './EntityManager';
import { EffectSystem } from '../EffectSystem';
import { InspectorSystem } from '../InspectorSystem';
import { UIManager } from '../UIManager';
import { MetricsSystem } from '../MetricsSystem';
import { IMapData } from '../MapData';
import { EventEmitter } from '../Events';

/**
 * Handles user actions and game controller logic:
 * - Tower building/selection
 * - Card drop handling
 * - Grid click handling
 * - Keyboard hotkeys
 */
export class GameController {
    constructor(
        private state: GameState,
        private entityManager: EntityManager,
        private effects: EffectSystem,
        private inspector: InspectorSystem,
        private ui: UIManager,
        private metrics: MetricsSystem,
        private mapData: IMapData,
        private isBuildable: (col: number, row: number) => boolean,
        private cardSys: any, // CardSystem reference
        private events: EventEmitter,
    ) {
        this.events.on('CARD_DROPPED', (data: any) => {
            this.handleCardDrop(data.card, data.x, data.y);
        });
    }

    private lastErrorTime: number = 0;

    // === Tower Building ===

    public startBuildingTower(col: number, row: number): void {
        const screenX = col * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const screenY = row * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        const validation = this.entityManager.canBuildTower(col, row, this.mapData, this.isBuildable);

        if (!validation.valid) {
            // Debounce error text to prevent infinite spam
            const now = Date.now();
            if (now - this.lastErrorTime > 500) {
                this.showFloatingText(validation.reason!, screenX, screenY, 'red');
                this.lastErrorTime = now;
            }
            return;
        }

        const tower = this.entityManager.buildTower(col, row);
        this.ui.update();
    }

    // === Grid Click Handling ===

    public handleGridClick(col: number, row: number): void {
        const tower = this.entityManager.getTowerAt(col, row);
        if (tower) {
            this.state.selectTower(tower);
            this.inspector.selectTower(tower);
        } else {
            this.state.selectTower(null);
            this.inspector.hide();
        }
    }

    // === Card Drop Handling ===

    public handleCardDrop(card: ICard, x: number, y: number): boolean {
        const col = Math.floor(x / CONFIG.TILE_SIZE);
        const row = Math.floor(y / CONFIG.TILE_SIZE);

        // Check if this is a tower card
        if (
            card.type.id === 'fire' ||
            card.type.id === 'ice' ||
            card.type.id === 'sniper' ||
            card.type.id === 'multi' ||
            card.type.id === 'minigun'  // FIXED: Added minigun support
        ) {
            const success = this.entityManager.addCardToTower(card, col, row, this.isBuildable);

            if (success) {
                this.cardSys.removeCardFromHand(card);
                this.showFloatingText('Card installed!', x, y, 'lime');
                this.ui.update();

                // Refresh inspector if this tower is selected
                const tower = this.entityManager.getTowerAt(col, row);
                if (tower && this.state.selectedTower === tower) {
                    this.inspector.selectTower(tower);
                }
                return true;
            } else {
                const tower = this.entityManager.getTowerAt(col, row);
                if (tower && tower.cards.length >= 3) {
                    this.showFloatingText('Tower full!', x, y, 'orange');
                } else if (this.state.money < CONFIG.ECONOMY.TOWER_COST) {
                    this.showFloatingText('Not enough money!', x, y, 'red');
                } else {
                    this.showFloatingText("Can't build here", x, y, 'red');
                }
                return false;
            }
        }

        return false;
    }

    // === Tower Selling ===

    public sellTower(tower: Tower): void {
        const refund = this.entityManager.sellTower(tower);
        if (refund > 0) {
            this.inspector.hide();
            this.ui.update();
        }
    }

    public sellCardFromTower(tower: Tower, cardIndex: number): void {
        const result = this.entityManager.sellCardFromTower(tower, cardIndex);
        if (result.card) {
            this.ui.update();
            // Refresh inspector to show updated card slots
            this.inspector.selectTower(tower);
        }
    }

    // === Card Management ===

    public giveRandomCard(): void {
        const keys = Object.keys(CONFIG.CARD_TYPES);
        const key = keys[Math.floor(Math.random() * keys.length)];
        this.cardSys.addCard(key, 1);
        this.ui.update();
    }

    // === Keyboard Hotkeys ===

    public handleKeyDown(e: KeyboardEvent): void {
        if (this.state.paused) return;

        switch (e.code) {
            case 'Space':
                this.handleSpaceKey();
                break;
                if (this.state.selectedTower) {
                    this.sellTower(this.state.selectedTower);
                }
                break;
            case 'KeyM':
                console.log('CHEAT: Give Minigun');
                this.cardSys.addCard('MINIGUN', 1);
                this.ui.update();
                this.showFloatingText('+ MINIGUN', window.innerWidth / 2, window.innerHeight / 2, '#d0f');
                break;
            case 'Digit1':
            case 'Digit2':
            case 'Digit3':
            case 'Digit4':
            case 'Digit5':
                // Card selection hotkeys (if implemented in future)
                break;
        }
    }

    private handleSpaceKey(): void {
        // Space key logic will be handled by WaveManager
        // Just toggle time scale if wave is active
        const waveActive = false; // This should come from WaveManager

        if (waveActive) {
            this.state.toggleTimeScale();
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const text = this.state.timeScale === 2.0 ? '>> 2x Speed' : '> 1x Speed';
            this.showFloatingText(text, centerX, centerY, '#fff');
        }
    }

    // === Helper Methods ===

    public showFloatingText(text: string, x: number, y: number, color: string = '#fff'): void {
        this.effects.add({ type: 'text', text, x, y, life: 60, color, vy: -1 });
    }
}
</file>

<file path="src/SoundManager.ts">
export enum SoundPriority {
    LOW = 0,
    HIGH = 1
}

export class SoundManager {
    private static ctx: AudioContext;
    private static buffers: Record<string, AudioBuffer> = {};
    private static lastPlayed: Record<string, number> = {};
    private static lastPlayedType: Record<string, number> = {}; // Track last play time by TYPE

    // Config
    private static CULL_MS = 50; // Minimum time between same sounds (Legacy logic)
    private static THROTTLE_MS = 60; // Global throttle for identical sounds
    public static MASTER_VOLUME = 0.3; // Made public for settings
    public static SFX_VOLUME = 1.0;
    public static MUSIC_VOLUME = 0.5;

    public static setVolume(master: number) {
        this.MASTER_VOLUME = Math.max(0, Math.min(1, master));
    }

    public static async init() {
        if (this.ctx) return;

        try {
            // @ts-ignore - Handle webkit prefix for older browsers if needed
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContextClass();
            console.log('SoundManager: AudioContext initialized');

            // Generate basic sounds
            this.generateSounds();
        } catch (e) {
            console.error('SoundManager: Failed to init AudioContext', e);
        }
    }

    public static resume() {
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    public static play(key: string, priority: SoundPriority = SoundPriority.LOW) {
        if (!this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();

        const now = Date.now();
        const last = this.lastPlayed[key] || 0;

        // 1. Culling / Ducking logic
        // If High Priority, we always play (or maybe duck others? For now just play)
        // If Low Priority, check time since last played
        if (priority === SoundPriority.LOW) {
            // Check legacy cull (per specific key/instance if unique keys used)
            if (now - last < this.CULL_MS) {
                return;
            }

            // Global Type Throttling 
            // This prevents "shoot_basic" from playing 10 times in one frame from 10 towers
            const lastType = this.lastPlayedType[key] || 0;
            if (now - lastType < this.THROTTLE_MS) {
                return;
            }
        }

        this.lastPlayed[key] = now;
        this.lastPlayedType[key] = now;

        const buffer = this.buffers[key];
        if (!buffer) {
            // console.warn(`SoundManager: Sound '${key}' not found`);
            return;
        }

        // Create Source
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;

        // 2. Pitch Variance (Tech Trick)
        // +/- 10% (0.9 to 1.1)
        const detune = 0.9 + Math.random() * 0.2;
        source.playbackRate.value = detune;

        // Gain (Volume)
        const gainNode = this.ctx.createGain();
        let vol = this.MASTER_VOLUME * this.SFX_VOLUME;

        // Boost high priority sounds slightly
        if (priority === SoundPriority.HIGH) vol *= 1.5;

        // Randomize volume slightly too for "organic" feel
        vol *= (0.9 + Math.random() * 0.2);

        gainNode.gain.value = vol;

        // Connect
        source.connect(gainNode);
        gainNode.connect(this.ctx.destination);

        source.start();
    }

    private static generateSounds() {
        // We synthesize simple buffers
        // 1. Shoot (Sniper/Gun) - Sharp decay noise/square
        this.buffers['shoot_basic'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 20);
            return (Math.random() * 2 - 1) * decay;
        }, 0.2);

        this.buffers['shoot_sniper'] = this.createBuffer((t) => {
            // Longer, louder crack
            const decay = Math.exp(-t * 10);
            const noise = (Math.random() * 2 - 1);
            return noise * decay * 1.5; // Boost
        }, 0.5);

        // 2. Hit - High pitched tick
        this.buffers['hit'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 50);
            return Math.sin(t * 2000 * Math.PI * 2) * decay;
        }, 0.1);

        // 3. Enemy Death - Soft pop (pleasant, not annoying on repeat)
        this.buffers['death'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 25);
            // Soft bubble pop - high start, quick fade
            const freq = 400 * Math.exp(-t * 8);
            return Math.sin(t * freq * Math.PI * 2) * decay * 0.6;
        }, 0.15);

        // 4. Boss Spawn - Low droning sweep
        this.buffers['boss_spawn'] = this.createBuffer((t) => {
            const freq = 50 + Math.sin(t * 10) * 20;
            return Math.sin(t * freq * Math.PI * 2) * 0.8;
        }, 1.5);

        // 5. UI Click - Clean pip
        this.buffers['click'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 30);
            return Math.sin(t * 800 * Math.PI * 2) * decay;
        }, 0.1);

        // 6. UI Hover - Very short tick
        this.buffers['hover'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 50);
            return Math.sin(t * 1200 * Math.PI * 2) * decay * 0.2;
        }, 0.05);

        // 7. Explosion
        this.buffers['explosion'] = this.createBuffer((t) => {
            const decay = Math.exp(-t * 5);
            return (Math.random() * 2 - 1) * decay;
        }, 0.5);
    }

    private static createBuffer(fn: (t: number) => number, duration: number): AudioBuffer {
        const sampleRate = this.ctx.sampleRate;
        const frames = sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, frames, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < frames; i++) {
            data[i] = fn(i / sampleRate);
        }
        return buffer;
    }
}
</file>

<file path="src/systems/LightingSystem.ts">
import { CONFIG } from '../Config';
import { InkLightingSystem } from '../graphics/InkLightingSystem';

export interface ILight {
    x: number;
    y: number;
    radius: number;
    color: string; // Hex or rgba
    intensity: number; // 0 to 1
}

export class LightingSystem {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private width: number;
    private height: number;
    private scale: number; // Phase 6: Performance optimization

    private lights: ILight[] = [];
    public ambientLight: number = 0.9; // 0 = Pitch Black, 1 = Full Brightness

    // [NEW] Ink implementation
    private inkSystem: InkLightingSystem;

    constructor(width: number, height: number, optimization: boolean = false) {
        this.width = width;
        this.height = height;

        // Phase 6: 2x scale optimization for performance
        this.scale = optimization ? 2 : 1;

        // Create offscreen canvas for light map (at reduced resolution if optimized)
        this.canvas = document.createElement('canvas');
        this.canvas.width = Math.floor(width / this.scale);
        this.canvas.height = Math.floor(height / this.scale);
        this.ctx = this.canvas.getContext('2d', { alpha: true })!;

        // Init Ink System
        this.inkSystem = new InkLightingSystem(width, height);
    }

    public resize(width: number, height: number) {
        this.width = width;
        this.height = height;
        this.canvas.width = Math.floor(width / this.scale);
        this.canvas.height = Math.floor(height / this.scale);

        this.inkSystem.resize(width, height);
    }

    public clear() {
        this.lights = [];
        this.inkSystem.clear();
    }

    public addLight(x: number, y: number, radius: number, color: string, intensity: number = 1.0) {
        // Standard system
        this.lights.push({
            x: x / this.scale,
            y: y / this.scale,
            radius: radius / this.scale,
            color,
            intensity
        });

        // Ink system (full resolution)
        this.inkSystem.addLight(x, y, radius, color, intensity);
    }

    /**
     * Phase 6: Enable global darkness (nighttime mode)
     */
    public enableGlobalDarkness(darknessLevel: number = 0.7) {
        this.ambientLight = 1 - darknessLevel; // e.g., 0.7 darkness = 0.3 ambient
        this.inkSystem.ambientLight = this.ambientLight; // Sync ambient
    }

    /**
     * Phase 6: Add light from a tower
     */
    public addTowerLight(x: number, y: number, tileSize: number) {
        this.addLight(x + tileSize / 2, y + tileSize / 2, tileSize * 2.5, '#ffaa00', 0.8);
    }

    public render(targetCtx: CanvasRenderingContext2D) {
        // Dispatch based on config
        if (CONFIG.VISUAL_STYLE === 'INK') {
            // Make sure ambient light is synced before render
            this.inkSystem.ambientLight = this.ambientLight;
            this.inkSystem.render(targetCtx);
            return;
        }

        // Logic for SPRITE style (Original)
        const w = this.canvas.width;
        const h = this.canvas.height;

        // 0. Clear previous frame
        this.ctx.clearRect(0, 0, w, h);

        // 1. Fill light map with "Darkness"
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.fillStyle = `rgba(0, 0, 0, ${1 - this.ambientLight})`;
        this.ctx.fillRect(0, 0, w, h);

        // 2. Punch holes / Add lights (Visibility)
        this.ctx.globalCompositeOperation = 'destination-out';

        this.lights.forEach(light => {
            const g = this.ctx.createRadialGradient(light.x, light.y, 0, light.x, light.y, light.radius);
            g.addColorStop(0, `rgba(0, 0, 0, ${light.intensity})`); // Full erase
            g.addColorStop(1, 'rgba(0, 0, 0, 0)'); // No erase

            this.ctx.fillStyle = g;
            this.ctx.beginPath();
            this.ctx.arc(light.x, light.y, light.radius, 0, Math.PI * 2);
            this.ctx.fill();
        });

        // 3. Draw colored glows (Additive Pass)
        // We render this DIRECTLY to the target context to add glow on top of game + darkness
        // OR we render to a separate canvas. 
        // Rendering to targetCtx directly is better for performance and visual control.

        // Draw the darkness overlay first (scaled up if using optimization)
        targetCtx.save();
        targetCtx.drawImage(this.canvas, 0, 0, this.width, this.height);

        // Now draw colored lights on TOP using 'lighter' (or 'screen')
        targetCtx.globalCompositeOperation = 'lighter'; // Additive blending

        this.lights.forEach(light => {
            if (light.color === '#000000') return; // Skip black lights

            // Scale back to target resolution
            const x = light.x * this.scale;
            const y = light.y * this.scale;
            const r = light.radius * this.scale;

            const g = targetCtx.createRadialGradient(x, y, 0, x, y, r);
            // Convert hex to rgb for gradient? Or just use hex if browser supports (it does usually)
            // But we need alpha falloff.

            // Helper to get RGBA from potentially hex string would be nice, but simple fix:
            // Let's assume color is a valid CSS color string. 
            // We'll use a simple approximation or just draw with lower opacity at center.

            g.addColorStop(0, light.color); // Color at center
            g.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade to transparent

            targetCtx.fillStyle = g;
            targetCtx.globalAlpha = light.intensity * 0.6; // Scale down glow intensity
            targetCtx.beginPath();
            targetCtx.arc(light.x, light.y, light.radius, 0, Math.PI * 2);
            targetCtx.fill();
        });

        targetCtx.restore();
    }
}
</file>

<file path="src/VisualConfig.ts">
/**
 * Centralized Visual Configuration
 * Stores colors, sizes, and other visual constants for procedural generation and rendering.
 */

export const VISUALS = {
    ENVIRONMENT: {
        GRASS: {
            // –ñ–∏–≤–∞—è —Ç—Ä–∞–≤–∞ (—Å—Ä–µ–¥–Ω—è—è –∑–µ–ª–µ–Ω—å) - –§–ê–ó–ê 2: –û–±–Ω–æ–≤–ª–µ–Ω–æ
            BASE: '#6b9e4a',         // –°—Ä–µ–¥–Ω–µ-–∑–µ–ª—ë–Ω—ã–π (–æ—Å–Ω–æ–≤–∞)
            LIGHT: '#7ab55a',        // –°–≤–µ—Ç–ª–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è
            DARK: '#5a8839',         // –¢—ë–º–Ω–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è (—Ç–µ–Ω–∏)
            BLADE: '#8bc34a',        // –¢—Ä–∞–≤–∏–Ω–∫–∏ (—è—Ä–∫–∏–µ)
            DETAIL: '#757575',       // –ö–∞–º–µ—à–∫–∏
            FLOWER: '#ffeb3b',       // –ú–µ–ª–∫–∏–µ —Ü–≤–µ—Ç–æ—á–∫–∏

            // –ë–∏–æ–ª—é–º–∏–Ω–µ—Å—Ü–µ–Ω—Ü–∏—è (–ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô - –¥–ª—è –§–∞–∑—ã 4)
            BIOLUM: '#4dd0e1',       // Cyan bioluminescence

            // LEGACY - –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º
            MAIN: '#6b9e4a',         // = BASE (fallback)
            VAR_1: '#7ab55a',        // = LIGHT (fallback)
            VAR_2: '#5a8839',        // = DARK (fallback)
        },
        PATH: {
            // –ö–∞–º–µ–Ω–Ω–∞—è –¥–æ—Ä–æ–≥–∞ (–§–ê–ó–ê 1: –û–±–Ω–æ–≤–ª–µ–Ω–æ)
            STONE_BASE: '#c5b8a1',       // –°–≤–µ—Ç–ª—ã–π –±–µ–∂–µ–≤—ã–π –∫–∞–º–µ–Ω—å
            STONE_LIGHT: '#d4c5a9',      // –°–≤–µ—Ç–ª–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è
            STONE_DARK: '#b6a890',       // –¢—ë–º–Ω–∞—è –≤–∞—Ä–∏–∞—Ü–∏—è
            CRACK: '#8b7e6a',            // –¢—Ä–µ—â–∏–Ω—ã (—Ç—ë–º–Ω–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ã–π)
            EDGE: '#9a8d7a',             // –ö—Ä–∞—è –º–µ–∂–¥—É –ø–ª–∏—Ç–∞–º–∏
            MOSS: '#7a8f63',             // –ú–æ—Ö (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

            // LEGACY - –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º
            MAIN: '#c5b8a1',             // = STONE_BASE (fallback)
            DETAIL: '#8b7e6a',           // = CRACK (fallback)
            GRID: '#9a8d7a',             // = EDGE (fallback)
            BORDER: '#9a8d7a',           // = EDGE (fallback)
        },
        DECOR: {
            TREE: {
                BASE: '#3a4a2f', // Match –Ω–æ–≤—É—é grass
                FOLIAGE_LIGHT: '#2e4d32',
                FOLIAGE_DARK: '#1b3e20',
            },
            ROCK: {
                BASE: '#3a4a2f',
                STONE: '#5a606c', // –¢–µ–º–Ω–µ–µ –¥–ª—è Dark —Å—Ç–∏–ª—è
            }
        },
        FOG: {
            BASE: '#263238',
        }
    },
    // –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–µ—Ç–∞ (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –§–∞–∑—ã 5!)
    LIGHTING: {
        GLOBAL_LIGHT_ANGLE: Math.PI * 0.75,  // 135¬∞ (—Å–µ–≤–µ—Ä–æ-–∑–∞–ø–∞–¥ ‚Üí —é–≥–æ-–≤–æ—Å—Ç–æ–∫)
        SHADOW_OFFSET_X: 3,   // px —Å–º–µ—â–µ–Ω–∏—è —Ç–µ–Ω–∏
        SHADOW_OFFSET_Y: 3,
        HIGHLIGHT_OFFSET_X: -2,  // px –±–ª–∏–∫–∞ (–ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ —Ç–µ–Ω–∏)
        HIGHLIGHT_OFFSET_Y: -2,
    },
    TOWER: {
        BASE: {
            PLATFORM: '#9e9e9e', // Grey 500
            RIM: '#616161',      // Grey 700
            RIVETS: '#424242',
        },
        TURRET: {
            STANDARD: {
                MAIN: '#616161',
                STROKE: '#212121',
                BARREL: '#616161',
            },
            ICE: {
                MAIN: '#00acc1', // Cyan 600
                STROKE: '#e0f7fa',
                SPIKE: '#4dd0e1', // Cyan 300
            },
            FIRE: {
                MAIN: '#f4511e', // Deep Orange 600
                STROKE: '#ffccbc',
                BARREL: '#ff7043',
                TIP: '#bf360c',
            },
            SNIPER: {
                MAIN: '#2e7d32', // Green 800
                BARREL: '#1b5e20', // Green 900
                MUZZLE: '#4caf50',
            },
            SPLIT: {
                MAIN: '#f57f17', // Yellow 900
                BARREL: '#fbc02d', // Yellow 700
            }
        },
        MODULES: {
            ICE: {
                BODY: '#0277bd',
                LIQUID: '#4fc3f7',
                CAP: '#eceff1',
            },
            FIRE: {
                BODY: '#c62828',
                SYMBOL: '#ffeb3b',
            },
            SNIPER: {
                BODY: '#212121',
                LENS: '#00e5ff',
            },
            SPLIT: {
                BODY: '#ff6f00',
                ACCENT: '#ffd54f',
            }
        },
        BUILDING: {
            BASE: 'rgba(158, 158, 158, 0.5)',
            BAR_BG: '#333',
            BAR_FILL: 'gold',
        },
        LASER: 'rgba(255, 0, 0, 0.3)',
        RANGE_CIRCLE: {
            FILL: 'rgba(0, 255, 255, 0.1)',
            STROKE: 'rgba(0, 255, 255, 0.4)',
        }
    },
    ENEMY: {
        SKELETON: {
            BONE: '#e0e0e0',
            EYES: '#212121',
        },
        WOLF: {
            BODY: '#5d4037',
            EYES: '#ff1744',
        },
        TROLL: {
            SKIN: '#558b2f',
            FEATURE: '#33691e',
        },
        SPIDER: {
            BODY: '#311b92',
            HEAD: '#4527a0',
            EYES: '#d50000',
        },
        PROPS: {
            SHIELD: { WOOD: '#8d6e63', METAL: '#bdbdbd' },
            HELMET: { GOLD: '#ffd700', HORN: '#e0e0e0' },
            BARRIER: { FILL: 'rgba(100, 255, 218, 0.4)', STROKE: 'rgba(255, 255, 255, 0.8)' },
            WEAPON: { HANDLE: '#5d4037', GUARD: '#ffd700', BLADE: '#cfd8dc' },
        }
    },
    PROJECTILES: {
        STANDARD: '#fff',
        ICE: '#00bcd4',
        FIRE: '#f44336',
        SNIPER: '#4caf50',
        SPLIT: '#ff9800',
    }
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": [
      "ESNext",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "strict": false,
    "noImplicitAny": true,
    "strictPropertyInitialization": false,
    "strictNullChecks": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitReturns": true,
    "types": [
      "vite/client",
      "jest",
      "node"
    ]
  },
  "include": [
    "src/**/*",
    "__tests__/**/*"
  ]
}
</file>

<file path="src/BestiarySystem.ts">
import { GameScene } from './scenes/GameScene';
import { CONFIG } from './Config';

export class BestiarySystem {
    private scene: GameScene;
    private unlockedEnemies: Set<string> = new Set();

    private btn!: HTMLElement;
    private panel!: HTMLElement;
    private listContainer!: HTMLElement;
    private isVisible: boolean = false;

    constructor(scene: GameScene) {
        this.scene = scene;

        // –°–æ–∑–¥–∞–µ–º UI —ç–ª–µ–º–µ–Ω—Ç—ã
        this.createUI();

        // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –æ—Ç–∫—Ä—ã–≤–∞–µ–º –ø–µ—Ä–≤–æ–≥–æ –≤—Ä–∞–≥–∞
        this.unlock('grunt');
    }

    public unlock(typeId: string) {
        const id = typeId.toLowerCase();
        if (!this.unlockedEnemies.has(id)) {
            this.unlockedEnemies.add(id);
            // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≤—Å–ø–ª—ã–≤–∞—é—â–µ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ scene.showFloatingText
            // –ù–æ –ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–∏–º —Å–ø–∏—Å–æ–∫, –µ—Å–ª–∏ –ø–∞–Ω–µ–ª—å –æ—Ç–∫—Ä—ã—Ç–∞
            if (this.isVisible) this.renderList();
        }
    }

    private createUI() {
        // 1. –ö–Ω–æ–ø–∫–∞ (–ö–Ω–∏–≥–∞)
        this.btn = document.createElement('div');
        this.btn.innerText = 'üìñ';
        this.btn.title = 'Bestiary';
        Object.assign(this.btn.style, {
            position: 'absolute',
            top: '20px',
            left: '20px',
            width: '40px',
            height: '40px',
            background: 'rgba(0,0,0,0.6)',
            color: '#fff',
            border: '2px solid #aaa',
            borderRadius: '50%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '24px',
            cursor: 'pointer',
            zIndex: '100',
            userSelect: 'none',
            transition: 'transform 0.1s',
        });

        this.btn.onmousedown = () => (this.btn.style.transform = 'scale(0.9)');
        this.btn.onmouseup = () => (this.btn.style.transform = 'scale(1)');
        this.btn.onclick = () => this.toggle();

        document.body.appendChild(this.btn);

        // 2. –ü–∞–Ω–µ–ª—å (–°–ø–∏—Å–æ–∫)
        this.panel = document.createElement('div');
        Object.assign(this.panel.style, {
            position: 'absolute',
            top: '70px',
            left: '20px',
            width: '300px',
            maxHeight: '400px',
            background: 'rgba(20, 20, 30, 0.95)',
            border: '2px solid #888',
            borderRadius: '8px',
            padding: '10px',
            display: 'none',
            flexDirection: 'column',
            gap: '10px',
            overflowY: 'auto',
            zIndex: '100',
            color: '#fff',
            fontFamily: 'Segoe UI, sans-serif',
        });

        // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –ø–∞–Ω–µ–ª–∏
        const title = document.createElement('div');
        title.innerText = 'BESTIARY';
        title.style.textAlign = 'center';
        title.style.fontWeight = 'bold';
        title.style.borderBottom = '1px solid #555';
        title.style.paddingBottom = '5px';
        this.panel.appendChild(title);

        // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        this.listContainer = document.createElement('div');
        this.listContainer.style.display = 'flex';
        this.listContainer.style.flexDirection = 'column';
        this.listContainer.style.gap = '8px';
        this.panel.appendChild(this.listContainer);

        document.body.appendChild(this.panel);
    }

    private toggle() {
        this.isVisible = !this.isVisible;
        this.panel.style.display = this.isVisible ? 'flex' : 'none';
        if (this.isVisible) {
            this.renderList();
        }
    }

    private renderList() {
        this.listContainer.innerHTML = '';

        // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º —Ç–∏–ø–∞–º –≤—Ä–∞–≥–æ–≤ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
        const types = CONFIG.ENEMY_TYPES;
        for (const key in types) {
            const conf = types[key as keyof typeof types];
            const isUnlocked = this.unlockedEnemies.has(conf.id.toLowerCase());

            const row = document.createElement('div');
            Object.assign(row.style, {
                display: 'flex',
                alignItems: 'center',
                gap: '10px',
                padding: '8px',
                background: 'rgba(255,255,255,0.05)',
                borderRadius: '4px',
            });

            if (isUnlocked) {
                row.innerHTML = `
                    <div style="font-size: 24px; width: 30px; text-align: center;">${conf.symbol}</div>
                    <div>
                        <div style="font-weight: bold; color: ${conf.color || '#fff'}">${key}</div>
                        <div style="font-size: 11px; color: #aaa;">HP: ${Math.round(CONFIG.ENEMY.BASE_HP * conf.hpMod)} | Spd: ${conf.speed}</div>
                        <div style="font-size: 11px; color: gold;">Reward: ${conf.reward}üí∞</div>
                    </div>
                `;
            } else {
                row.innerHTML = `
                    <div style="font-size: 24px; width: 30px; text-align: center; filter: grayscale(1); opacity: 0.5;">‚ùì</div>
                    <div>
                        <div style="font-weight: bold; color: #555">???</div>
                        <div style="font-size: 11px; color: #555;">Locked</div>
                    </div>
                `;
            }
            this.listContainer.appendChild(row);
        }
    }
}
</file>

<file path="src/cards/SniperCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Sniper Card Upgrades
 * 
 * Level 1: +80 range, +14 damage, -50% attack speed, 10% crit chance
 * Level 2: +160 range, +24 damage, -35% attack speed, 15% crit chance
 * Level 3: +240 range, +46 damage, -15% attack speed, 20% crit chance, pierce 2 enemies (15% damage loss each)
 */
export const SNIPER_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damage: 14,
            range: 80,
            attackSpeedMultiplier: 0.30, // -70% attack speed (slower)
            critChance: 0.15, // 15% crit chance
        },
        effects: [],
        visualOverrides: {
            projectileType: 'sniper',
            projectileColor: '#4caf50',
            projectileSpeed: 15,
        }
    },
    2: {
        level: 2,
        modifiers: {
            damage: 24,
            range: 160,
            attackSpeedMultiplier: 0.45, // -55% attack speed
            critChance: 0.15,
        },
        effects: []
    },
    3: {
        level: 3,
        modifiers: {
            damage: 46,
            range: 240,
            attackSpeedMultiplier: 0.60, // -40% attack speed (improved from level 2)
            critChance: 0.20,
        },
        effects: [
            {
                type: 'pierce',
                pierceCount: 2, // Pierce through 2 enemies
                pierceDamageLoss: 0.15, // Lose 15% damage per pierce
            }
        ]
    }
};
</file>

<file path="src/FogSystem.ts">
import { IMapData } from './MapData';
import { FogRenderer } from './FogRenderer';
import { FogStructure, buildFogStructures } from './FogStructure';
import { CONFIG } from './Config';
import { InkFogRenderer } from './graphics/InkFogRenderer';

/**
 * Fog System - manages layered fog with density and structure-based animation
 * @description
 * Supports 6 density levels:
 * - 0: No fog (visible)
 * - 1: 20% density
 * - 2: 40% density
 * - 3: 60% density
 * - 4: 80% density
 * - 5: 100% density
 */
export class FogSystem {
    private mapData: IMapData;
    private renderer: FogRenderer;
    private inkRenderer: InkFogRenderer;
    private structures: FogStructure[] = [];
    private time: number = 0;
    private dirty: boolean = true;

    constructor(mapData: IMapData) {
        this.mapData = mapData;

        // Initialize fog data if missing
        if (!this.mapData.fogData) {
            this.mapData.fogData = Array(mapData.width * mapData.height).fill(0);
        } else if (this.mapData.fogData.length !== mapData.width * mapData.height) {
            const newData = Array(mapData.width * mapData.height).fill(0);
            this.mapData.fogData = newData;
        }

        // Create standard renderer
        this.renderer = new FogRenderer(
            mapData.width * 64, // Assuming TILE_SIZE = 64
            mapData.height * 64
        );

        // Create ink renderer
        this.inkRenderer = new InkFogRenderer(
            mapData.width * 64, // Assuming TILE_SIZE = 64
            mapData.height * 64
        );

        this.buildStructures();
    }

    /**
     * Build fog structures from current fog data
     */
    private buildStructures(): void {
        this.structures = buildFogStructures(
            this.mapData.fogData!,
            this.mapData.width,
            this.mapData.height
        );
        this.dirty = false;

        console.log(`FogSystem: Found ${this.structures.length} fog structures`);
    }

    /**
     * Update fog animation
     */
    public update(dt: number = 0.016): void {
        // Rebuild structures if data changed
        if (this.dirty) {
            this.buildStructures();
        }

        const t = (dt > 0) ? (this.time += dt * 60) : 0;

        // Only animate if dt > 0 (game mode)
        if (CONFIG.VISUAL_STYLE === 'INK') {
            this.inkRenderer.render(this.structures, t);
        } else {
            if (dt > 0 || this.time === 0) { // Render Sprite logic
                this.renderer.render(this.structures, this.time);
            }
        }
    }

    /**
     * Draw fog to main canvas
     */
    public draw(ctx: CanvasRenderingContext2D): void {
        ctx.save();
        if (CONFIG.VISUAL_STYLE === 'INK') {
            ctx.drawImage(this.inkRenderer.getCanvas(), 0, 0);
        } else {
            ctx.drawImage(this.renderer.getCanvas(), 0, 0);
        }
        ctx.restore();
    }

    /**
     * Set fog density at specific tile
     * @param x Column
     * @param y Row
     * @param density 0-5 (0 = no fog, 5 = max density)
     */
    public setFog(x: number, y: number, density: number): void {
        if (x < 0 || x >= this.mapData.width || y < 0 || y >= this.mapData.height) return;
        if (density < 0 || density > 5) return;

        const index = y * this.mapData.width + x;
        if (this.mapData.fogData![index] !== density) {
            this.mapData.fogData![index] = density;
            this.dirty = true;
        }
    }

    /**
     * Get fog density at specific tile
     */
    public getFog(x: number, y: number): number {
        if (x < 0 || x >= this.mapData.width || y < 0 || y >= this.mapData.height) return 0;
        const index = y * this.mapData.width + x;
        return this.mapData.fogData![index] || 0;
    }

    /**
     * Cycle fog density (1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 1)
     * For editor use - each click increases density
     */
    public cycleFogDensity(x: number, y: number): void {
        const current = this.getFog(x, y);
        let next: number;

        if (current === 0) {
            // First click on empty tile -> density 1
            next = 1;
        } else if (current >= 5) {
            // Max density -> back to 1
            next = 1;
        } else {
            // Increment density
            next = current + 1;
        }

        this.setFog(x, y, next);
    }

    /**
     * Get fog data array
     */
    public getFogData(): number[] {
        return this.mapData.fogData || [];
    }

    /**
     * Legacy method for compatibility
     * @deprecated Use setFog or cycleFogDensity instead
     */
    public toggleFog(col: number, row: number): void {
        this.cycleFogDensity(col, row);
    }
}
</file>

<file path="src/ForgeSystem.ts">
import { IGameScene } from './scenes/IGameScene';
import { CardSystem, ICard } from './CardSystem';
import { CONFIG } from './Config';

export class ForgeSystem {
    private scene: IGameScene;
    private slotEls: HTMLElement[];

    public forgeSlots: (ICard | null)[] = [null, null];
    public isForging: boolean = false;

    constructor(scene: IGameScene) {
        this.scene = scene;
        // –ö—ç—à–∏—Ä—É–µ–º DOM —ç–ª–µ–º–µ–Ω—Ç—ã —Å–ª–æ—Ç–æ–≤. 
        // –í –∏–¥–µ–∞–ª–µ —ç—Ç–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤ UIManager, –Ω–æ –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–∏–º –∑–¥–µ—Å—å –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏.
        this.slotEls = [document.getElementById('forge-slot-0')!, document.getElementById('forge-slot-1')!];
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –æ—Ç–ø—É—Å—Ç–∏–ª–∏ –ª–∏ –º—ã—à—å –Ω–∞–¥ —Å–ª–æ—Ç–æ–º –∫—É–∑–Ω–∏—Ü—ã.
     * –ï—Å–ª–∏ –¥–∞ - –∫–ª–∞–¥–µ—Ç –∫–∞—Ä—Ç—É –≤ —Å–ª–æ—Ç.
     */
    public tryDropCard(mouseX: number, mouseY: number, card: ICard): boolean {
        // –ù–µ–ª—å–∑—è –∫–ª–∞—Å—Ç—å –∫–∞—Ä—Ç—ã, –ø–æ–∫–∞ –∏–¥–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –∫–æ–≤–∫–∏
        if (this.isForging) return false;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π —Å–ª–æ—Ç
        for (let i = 0; i < this.slotEls.length; i++) {
            const rect = this.slotEls[i].getBoundingClientRect();

            // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –∫—É—Ä—Å–æ—Ä –≤–Ω—É—Ç—Ä–∏ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ —Å–ª–æ—Ç–∞?
            if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) {
                // –ï—Å–ª–∏ —Å–ª–æ—Ç –∑–∞–Ω—è—Ç - –Ω–µ –∫–ª–∞–¥–µ–º
                if (this.forgeSlots[i] !== null) {
                    return false;
                }

                // –£—Å–ø–µ—Ö: –∫–ª–∞–¥–µ–º –∫–∞—Ä—Ç—É
                this.putInForgeSlot(i, card);
                return true;
            }
        }
        return false;
    }

    public canForge(): boolean {
        const c1 = this.forgeSlots[0];
        const c2 = this.forgeSlots[1];
        return !!(c1 && c2 && c1.type.id === c2.type.id && c1.level === c2.level && c1.level < 3);
    }

    public putInForgeSlot(slotIdx: number, card: ICard) {
        this.scene.cardSys.removeCardFromHand(card);
        this.forgeSlots[slotIdx] = card;
        this.render();
        // UI update via generic update or event would be better
        this.scene.ui.update();
    }

    public returnFromForge(slotIdx: number) {
        const card = this.forgeSlots[slotIdx];
        if (card) {
            this.forgeSlots[slotIdx] = null;
            this.scene.cardSys.hand.push(card); // Push back to hand
            this.scene.cardSys.render(); // Re-render hand
            this.render();
            this.scene.ui.update();
        }
    }

    public tryForge() {
        if (!this.canForge()) return;

        // Progressive Forge Cost
        const card = this.forgeSlots[0]!;
        const cost = card.level === 1
            ? CONFIG.ECONOMY.FORGE_COST_LVL1   // 50
            : CONFIG.ECONOMY.FORGE_COST_LVL2;  // 65

        // Logic decoupled from UI floating text hopefully? 
        // No, we still need feedback.
        if (this.scene.money < cost) {
            this.scene.showFloatingText('Need Money!', 500, 500, 'red');
            return;
        }

        if (!this.scene.spendMoney(cost)) {
            return;
        }
        this.isForging = true;

        // Get forge slot position for particle effects
        const forgeSlot0 = this.slotEls[0];
        const forgeSlot1 = this.slotEls[1];
        const canvas = this.scene.game.canvas;
        const canvasRect = canvas.getBoundingClientRect();

        // Add visual feedback to forge slots (CSS classes)
        if (forgeSlot0) forgeSlot0.classList.add('forging');
        if (forgeSlot1) forgeSlot1.classList.add('forging');

        // Calculate center position between slots for effects
        let effectX = 200;
        let effectY = canvas.height - 300;

        if (forgeSlot0 && forgeSlot1) {
            const rect0 = forgeSlot0.getBoundingClientRect();
            const rect1 = forgeSlot1.getBoundingClientRect();
            const centerX = (rect0.left + rect1.right) / 2;
            const centerY = (rect0.top + rect0.bottom) / 2;

            // Convert screen coords to canvas coords
            effectX = (centerX - canvasRect.left) * (canvas.width / canvasRect.width);
            effectY = (centerY - canvasRect.top) * (canvas.height / canvasRect.height);
        }

        // Spawn particles during forge animation
        let forgeFrame = 0;
        const particleInterval = setInterval(() => {
            forgeFrame++;
            // const intensity = 1 + (forgeFrame / 16); 

            for (let i = 0; i < 5; i++) {
                this.scene.effects.add({
                    type: 'particle',
                    x: effectX + (Math.random() - 0.5) * 80,
                    y: effectY + (Math.random() - 0.5) * 50,
                    vx: (Math.random() - 0.5) * 6,
                    vy: -(Math.random() * 4 + 1),
                    life: 30 + Math.random() * 20,
                    radius: Math.random() * 4 + 2,
                    color: Math.random() > 0.5 ? '#ff9800' : '#ffeb3b', // Orange/Yellow sparks
                });
            }
        }, 50);

        // Forging complete
        setTimeout(() => {
            clearInterval(particleInterval);

            // Remove forging animation from slots
            if (forgeSlot0) forgeSlot0.classList.remove('forging');
            if (forgeSlot1) forgeSlot1.classList.remove('forging');

            const c1 = this.forgeSlots[0]!;
            const newLevel = c1.level + 1;

            // Find card type key
            let typeKey = 'FIRE';
            for (const k in CONFIG.CARD_TYPES) {
                if (CONFIG.CARD_TYPES[k].id === c1.type.id) {
                    typeKey = k;
                    break;
                }
            }

            this.forgeSlots = [null, null];
            this.isForging = false;

            // Add upgraded card back to hand
            this.scene.cardSys.addCard(typeKey, newLevel);

            // Enhanced completion effects
            this.scene.effects.add({
                type: 'explosion',
                x: effectX,
                y: effectY,
                radius: 60,
                life: 35,
                color: '#ffd700', // Gold
            });

            // Burst of particles
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                this.scene.effects.add({
                    type: 'particle',
                    x: effectX,
                    y: effectY,
                    vx: Math.cos(angle) * 5,
                    vy: Math.sin(angle) * 5,
                    life: 40,
                    radius: 4,
                    color: '#ffd700',
                });
            }

            this.scene.showFloatingText('‚öíÔ∏è FORGED!', effectX, effectY - 30, 'gold');

            // Re-render
            this.render();
            this.scene.ui.update();

        }, 800);
    }

    public render() {
        this.slotEls.forEach((el, idx) => {
            el.innerHTML = '';
            const slotCard = this.forgeSlots[idx];
            if (slotCard) {
                const cardEl = CardSystem.createCardElement(slotCard);
                cardEl.onclick = () => this.returnFromForge(idx);
                el.appendChild(cardEl);
            } else {
                el.innerText = (idx + 1).toString();
            }
        });
    }

    public update() {
        // No per-frame update needed for now
    }
}
</file>

<file path="src/InspectorSystem.ts">
import { GameScene } from './scenes/GameScene';
import { Tower } from './Tower';
import { CONFIG } from './Config';

export class InspectorSystem {
    private scene: GameScene;
    private elInspector: HTMLElement;
    private elName: HTMLElement;
    private elStats: HTMLElement;
    private elCardsContainer: HTMLElement;
    private elSellBtn: HTMLButtonElement;

    private currentTower: Tower | null = null;

    constructor(scene: GameScene) {
        this.scene = scene;
        this.elInspector = document.createElement('div');

        // Create inspector panel
        this.elInspector.id = 'inspector-panel';
        this.elInspector.className = 'ui-panel'; // Use existing panel style
        Object.assign(this.elInspector.style, {
            background: 'rgba(20, 20, 30, 0.95)',
            border: '2px solid #555',
            borderRadius: '8px',
            padding: '15px',
            color: '#fff',
            display: 'none',
            pointerEvents: 'auto',
            marginBottom: '15px', // Space above shop panel
        });

        this.elName = document.createElement('h3');
        this.elName.style.margin = '0 0 10px 0';
        this.elName.style.textAlign = 'center';

        this.elStats = document.createElement('div');
        this.elStats.style.fontSize = '13px';
        this.elStats.style.marginBottom = '10px';

        this.elCardsContainer = document.createElement('div');
        Object.assign(this.elCardsContainer.style, {
            borderTop: '1px solid #555',
            paddingTop: '10px',
            marginTop: '10px',
        });

        this.elSellBtn = document.createElement('button');
        this.elSellBtn.innerText = 'üóëÔ∏è –ü–†–û–î–ê–¢–¨ –ë–ê–®–ù–Æ';
        Object.assign(this.elSellBtn.style, {
            marginTop: '10px',
            padding: '12px',
            background: '#d32f2f',
            color: '#fff',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            fontWeight: 'bold',
            width: '100%',
            fontSize: '14px',
        });

        // CRITICAL: Use addEventListener for better event handling
        this.elSellBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event from bubbling to canvas
            e.preventDefault();
            console.log('Sell button clicked! Tower:', this.currentTower);
            if (this.currentTower) {
                this.scene.sellTower(this.currentTower);
            }
        });

        this.elInspector.appendChild(this.elName);
        this.elInspector.appendChild(this.elStats);
        this.elInspector.appendChild(this.elCardsContainer);
        this.elInspector.appendChild(this.elSellBtn);

        // CRITICAL: Attach to #ui-right container, NOT document.body
        // This ensures proper event handling within the UI layer
        const uiRight = document.getElementById('ui-right');
        if (uiRight) {
            // Insert at the beginning so it appears above shop
            uiRight.insertBefore(this.elInspector, uiRight.firstChild);
        } else {
            // Fallback to body if ui-right not found
            document.body.appendChild(this.elInspector);
        }
    }

    public selectTower(tower: Tower) {
        this.currentTower = tower;
        this.elInspector.style.display = 'block';
        this.updateInfo();
    }

    public hide() {
        this.currentTower = null;
        this.elInspector.style.display = 'none';
    }

    private updateInfo() {
        if (!this.currentTower) return;

        this.elName.innerText = 'üè∞ –ë–∞—à–Ω—è';

        // Get tower stats
        const stats = this.currentTower.getStats();

        // Build stats display
        let statsHTML = '';
        statsHTML += `<div>‚öîÔ∏è –£—Ä–æ–Ω: ${stats.dmg.toFixed(1)}</div>`;
        statsHTML += `<div>üìè –†–∞–¥–∏—É—Å: ${stats.range.toFixed(0)}</div>`;
        statsHTML += `<div>‚è±Ô∏è –°–∫–æ—Ä–æ—Å—Ç—å: ${(60 / stats.cd).toFixed(1)}/—Å</div>`;
        if (stats.pierce > 0) {
            statsHTML += `<div>üéØ –ü—Ä–æ–±–∏–≤–∞–Ω–∏–µ: ${stats.pierce}</div>`;
        }
        this.elStats.innerHTML = statsHTML;

        // Clear and rebuild cards container
        this.elCardsContainer.innerHTML = '';

        // === TARGETING MODE SELECTOR ===
        const targetingSection = document.createElement('div');
        Object.assign(targetingSection.style, {
            borderBottom: '1px solid #555',
            paddingBottom: '10px',
            marginBottom: '10px',
        });

        const targetingLabel = document.createElement('div');
        targetingLabel.innerText = '–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Ü–µ–ª–∏:';
        Object.assign(targetingLabel.style, {
            fontSize: '12px',
            color: '#aaa',
            marginBottom: '5px',
            textAlign: 'center',
        });
        targetingSection.appendChild(targetingLabel);

        const targetingRow = document.createElement('div');
        Object.assign(targetingRow.style, {
            display: 'flex',
            gap: '5px',
            justifyContent: 'center',
        });

        // Create buttons for each targeting mode
        Object.values(CONFIG.TARGETING_MODES).forEach((mode: any) => {
            const btn = document.createElement('button');
            btn.innerText = mode.icon;
            btn.title = `${mode.name}: ${mode.desc}`;

            const isActive = this.currentTower!.targetingMode === mode.id;
            Object.assign(btn.style, {
                width: '36px',
                height: '36px',
                fontSize: '18px',
                background: isActive ? '#4caf50' : '#444',
                border: `2px solid ${isActive ? '#fff' : '#666'}`,
                borderRadius: '6px',
                cursor: 'pointer',
                transition: 'all 0.15s',
            });

            btn.addEventListener('mouseenter', () => {
                if (!isActive) btn.style.background = '#555';
            });
            btn.addEventListener('mouseleave', () => {
                if (!isActive) btn.style.background = '#444';
            });

            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                if (this.currentTower) {
                    this.currentTower.targetingMode = mode.id;
                    console.log('Targeting mode changed to:', mode.id);
                    this.updateInfo(); // Refresh to show new selection
                }
            });

            targetingRow.appendChild(btn);
        });

        targetingSection.appendChild(targetingRow);
        this.elCardsContainer.appendChild(targetingSection);
        // === END TARGETING MODE SELECTOR ===

        const label = document.createElement('div');
        label.style.fontSize = '12px';
        label.style.color = '#aaa';
        label.style.marginBottom = '5px';
        label.style.textAlign = 'center';
        label.innerText = '–ö–∞—Ä—Ç—ã (–∫–ª–∏–∫ = –ø—Ä–æ–¥–∞—Ç—å):';
        this.elCardsContainer.appendChild(label);

        const cardsRow = document.createElement('div');
        Object.assign(cardsRow.style, {
            display: 'flex',
            gap: '5px',
            justifyContent: 'center',
        });

        for (let i = 0; i < 3; i++) {
            const slotEl = document.createElement('div');

            if (this.currentTower.cards[i]) {
                const card = this.currentTower.cards[i];
                const stars = '‚òÖ'.repeat(card.level);
                const sellPrice = CONFIG.ECONOMY.CARD_SELL_PRICES[card.level] || 5;

                Object.assign(slotEl.style, {
                    width: '50px',
                    height: '70px',
                    background: card.type.color,
                    borderRadius: '4px',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    border: '2px solid rgba(255,255,255,0.3)',
                    position: 'relative',
                    cursor: 'pointer',
                    transition: 'transform 0.1s, box-shadow 0.1s',
                });

                slotEl.innerHTML = `
                    <div style="position: absolute; top: 2px; left: 2px; font-size: 8px; color: #fff;">${stars}</div>
                    <div style="font-size: 24px;">${card.type.icon}</div>
                    <div style="font-size: 10px; color: #fff; margin-top: 2px;">${sellPrice}üí∞</div>
                `;

                // Hover effect
                slotEl.onmouseenter = () => {
                    slotEl.style.transform = 'scale(1.1)';
                    slotEl.style.boxShadow = '0 0 10px gold';
                };
                slotEl.onmouseleave = () => {
                    slotEl.style.transform = 'scale(1)';
                    slotEl.style.boxShadow = 'none';
                };

                // Click to sell card
                const cardIndex = i;
                slotEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    console.log('Card sell clicked! Index:', cardIndex, 'Tower:', this.currentTower);
                    if (this.currentTower) {
                        this.scene.sellCardFromTower(this.currentTower, cardIndex);
                    }
                });
            } else {
                // Empty slot
                Object.assign(slotEl.style, {
                    width: '50px',
                    height: '70px',
                    background: '#333',
                    borderRadius: '4px',
                    border: '1px dashed #555',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: '#555',
                    fontSize: '18px',
                });
                slotEl.innerText = '?';
            }

            cardsRow.appendChild(slotEl);
        }

        this.elCardsContainer.appendChild(cardsRow);

        // Update sell button with refund amount
        const refund = Math.floor(CONFIG.ECONOMY.TOWER_COST * CONFIG.ECONOMY.SELL_REFUND);
        this.elSellBtn.innerText = `üóëÔ∏è –ü–†–û–î–ê–¢–¨ (+${refund}üí∞)`;
    }
}
</file>

<file path="package.json">
{
  "name": "newtower-1.1",
  "version": "1.4.0-alpha",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "jest",
    "dev": "vite",
    "build": "tsc --noEmit && vite build",
    "preview": "vite preview",
    "lint": "eslint src/**/*.ts",
    "format": "prettier --write src/**/*.ts"
  },
  "repository": {
    "type": "git",
    "url": "git+https://guardokaz39-del@github.com/guardokaz39-del/NewTower-CardTD.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/guardokaz39-del/NewTower-CardTD/issues"
  },
  "homepage": "https://github.com/guardokaz39-del/NewTower-CardTD#readme",
  "devDependencies": {
    "@types/jest": "^30.0.0",
    "@types/node": "^24.10.1",
    "@typescript-eslint/eslint-plugin": "^8.48.1",
    "@typescript-eslint/parser": "^8.48.1",
    "eslint": "^9.39.1",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.4",
    "jest": "^30.2.0",
    "prettier": "^3.7.4",
    "ts-jest": "^29.4.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3",
    "vite": "^7.3.0",
    "vite-plugin-checker": "^0.12.0"
  }
}
</file>

<file path="src/cards/CardType.ts">
/**
 * Base interfaces and types for the upgrade card system
 */

export interface ICardModifiers {
    damage?: number;              // Flat damage bonus
    damageMultiplier?: number;    // Multiplier for base damage (e.g., 0.30 = 30% of base)
    attackSpeedMultiplier?: number; // Multiplier for attack speed (0.85 = -15% speed, 1.0 = no change)
    range?: number;               // Flat range bonus
    rangeMultiplier?: number;     // Multiplier for range
    critChance?: number;          // Critical hit chance (0-1)
}

export interface ICardEffect {
    type: 'splash' | 'slow' | 'pierce' | 'explodeOnDeath' | 'chainSlowOnDeath' | 'spinup';

    // Splash effect properties
    splashRadius?: number;

    // Slow effect properties
    slowPower?: number;           // 0-1, where 0.2 = 20% slow
    slowDuration?: number;        // Frames
    damageToSlowed?: number;      // Damage multiplier for slowed enemies (1.2 = +20% damage)

    // Pierce properties
    pierceCount?: number;         // Number of enemies to pierce through
    pierceDamageLoss?: number;    // Damage loss per pierce (0.15 = 15% loss)

    // Explosion on death properties
    explosionDamagePercent?: number; // Percent of tower damage (0.5 = 50%)
    explosionRadius?: number;

    // Chain slow properties
    chainRadius?: number;

    // Spinup properties (Minigun mechanic)
    spinupDamagePerSecond?: number;   // Flat damage bonus per second of continuous fire
    spinupCritPerSecond?: number;     // Crit chance bonus per second (0.02 = 2%)
    spinupSteps?: Array<{ threshold: number; damage: number }>; // For stepped damage (level 3)
    maxSpinupSeconds?: number;        // Maximum spinup time (7 seconds)
    overheatDuration?: number;        // Overheat lockout duration in frames (90 or 180)
    overheatExtensionWithIce?: number; // Bonus time before overheat when combined with Ice card (180 frames = 3 sec)

    // Legacy/Generic properties (fixing TS errors)
    radius?: number;
    dur?: number;
    power?: number;
}

export interface ICardVisualOverrides {
    projectileType?: string;    // Visual type: 'standard', 'fire', 'ice', 'sniper', 'minigun', 'split'
    projectileColor?: string;   // Hex color for projectile
    projectileSpeed?: number;   // Projectile travel speed
}

export interface IUpgradeCard {
    level: number;
    modifiers: ICardModifiers;
    effects: ICardEffect[];
    visualOverrides?: ICardVisualOverrides; // NEW: Data-driven visuals
}

/**
 * Merge multiple card modifiers into one
 */
export function mergeModifiers(modifiers: ICardModifiers[]): ICardModifiers {
    const result: ICardModifiers = {
        damage: 0,
        attackSpeedMultiplier: 1.0,
        range: 0,
        rangeMultiplier: 1.0,
        critChance: 0,
    };

    modifiers.forEach(mod => {
        result.damage! += mod.damage || 0;
        result.attackSpeedMultiplier! *= mod.attackSpeedMultiplier || 1.0;
        result.range! += mod.range || 0;
        result.rangeMultiplier! *= mod.rangeMultiplier || 1.0;
        result.critChance! = Math.max(result.critChance!, mod.critChance || 0);
    });

    return result;
}

/**
 * Merge multiple card effects into one array
 */
export function mergeEffects(effectArrays: ICardEffect[][]): ICardEffect[] {
    const result: ICardEffect[] = [];
    effectArrays.forEach(effects => {
        result.push(...effects);
    });
    return result;
}
</file>

<file path="src/cards/IceCard.ts">
import { IUpgradeCard } from './CardType';

/**
 * Ice Card Upgrades
 * 
 * Level 1: 30% slow, -10% range, +1 damage
 * Level 2: 45% slow, -20% range, +3 damage, +20% damage to slowed enemies
 * Level 3: 75% slow, -25% range, +6 damage, +40% damage to slowed, chain slow on death
 */
export const ICE_UPGRADES: Record<number, IUpgradeCard> = {
    1: {
        level: 1,
        modifiers: {
            damage: 1,
            rangeMultiplier: 0.90, // -10% range
        },
        effects: [
            {
                type: 'slow',
                slowPower: 0.30, // 30% slow
                slowDuration: 180, // 3 seconds at 60 FPS
            }
        ],
        visualOverrides: {
            projectileType: 'ice',
            projectileColor: '#00bcd4',
            projectileSpeed: 10,
        }
    },
    2: {
        level: 2,
        modifiers: {
            damage: 3,
            rangeMultiplier: 0.80, // -20% range
        },
        effects: [
            {
                type: 'slow',
                slowPower: 0.45, // 45% slow
                slowDuration: 270, // 4.5 seconds at 60 FPS
                damageToSlowed: 1.20, // +20% damage to slowed enemies
            }
        ]
    },
    3: {
        level: 3,
        modifiers: {
            damage: 6,
            rangeMultiplier: 0.75, // -25% range
        },
        effects: [
            {
                type: 'slow',
                slowPower: 0.75, // 75% slow
                slowDuration: 360, // 6 seconds at 60 FPS
                damageToSlowed: 1.40, // +40% damage to slowed enemies
            },
            {
                type: 'chainSlowOnDeath',
                chainRadius: 80,
            }
        ]
    }
};
</file>

<file path="src/scenes/EntityManager.ts">
import { Enemy } from '../Enemy';
import { Tower } from '../Tower';
import { ICard } from '../CardSystem';
import { CONFIG, getEnemyType } from '../Config';
import { EntityFactory } from '../EntityFactory';
import { GameState } from './GameState';
import { EffectSystem } from '../EffectSystem';
import { MetricsSystem } from '../MetricsSystem';
import { SoundManager } from '../SoundManager';

/**
 * Manages entity lifecycle:
 * - Tower building/selling
 * - Enemy spawning/death
 * - Projectile cleanup
 * - Visual effects coordination
 */
export class EntityManager {
    constructor(
        private state: GameState,
        private effects: EffectSystem,
        private metrics: MetricsSystem,
    ) { }

    // === Tower Management ===

    /**
     * Validate if a tower can be built at the given position
     */
    public canBuildTower(col: number, row: number, mapData: any, isBuildable: (c: number, r: number) => boolean): { valid: boolean; reason?: string } {
        if (!isBuildable(col, row)) {
            return { valid: false, reason: "Can't build here!" };
        }

        // Check existing tower
        const existingTower = this.state.towers.find((t) => t.col === col && t.row === row);
        if (existingTower) {
            return { valid: false, reason: 'Tower already here!' };
        }

        // Check money
        if (this.state.money < CONFIG.ECONOMY.TOWER_COST) {
            return { valid: false, reason: 'Not enough money!' };
        }

        return { valid: true };
    }

    /**
     * Build a tower at the specified position
     */
    public buildTower(col: number, row: number): Tower {
        this.state.spendMoney(CONFIG.ECONOMY.TOWER_COST);
        this.metrics.trackMoneySpent(CONFIG.ECONOMY.TOWER_COST);

        const tower = EntityFactory.createTower(col, row);
        tower.isBuilding = true;
        tower.buildProgress = 0;
        this.state.towers.push(tower);

        this.metrics.trackTowerBuilt();
        return tower;
    }

    /**
     * Sell an existing tower
     */
    public sellTower(tower: Tower): number {
        const idx = this.state.towers.indexOf(tower);
        if (idx === -1) return 0;

        this.state.towers.splice(idx, 1);
        const refund = Math.floor(CONFIG.ECONOMY.TOWER_COST * CONFIG.ECONOMY.SELL_REFUND);
        this.state.addMoney(refund);

        // Visual feedback
        this.showFloatingText(`+${refund}üí∞`, tower.x, tower.y, 'gold');

        if (this.state.selectedTower === tower) {
            this.state.selectTower(null);
        }

        return refund;
    }

    /**
     * Add a card to a tower or create new tower if none exists
     */
    public addCardToTower(card: ICard, col: number, row: number, isBuildable: (c: number, r: number) => boolean): boolean {
        let tower = this.state.towers.find((t) => t.col === col && t.row === row);

        // If no tower exists, we do NOT build one automatically on drop
        // User requested: "if card is carried not to tower base but to empty cell... it should return to hand"
        if (!tower) {
            return false;
        }

        // Add card to tower
        if (tower.cards.length < 3) {
            tower.cards.push(card);
            this.metrics.trackCardUsed(card.type.id);
            return true;
        }

        return false;
    }

    /**
     * Sell a card from a tower
     */
    public sellCardFromTower(tower: Tower, cardIndex: number): { card: ICard | null; refund: number } {
        const card = tower.removeCard(cardIndex);
        if (!card) return { card: null, refund: 0 };

        const prices = CONFIG.ECONOMY.CARD_SELL_PRICES;
        const refund = prices[card.level] || 5;
        this.state.addMoney(refund);

        this.showFloatingText(`+${refund}üí∞`, tower.x, tower.y - 30, 'gold');
        this.metrics.trackMoneyEarned(refund);

        return { card, refund };
    }

    // === Enemy Management ===

    /**
     * Spawn an enemy of the given type
     */
    public spawnEnemy(type: string, waypoints: { x: number; y: number }[]): Enemy | null {
        if (!waypoints || waypoints.length === 0) return null;

        const enemy = this.state.enemyPool.obtain();
        EntityFactory.setupEnemy(enemy, type, this.state.wave, waypoints);
        this.state.enemies.push(enemy);

        return enemy;
    }

    /**
     * Update enemy counter in HUD
     */
    private updateEnemyCounterUI(): void {
        // This will be called from updateEnemies
    }

    /**
     * Process enemy death - rewards, effects, cleanup
     */
    public handleEnemyDeath(enemy: Enemy): void {
        const reward = enemy.reward || 5;
        this.state.addMoney(reward);
        this.metrics.trackEnemyKilled();
        this.metrics.trackMoneyEarned(reward);

        const enemyTypeConf = getEnemyType(enemy.typeId.toUpperCase());

        // Scale pop animation (enemy "pops" before disappearing)
        const archetype = enemyTypeConf?.archetype || 'skeleton';
        this.effects.add({
            type: 'scale_pop',
            x: enemy.x,
            y: enemy.y,
            life: 12,
            enemySprite: `enemy_${archetype.toLowerCase()}`,
            enemyColor: enemyTypeConf?.color
        });

        // Soft death sound (throttled by SoundManager)
        SoundManager.play('death');

        // Floating text with emoji
        this.effects.add({
            type: 'text',
            text: `+${reward}üí∞`,
            x: enemy.x,
            y: enemy.y,
            life: 40,
            color: 'gold',
            vy: -1.5,
        });

        // Coin particle burst
        const particleCount = Math.min(3 + Math.floor(reward / 5), 8);
        for (let p = 0; p < particleCount; p++) {
            this.effects.add({
                type: 'particle',
                x: enemy.x + (Math.random() - 0.5) * 20,
                y: enemy.y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 6,
                vy: -(Math.random() * 4 + 2),
                life: 25 + Math.floor(Math.random() * 15),
                radius: 3 + Math.random() * 2,
                color: Math.random() > 0.3 ? '#ffd700' : '#ffeb3b',
            });
        }

        // Death debris (colored by enemy type)
        const debrisColor = enemyTypeConf?.color || '#888';
        const debrisCount = 4 + Math.floor(Math.random() * 3);
        for (let d = 0; d < debrisCount; d++) {
            this.effects.add({
                type: 'debris',
                x: enemy.x,
                y: enemy.y,
                vx: (Math.random() - 0.5) * 6,
                vy: -(Math.random() * 3 + 1),
                life: 25 + Math.floor(Math.random() * 10),
                size: 2 + Math.random() * 3,
                color: debrisColor,
                rotation: Math.random() * Math.PI * 2,
                vRot: (Math.random() - 0.5) * 0.3,
                gravity: 0.25,
            });
        }
    }

    /**
 * Process enemy reaching the end - lose life, cleanup
     */
    public handleEnemyFinished(enemy: Enemy): void {
        this.state.loseLife(1, this.effects); // Pass effects for screen flash
        this.metrics.trackLifeLost();
        // Removed triggerShake - flash effect is enough
        SoundManager.play('explosion', 1); // SoundPriority.HIGH = 1
    }

    /**
     * Update all enemies and handle death/finish
     */
    public updateEnemies(): void {
        for (let i = this.state.enemies.length - 1; i >= 0; i--) {
            const e = this.state.enemies[i];
            e.move();
            e.update();

            if (!e.isAlive()) {
                this.handleEnemyDeath(e);
                this.state.enemyPool.free(e);
                this.state.enemies.splice(i, 1);
            } else if (e.finished) {
                this.handleEnemyFinished(e);
                this.state.enemies.splice(i, 1);
                this.state.enemyPool.free(e);
            }
        }
    }

    // === Projectile Management ===

    /**
     * Update all projectiles and cleanup dead ones
     */
    public updateProjectiles(): void {
        for (let i = this.state.projectiles.length - 1; i >= 0; i--) {
            const p = this.state.projectiles[i];
            p.update(this.effects);
            if (!p.alive) {
                this.state.projectiles.splice(i, 1);
                this.state.projectilePool.free(p);
            }
        }
    }

    // === Helper Methods ===

    private showFloatingText(text: string, x: number, y: number, color: string = '#fff'): void {
        this.effects.add({ type: 'text', text, x, y, life: 60, color, vy: -1 });
    }

    /**
     * Get tower at specific grid position
     */
    public getTowerAt(col: number, row: number): Tower | null {
        return this.state.towers.find((t) => t.col === col && t.row === row) || null;
    }
}
</file>

<file path="src/scenes/IGameScene.ts">
import { Game } from '../Game';
import { IMapData } from '../MapData';
import { WaveManager } from '../WaveManager';
import { CardSystem, ICard } from '../CardSystem';
import { UIManager } from '../UIManager';
import { ForgeSystem } from '../ForgeSystem';
import { InspectorSystem } from '../InspectorSystem';
import { MetricsSystem } from '../MetricsSystem';
import { Enemy } from '../Enemy';
import { Tower } from '../Tower';
import { Projectile } from '../Projectile';
import { EffectSystem } from '../EffectSystem';
import { EventEmitter } from '../Events';

// Define the interface for the GameScene
export interface IGameScene {
    // Core references
    game: Game;
    mapData: IMapData;

    // Systems
    waveManager: WaveManager;
    cardSys: CardSystem;
    ui: UIManager;
    forge: ForgeSystem;
    inspector: InspectorSystem;
    metrics: MetricsSystem;
    effects: EffectSystem;
    events: EventEmitter;

    // State
    wave: number;
    readonly money: number;
    readonly lives: number;
    readonly startingLives: number; // For perfect wave bonus detection
    enemies: Enemy[];
    towers: Tower[];
    projectiles: Projectile[];

    // Methods
    spawnEnemy(type: string): void;
    showFloatingText(text: string, x: number, y: number, color?: string): void;
    handleCardDrop(card: ICard, x: number, y: number): boolean;
    giveRandomCard(): void;
    sellTower(tower: Tower): void;
    sellCardFromTower(tower: Tower, cardIndex: number): void;
    restart(): void;
    togglePause(): void;

    // Helper Methods
    addMoney(amount: number): void;
    spendMoney(amount: number): boolean;
    loseLife(amount?: number): void;

    // Need these for some systems (e.g. UIManager accessing shop)
    // shop is in UIManager, but UIManager might access scene's other props
}
</file>

<file path="src/ui/GameHUD.ts">
import { IGameScene } from '../scenes/IGameScene';
import { CONFIG } from '../Config';
import { UIUtils } from '../UIUtils';
import { EventBus, Events } from '../EventBus';

export class GameHUD {
    private scene: IGameScene;

    private elMoney: HTMLElement;
    private elWave: HTMLElement;
    private elLives: HTMLElement;
    private elEnemyCounter: HTMLElement;
    private elForgeBtn: HTMLButtonElement;
    private elStartBtn: HTMLButtonElement;
    // private elPauseBtn: HTMLButtonElement; // REMOVED

    constructor(scene: IGameScene) {
        this.scene = scene;

        this.elMoney = document.getElementById('money')!;
        this.elWave = document.getElementById('wave')!;
        this.elLives = document.getElementById('lives')!;
        this.elEnemyCounter = document.getElementById('enemy-counter')!;
        this.elForgeBtn = document.getElementById('forge-btn') as HTMLButtonElement;
        this.elStartBtn = document.getElementById('start-wave-btn') as HTMLButtonElement;
        // Pause button removed

        this.initListeners();
        this.initSubscriptions();

        // Initial values
        this.updateMoney(this.scene.money);
        this.updateLives(this.scene.lives);
        this.updateWaveText(this.scene.wave);
    }

    private initListeners() {
        this.elStartBtn.addEventListener('click', () => this.scene.waveManager.startWave());

        // Pause button listener removed

        this.elForgeBtn.addEventListener('click', () => {
            // FIX: Use forge system
            if (!this.scene.forge || !this.scene.forge.canForge()) return;

            // Determine cost based on card level
            const card = this.scene.forge.forgeSlots[0];
            const forgeCost = card && card.level >= 2
                ? CONFIG.ECONOMY.FORGE_COST_LVL2
                : CONFIG.ECONOMY.FORGE_COST_LVL1;

            if (this.scene.money >= forgeCost) {
                this.scene.forge.tryForge();
                // Button state will update on next tick or via event if we add more events
            }
        });
    }

    private initSubscriptions() {
        const bus = EventBus.getInstance();
        bus.on(Events.MONEY_CHANGED, (money: number) => this.updateMoney(money));
        bus.on(Events.LIVES_CHANGED, (lives: number) => this.updateLives(lives));
        bus.on(Events.WAVE_STARTED, (wave: number) => {
            this.updateWaveText(wave);
            this.updateStartBtn(true);
        });
        bus.on(Events.WAVE_COMPLETED, () => this.updateStartBtn(false));
        // Pause toggle event listener removed for button update (button doesn't exist)
    }

    private updateMoney(newMoney: number) {
        // Flash animation
        const current = parseInt(this.elMoney.innerText) || 0;
        if (newMoney > current) {
            UIUtils.flashElement(this.elMoney.parentElement || this.elMoney, '#4caf50');
        } else if (newMoney < current) {
            UIUtils.flashElement(this.elMoney.parentElement || this.elMoney, '#f44336');
        }
        this.elMoney.innerText = newMoney.toString();
        this.updateForgeBtn(newMoney);
    }

    private updateLives(newLives: number) {
        const current = parseInt(this.elLives.innerText) || 0;
        if (newLives < current) {
            UIUtils.flashElement(this.elLives.parentElement || this.elLives, '#f44336');
        }
        this.elLives.innerText = newLives.toString();
    }

    private updateWaveText(wave: number) {
        this.elWave.innerText = wave.toString();
    }

    public updateEnemyCounter(currentCount: number) {
        this.elEnemyCounter.innerText = currentCount.toString();
    }

    private updateStartBtn(isWaveActive: boolean) {
        if (isWaveActive) {
            this.elStartBtn.innerText = '>>'; // Fast forward / Next wave
            this.elStartBtn.disabled = false;
            this.elStartBtn.style.opacity = '1';
            this.elStartBtn.title = 'Start next wave early for bonus!';
        } else {
            this.elStartBtn.innerText = '‚öîÔ∏è';
            this.elStartBtn.disabled = false;
            this.elStartBtn.style.opacity = '1';
            this.elStartBtn.title = 'Start Wave';
        }
    }

    private updateForgeBtn(money: number) {
        const forgeSys = this.scene.forge;

        // Determine cost based on slot
        let forgeCost: number = CONFIG.ECONOMY.FORGE_COST_LVL1;
        if (forgeSys && forgeSys.forgeSlots[0] && forgeSys.forgeSlots[0].level >= 2) {
            forgeCost = CONFIG.ECONOMY.FORGE_COST_LVL2;
        }

        const canForge = forgeSys && forgeSys.canForge();
        const hasMoney = money >= forgeCost;

        if (canForge && hasMoney) {
            this.elForgeBtn.disabled = false;
            this.elForgeBtn.innerHTML = `<span>‚öíÔ∏è</span> ${forgeCost}üí∞`;
            this.elForgeBtn.style.opacity = '1';
        } else {
            this.elForgeBtn.disabled = true;
            if (!canForge) this.elForgeBtn.innerHTML = `<span>‚öíÔ∏è</span> –ù–ï–¢ –ö–ê–†–¢`;
            else if (!hasMoney) this.elForgeBtn.innerHTML = `<span>‚öíÔ∏è</span> ${forgeCost}üí∞`;
        }
    }

    // updatePauseBtn removed

    public update() {
        // Polling kept only for complex checks if needed, but currently mostly event driven.
        // Forge button might need polling if HAND changes without event.
        // Let's keep a light update for safety or refactor fully later.
        // For now, let's update ForgeBtn here to be safe as CardSystem doesn't emit events yet.
        if (!this.scene) return;
        this.updateForgeBtn(this.scene.money);

        // Also update start btn state just in case? Or rely on events.
        // Events should be enough for Start Btn.
        this.updateStartBtn(this.scene.waveManager.isWaveActive);
    }
}
</file>

<file path="src/ui/ShopUI.ts">
import { IGameScene } from '../scenes/IGameScene';
import { CONFIG } from '../Config';
import { EventBus, Events } from '../EventBus';

export class ShopUI {
    private scene: IGameScene;

    private elShopBtn: HTMLButtonElement;
    private elRefreshBtn: HTMLButtonElement; // [NEW]
    private elSlotsContainer: HTMLElement;

    private shopCards: string[] = [];
    private selectedSlot: number = -1;

    public readonly cost: number = 100;
    public readonly refreshCost: number = CONFIG.ECONOMY.SHOP_REROLL_COST; // [NEW]

    constructor(scene: IGameScene) {
        this.scene = scene;
        this.elShopBtn = document.getElementById('shop-btn') as HTMLButtonElement;
        this.elRefreshBtn = document.getElementById('shop-refresh-btn') as HTMLButtonElement; // [NEW]
        this.elSlotsContainer = document.getElementById('shop-slots')!;

        this.initListeners();
        this.rerollShop();
    }

    private initListeners() {
        this.elShopBtn.addEventListener('click', () => this.buySelectedCard());
        this.elRefreshBtn.addEventListener('click', () => this.rerollWithCost()); // [NEW]

        EventBus.getInstance().on(Events.MONEY_CHANGED, () => {
            this.update();
        });
    }

    public rerollWithCost() {
        if (this.scene.money < this.refreshCost) {
            this.scene.showFloatingText('Not enough gold!', 800, 800, 'red');
            return;
        }

        if (this.scene.spendMoney(this.refreshCost)) {
            this.scene.metrics.trackMoneySpent(this.refreshCost);
            this.scene.showFloatingText(`- ${this.refreshCost}üí∞`, 800, 800, 'gold');
            this.rerollShop();

            // Anim refresh
            this.elRefreshBtn.classList.add('shaking');
            setTimeout(() => this.elRefreshBtn.classList.remove('shaking'), 500);
        }
    }

    public rerollShop() {
        this.shopCards = [];
        const allKeys = Object.keys(CONFIG.CARD_TYPES);

        // IMPROVED: Ensure diversity - no duplicates if possible
        const shuffled = [...allKeys].sort(() => Math.random() - 0.5);
        for (let i = 0; i < 3; i++) {
            this.shopCards.push(shuffled[i % shuffled.length]);
        }

        this.selectedSlot = -1;
        this.render();
    }

    private getRandomCardKey(): string {
        const keys = Object.keys(CONFIG.CARD_TYPES);
        return keys[Math.floor(Math.random() * keys.length)];
    }

    public selectSlot(index: number) {
        if (index < 0 || index >= this.shopCards.length) return;

        if (this.selectedSlot === index) {
            this.selectedSlot = -1;
        } else {
            this.selectedSlot = index;
        }
        this.render();
        this.update();
    }

    public buySelectedCard() {
        if (this.selectedSlot === -1) return;

        if (this.scene.money < this.cost) {
            this.scene.showFloatingText('–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –∑–æ–ª–æ—Ç–∞!', 800, 800, 'red');
            return;
        }

        if (this.scene.cardSys.hand.length >= CONFIG.PLAYER.HAND_LIMIT) {
            this.scene.showFloatingText('–†—É–∫–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∞!', 800, 800, 'orange');
            return;
        }

        if (!this.scene.spendMoney(this.cost)) {
            this.scene.showFloatingText('Error: Transaction Failed', 800, 800, 'red');
            return;
        }
        this.scene.metrics.trackMoneySpent(this.cost);

        const cardKey = this.shopCards[this.selectedSlot];
        this.scene.cardSys.addCard(cardKey, 1);

        this.scene.effects.add({
            type: 'text',
            text: `- ${this.cost}üí∞`,
            x: this.scene.game.canvas.width - 200,
            y: this.scene.game.canvas.height - 100,
            life: 60,
            color: 'gold',
            vy: -1,
        });

        this.shopCards[this.selectedSlot] = this.getRandomCardKey();
        this.selectedSlot = -1;

        this.render();
        this.update();
    }

    public update() {
        this.elShopBtn.innerHTML = `<span>üõí</span> ${this.cost}üí∞`;

        const canAfford = this.scene.money >= this.cost;
        const hasSelection = this.selectedSlot !== -1;

        if (canAfford && hasSelection) {
            this.elShopBtn.disabled = false;
            this.elShopBtn.style.opacity = '1';
            this.elShopBtn.style.cursor = 'pointer';
        } else {
            this.elShopBtn.disabled = true;
            this.elShopBtn.style.opacity = '0.5';
            this.elShopBtn.style.cursor = 'not-allowed';
        }

        // Refresh Btn State
        this.elRefreshBtn.innerHTML = `‚Üª ${this.refreshCost}üí∞`; // NEW: Update text dynamically
        if (this.scene.money >= this.refreshCost) {
            this.elRefreshBtn.disabled = false;
            this.elRefreshBtn.style.opacity = '1';
            this.elRefreshBtn.style.cursor = 'pointer';
        } else {
            this.elRefreshBtn.disabled = true;
            this.elRefreshBtn.style.opacity = '0.5';
            this.elRefreshBtn.style.cursor = 'not-allowed';
        }
    }

    private render() {
        this.elSlotsContainer.innerHTML = '';

        this.shopCards.forEach((key, idx) => {
            const typeConfig = CONFIG.CARD_TYPES[key];

            // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å–ª–æ—Ç–∞
            const slot = document.createElement('div');
            slot.className = 'slot shop-slot';

            // --- –í–ò–ó–£–ê–õ–¨–ù–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï ---
            // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É –≤–Ω—É—Ç—Ä–∏, —Ç–æ—á–Ω–æ —Ç–∞–∫—É—é –∂–µ, –∫–∞–∫ –≤ —Ä—É–∫–µ
            const cardVisual = document.createElement('div');
            cardVisual.className = `card type-${typeConfig.id} level-1`;
            // –£–±–∏—Ä–∞–µ–º pointer-events, —á—Ç–æ–±—ã –∫–ª–∏–∫ –ø—Ä–æ—Ö–æ–¥–∏–ª —Å–∫–≤–æ–∑—å –∫–∞—Ä—Ç—É –Ω–∞ —Å–ª–æ—Ç
            cardVisual.style.pointerEvents = 'none';

            // Get stats HTML for level 1
            const statsHTML = this.getCardStatsHTML(typeConfig.id);

            // –í –º–∞–≥–∞–∑–∏–Ω–µ –º—ã –ø—Ä–æ–¥–∞–µ–º –∫–∞—Ä—Ç—ã 1 —É—Ä–æ–≤–Ω—è
            cardVisual.innerHTML = `
                <div class="card-level">‚òÖ</div>
                <div class="card-icon">${typeConfig.icon}</div>
                <div class="card-stats">${statsHTML}</div>
            `;

            slot.appendChild(cardVisual);
            // -----------------------------

            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞
            if (this.selectedSlot === idx) {
                slot.classList.add('selected');
            } else {
                slot.classList.remove('selected');
            }

            // Clean inline styles that might persist if we swapped logic
            slot.style.border = '';
            slot.style.boxShadow = '';
            slot.style.background = '';

            slot.style.cursor = 'pointer';
            slot.onclick = () => this.selectSlot(idx);

            this.elSlotsContainer.appendChild(slot);
        });
    }

    private getCardStatsHTML(typeId: string): string {
        // Same logic as CardSystem, but always level 1
        switch (typeId) {
            case 'fire':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +15</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 50</div>`;
            case 'ice':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +3</div><div class="card-stat-line">‚ùÑÔ∏è 30%</div>`;
            case 'sniper':
                return `<div class="card-stat-primary">–£—Ä–æ–Ω +14</div><div class="card-stat-line">üéØ +80</div>`;
            case 'multi':
                return `<div class="card-stat-primary">2 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.8x —É—Ä–æ–Ω</div>`;
            case 'minigun':
                return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+3 —É—Ä–æ–Ω/—Å</div>`;
            default:
                return `<div class="card-stat-line">–ö–∞—Ä—Ç–∞</div>`;
        }
    }
}
</file>

<file path="src/WaveEditor.ts">
import { IWaveConfig, SpawnPattern } from './MapData';
import { CONFIG } from './Config';
import { UIUtils } from './UIUtils';

export class WaveEditor {
    private container!: HTMLElement;
    private waves: IWaveConfig[] = [];
    private onSave: (waves: IWaveConfig[]) => void;
    private onClose: () => void;

    constructor(initialWaves: IWaveConfig[], onSave: (waves: IWaveConfig[]) => void, onClose: () => void) {
        // Deep copy to avoid mutating original until save
        this.waves = JSON.parse(JSON.stringify(initialWaves || []));
        this.onSave = onSave;
        this.onClose = onClose;
        this.createUI();
    }

    private createUI() {
        this.container = UIUtils.createContainer({
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            width: '400px',
            maxHeight: '80vh',
            overflowY: 'auto',
            background: '#222',
            border: '2px solid #444',
            borderRadius: '8px',
            padding: '20px',
            color: '#fff',
            display: 'flex',
            flexDirection: 'column',
            gap: '10px',
            zIndex: '2000',
            // boxShadow not in IContainerOptions but let's assume it's fine or add it if strictly typed (it's not there, so I'll leave it or basic styling is enough)
        });
        // Manual override for shadow as it wasn't in my interface
        this.container.style.boxShadow = '0 0 20px rgba(0,0,0,0.5)';

        const title = document.createElement('h2');
        title.innerText = 'Wave Configuration';
        title.style.margin = '0 0 10px 0';
        title.style.textAlign = 'center';
        this.container.appendChild(title);

        const wavesList = document.createElement('div');
        wavesList.id = 'waves-list';
        wavesList.style.display = 'flex';
        wavesList.style.flexDirection = 'column';
        wavesList.style.gap = '10px';
        this.container.appendChild(wavesList);

        this.renderWaves(wavesList);



        UIUtils.createButton(this.container, '+ Add Wave', () => {
            this.waves.push({ enemies: [] });
            this.renderWaves(wavesList);
        }, { background: '#1976d2', border: 'none', padding: '5px 10px', borderRadius: '4px' });

        const buttons = document.createElement('div');
        buttons.style.display = 'flex';
        buttons.style.gap = '10px';
        buttons.style.marginTop = '20px';


        // IButtonOptions doesn't have flex. style copying in UIUtils is manual. 
        // I created UIUtils.createButton to return the button, so I can apply extra styles.
        // Let's rewrite it slightly.
        const btnSave = UIUtils.createButton(buttons, 'Save & Close', () => {
            if (!this.validateWaves()) return;
            this.onSave(this.waves);
            this.destroy();
        }, { background: '#4caf50', border: 'none', padding: '5px 10px', borderRadius: '4px' });
        btnSave.style.flex = '1';

        const btnCancel = UIUtils.createButton(buttons, 'Cancel', () => {
            this.onClose();
            this.destroy();
        }, { background: '#f44336', border: 'none', padding: '5px 10px', borderRadius: '4px' });
        btnCancel.style.flex = '1';

        this.container.appendChild(buttons);

        document.body.appendChild(this.container);
    }

    private renderWaves(parent: HTMLElement) {
        parent.innerHTML = '';
        this.waves.forEach((wave, index) => {
            const waveDiv = document.createElement('div');
            Object.assign(waveDiv.style, {
                background: '#333',
                padding: '10px',
                borderRadius: '4px',
                border: '1px solid #555',
            });

            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.marginBottom = '5px';
            header.innerHTML = `<strong>Wave ${index + 1}</strong>`;

            UIUtils.createButton(header, 'X', () => {
                this.waves.splice(index, 1);
                this.renderWaves(parent);
            }, {
                background: '#d32f2f',
                padding: '2px 6px',
                fontSize: '12px',
                border: 'none',
                borderRadius: '4px'
            });
            waveDiv.appendChild(header);

            // Enemy groups
            const groupsDiv = document.createElement('div');
            groupsDiv.style.marginLeft = '10px';

            wave.enemies.forEach((group, gIndex) => {
                const groupRow = document.createElement('div');
                groupRow.style.display = 'flex';
                groupRow.style.gap = '5px';
                groupRow.style.alignItems = 'center';
                groupRow.style.marginBottom = '5px';

                const typeSelect = document.createElement('select');
                const types = Object.keys(CONFIG.ENEMY_TYPES);
                types.forEach((t) => {
                    const opt = document.createElement('option');
                    opt.value = t;
                    opt.innerText = t;
                    if (t === group.type) opt.selected = true;
                    typeSelect.appendChild(opt);
                });
                typeSelect.onchange = (e) => {
                    group.type = (e.target as HTMLSelectElement).value;
                };

                const countInput = document.createElement('input');
                countInput.type = 'number';
                countInput.value = group.count.toString();
                countInput.min = '1';
                countInput.style.width = '50px';
                countInput.onchange = (e) => {
                    group.count = parseInt((e.target as HTMLInputElement).value) || 1;
                };

                // Spawn Pattern dropdown - —Ä–µ–∂–∏–º –ø–æ—è–≤–ª–µ–Ω–∏—è –≤—Ä–∞–≥–æ–≤
                const patternSelect = document.createElement('select');
                patternSelect.style.width = '100px';
                patternSelect.style.fontSize = '12px';
                patternSelect.title = '–†–µ–∂–∏–º –ø–æ—è–≤–ª–µ–Ω–∏—è –≤—Ä–∞–≥–æ–≤';

                const patterns: Array<{ value: SpawnPattern; label: string }> = [
                    { value: 'normal', label: '‚è±Ô∏è –û–±—ã—á–Ω—ã–π' },
                    { value: 'random', label: 'üé≤ –†–∞–Ω–¥–æ–º' },
                    { value: 'swarm', label: 'üêù –†–æ–π' }
                ];

                patterns.forEach(({ value, label }) => {
                    const opt = document.createElement('option');
                    opt.value = value;
                    opt.textContent = label;
                    if (value === (group.spawnPattern || 'normal')) opt.selected = true;
                    patternSelect.appendChild(opt);
                });

                patternSelect.onchange = (e) => {
                    group.spawnPattern = (e.target as HTMLSelectElement).value as SpawnPattern;
                };

                UIUtils.createButton(groupRow, '-', () => {
                    wave.enemies.splice(gIndex, 1);
                    this.renderWaves(parent);
                }, { background: '#555', padding: '2px 6px', border: 'none', borderRadius: '4px' });

                groupRow.appendChild(typeSelect);
                groupRow.appendChild(document.createTextNode('x'));
                groupRow.appendChild(countInput);
                groupRow.appendChild(patternSelect);

                groupsDiv.appendChild(groupRow);
            });

            UIUtils.createButton(waveDiv, '+ Add Enemy', () => {
                wave.enemies.push({ type: 'GRUNT', count: 1 });
                this.renderWaves(parent);
            }, { background: '#444', fontSize: '12px', width: '100%', border: 'none', borderRadius: '4px', padding: '5px 10px' });

            waveDiv.appendChild(groupsDiv);

            parent.appendChild(waveDiv);
        });
    }

    // styleBtn removed

    /**
     * –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –≤–æ–ª–Ω –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º
     */
    private validateWaves(): boolean {
        for (const wave of this.waves) {
            if (!wave.enemies || wave.enemies.length === 0) {
                alert('–ö–∞–∂–¥–∞—è –≤–æ–ª–Ω–∞ –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –≥—Ä—É–ø–ø—É –≤—Ä–∞–≥–æ–≤!');
                return false;
            }

            for (const group of wave.enemies) {
                if (!group.type || group.count < 1) {
                    alert('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≥—Ä—É–ø–ø—ã –≤—Ä–∞–≥–æ–≤!');
                    return false;
                }

                // –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—è spawnPattern
                if (group.spawnPattern &&
                    !['normal', 'random', 'swarm'].includes(group.spawnPattern)) {
                    alert('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ä–µ–∂–∏–º –ø–æ—è–≤–ª–µ–Ω–∏—è!');
                    return false;
                }
            }
        }
        return true;
    }

    public destroy() {
        if (this.container && this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
    }
}
</file>

<file path="src/WeaponSystem.ts">
import { Tower } from './Tower';
import { Enemy } from './Enemy';
import { Projectile } from './Projectile';
import { ObjectPool } from './Utils';
import { CONFIG } from './Config';
import { EffectSystem } from './EffectSystem';
import { SoundManager, SoundPriority } from './SoundManager';

export class WeaponSystem {

    public update(towers: Tower[], enemies: Enemy[], projectiles: Projectile[], pool: ObjectPool<Projectile>, effects?: EffectSystem) {
        towers.forEach(tower => {
            this.processTower(tower, enemies, projectiles, pool, effects);
        });
    }

    private processTower(tower: Tower, enemies: Enemy[], projectiles: Projectile[], pool: ObjectPool<Projectile>, effects?: EffectSystem) {
        if (tower.isBuilding) return;
        if (tower.cards.length === 0) return;

        // Handle overheat cooldown
        if (tower.isOverheated) {
            if (tower.overheatCooldown > 0) {
                tower.overheatCooldown--;
            } else {
                tower.isOverheated = false;
                tower.spinupFrames = 0; // Reset spinup after overheat
            }
            return; // Can't shoot while overheated
        }

        if (tower.cooldown > 0) {
            tower.cooldown--;
        }

        const stats = tower.getStats();

        // 1. Find Target
        const target = this.findTarget(tower, enemies, stats.range);

        if (target) {
            // 2. Rotate Tower Smoothly
            const dx = target.x - tower.x;
            const dy = target.y - tower.y;
            const desiredAngle = Math.atan2(dy, dx);

            // Apply semi-smooth rotation
            tower.angle = this.rotateTowards(tower.angle, desiredAngle, CONFIG.TOWER.TURN_SPEED);

            // 3. Fire only if aimed close enough
            const angleDiff = Math.abs(this.getShortestAngleDifference(tower.angle, desiredAngle));

            if (tower.cooldown <= 0 && angleDiff < CONFIG.TOWER.AIM_TOLERANCE) {
                this.fire(tower, target, stats, projectiles, pool, effects);
                tower.cooldown = stats.cd;

                // === SPINUP MECHANIC ===
                // Increment spinup progress when firing
                const spinupEffect = stats.effects.find(e => e.type === 'spinup');
                if (spinupEffect) {
                    tower.spinupFrames++;

                    // Check for overheat
                    const maxSpinupSeconds = spinupEffect.maxSpinupSeconds || 7;
                    const maxFrames = maxSpinupSeconds * 60;
                    tower.maxHeat = maxFrames; // Sync for visual bar

                    // Check if tower has Ice card (for overheat extension)
                    const hasIceCard = tower.cards.some(c => c.type.id === 'ice');
                    const overheatExtension = hasIceCard ? (spinupEffect.overheatExtensionWithIce || 0) : 0;
                    const overheatThreshold = maxFrames + overheatExtension;

                    if (tower.spinupFrames >= overheatThreshold) {
                        tower.isOverheated = true;
                        tower.overheatCooldown = spinupEffect.overheatDuration || 90;
                        tower.spinupFrames = 0;
                    }
                }
            }
        } else {
            // === SPINUP RESET / COOLING ===
            // No target - Start cooling down
            if (tower.spinupFrames > 0) {
                // Cool down rate: 
                // User wants 1.5 seconds (90 frames) to cool down from max heat
                // Max heat is dynamic (5s * 60 = 300 frames)
                // Rate = 300 / 90 = 3.333

                const coolRate = (tower.maxHeat || 300) / 90;
                tower.spinupFrames = Math.max(0, tower.spinupFrames - coolRate);
            }
            if (tower.isOverheated) {
                tower.isOverheated = false;
                tower.overheatCooldown = 0;
            }
        }
    }

    private findTarget(tower: Tower, enemies: Enemy[], range: number): Enemy | null {
        // Filter enemies within range
        const inRange = enemies.filter(e => {
            if (!e.isAlive()) return false;
            const dist = Math.hypot(e.x - tower.x, e.y - tower.y);
            return dist <= range;
        });

        if (inRange.length === 0) return null;

        // Apply targeting strategy based on tower's mode
        switch (tower.targetingMode) {
            case 'first':
                // Enemy closest to end of path (highest pathIndex)
                return inRange.reduce((a, b) => a.pathIndex > b.pathIndex ? a : b);

            case 'closest':
                // Enemy nearest to tower
                return inRange.reduce((a, b) => {
                    const distA = Math.hypot(a.x - tower.x, a.y - tower.y);
                    const distB = Math.hypot(b.x - tower.x, b.y - tower.y);
                    return distA < distB ? a : b;
                });

            case 'strongest':
                // Enemy with highest max health
                return inRange.reduce((a, b) => a.maxHealth > b.maxHealth ? a : b);

            case 'weakest':
                // Enemy with lowest current health
                return inRange.reduce((a, b) => a.currentHealth < b.currentHealth ? a : b);

            case 'last':
                // Enemy furthest from end (lowest pathIndex)
                return inRange.reduce((a, b) => a.pathIndex < b.pathIndex ? a : b);

            default:
                // Default to first available
                return inRange[0];
        }
    }

    private rotateTowards(current: number, target: number, maxStep: number): number {
        const diff = this.getShortestAngleDifference(current, target);

        if (Math.abs(diff) <= maxStep) {
            return target;
        }

        return current + Math.sign(diff) * maxStep;
    }

    /**
     * Returns the shortest difference between two angles in radians (-PI to PI)
     */
    private getShortestAngleDifference(current: number, target: number): number {
        let diff = target - current;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        return diff;
    }

    private fire(tower: Tower, target: { x: number, y: number }, stats: any, projectiles: Projectile[], pool: ObjectPool<Projectile>, effects?: EffectSystem) {
        // Muzzle Math
        const barrelLen = CONFIG.TOWER.BARREL_LENGTH;
        const muzzleX = tower.x + Math.cos(tower.angle) * barrelLen;
        const muzzleY = tower.y + Math.sin(tower.angle) * barrelLen;

        // === MUZZLE FLASH EFFECT ===
        if (effects) {
            effects.add({
                type: 'muzzle_flash',
                x: muzzleX,
                y: muzzleY,
                radius: 15,
                life: 5,
            });

            // === SHELL CASING EFFECT ===
            // Eject shell perpendicular to fire angle
            const ejectAngle = tower.angle + Math.PI / 2 + (Math.random() - 0.5) * 0.5;
            const ejectSpeed = 2 + Math.random() * 2;
            effects.add({
                type: 'debris',
                x: tower.x, // Eject from tower center/breech
                y: tower.y,
                vx: Math.cos(ejectAngle) * ejectSpeed,
                vy: Math.sin(ejectAngle) * ejectSpeed,
                gravity: 0.2, // Now valid for debris
                rotation: Math.random() * Math.PI,
                vRot: (Math.random() - 0.5) * 0.5,
                life: 60,
                color: '#ffd700', // Gold shell
                size: 3,
            });
        }

        // Multishot logic
        if (stats.projCount > 1) {
            const startAngle = tower.angle - (stats.spread * (stats.projCount - 1)) / 2;

            for (let i = 0; i < stats.projCount; i++) {
                const currentAngle = startAngle + i * stats.spread;

                // For 'shotgun' spread, we might want the projectile to originate from the same muzzle point
                // but travel in different directions.
                // Or we can slightly offset the origin if it's a wide bank of guns.
                // Let's keep origin same, vary velocity vector implies target varies OR we just calculate velocity manually in Projectile.

                // Currently Projectile.init calculates angle to target. 
                // We need to override this or create a virtual target for the spread shots.

                // Calculate a virtual target point in the direction of fire
                const range = 500; // Arbitrary far distance
                const vx = Math.cos(currentAngle) * range;
                const vy = Math.sin(currentAngle) * range;
                const virtualTarget = { x: muzzleX + vx, y: muzzleY + vy };

                const finalDamage = Math.max(1, stats.damage * (stats.damageMultiplier || 1));
                const p = pool.obtain();
                p.init(muzzleX, muzzleY, virtualTarget, { ...stats, damage: finalDamage });
                projectiles.push(p);
            }
        } else {
            // Single shot
            const finalDamage = Math.max(1, stats.damage * (stats.damageMultiplier || 1));
            const p = pool.obtain();
            p.init(muzzleX, muzzleY, target, { ...stats, damage: finalDamage });
            projectiles.push(p);

            // Trigger recoil for critical hits
            if (p.isCrit) {
                tower.recoilFrames = 10;
                tower.recoilIntensity = 3;
            }
        }

        // Minigun vibration (constant while firing)
        if (stats.projectileType === 'minigun') {
            tower.recoilFrames = 5;
            // tower.recoilIntensity = 0.5; // OLD: Caused constant shaking
            // Only purely visual recoil for the tower itself, do not trigger screen shake here if possible
            // But if recoilFrames is used for screen shake, we need to be careful.
            // GameScene uses gameState.shakeTimer for screen shake. 
            // Tower.recoilFrames usually just shakes the tower sprite.
            // Let's verify Tower.ts usage of recoil.
        }

        // Play Sound
        const isSniper = stats.projectileType === 'sniper';
        const soundKey = isSniper ? 'shoot_sniper' : 'shoot_basic';
        const priority = isSniper ? SoundPriority.HIGH : SoundPriority.LOW;

        SoundManager.play(soundKey, priority);
    }
}
</file>

<file path="src/CollisionSystem.ts">
import { Enemy } from './Enemy';
import { Projectile } from './Projectile';
import { EffectSystem } from './EffectSystem';
import { SoundManager, SoundPriority } from './SoundManager';
import { SpatialGrid } from './SpatialGrid';

export class CollisionSystem {
    private effects: EffectSystem;
    private enemyGrid: SpatialGrid<Enemy>;

    constructor(effects: EffectSystem) {
        this.effects = effects;
        // Initialize grid with screen dimensions, 128px cells
        this.enemyGrid = new SpatialGrid<Enemy>(window.innerWidth, window.innerHeight, 128);
    }


    public update(projectiles: Projectile[], enemies: Enemy[]) {
        // Rebuild spatial grid each frame
        this.enemyGrid.clear();
        for (const enemy of enemies) {
            if (enemy.isAlive()) {
                this.enemyGrid.register(enemy);
            }
        }

        // Check projectile collisions using spatial grid
        for (const p of projectiles) {
            if (!p.alive) continue;

            // Out of bounds check
            if (p.x < -50 || p.x > window.innerWidth + 50 || p.y < -50 || p.y > window.innerHeight + 50) {
                p.alive = false;
                continue;
            }

            // Get only nearby enemies instead of checking all enemies
            const searchRadius = 100; // Reasonable search radius for collision
            const nearbyEnemies = this.enemyGrid.getNearby(p.x, p.y, searchRadius);

            for (const e of nearbyEnemies) {
                if (!e.isAlive()) continue;
                if (p.hitList.includes(e.id)) continue;

                const dist = Math.hypot(e.x - p.x, e.y - p.y);
                const hitDist = 20 + p.radius;

                if (dist < hitDist) {
                    this.handleHit(p, e, enemies);

                    if (p.pierce > 0) {
                        p.pierce--;
                        p.hitList.push(e.id);
                    } else {
                        p.alive = false;
                        break;
                    }
                }
            }
        }
    }

    private handleHit(p: Projectile, target: Enemy, allEnemies: Enemy[]) {
        // Apply damage with projectile reference (for tracking kills)
        const wasSlowed = target.statuses.some(s => s.type === 'slow');

        target.takeDamage(p.damage, p);

        // Sound Hit
        SoundManager.play('hit', SoundPriority.LOW);

        // --- –í–ò–ó–£–ê–õ: –ò—Å–∫—Ä—ã –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏ (critical hit = more particles) ---
        const particleCount = p.isCrit ? 10 : 5;
        for (let i = 0; i < particleCount; i++) {
            this.effects.add({
                type: 'particle',
                x: target.x,
                y: target.y,
                vx: (Math.random() - 0.5) * (p.isCrit ? 8 : 4),
                vy: (Math.random() - 0.5) * (p.isCrit ? 8 : 4),
                life: p.isCrit ? 30 : 20,
                color: p.color, // Use projectile color (tower type)
                radius: p.isCrit ? 4 : 2,
            });
        }

        // === CRIT FLASH + BIG TEXT ===
        if (p.isCrit) {
            // Screen flash (white)
            this.effects.add({
                type: 'screen_flash',
                x: 0,
                y: 0,
                life: 8,
                flashColor: 'rgba(255, 255, 255, ',
            });

            // Big "CRIT!" text
            this.effects.add({
                type: 'text',
                text: 'CRIT!',
                x: target.x,
                y: target.y - 30,
                life: 35,
                color: '#ff0',
                fontSize: 28,
                vy: -2,
            });

            // Enlarged damage number
            this.effects.add({
                type: 'text',
                text: Math.floor(p.damage).toString(),
                x: target.x + 15,
                y: target.y - 10,
                life: 30,
                color: '#ffd700',
                fontSize: 22,
                vy: -1.5,
            });
        }
        // === END CRIT EFFECTS ===
        // -----------------------------------

        // Handle enemy death effects
        const enemyDied = !target.isAlive();
        if (enemyDied) {
            this.handleEnemyDeath(target, p, allEnemies, wasSlowed);
        }

        // Splash damage effect
        const splash = p.effects.find((ef) => ef.type === 'splash');
        if (splash) {
            this.effects.add({
                type: 'explosion',
                x: target.x,
                y: target.y,
                radius: splash.splashRadius || splash.radius,
                life: 15,
                color: 'rgba(255, 100, 0, 0.5)',
            });

            for (const neighbor of allEnemies) {
                if (neighbor === target || !neighbor.isAlive()) continue;
                const dist = Math.hypot(neighbor.x - target.x, neighbor.y - target.y);
                if (dist <= (splash.splashRadius || splash.radius)) {
                    neighbor.takeDamage(p.damage * 0.7);
                }
            }
        }

        // Slow effect (with damage modifier)
        const slow = p.effects.find((ef) => ef.type === 'slow');
        if (slow) {
            const damageBonus = slow.damageToSlowed || 1.0;
            target.applyStatus('slow', slow.slowDuration || slow.dur || 60, slow.slowPower || slow.power || 0.4, damageBonus);
        }
    }

    private handleEnemyDeath(enemy: Enemy, killingProjectile: Projectile, allEnemies: Enemy[], wasSlowed: boolean) {
        const deathX = enemy.x;
        const deathY = enemy.y;

        // Sound Death
        // Boss death sound? (Checking enemy type or size)
        SoundManager.play('death', SoundPriority.LOW);

        // Fire Level 3: Explosion on death
        if (killingProjectile.explodeOnDeath) {
            this.effects.add({
                type: 'explosion',
                x: deathX,
                y: deathY,
                radius: killingProjectile.explosionRadius,
                life: 20,
                color: 'rgba(255, 69, 0, 0.8)',
            });

            // Damage nearby enemies
            for (const neighbor of allEnemies) {
                if (!neighbor.isAlive()) continue;
                const dist = Math.hypot(neighbor.x - deathX, neighbor.y - deathY);
                if (dist <= killingProjectile.explosionRadius) {
                    neighbor.takeDamage(killingProjectile.explosionDamage);
                }
            }
        }

        // Ice Level 3: Chain slow on death (if enemy was slowed when it died)
        if (wasSlowed) {
            const chainSlowEffect = killingProjectile.effects.find((ef: any) => ef.type === 'chainSlowOnDeath');
            if (chainSlowEffect) {
                const chainRadius = chainSlowEffect.chainRadius || 60;

                // Visual effect for chain slow
                this.effects.add({
                    type: 'explosion',
                    x: deathX,
                    y: deathY,
                    radius: chainRadius,
                    life: 20,
                    color: 'rgba(0, 188, 212, 0.5)',
                });

                // Apply slow to nearby enemies
                for (const neighbor of allEnemies) {
                    if (!neighbor.isAlive()) continue;
                    const dist = Math.hypot(neighbor.x - deathX, neighbor.y - deathY);
                    if (dist <= chainRadius) {
                        // Apply the same slow effect from the projectile
                        const slowEffect = killingProjectile.effects.find((ef: any) => ef.type === 'slow');
                        if (slowEffect) {
                            const damageBonus = slowEffect.damageToSlowed || 1.0;
                            neighbor.applyStatus('slow', slowEffect.slowDuration || slowEffect.dur || 60, slowEffect.slowPower || slowEffect.power || 0.4, damageBonus);
                        }
                    }
                }
            }
        }
    }
}
</file>

<file path="src/scenes/MenuScene.ts">
import { BaseScene } from '../BaseScene';
import { Game } from '../Game';
import { DEMO_MAP, IMapData } from '../MapData';
import { validateMap, getSavedMaps } from '../Utils';
import { MapManager } from '../Map';
import { CONFIG } from '../Config';
import { UIUtils } from '../UIUtils';

export class MenuScene extends BaseScene {
    private game: Game;
    private container!: HTMLElement;
    private mapSelectionContainer!: HTMLElement;

    constructor(game: Game) {
        super();
        this.game = game;
        this.createUI();
        this.createMapSelectionUI();
    }

    public onEnter() {
        this.container.style.display = 'flex';
        this.mapSelectionContainer.style.display = 'none';

        const uiLayer = document.getElementById('ui-layer');
        if (uiLayer) uiLayer.style.display = 'none';
        const hand = document.getElementById('hand-container');
        if (hand) hand.style.display = 'none';
    }

    public onExit() {
        this.container.style.display = 'none';
        this.mapSelectionContainer.style.display = 'none';
    }

    public update() { }

    public draw(ctx: CanvasRenderingContext2D) {
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);

        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;
        const s = 64;
        for (let x = 0; x < this.game.canvas.width; x += s) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, this.game.canvas.height);
            ctx.stroke();
        }
        for (let y = 0; y < this.game.canvas.height; y += s) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(this.game.canvas.width, y);
            ctx.stroke();
        }

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 60px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('NEW TOWER', this.game.canvas.width / 2, 150);
    }

    private createUI() {
        this.container = UIUtils.createContainer({
            position: 'absolute',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            display: 'none',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            gap: '20px',
            pointerEvents: 'none'
        });

        UIUtils.createButton(this.container, '‚ñ∂ START GAME', () => {
            this.showMapSelection();
        }, { width: '300px', fontSize: '24px', padding: '15px 40px' });

        UIUtils.createButton(this.container, 'üõ† EDITOR', () => {
            this.game.toEditor();
        }, { width: '300px', fontSize: '24px', padding: '15px 40px' });

        document.body.appendChild(this.container);
    }

    private createMapSelectionUI() {
        this.mapSelectionContainer = UIUtils.createContainer({
            position: 'absolute',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            display: 'none',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            background: 'rgba(0,0,0,0.9)',
            zIndex: '2000',
            color: '#fff'
        });

        const title = document.createElement('h2');
        title.innerText = 'SELECT MAP';
        title.style.marginBottom = '20px';
        this.mapSelectionContainer.appendChild(title);

        const listContainer = document.createElement('div');
        Object.assign(listContainer.style, {
            display: 'flex',
            gap: '20px',
            overflowX: 'auto',
            maxWidth: '90%',
            padding: '20px',
            border: '1px solid #444',
            borderRadius: '8px',
            background: '#222',
        });
        this.mapSelectionContainer.appendChild(listContainer);

        // Function to refresh list
        (this.mapSelectionContainer as any).refreshList = () => {
            listContainer.innerHTML = '';

            // DEMO MAP
            this.createMapCard(listContainer, 'Demo Map', DEMO_MAP);

            // SAVED MAPS
            const saved = getSavedMaps();
            for (const key in saved) {
                this.createMapCard(listContainer, key, saved[key]);
            }
        };

        UIUtils.createButton(this.mapSelectionContainer, 'BACK', () => {
            this.mapSelectionContainer.style.display = 'none';
            this.container.style.display = 'flex';
        }, {
            background: '#d32f2f',
            fontSize: '18px',
            padding: '10px 30px',
            border: 'none',
            width: 'auto' // override default if needed
        });

        document.body.appendChild(this.mapSelectionContainer);
    }

    private createMapCard(parent: HTMLElement, name: string, data: IMapData) {
        try {
            const card = document.createElement('div');
            Object.assign(card.style, {
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                gap: '10px',
                background: '#333',
                padding: '10px',
                borderRadius: '8px',
                minWidth: '200px',
                cursor: 'pointer',
                border: '2px solid transparent',
                transition: '0.2s',
            });

            // Preview Canvas
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 150;
            const ctx = canvas.getContext('2d')!;

            // Render preview
            // We need a temporary MapManager to draw
            const tempMap = new MapManager(data);
            // Scale context to fit
            ctx.save();
            const scale = Math.min(200 / (tempMap.cols * CONFIG.TILE_SIZE), 150 / (tempMap.rows * CONFIG.TILE_SIZE));
            ctx.scale(scale, scale);
            tempMap.draw(ctx);
            ctx.restore();

            card.appendChild(canvas);

            const label = document.createElement('div');
            label.innerText = name;
            label.style.fontWeight = 'bold';
            card.appendChild(label);

            card.onmouseover = () => (card.style.borderColor = '#fff');
            card.onmouseout = () => (card.style.borderColor = 'transparent');
            card.onclick = () => {
                console.log('Map card clicked:', name);
                console.log('Map data:', data);
                const isValid = validateMap(data);
                console.log('Map validation result:', isValid);
                if (isValid) {
                    console.log('Calling toGame...');
                    this.game.toGame(data);
                } else {
                    console.error('Map is invalid!');
                    alert('Map is invalid!');
                }
            };

            parent.appendChild(card);
        } catch (e) {
            console.error(`Failed to render map card for ${name}`, e);
            const errCard = document.createElement('div');
            errCard.innerText = `‚ùå ${name} (Corrupted)`;
            Object.assign(errCard.style, {
                background: '#300',
                color: '#f88',
                padding: '10px',
                borderRadius: '8px',
                minWidth: '200px',
                textAlign: 'center',
            });
            parent.appendChild(errCard);
        }
    }

    private showMapSelection() {
        this.container.style.display = 'none';
        this.mapSelectionContainer.style.display = 'flex';
        if ((this.mapSelectionContainer as any).refreshList) {
            (this.mapSelectionContainer as any).refreshList();
        }
    }

    // createBtn removed - replaced by UIUtils.createButton
}
</file>

<file path="src/Assets.ts">
import { CONFIG } from './Config';
import { VISUALS } from './VisualConfig';
import { ProceduralPatterns } from './ProceduralPatterns';
import { ProceduralRoad } from './renderers/ProceduralRoad';
import { ProceduralGrass } from './renderers/ProceduralGrass';

export class Assets {
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    private static images: Record<string, HTMLCanvasElement | HTMLImageElement> = {};

    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è —Ä–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, grass –º–æ–∂–µ—Ç –∏–º–µ—Ç—å grass_1, grass_2, grass_3)
    private static variants: Record<string, (HTMLCanvasElement | HTMLImageElement)[]> = {};

    // –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã: true = –ø—ã—Ç–∞—Ç—å—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å PNG, false = —Ç–æ–ª—å–∫–æ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è
    private static USE_EXTERNAL_ASSETS = true;

    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏
    private static loadStats = {
        attempted: 0,
        loaded: 0,
        failed: 0,
        procedural: 0
    };

    // –ì–õ–ê–í–ù–´–ô –ú–ï–¢–û–î –ó–ê–ì–†–£–ó–ö–ò
    public static async loadAll(): Promise<void> {
        console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
        console.log('‚ïë   ASSETS: –ù–∞—á–∞–ª–æ –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤    ‚ïë');
        console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

        this.loadStats = { attempted: 0, loaded: 0, failed: 0, procedural: 0 };

        if (this.USE_EXTERNAL_ASSETS) {
            console.log('[1/2] –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –≤–Ω–µ—à–Ω–∏–µ PNG –∞—Å—Å–µ—Ç—ã...');
            try {
                await this.loadExternalAssets();
                console.log(`‚úì –í–Ω–µ—à–Ω–∏–µ PNG: –∑–∞–≥—Ä—É–∂–µ–Ω–æ ${this.loadStats.loaded}, –Ω–µ –Ω–∞–π–¥–µ–Ω–æ ${this.loadStats.failed}\n`);
            } catch (error) {
                console.warn('‚ö† –û—à–∏–±–∫–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ PNG, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ', error);
            }
        }

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –∞—Å—Å–µ—Ç–æ–≤
        console.log('[2/2] –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã—Ö —Ç–µ–∫—Å—Ç—É—Ä –¥–ª—è –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –∞—Å—Å–µ—Ç–æ–≤...');
        this.generateFallbackTextures();

        console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
        console.log(`‚ïë   –ò–¢–û–ì–û: ${Object.keys(this.images).length} –∞—Å—Å–µ—Ç–æ–≤ –∑–∞–≥—Ä—É–∂–µ–Ω–æ           ‚ïë`);
        console.log(`‚ïë   PNG: ${this.loadStats.loaded} | –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã—Ö: ${this.loadStats.procedural}          ‚ïë`);
        console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

        return Promise.resolve();
    }

    /**
     * –ü–æ–ª—É—á–∏—Ç—å –∞—Å—Å–µ—Ç –ø–æ –∏–º–µ–Ω–∏. –ï—Å–ª–∏ –µ—Å—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã - –≤–µ—Ä–Ω–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π.
     */
    public static get(name: string): HTMLCanvasElement | HTMLImageElement | undefined {
        // –ï—Å–ª–∏ –µ—Å—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã - –≤—ã–±—Ä–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–π
        if (this.variants[name] && this.variants[name].length > 0) {
            const variantList = this.variants[name];
            return variantList[Math.floor(Math.random() * variantList.length)];
        }

        // –ò–Ω–∞—á–µ –≤–µ—Ä–Ω—É—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π –∞—Å—Å–µ—Ç
        return this.images[name];
    }

    /**
     * –ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –∞—Å—Å–µ—Ç–∞ (–¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞)
     */
    public static getVariant(name: string, variantIndex: number): HTMLCanvasElement | HTMLImageElement | undefined {
        if (this.variants[name] && this.variants[name][variantIndex]) {
            return this.variants[name][variantIndex];
        }
        return this.images[name];
    }

    /**
     * –ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–ª—è –∞—Å—Å–µ—Ç–∞
     */
    public static getVariantCount(name: string): number {
        return this.variants[name]?.length || 0;
    }

    /**
     * –ó–∞–≥—Ä—É–∑–∫–∞ –æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
     * –ü—ã—Ç–∞–µ—Ç—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å: name.png, name_1.png, name_2.png, etc.
     */
    private static async loadImage(name: string, path: string, maxVariants: number = 5): Promise<void> {
        this.loadStats.attempted++;

        // –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª
        const mainLoaded = await this.tryLoadSingleImage(name, path);

        if (mainLoaded) {
            this.loadStats.loaded++;

            // –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã (name_1.png, name_2.png, etc.)
            const variantList: (HTMLCanvasElement | HTMLImageElement)[] = [];

            // –î–æ–±–∞–≤–∏—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π –∫–∞–∫ –ø–µ—Ä–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç
            if (this.images[name]) {
                variantList.push(this.images[name]);
            }

            // –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
            for (let i = 1; i <= maxVariants; i++) {
                const variantPath = path.replace(/\.png$/, `_${i}.png`);
                const variantName = `${name}_${i}`;
                const loaded = await this.tryLoadSingleImage(variantName, variantPath, true); // silent = true

                if (loaded && this.images[variantName]) {
                    variantList.push(this.images[variantName]);
                }
            }

            // –ï—Å–ª–∏ –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ - —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏—Ö
            if (variantList.length > 1) {
                this.variants[name] = variantList;
                console.log(`Assets: Found ${variantList.length} variants for "${name}"`);
            }
        } else {
            this.loadStats.failed++;
        }
    }

    /**
     * –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
     */
    private static tryLoadSingleImage(name: string, path: string, silent: boolean = false): Promise<boolean> {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                this.images[name] = img;
                if (!silent) {
                    console.log(`‚úÖ Assets: "${path}" loaded successfully`);
                }
                resolve(true);
            };
            img.onerror = () => {
                if (!silent) {
                    console.log(`‚ùå Assets: "${path}" not found, will use procedural fallback`);
                }
                resolve(false);
            };
            img.src = `/assets/images/${path}`;
        });
    }

    /**
     * –ó–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö –≤–Ω–µ—à–Ω–∏—Ö –∞—Å—Å–µ—Ç–æ–≤
     */
    private static async loadExternalAssets(): Promise<void> {
        const loadTasks: Promise<void>[] = [];

        // === –ö–†–ò–¢–ò–ß–ù–´–ï –ê–°–°–ï–¢–´ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è PNG) ===

        // Tiles - –æ–∫—Ä—É–∂–µ–Ω–∏–µ (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è)
        // –§–ê–ó–ê 2: –û—Ç–∫–ª—é—á–µ–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é grass_0...grass_3
        // loadTasks.push(this.loadImage('grass', 'tiles/grass.png', 5));  // –¥–æ 5 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
        loadTasks.push(this.loadImage('path', 'tiles/path.png', 3));

        // Fog tiles (0-15) - –±–µ–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, —Ç.–∫. –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è –±–∏—Ç–º–∞—Å–∫–∏–Ω–≥–∞
        for (let i = 0; i < 16; i++) {
            loadTasks.push(this.loadImage(`fog_${i}`, `tiles/fog_${i}.png`, 0));
        }

        // –î–µ–∫–æ—Ä–∞—Ü–∏–∏ - –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã
        loadTasks.push(this.loadImage('decor_tree', 'tiles/tree.png', 3));
        loadTasks.push(this.loadImage('decor_rock', 'tiles/rock.png', 5));
        loadTasks.push(this.loadImage('stone', 'tiles/stone.png', 3));
        loadTasks.push(this.loadImage('wheat', 'tiles/wheat.png', 2));
        loadTasks.push(this.loadImage('flowers', 'tiles/flowers.png', 3));

        // –ë–∞—à–Ω–∏ - –±–∞–∑–æ–≤—ã–µ (–±–µ–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, —Ç.–∫. –≤–∏–∑—É–∞–ª—å–Ω–æ –≤–∞–∂–Ω–∞ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å)
        loadTasks.push(this.loadImage('tower_base', 'towers/base.png'));
        loadTasks.push(this.loadImage('base_default', 'towers/base_default.png'));
        loadTasks.push(this.loadImage('tower_gun', 'towers/gun.png'));

        // –¢—É—Ä–µ–ª–∏
        loadTasks.push(this.loadImage('turret_standard', 'towers/turret_standard.png'));
        loadTasks.push(this.loadImage('turret_ice', 'towers/turret_ice.png'));
        loadTasks.push(this.loadImage('turret_fire', 'towers/turret_fire.png'));
        loadTasks.push(this.loadImage('turret_sniper', 'towers/turret_sniper.png'));
        loadTasks.push(this.loadImage('turret_split', 'towers/turret_split.png'));
        loadTasks.push(this.loadImage('turret_minigun', 'towers/turret_minigun.png'));

        // –ú–æ–¥—É–ª–∏
        loadTasks.push(this.loadImage('mod_ice', 'modules/ice.png'));
        loadTasks.push(this.loadImage('mod_fire', 'modules/fire.png'));
        loadTasks.push(this.loadImage('mod_sniper', 'modules/sniper.png'));
        loadTasks.push(this.loadImage('mod_split', 'modules/split.png'));
        loadTasks.push(this.loadImage('mod_minigun', 'modules/minigun.png'));

        // –í—Ä–∞–≥–∏ - –±–∞–∑–æ–≤—ã–µ –∞—Ä—Ö–µ—Ç–∏–ø—ã (–º–æ–≥—É—Ç –∏–º–µ—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è)
        loadTasks.push(this.loadImage('enemy_skeleton', 'enemies/skeleton.png', 3));
        loadTasks.push(this.loadImage('enemy_wolf', 'enemies/wolf.png', 2));
        loadTasks.push(this.loadImage('enemy_troll', 'enemies/troll.png', 2));
        loadTasks.push(this.loadImage('enemy_spider', 'enemies/spider.png', 2));

        // Props –≤—Ä–∞–≥–æ–≤
        loadTasks.push(this.loadImage('prop_shield', 'props/shield.png'));
        loadTasks.push(this.loadImage('prop_helmet', 'props/helmet.png'));
        loadTasks.push(this.loadImage('prop_weapon', 'props/weapon.png'));
        loadTasks.push(this.loadImage('prop_barrier', 'props/barrier.png'));

        // –°–Ω–∞—Ä—è–¥—ã - –∫—Ä–∏—Ç–∏—á–Ω—ã–µ –¥–ª—è –≥–µ–π–º–ø–ª–µ—è
        loadTasks.push(this.loadImage('projectile_standard', 'projectiles/standard.png'));
        loadTasks.push(this.loadImage('projectile_ice', 'projectiles/ice.png'));
        loadTasks.push(this.loadImage('projectile_fire', 'projectiles/fire.png'));
        loadTasks.push(this.loadImage('projectile_sniper', 'projectiles/sniper.png'));
        loadTasks.push(this.loadImage('projectile_split', 'projectiles/split.png'));
        loadTasks.push(this.loadImage('projectile_minigun', 'projectiles/minigun.png'));

        // –≠–§–§–ï–ö–¢–´ - –æ—Å—Ç–∞–≤–ª—è–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–º–∏ (–Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ–º PNG)
        // effect_muzzle_flash, shadow_small - –±—É–¥—É—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
        await Promise.all(loadTasks);
    }

    /**
     * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è –≤—Å–µ—Ö –∞—Å—Å–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –±—ã–ª–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
     */
    private static generateFallbackTextures(): void {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∫–∏–µ –∞—Å—Å–µ—Ç—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–ª—è –Ω–∏—Ö –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã
        const requiredAssets = [
            'grass_0', 'grass_1', 'grass_2', 'grass_3', // 4 variants for grass
            'path', 'decor_tree', 'decor_rock', 'stone', 'wheat', 'flowers',
            'tower_base', 'base_default', 'tower_gun',
            'turret_standard', 'turret_ice', 'turret_fire', 'turret_sniper', 'turret_split', 'turret_minigun',
            'mod_ice', 'mod_fire', 'mod_sniper', 'mod_split', 'mod_minigun',
            'projectile_standard', 'projectile_ice', 'projectile_fire', 'projectile_sniper', 'projectile_split', 'projectile_minigun',
            'effect_muzzle_flash', 'shadow_small'
        ];

        // –î–æ–±–∞–≤–ª—è–µ–º fog tiles
        for (let i = 0; i < 16; i++) {
            requiredAssets.push(`fog_${i}`);
        }

        // –î–æ–±–∞–≤–ª—è–µ–º path tiles (Phase 2 - bitmasking)
        for (let i = 0; i < 16; i++) {
            requiredAssets.push(`path_${i}`);
        }

        // –î–æ–±–∞–≤–ª—è–µ–º enemies
        const enemies = Object.values(CONFIG.ENEMY_TYPES);
        enemies.forEach((e) => {
            requiredAssets.push(`enemy_${e.id}`);
        });

        // –î–æ–±–∞–≤–ª—è–µ–º props
        requiredAssets.push('prop_shield', 'prop_helmet', 'prop_weapon', 'prop_barrier');

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ
        requiredAssets.forEach(assetName => {
            if (!this.images[assetName]) {
                this.generateProceduralAsset(assetName);
            }
        });
    }

    /**
     * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω—É—é —Ç–µ–∫—Å—Ç—É—Ä—É –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∞—Å—Å–µ—Ç–∞
     */
    private static generateProceduralAsset(name: string): void {
        // –í—ã–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ä—É—é —Å–∏—Å—Ç–µ–º—É –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
        if (name.startsWith('grass_')) {
            // –§–ê–ó–ê 2: –û–±–Ω–æ–≤–ª–µ–Ω–æ - –ø—Ä–æ—Å—Ç–∞—è –∑–µ–ª–µ–Ω–∞—è —Ç—Ä–∞–≤–∞ (–ø–æ –∑–∞–ø—Ä–æ—Å—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
            const variantIdx = parseInt(name.split('_')[1]);

            this.generateTexture(name, CONFIG.TILE_SIZE, (ctx, w, h) => {
                // –ü—Ä–æ—Å—Ç–æ –∑–µ–ª—ë–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç –ë–ï–ó –¥–µ—Ç–∞–ª–µ–π
                ctx.fillStyle = '#6b9e4a'; // –°—Ä–µ–¥–Ω–∏–π –∑–µ–ª—ë–Ω—ã–π
                ctx.fillRect(0, 0, w, h);
            });

            // IMPORTANT: Register as variant for 'grass'
            if (!this.variants['grass']) {
                this.variants['grass'] = [];
            }
            if (this.images[name] instanceof HTMLCanvasElement) {
                this.variants['grass'].push(this.images[name] as HTMLCanvasElement);
            }

            this.loadStats.procedural++;

            // –ï—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –µ–≥–æ –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–π –∞—Å—Å–µ—Ç 'grass'
            if (name === 'grass_0') {
                this.images['grass'] = this.images[name];
            }


        } else if (name === 'path') {
            this.generateTexture('path', CONFIG.TILE_SIZE, (ctx, w, h) => {
                ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.MAIN;
                ctx.fillRect(0, 0, w, h);
                for (let i = 0; i < 15; i++) {
                    ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.DETAIL;
                    ctx.beginPath();
                    ctx.arc(Math.random() * w, Math.random() * h, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            this.loadStats.procedural++;
        } else if (name.startsWith('fog_')) {
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º fog tiles –ø–æ —Å—Ç–∞—Ä–æ–º—É
            const index = parseInt(name.replace('fog_', ''));
            if (!isNaN(index)) {
                this.generateFogTile(index);
                this.loadStats.procedural++;
            }
        } else if (name.startsWith('path_')) {
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º path tiles (Phase 2 - bitmasking)
            this.generatePathTiles(); // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Å–µ 16 –∑–∞ —Ä–∞–∑
            this.loadStats.procedural++;
        } else if (name.startsWith('enemy_')) {
            // Enemies
            const enemyId = name.replace('enemy_', '');
            const enemy = Object.values(CONFIG.ENEMY_TYPES).find(e => e.id === enemyId);
            if (enemy) {
                this.generateEnemyTexture(enemy.id, enemy.color);
                this.loadStats.procedural++;
            }
        } else {
            // –î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∞—Å—Å–µ—Ç–æ–≤ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —á–µ—Ä–µ–∑ —Å—Ç–∞—Ä—É—é —Å–∏—Å—Ç–µ–º—É
            // –ù–û –¢–û–õ–¨–ö–û –ï–°–õ–ò –æ–Ω–∏ –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!
            console.log(`[Assets] No specific fallback for "${name}", checking if already loaded...`);
            if (!this.images[name]) {
                console.log(`[Assets] "${name}" not loaded, generating procedurally...`);
                this.generateAllTextures();  // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –í–°–ï –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ
            } else {
                console.log(`[Assets] "${name}" already loaded (PNG), skipping generation`);
            }
        }
    }

    // --- –°–¢–ê–†–ê–Ø –°–ò–°–¢–ï–ú–ê –ü–†–û–¶–ï–î–£–†–ù–û–ô –ì–ï–ù–ï–†–ê–¶–ò–ò (–æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è fallback) ---
    private static generateAllTextures() {
        // –§–ê–ó–ê 2: –°—Ç–∞—Ä–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è 'grass' –£–î–ê–õ–ï–ù–ê
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—É—é —Å–∏—Å—Ç–µ–º—É grass_0...grass_3 (—Å–º. generateProceduralAsset)


        this.generateTexture('path', CONFIG.TILE_SIZE, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.MAIN;
            ctx.fillRect(0, 0, w, h);
            for (let i = 0; i < 15; i++) {
                ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.DETAIL;
                ctx.beginPath();
                ctx.arc(Math.random() * w, Math.random() * h, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        this.generateTexture('decor_tree', CONFIG.TILE_SIZE, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.TREE.BASE;
            ctx.fillRect(0, 0, w, h); // –§–æ–Ω —Ç—Ä–∞–≤—ã
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.TREE.FOLIAGE_LIGHT;
            ctx.beginPath();
            ctx.arc(w / 2, h / 2, 16, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.TREE.FOLIAGE_DARK;
            ctx.beginPath();
            ctx.arc(w / 2 - 5, h / 2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
        });

        this.generateTexture('decor_rock', CONFIG.TILE_SIZE, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.ROCK.BASE;
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = VISUALS.ENVIRONMENT.DECOR.ROCK.STONE;
            ctx.beginPath();
            ctx.moveTo(10, h - 10);
            ctx.lineTo(w / 2, 10);
            ctx.lineTo(w - 10, h - 10);
            ctx.fill();
        });

        // –ë–∞—à–Ω–∏
        this.generateTexture('tower_base', CONFIG.TILE_SIZE, (ctx, w, h) => {
            const center = w / 2;
            ctx.fillStyle = VISUALS.TOWER.BASE.PLATFORM;
            ctx.beginPath();
            ctx.arc(center, center, w * 0.375, 0, Math.PI * 2); // 24/64 = 0.375
            ctx.fill();
            ctx.strokeStyle = VISUALS.TOWER.BASE.RIM;
            ctx.lineWidth = 4;
            ctx.stroke();
        });

        this.generateTexture('tower_gun', CONFIG.TILE_SIZE, (ctx, w, h) => {
            const center = w / 2;
            const barrelWidth = w * 0.125;  // 8/64 = 0.125
            const barrelLength = w * 0.53;  // 34/64 ~= 0.53
            const barrelStart = w * 0.31;   // 20/64 ~= 0.31

            ctx.fillStyle = VISUALS.TOWER.BASE.RIVETS; // Using rivets color for gun? Original was #424242 which matches rivets
            // Draw barrel horizontally pointing RIGHT (East)
            ctx.fillRect(barrelStart, center - barrelWidth / 2, barrelLength, barrelWidth);
            ctx.beginPath();
            ctx.arc(center, center, w * 0.22, 0, Math.PI * 2); // 14/64 ~= 0.22
            ctx.fill(); // Turret body
            ctx.fillStyle = '#eceff1';
            ctx.beginPath();
            ctx.arc(center, center, w * 0.094, 0, Math.PI * 2); // 6/64 ~= 0.094
            ctx.fill();
        });

        // –í—Ä–∞–≥–∏
        const enemies = Object.values(CONFIG.ENEMY_TYPES);
        enemies.forEach((e) => {
            this.generateEnemyTexture(e.id, e.color);
        });

        // Fog
        this.generateFogTiles();

        // Path tiles (Phase 2 - bitmasking)
        this.generatePathTiles();

        // --- NEW MODULAR TOWER ASSETS ---
        this.generateTowerParts();

        // --- PROJECTILES & EFFECTS ---
        this.generateProjectiles();
        this.generateMisc();
    }

    private static generateTexture(
        name: string,
        size: number,
        drawFn: (ctx: CanvasRenderingContext2D, w: number, h: number) => void,
    ) {
        // –ö–†–ò–¢–ò–ß–ù–û: –ù–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞—Ç—å —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ PNG!
        if (this.images[name]) {
            console.log(`[generateTexture] Skipping "${name}" - already loaded as PNG`);
            return;
        }

        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d')!;
        drawFn(ctx, size, size);
        this.images[name] = canvas;
        console.log(`[generateTexture] Generated procedural "${name}"`);
    }

    /**
     * Layered Texture Generation (Phase 1)
     * Generates textures using multiple layers for richer visuals
     * @param name Asset name
     * @param size Texture size
     * @param layers Layer functions: base, pattern, highlight, dirt
     */
    private static generateLayeredTexture(
        name: string,
        size: number,
        layers: {
            base: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
            pattern?: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
            highlight?: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
            dirt?: (ctx: CanvasRenderingContext2D, w: number, h: number) => void;
        }
    ): void {
        // –ö–†–ò–¢–ò–ß–ù–û (–∏–∑ –∞—É–¥–∏—Ç–∞): –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏!
        if (this.images[name]) {
            console.warn(`[Assets] Texture "${name}" already generated, skipping`);
            return;
        }

        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d')!;

        // Layer 1: Base (–ø–æ–¥–ª–æ–∂–∫–∞)
        layers.base(ctx, size, size);

        // Layer 2: Pattern (—É–∑–æ—Ä)
        if (layers.pattern) {
            layers.pattern(ctx, size, size);
        }

        // Layer 3: Highlight (–±–ª–∏–∫–∏/–∞–∫—Ü–µ–Ω—Ç—ã)
        if (layers.highlight) {
            layers.highlight(ctx, size, size);
        }

        // Layer 4: Dirt (–≥—Ä—è–∑—å/—à—É–º)
        if (layers.dirt) {
            layers.dirt(ctx, size, size);
        }

        this.images[name] = canvas;
        console.log(`[generateLayeredTexture] Generated "${name}" with ${Object.keys(layers).length} layers`);
    }


    private static generateEnemyTexture(name: string, color: string) {
        this.generateTexture(`enemy_${name}`, 48, (ctx, w, h) => {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(w / 2, h / 2, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            // –ì–ª–∞–∑–∞
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(w / 2 - 6, h / 2 - 5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(w / 2 + 6, h / 2 - 5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(w / 2 - 6, h / 2 - 5, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(w / 2 + 6, h / 2 - 5, 1.5, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    private static generateFogTiles() {
        const TS = CONFIG.TILE_SIZE;
        // Generate 16 bitmask variations (0-15)
        for (let i = 0; i < 16; i++) {
            this.generateTexture(`fog_${i}`, TS, (ctx, w, h) => {
                const NORTH = (i & 1) !== 0;
                const WEST = (i & 2) !== 0;
                const EAST = (i & 4) !== 0;
                const SOUTH = (i & 8) !== 0;

                // Base fog color (Dark)
                ctx.fillStyle = VISUALS.ENVIRONMENT.FOG.BASE; // Dark Blue Grey

                // Draw main body based on connections
                // We draw a center rect and extend to connected sides
                const cx = w / 2;
                const cy = h / 2;
                const halfW = w / 2;
                const halfH = h / 2;

                // Always draw center
                ctx.fillRect(cx - halfW, cy - halfH, w, h);

                // This simple logic fills the whole tile if it's fog
                // But for bitmasking we want to show "edges" where there is NO fog neighbor

                // Actually, for "Fog of War" where 1=Fog (Hidden), we draw the fog.
                // If I am a Fog tile, I am fully obscured. 
                // But to make it look nice (soft edges), we can use gradients or rounded corners 
                // on sides that are NOT connected to other fog.

                // Let's retry the visual approach:
                // We fill the whole tile with black/dark.
                // Then, for sides that are NOT connected (value 0 in bitmask), we fade out or draw a border?
                // Wait, standard bitmasking works by selecting a sprite that "connects" to neighbors.
                // So '15' (connected all sides) is a solid dark block.
                // '0' (connected to none, i.e., isolated fog) is a dark circle or blob.

                ctx.clearRect(0, 0, w, h); // Start fresh
                ctx.fillStyle = VISUALS.ENVIRONMENT.FOG.BASE;

                // Dynamic dimensions based on tile size (25% margins, 50% center)
                const cX = Math.floor(w / 4);      // Left margin
                const cY = Math.floor(h / 4);      // Top margin
                const cW = Math.floor(w / 2);      // Center width
                const cH = Math.floor(h / 2);      // Center height
                const arcRadius = Math.floor(cW / 2);

                // Draw Center
                ctx.fillRect(cX, cY, cW, cH);

                // NORTH
                if (NORTH) {
                    ctx.fillRect(cX, 0, cW, cY);
                } else {
                    ctx.beginPath();
                    ctx.arc(w / 2, cY, arcRadius, Math.PI, 0);
                    ctx.fill();
                }

                // SOUTH
                if (SOUTH) {
                    ctx.fillRect(cX, cY + cH, cW, h - (cY + cH));
                } else {
                    ctx.beginPath();
                    ctx.arc(w / 2, cY + cH, arcRadius, 0, Math.PI);
                    ctx.fill();
                }

                // WEST
                if (WEST) {
                    ctx.fillRect(0, cY, cX, cH);
                } else {
                    ctx.beginPath();
                    ctx.arc(cX, h / 2, arcRadius, Math.PI * 0.5, Math.PI * 1.5);
                    ctx.fill();
                }

                // EAST
                if (EAST) {
                    ctx.fillRect(cX + cW, cY, w - (cX + cW), cH);
                } else {
                    ctx.beginPath();
                    ctx.arc(cX + cW, h / 2, arcRadius, Math.PI * 1.5, Math.PI * 0.5);
                    ctx.fill();
                }

                // Fill corners if both adjacent sides are connected
                // NW
                if (NORTH && WEST) ctx.fillRect(0, 0, cX, cY);
                // NE
                if (NORTH && EAST) ctx.fillRect(cX + cW, 0, w - (cX + cW), cY);
                // SW
                if (SOUTH && WEST) ctx.fillRect(0, cY + cH, cX, h - (cY + cH));
                // SE
                if (SOUTH && EAST) ctx.fillRect(cX + cW, cY + cH, w - (cX + cW), h - (cY + cH));
            });
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ç–∏—Ä—É–µ—Ç –æ–¥–∏–Ω fog tile –ø–æ –∏–Ω–¥–µ–∫—Å—É (–¥–ª—è fallback)
     */
    private static generateFogTile(index: number) {
        const TS = CONFIG.TILE_SIZE;
        this.generateTexture(`fog_${index}`, TS, (ctx, w, h) => {
            const NORTH = (index & 1) !== 0;
            const WEST = (index & 2) !== 0;
            const EAST = (index & 4) !== 0;
            const SOUTH = (index & 8) !== 0;

            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = VISUALS.ENVIRONMENT.FOG.BASE;

            const cX = Math.floor(w / 4);
            const cY = Math.floor(h / 4);
            const cW = Math.floor(w / 2);
            const cH = Math.floor(h / 2);
            const arcRadius = Math.floor(cW / 2);

            // Draw Center
            ctx.fillRect(cX, cY, cW, cH);

            // NORTH
            if (NORTH) {
                ctx.fillRect(cX, 0, cW, cY);
            } else {
                ctx.beginPath();
                ctx.arc(w / 2, cY, arcRadius, Math.PI, 0);
                ctx.fill();
            }

            // SOUTH
            if (SOUTH) {
                ctx.fillRect(cX, cY + cH, cW, h - (cY + cH));
            } else {
                ctx.beginPath();
                ctx.arc(w / 2, cY + cH, arcRadius, 0, Math.PI); ctx.fill();
            }

            // WEST
            if (WEST) {
                ctx.fillRect(0, cY, cX, cH);
            } else {
                ctx.beginPath();
                ctx.arc(cX, h / 2, arcRadius, Math.PI * 0.5, Math.PI * 1.5);
                ctx.fill();
            }

            // EAST
            if (EAST) {
                ctx.fillRect(cX + cW, cY, w - (cX + cW), cH);
            } else {
                ctx.beginPath();
                ctx.arc(cX + cW, h / 2, arcRadius, Math.PI * 1.5, Math.PI * 0.5);
                ctx.fill();
            }

            // Fill corners if both adjacent sides are connected
            if (NORTH && WEST) ctx.fillRect(0, 0, cX, cY);
            if (NORTH && EAST) ctx.fillRect(cX + cW, 0, w - (cX + cW), cY);
            if (SOUTH && WEST) ctx.fillRect(0, cY + cH, cX, h - (cY + cH));
            if (SOUTH && EAST) ctx.fillRect(cX + cW, cY + cH, w - (cX + cW), h - (cY + cH));
        });
    }

    /**
     * Generate Path Tiles with Bitmasking
     * Creates 16 variants (0-15) for smooth path connections
     * –§–ê–ó–ê 1: –û–±–Ω–æ–≤–ª–µ–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ProceduralRoad –¥–ª—è –∫–∞–º–µ–Ω–Ω–æ–π —Ç–µ–∫—Å—Ç—É—Ä—ã
     */
    private static generatePathTiles() {
        const TS = CONFIG.TILE_SIZE;



        // Generate 16 bitmask variations (0-15)
        for (let i = 0; i < 16; i++) {
            this.generateTexture(`path_${i}`, TS, (ctx, w, h) => {
                // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å ProceduralRoad –¥–ª—è –∫–∞–º–µ–Ω–Ω–æ–π —Ç–µ–∫—Å—Ç—É—Ä—ã
                try {
                    ProceduralRoad.draw(ctx, 0, 0, i);
                } catch (error) {
                    console.error(`[Assets] ProceduralRoad.draw failed for path_${i}:`, error);
                    // Fallback - –ø—Ä–æ—Å—Ç–æ–π –∫–∞–º–µ–Ω—å
                    ctx.fillStyle = VISUALS.ENVIRONMENT.PATH.STONE_BASE || '#c5b8a1';
                    ctx.fillRect(0, 0, w, h);
                }
            });
        }
    }


    private static generateTowerParts() {
        const size = CONFIG.TILE_SIZE;

        // -- 1. Bases --
        this.generateTexture('base_default', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            const r = w * 0.35;
            // Main platform
            ctx.fillStyle = '#9e9e9e'; // Grey 500
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
            // Rim
            ctx.strokeStyle = '#616161'; // Grey 700
            ctx.lineWidth = 3;
            ctx.stroke();
            // Rivets
            ctx.fillStyle = '#424242';
            for (let i = 0; i < 4; i++) {
                const a = i * (Math.PI / 2);
                ctx.beginPath();
                ctx.arc(cx + Math.cos(a) * (r - 4), cy + Math.sin(a) * (r - 4), 2, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        // -- 2. Turrets --

        // Standard / Default
        this.generateTexture('turret_standard', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);
            // Simple gun
            ctx.fillStyle = VISUALS.TOWER.TURRET.STANDARD.BARREL;
            ctx.fillRect(0, -6, 20, 12); // Barrel
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2); // Body
            ctx.fill();
            ctx.strokeStyle = VISUALS.TOWER.TURRET.STANDARD.STROKE;
            ctx.lineWidth = 2;
            ctx.stroke();
        });

        // Ice Turret (Crystal/Prism, Blue)
        this.generateTexture('turret_ice', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);

            // Barrel - Crystal spike
            ctx.fillStyle = VISUALS.TOWER.TURRET.ICE.SPIKE; // Cyan 300
            ctx.beginPath();
            ctx.moveTo(0, -4);
            ctx.lineTo(24, 0);
            ctx.lineTo(0, 4);
            ctx.fill();

            // Body - Hexagon
            ctx.fillStyle = VISUALS.TOWER.TURRET.ICE.MAIN; // Cyan 600
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const a = i * (Math.PI / 3);
                const r = 14;
                ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = VISUALS.TOWER.TURRET.ICE.STROKE;
            ctx.lineWidth = 2;
            ctx.stroke();
        });

        // Fire Turret (Mortar/Flamethrower, Orange/Red)
        this.generateTexture('turret_fire', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);

            // Barrel - Wide, short
            ctx.fillStyle = VISUALS.TOWER.TURRET.FIRE.BARREL; // Deep Orange 400
            ctx.fillRect(0, -10, 18, 20);
            // Barrel Tip (charred)
            ctx.fillStyle = VISUALS.TOWER.TURRET.FIRE.TIP;
            ctx.fillRect(14, -10, 4, 20);

            // Body - Round, massive
            ctx.fillStyle = VISUALS.TOWER.TURRET.FIRE.MAIN; // Deep Orange 600
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = VISUALS.TOWER.TURRET.FIRE.STROKE;
            ctx.lineWidth = 2;
            ctx.stroke();
        });

        // Sniper Turret (Long Rifle, Green/Camo)
        this.generateTexture('turret_sniper', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);

            // Barrel - Long, thin
            ctx.fillStyle = VISUALS.TOWER.TURRET.SNIPER.BARREL; // Green 900
            ctx.fillRect(0, -3, 30, 6);
            // Muzzle brake
            ctx.fillStyle = VISUALS.TOWER.TURRET.SNIPER.MUZZLE;
            ctx.fillRect(28, -5, 4, 10);

            // Body - Sleek, angular
            ctx.fillStyle = VISUALS.TOWER.TURRET.SNIPER.MAIN; // Green 800
            ctx.beginPath();
            ctx.moveTo(-10, -8);
            ctx.lineTo(10, -5);
            ctx.lineTo(10, 5);
            ctx.lineTo(-10, 8);
            ctx.closePath();
            ctx.fill();
        });

        // Split Turret (Gatling/Tri-barrel, Yellow)
        this.generateTexture('turret_split', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);

            // Barrels - Three spread out
            ctx.fillStyle = VISUALS.TOWER.TURRET.SPLIT.BARREL; // Yellow 700
            const spread = 0.3;
            // 1
            ctx.save(); ctx.rotate(-spread); ctx.fillRect(0, -3, 20, 6); ctx.restore();
            // 2
            ctx.fillRect(0, -3, 22, 6);
            // 3
            ctx.save(); ctx.rotate(spread); ctx.fillRect(0, -3, 20, 6); ctx.restore();

            // Body - Wide
            ctx.fillStyle = VISUALS.TOWER.TURRET.SPLIT.MAIN; // Yellow 900
            ctx.beginPath();
            ctx.arc(0, 0, 14, 0, Math.PI * 2);
            ctx.fill();
        });

        // Minigun Turret (Gatling gun, Purple/Electric)
        this.generateTexture('turret_minigun', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.translate(cx, cy);

            // Rotating barrel assembly - Multiple thin barrels
            ctx.fillStyle = '#7b1fa2'; // Purple 700
            const barrelCount = 6;
            for (let i = 0; i < barrelCount; i++) {
                const angle = (i / barrelCount) * Math.PI * 2;
                const r = 6; // Radius of barrel circle
                ctx.save();
                ctx.translate(Math.cos(angle) * r, Math.sin(angle) * r);
                ctx.fillRect(0, -1.5, 18, 3); // Thin barrel
                ctx.restore();
            }

            // Central motor housing
            ctx.fillStyle = '#9c27b0'; // Purple 500
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();

            // Electric coil detail
            ctx.strokeStyle = '#e1bee7'; // Purple 100  (light accent)
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.stroke();
        });


        // -- 3. Modules (Overlay attachments) --

        // Mod Ice (Cooling tank - Blue canister)
        this.generateTexture('mod_ice', 24, (ctx, w, h) => {
            // Anchor point is roughly center relative to mounting point
            ctx.fillStyle = VISUALS.TOWER.MODULES.ICE.BODY; // Light Blue 800
            ctx.fillRect(4, 4, 16, 10);
            ctx.fillStyle = VISUALS.TOWER.MODULES.ICE.LIQUID; // Light Blue 300 (liquid level)
            ctx.fillRect(6, 6, 12, 6);
            // Cap
            ctx.fillStyle = VISUALS.TOWER.MODULES.ICE.CAP;
            ctx.fillRect(18, 6, 4, 6);
        });

        // Mod Fire (Fuel tank - Red canister)
        this.generateTexture('mod_fire', 24, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.MODULES.FIRE.BODY; // Red 800
            ctx.beginPath();
            ctx.rect(6, 4, 12, 16);
            ctx.fill();
            // Symbol
            ctx.fillStyle = VISUALS.TOWER.MODULES.FIRE.SYMBOL;
            ctx.font = '10px Arial';
            ctx.fillText('‚ö°', 8, 16);
        });

        // Mod Sniper (Scope - Lens)
        this.generateTexture('mod_sniper', 24, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.MODULES.SNIPER.BODY; // Black body
            ctx.fillRect(2, 8, 20, 8);
            // Lens
            ctx.fillStyle = VISUALS.TOWER.MODULES.SNIPER.LENS; // Cyan accent
            ctx.beginPath();
            ctx.arc(22, 12, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        // Mod Split (Ammo box / Extra barrel)
        this.generateTexture('mod_split', 24, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.MODULES.SPLIT.BODY; // Amber 900
            ctx.fillRect(4, 4, 16, 16);
            // Bullets hint
            ctx.fillStyle = VISUALS.TOWER.MODULES.SPLIT.ACCENT;
            ctx.fillRect(6, 6, 4, 12);
            ctx.fillRect(14, 6, 4, 12);
        });

        // Mod Minigun (Ammo belt / Power cell)
        this.generateTexture('mod_minigun', 24, (ctx, w, h) => {
            // Purple ammunition belt with electric coils
            ctx.fillStyle = '#6a1b9a'; // Purple 800
            ctx.fillRect(4, 6, 16, 12);

            // Belt links
            ctx.fillStyle = '#ce93d8'; // Purple 200 (light)
            for (let i = 0; i < 4; i++) {
                ctx.fillRect(6 + i * 4, 8, 2, 8);
            }

            // Energy cell accent
            ctx.fillStyle = '#ba68c8'; // Purple 300
            ctx.beginPath();
            ctx.arc(12, 12, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        this.generateEnemyArchetypes();
        this.generateEnemyProps();
    }

    private static generateEnemyArchetypes() {
        const size = 48; // Base enemy size

        // 1. Skeleton (Standard)
        this.generateTexture('enemy_skeleton', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Bones (White/Grey)
            ctx.fillStyle = VISUALS.ENEMY.SKELETON.BONE;

            // Skull
            ctx.beginPath();
            ctx.arc(cx, cy - 5, 10, 0, Math.PI * 2);
            ctx.fill();

            // Ribcage/Shoulders
            ctx.fillRect(cx - 8, cy + 2, 16, 6);

            // Spine
            ctx.fillRect(cx - 2, cy + 8, 4, 8);

            // Pelvis
            ctx.fillRect(cx - 6, cy + 16, 12, 4);

            // Eyes (Hollow)
            ctx.fillStyle = VISUALS.ENEMY.SKELETON.EYES;
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 5, 2, 0, Math.PI * 2);
            ctx.arc(cx + 3, cy - 5, 2, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. Wolf (Fast)
        this.generateTexture('enemy_wolf', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Body (Elongated) - Grey/Brown
            ctx.fillStyle = VISUALS.ENEMY.WOLF.BODY; // Brownish grey

            ctx.beginPath();
            ctx.ellipse(cx, cy + 2, 8, 14, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.beginPath();
            ctx.arc(cx, cy - 10, 8, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.beginPath();
            ctx.moveTo(cx - 5, cy - 14);
            ctx.lineTo(cx - 8, cy - 20);
            ctx.lineTo(cx - 2, cy - 16);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(cx + 5, cy - 14);
            ctx.lineTo(cx + 8, cy - 20);
            ctx.lineTo(cx + 2, cy - 16);
            ctx.fill();

            // Tail
            ctx.strokeStyle = VISUALS.ENEMY.WOLF.BODY;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(cx, cy + 14);
            ctx.lineTo(cx, cy + 22);
            ctx.stroke();

            // Eyes (Red glow)
            ctx.fillStyle = VISUALS.ENEMY.WOLF.EYES;
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.arc(cx + 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.fill();
        });

        // 3. Troll (Heavy)
        this.generateTexture('enemy_troll', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Body (Massive) - Green skin
            ctx.fillStyle = VISUALS.ENEMY.TROLL.SKIN;

            ctx.beginPath();
            ctx.arc(cx, cy, 18, 0, Math.PI * 2);
            ctx.fill();

            // Arms (Big shoulders)
            ctx.beginPath();
            ctx.arc(cx - 16, cy - 5, 8, 0, Math.PI * 2);
            ctx.arc(cx + 16, cy - 5, 8, 0, Math.PI * 2);
            ctx.fill();

            // Head (Small relative to body)
            ctx.beginPath();
            ctx.arc(cx, cy - 10, 10, 0, Math.PI * 2);
            ctx.fill();

            // Angry brow
            ctx.fillStyle = VISUALS.ENEMY.TROLL.FEATURE;
            ctx.beginPath();
            ctx.arc(cx, cy - 12, 10, 0.2, Math.PI - 0.2, true);
            ctx.fill();
        });

        // 4. Spider (Boss)
        this.generateTexture('enemy_spider', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Abdomen (Large rear) - Black/Dark Purple
            ctx.fillStyle = VISUALS.ENEMY.SPIDER.BODY;
            ctx.beginPath();
            ctx.ellipse(cx, cy + 8, 12, 16, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cephalothorax (Head/Chest)
            ctx.fillStyle = VISUALS.ENEMY.SPIDER.HEAD;
            ctx.beginPath();
            ctx.arc(cx, cy - 8, 10, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.strokeStyle = VISUALS.ENEMY.SPIDER.BODY;
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                // Right legs
                ctx.beginPath();
                ctx.moveTo(cx + 5, cy - 5 + i * 4);
                ctx.lineTo(cx + 20, cy - 10 + i * 6);
                ctx.stroke();

                // Left legs
                ctx.beginPath();
                ctx.moveTo(cx - 5, cy - 5 + i * 4);
                ctx.lineTo(cx - 20, cy - 10 + i * 6);
                ctx.stroke();
            }

            // Many eyes
            ctx.fillStyle = VISUALS.ENEMY.SPIDER.EYES;
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.arc(cx + 3, cy - 10, 1.5, 0, Math.PI * 2);
            ctx.arc(cx, cy - 12, 2, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    private static generateEnemyProps() {
        const size = 32;

        // 1. Shield (Armor)
        this.generateTexture('prop_shield', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Wood texture
            ctx.fillStyle = VISUALS.ENEMY.PROPS.SHIELD.WOOD;
            ctx.beginPath();
            ctx.arc(cx, cy, 12, 0, Math.PI * 2);
            ctx.fill();
            // Metal rim
            ctx.strokeStyle = VISUALS.ENEMY.PROPS.SHIELD.METAL;
            ctx.lineWidth = 3;
            ctx.stroke();
            // Center boss
            ctx.fillStyle = VISUALS.ENEMY.PROPS.SHIELD.METAL;
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. Helmet (Leader)
        this.generateTexture('prop_helmet', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Gold
            ctx.fillStyle = VISUALS.ENEMY.PROPS.HELMET.GOLD;
            ctx.beginPath();
            ctx.moveTo(cx - 10, cy + 5);
            ctx.lineTo(cx + 10, cy + 5);
            ctx.lineTo(cx + 10, cy - 5);
            ctx.lineTo(cx, cy - 12); // Spike
            ctx.lineTo(cx - 10, cy - 5);
            ctx.closePath();
            ctx.fill();

            // Horns
            ctx.strokeStyle = VISUALS.ENEMY.PROPS.HELMET.HORN;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - 10, cy - 2);
            ctx.quadraticCurveTo(cx - 16, cy - 8, cx - 14, cy - 14);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cx + 10, cy - 2);
            ctx.quadraticCurveTo(cx + 16, cy - 8, cx + 14, cy - 14);
            ctx.stroke();
        });

        // 3. Barrier (Energy Shield)
        this.generateTexture('prop_barrier', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            // Semi-transparent sphere
            ctx.fillStyle = VISUALS.ENEMY.PROPS.BARRIER.FILL;
            ctx.beginPath();
            ctx.arc(cx, cy, 14, 0, Math.PI * 2);
            ctx.fill();

            // Runes
            ctx.strokeStyle = VISUALS.ENEMY.PROPS.BARRIER.STROKE;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx, cy, 12, 0, Math.PI * 2);
            ctx.stroke();
        });

        // 4. Weapon (Sword)
        this.generateTexture('prop_weapon', size, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;

            ctx.translate(cx, cy);
            ctx.rotate(Math.PI / 4); // Diagonal

            // Handle
            ctx.fillStyle = VISUALS.ENEMY.PROPS.WEAPON.HANDLE;
            ctx.fillRect(-2, 4, 4, 10);

            // Guard
            ctx.fillStyle = VISUALS.ENEMY.PROPS.WEAPON.GUARD;
            ctx.fillRect(-6, 2, 12, 2);

            // Blade
            ctx.fillStyle = VISUALS.ENEMY.PROPS.WEAPON.BLADE;
            ctx.fillRect(-3, -14, 6, 16);
            // Tip
            ctx.beginPath();
            ctx.moveTo(-3, -14);
            ctx.lineTo(3, -14);
            ctx.lineTo(0, -18);
            ctx.fill();
        });
    }
    private static generateProjectiles() {
        const size = 16;
        const cx = size / 2;
        const cy = size / 2;

        // 1. Standard (White Ball)
        this.generateTexture('projectile_standard', size, (ctx, w, h) => {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. Ice (Spike)
        this.generateTexture('projectile_ice', size, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.TURRET.ICE.SPIKE;
            ctx.beginPath();
            ctx.moveTo(cx + 6, cy);
            ctx.lineTo(cx - 2, cy + 4);
            ctx.lineTo(cx - 4, cy);
            ctx.lineTo(cx - 2, cy - 4);
            ctx.fill();
        });

        // 3. Fire (Fireball)
        this.generateTexture('projectile_fire', size, (ctx, w, h) => {
            // Core
            ctx.fillStyle = VISUALS.TOWER.TURRET.FIRE.MAIN;
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, Math.PI * 2);
            ctx.fill();
            // Outer glow (simulated)
            ctx.fillStyle = 'rgba(255, 87, 34, 0.5)';
            ctx.beginPath();
            ctx.arc(cx, cy, 7, 0, Math.PI * 2);
            ctx.fill();
        });

        // 4. Sniper (Bullet Head) - Trail is drawn dynamically
        this.generateTexture('projectile_sniper', size, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.TURRET.SNIPER.BARREL;
            ctx.fillRect(cx - 4, cy - 1.5, 8, 3);
        });

        // 5. Split (Small Pellet)
        this.generateTexture('projectile_split', size, (ctx, w, h) => {
            ctx.fillStyle = VISUALS.TOWER.TURRET.SPLIT.BARREL;
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        // 6. Minigun (Tracer round)
        this.generateTexture('projectile_minigun', size, (ctx, w, h) => {
            // Small fast tracer with purple/electric glow
            ctx.fillStyle = '#ba68c8'; // Purple 300
            ctx.fillRect(cx - 2, cy - 1, 5, 2);

            // Core
            ctx.fillStyle = '#e1bee7'; // Purple 100 (bright center)
            ctx.fillRect(cx, cy - 0.5, 3, 1);
        });
    }

    private static generateMisc() {
        // Shadow (Generic)
        this.generateTexture('shadow_small', 32, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(cx, cy, 12, 6, 0, 0, Math.PI * 2);
            ctx.fill();
        });

        // Muzzle Flash
        this.generateTexture('effect_muzzle_flash', 32, (ctx, w, h) => {
            const cx = w / 2;
            const cy = h / 2;
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 12);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(cx, cy, 12, 0, Math.PI * 2);
            ctx.fill();
        });
    }
}
</file>

<file path="src/EntityFactory.ts">
import { Enemy } from './Enemy';
import { Tower } from './Tower';
import { CONFIG, getEnemyType } from './Config';
import { generateUUID } from './Utils';

export class EntityFactory {
    // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–±—Ä–∞–ª–∏ –ª–∏—à–Ω–∏–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã, —Ç–µ–ø–µ—Ä—å —Ä–æ–≤–Ω–æ 3
    public static createEnemy(typeKey: string, wave: number, path: { x: number; y: number }[]): Enemy {
        const enemy = new Enemy();
        this.setupEnemy(enemy, typeKey, wave, path);
        return enemy;
    }

    public static setupEnemy(enemy: Enemy, typeKey: string, wave: number, path: { x: number; y: number }[]) {
        const safeKey = typeKey || 'GRUNT';

        const typeConf = getEnemyType(safeKey) || getEnemyType('GRUNT')!;
        if (!getEnemyType(safeKey)) {
            console.warn(`Unknown enemy type: ${typeKey}, falling back to GRUNT`);
        }

        const hp = CONFIG.ENEMY.BASE_HP * typeConf.hpMod * Math.pow(CONFIG.ENEMY.HP_GROWTH, wave - 1);

        // Spawn enemy at the first waypoint
        const startX = path.length > 0 ? path[0].x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 : 0;
        const startY = path.length > 0 ? path[0].y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2 : 0;

        enemy.init({
            id: `e_${generateUUID()}`,
            health: hp,
            speed: typeConf.speed,
            path: path,
            x: startX,
            y: startY,
        });

        enemy.setType(typeConf.id || safeKey.toLowerCase());
        enemy.reward = typeConf.reward || 5;
    }

    public static createTower(col: number, row: number): Tower {
        return new Tower(col, row);
    }
}
</file>

<file path="src/index.ts">
import { Game } from './Game';
import { getSavedMaps, deleteMapFromStorage } from './Utils';
import { CONFIG } from './Config';
import { CrashHandler } from './CrashHandler';

// Expose utils to window for EditorScene
(window as any).getSavedMaps = getSavedMaps;
(window as any).deleteMapFromStorage = deleteMapFromStorage;

window.addEventListener('DOMContentLoaded', () => {
    new CrashHandler();

    const canvas = document.getElementById('game-canvas');
    if (!canvas) {
        console.error('‚ùå –û–®–ò–ë–ö–ê: Canvas –Ω–µ –Ω–∞–π–¥–µ–Ω!');
        return;
    }

    try {
        const game = new Game('game-canvas');
        game.start();

        // Theme Switcher Logic
        const themeBtn = document.getElementById('theme-btn');
        if (themeBtn) {
            themeBtn.addEventListener('click', () => {
                // Toggle Config
                if (CONFIG.VISUAL_STYLE === 'SPRITE') {
                    CONFIG.VISUAL_STYLE = 'INK';
                    document.body.classList.add('ink-mode');
                    themeBtn.innerText = '‚úíÔ∏è'; // Pen icon for Ink mode
                    themeBtn.style.background = '#8d6e63';
                } else {
                    CONFIG.VISUAL_STYLE = 'SPRITE';
                    document.body.classList.remove('ink-mode');
                    themeBtn.innerText = 'üé®'; // Palette icon for Sprite mode
                    themeBtn.style.background = '#444';
                }
                console.log(`Visual Style Switched to: ${CONFIG.VISUAL_STYLE}`);
            });

            // Set initial state
            if (CONFIG.VISUAL_STYLE === 'INK') {
                document.body.classList.add('ink-mode');
                themeBtn.innerText = '‚úíÔ∏è';
                themeBtn.style.background = '#8d6e63';
            }
        }

        console.log('‚úÖ –ò–≥—Ä–∞ –≥–æ—Ç–æ–≤–∞. –ù–∞–∂–º–∏—Ç–µ ‚öîÔ∏è, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –≤–æ–ª–Ω—É.');
    } catch (e) {
        console.error('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞:', e);
    }
});
</file>

<file path="src/MapData.ts">
// –†–µ–∂–∏–º—ã –ø–æ—è–≤–ª–µ–Ω–∏—è –≤—Ä–∞–≥–æ–≤ –∏–∑ –ø–æ—Ä—Ç–∞–ª–∞
export type SpawnPattern = 'normal' | 'random' | 'swarm';

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ–¥–Ω–æ–π –≤–æ–ª–Ω—ã
export interface IWaveConfig {
    enemies: {
        type: string;
        count: number;
        // @deprecated –°—Ç–∞—Ä—ã–µ –ø–æ–ª—è - –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è, —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        speed?: number; // 0.5, 1.0, 1.5, 2.0 etc (multiplier)
        spawnRate?: 'fast' | 'medium' | 'slow'; // spawn delay
        // –ù–æ–≤–æ–µ –ø–æ–ª–µ - —Ä–µ–∂–∏–º –ø–æ—è–≤–ª–µ–Ω–∏—è –≥—Ä—É–ø–ø—ã –≤—Ä–∞–≥–æ–≤
        spawnPattern?: SpawnPattern;
    }[]; // –ö—Ç–æ –∏ —Å–∫–æ–ª—å–∫–æ
}

// –ü–æ–ª–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
export interface IMapObject {
    type: string; // 'stone' | 'rock' | 'tree' | 'wheat' | 'flowers'
    x: number;
    y: number;
    properties?: Record<string, any>;
    size?: number; // –†–∞–∑–º–µ—Ä –æ–±—ä–µ–∫—Ç–∞ –≤ —Ç–∞–π–ª–∞—Ö (–¥–ª—è —Å–∫–∞–ª: 2 –∏–ª–∏ 3)
}

export interface Cell {
    type: number; // 0=Grass, 1=Path, 2=Decor
    x: number;
    y: number;
    decor?: string | null;
}

// –ü–æ–ª–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
export interface IMapData {
    width: number;
    height: number;
    tiles: number[][]; // 0=Grass, 1=Path, 2=Decor
    waypoints: { x: number; y: number }[];
    objects: IMapObject[];

    // –ù–æ–≤—ã–µ –ø–æ–ª—è (—Å—Ü–µ–Ω–∞—Ä–∏–π)
    waves?: IWaveConfig[];
    startingMoney?: number;
    startingLives?: number;
    manualPath?: boolean; // true if waypoints were manually placed
    fogData?: number[]; // ARRAY: fog density per tile (0=Visible, 1-5=Fog density 20%-100%)
}

export interface Cell {
    type: number; // 0=Grass, 1=Path, 2=Decor
    x: number;
    y: number;
    decor?: string | null;
}

// –ó–∞–≥–ª—É—à–∫–∞ (—á—Ç–æ–±—ã —Å—Ç–∞—Ä—ã–π –∫–æ–¥ –Ω–µ –ª–æ–º–∞–ª—Å—è, –µ—Å–ª–∏ –≥–¥–µ-—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)
export const DEMO_MAP: IMapData = {
    width: 10,
    height: 10,
    tiles: Array(10)
        .fill(0)
        .map(() => Array(10).fill(0)), // 10x10 Grass
    waypoints: [],
    objects: [],
    waves: [],
    startingMoney: 100,
    startingLives: 20,
    fogData: [],
};
</file>

<file path="src/EffectSystem.ts">
import { Assets } from './Assets';
import { RendererFactory } from './RendererFactory';
import { InkParticles } from './graphics/InkParticles';
import { CONFIG } from './Config';
import { INK_CONFIG } from './graphics/InkConfig';

export interface IEffect {
    type: 'explosion' | 'text' | 'particle' | 'scan' | 'debris' | 'screen_flash' | 'muzzle_flash' | 'scale_pop';
    x: number;
    y: number;
    life: number;
    maxLife?: number;

    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
    radius?: number;
    size?: number; // –î–ª—è —á–∞—Å—Ç–∏—Ü
    color?: string;
    text?: string;
    vx?: number;
    vy?: number;
    rotation?: number; // –í—Ä–∞—â–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü—ã
    vRot?: number; // –°–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞—â–µ–Ω–∏—è
    fontSize?: number; // For custom text size
    gravity?: number; // For debris with gravity
    flashColor?: string; // For screen flash
    enemySprite?: string; // For scale_pop death animation
    enemyColor?: string; // For enemy tint in scale_pop
}

export class EffectSystem {
    private effects: IEffect[] = [];
    private ctx: CanvasRenderingContext2D;
    private canvasWidth: number;
    private canvasHeight: number;

    constructor(ctx: CanvasRenderingContext2D) {
        this.ctx = ctx;
        this.canvasWidth = ctx.canvas.width;
        this.canvasHeight = ctx.canvas.height;
    }

    public add(effect: IEffect) {
        if (!effect.maxLife) effect.maxLife = effect.life;
        this.effects.push(effect);
    }

    public get activeEffects(): IEffect[] {
        return this.effects;
    }

    public update() {
        this.effects.forEach((e) => {
            e.life--;

            if (e.type === 'particle' || e.type === 'text' || e.type === 'debris') {
                if (e.vx) e.x += e.vx;
                if (e.vy) e.y += e.vy;

                // Gravity for debris
                if (e.type === 'debris') {
                    if (e.gravity) e.vy = (e.vy || 0) + e.gravity;
                    if (e.vx) e.vx *= 0.98;
                    if (e.rotation !== undefined && e.vRot) e.rotation += e.vRot;
                }
            }
        });

        this.effects = this.effects.filter((e) => e.life > 0);
    }

    public draw() {
        this.effects.forEach((e) => {
            // Try Factory first
            if (RendererFactory.drawEffect(this.ctx, e)) {
                return;
            }

            const progress = e.life / (e.maxLife || 1);

            this.ctx.save();
            this.ctx.globalAlpha = progress;

            if (e.type === 'explosion') {
                if (CONFIG.VISUAL_STYLE === 'INK' || CONFIG.USE_NEW_RENDERER) { // Use Ink Splatter
                    // @ts-ignore
                    InkParticles.drawSplatter(this.ctx, e.x, e.y, e.radius || 30, progress, e.color || INK_CONFIG.PALETTE.INK);
                } else {
                    this.ctx.fillStyle = e.color || 'orange';
                    this.ctx.beginPath();
                    this.ctx.arc(e.x, e.y, e.radius || 30, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            } else if (e.type === 'text') {
                const fontSize = e.fontSize || 16;
                this.ctx.fillStyle = e.color || '#fff';
                this.ctx.font = `bold ${fontSize}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(e.text || '', e.x, e.y);
                this.ctx.strokeStyle = 'black';
                this.ctx.lineWidth = fontSize > 20 ? 3 : 2;
                this.ctx.strokeText(e.text || '', e.x, e.y);
            } else if (e.type === 'particle') {
                if (CONFIG.VISUAL_STYLE === 'INK' || CONFIG.USE_NEW_RENDERER) {
                    // Ink Dot
                    this.ctx.fillStyle = e.color || '#000';
                    this.ctx.globalAlpha = Math.min(1, progress * 1.2); // Fade out faster
                    this.ctx.beginPath();
                    // Irregular dot
                    const r = e.radius || 2;
                    const wobble = Math.sin(e.x * 0.1) * 0.5;
                    this.ctx.arc(e.x, e.y, r + wobble, 0, Math.PI * 2);
                    this.ctx.fill();
                } else {
                    // Standard Spark
                    this.ctx.fillStyle = e.color || '#fff';
                    this.ctx.beginPath();
                    this.ctx.arc(e.x, e.y, e.radius || 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            } else if (e.type === 'debris') {
                // –û—Å–∫–æ–ª–æ–∫ (–∫–≤–∞–¥—Ä–∞—Ç), –∫–æ—Ç–æ—Ä—ã–π –∫—Ä—É—Ç–∏—Ç—Å—è –∏ –ø–∞–¥–∞–µ—Ç
                this.ctx.translate(e.x, e.y);
                if (e.rotation) this.ctx.rotate(e.rotation);
                this.ctx.fillStyle = e.color || '#fff';
                const s = e.size || 4;
                this.ctx.fillRect(-s / 2, -s / 2, s, s);
            } else if (e.type === 'muzzle_flash') {
                // –í—Å–ø—ã—à–∫–∞ –Ω–∞ –¥—É–ª–µ –±–∞—à–Ω–∏ - BAKED
                const img = Assets.get('effect_muzzle_flash');
                if (img) {
                    const r = e.radius || 12;
                    this.ctx.drawImage(img, e.x - r, e.y - r, r * 2, r * 2);
                } else {
                    const gradient = this.ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, e.radius || 12);
                    gradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
                    gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(e.x, e.y, e.radius || 12, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            } else if (e.type === 'screen_flash') {
                // Flash –ø–æ –∫—Ä–∞—è–º —ç–∫—Ä–∞–Ω–∞
                const flashAlpha = progress * 0.4;
                const color = e.flashColor || 'rgba(255, 0, 0, ';
                const gradient = this.ctx.createRadialGradient(
                    this.canvasWidth / 2, this.canvasHeight / 2, 0,
                    this.canvasWidth / 2, this.canvasHeight / 2, Math.max(this.canvasWidth, this.canvasHeight) * 0.7
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(1, color + flashAlpha + ')');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
            } else if (e.type === 'scale_pop') {
                // Enemy death scale pop
                const scaleProgress = 1 - progress; // Reverse: 0 -> 1
                const scale = 1 + scaleProgress * 0.5; // Scale from 1.0 to 1.5

                if (e.enemySprite) {
                    const img = Assets.get(e.enemySprite);
                    if (img) {
                        this.ctx.save();
                        this.ctx.translate(e.x, e.y);
                        this.ctx.scale(scale, scale);

                        const size = 64;
                        const half = size / 2;
                        this.ctx.drawImage(img, -half, -half, size, size);

                        // Apply tint if available
                        if (e.enemyColor) {
                            this.ctx.globalCompositeOperation = 'source-atop';
                            this.ctx.fillStyle = e.enemyColor;
                            this.ctx.globalAlpha = 0.3 * progress;
                            this.ctx.fillRect(-half, -half, size, size);
                        }

                        this.ctx.restore();
                    }
                }
            }

            this.ctx.restore();
        });
    }
}
</file>

<file path="src/InputSystem.ts">
import { Game } from './Game';
import { GameScene } from './scenes/GameScene';
import { CONFIG } from './Config';
import { SoundManager } from './SoundManager';

export class InputSystem {
    private game: Game;
    private canvas: HTMLCanvasElement;

    public mouseX: number = 0;
    public mouseY: number = 0;
    public hoverCol: number = -1;
    public hoverRow: number = -1;

    public isMouseDown: boolean = false;
    private holdTimer: number = 0;
    private holdStartCol: number = -1;
    private holdStartRow: number = -1;
    private readonly HOLD_THRESHOLD: number = 12;

    constructor(game: Game) {
        this.game = game;
        this.canvas = game.canvas;
        this.initListeners();
    }

    private initListeners() {
        // Prevent default touch actions (scrolling) on canvas
        this.canvas.style.touchAction = 'none';

        this.canvas.addEventListener('pointermove', (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;

            this.mouseX = (e.clientX - rect.left) * scaleX;
            this.mouseY = (e.clientY - rect.top) * scaleY;

            this.hoverCol = Math.floor(this.mouseX / CONFIG.TILE_SIZE);
            this.hoverRow = Math.floor(this.mouseY / CONFIG.TILE_SIZE);

            const scene = this.game.currentScene;
            if (scene instanceof GameScene) {
                if (scene.cardSys && scene.cardSys.dragCard) {
                    scene.cardSys.updateDrag(e.clientX, e.clientY);
                }
            }
        });

        this.canvas.addEventListener('pointerdown', (e) => {
            SoundManager.resume();
            if (e.isPrimary && e.button === 0) {
                this.isMouseDown = true;
                this.holdStartCol = this.hoverCol;
                this.holdStartRow = this.hoverRow;
                this.holdTimer = 0;

                // Allow dragging outside canvas to be tracked if needed, 
                // but for now relying on window.pointerup is fine.
                // this.canvas.setPointerCapture(e.pointerId);
            }
        });

        window.addEventListener('pointerup', (e) => {
            if (this.isMouseDown) {
                this.isMouseDown = false;
                // this.canvas.releasePointerCapture(e.pointerId);
            }

            const scene = this.game.currentScene;
            if (scene instanceof GameScene) {
                // –ï—Å–ª–∏ —Ç–∞—â–∏–ª–∏ –∫–∞—Ä—Ç—É
                if (scene.cardSys.dragCard) {
                    scene.cardSys.endDrag(e);
                    return;
                }

                // CRITICAL FIX: Only process grid clicks if click was on the canvas
                // Otherwise UI clicks (sell button, cards) will trigger grid click and deselect tower
                const clickTarget = e.target as HTMLElement;
                const clickedOnCanvas = clickTarget === this.canvas;

                if (!clickedOnCanvas) {
                    // Click was on a UI element, don't process as grid click
                    this.holdTimer = 0;
                    return;
                }

                // –ï—Å–ª–∏ —ç—Ç–æ –±—ã–ª –∫–ª–∏–∫ (–Ω–µ —É–¥–µ—Ä–∂–∞–Ω–∏–µ)
                if (this.holdTimer < this.HOLD_THRESHOLD) {
                    // –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–∞ GameScene
                    scene.handleGridClick(this.hoverCol, this.hoverRow);
                }
            }

            this.holdTimer = 0;
        });
    }

    public update() {
        const scene = this.game.currentScene;

        if (this.isMouseDown && scene instanceof GameScene) {
            if (!scene.cardSys.dragCard) {
                if (
                    this.hoverCol === this.holdStartCol &&
                    this.hoverRow === this.holdStartRow &&
                    this.hoverCol !== -1
                ) {
                    this.holdTimer++;
                    if (this.holdTimer >= this.HOLD_THRESHOLD) {
                        // –í—ã–∑–æ–≤ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
                        scene.startBuildingTower(this.hoverCol, this.hoverRow);
                    }
                } else {
                    this.holdTimer = 0;
                }
            }
        }
    }
}
</file>

<file path="src/UIManager.ts">
import { IGameScene } from './scenes/IGameScene';
import { GameHUD } from './ui/GameHUD';
import { PauseMenu } from './ui/PauseMenu';
import { GameOverUI } from './ui/GameOverUI';
import { ShopUI } from './ui/ShopUI';

export class UIManager {
    private scene: IGameScene;

    // Components
    public shop: ShopUI;
    public hud: GameHUD;
    public pauseMenu: PauseMenu;
    public gameOver: GameOverUI;

    // –°—Å—ã–ª–∫–∏ –Ω–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã –¥–ª—è —Å–∫—Ä—ã—Ç–∏—è/–ø–æ–∫–∞–∑–∞
    private elHandContainer: HTMLElement;
    private elUiLayer: HTMLElement;

    constructor(scene: IGameScene) {
        this.scene = scene;

        // Init Components
        this.shop = new ShopUI(scene);
        this.hud = new GameHUD(scene);
        console.log('‚ú® UIManager: Initializing PauseMenu...');
        this.pauseMenu = new PauseMenu(scene);
        this.gameOver = new GameOverUI(scene);

        // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã
        this.elHandContainer = document.getElementById('hand-container')!;
        this.elUiLayer = document.getElementById('ui-layer')!;
    }

    public updatePauseMenu(paused: boolean) {
        this.pauseMenu.update(paused);
    }

    // --- –ù–û–í–´–ï –ú–ï–¢–û–î–´ –£–ü–†–ê–í–õ–ï–ù–ò–Ø –í–ò–î–ò–ú–û–°–¢–¨–Æ ---
    public show() {
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–≥—Ä–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
        this.elUiLayer.style.display = 'block';
        this.elHandContainer.style.display = 'block';
        // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ Game Over —Å–∫—Ä—ã—Ç –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
        this.gameOver.hide();
        this.update();
    }

    public hide() {
        // –ü—Ä—è—á–µ–º –≤—Å—ë –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –≤ –º–µ–Ω—é –∏–ª–∏ —Ä–µ–¥–∞–∫—Ç–æ—Ä
        this.elUiLayer.style.display = 'none';
        this.elHandContainer.style.display = 'none';
        this.gameOver.hide();
    }
    // ------------------------------------------

    public showGameOver(wave: number) {
        this.gameOver.show(wave);
    }

    public hideGameOver() {
        this.gameOver.hide();
    }

    public update() {
        if (!this.scene) return;

        this.hud.update();
        this.shop.update();
    }
}
</file>

<file path="src/scenes/EditorScene.ts">
import { BaseScene } from '../BaseScene';
import { Game } from '../Game';
import { MapManager } from '../Map';
import { CONFIG } from '../Config';
import { IMapData, IMapObject } from '../MapData';
import { serializeMap, saveMapToStorage, getSavedMaps, deleteMapFromStorage } from '../Utils';
import { UIUtils } from '../UIUtils';
import { Pathfinder } from '../Pathfinder';
import { WaveEditor } from '../WaveEditor';
import { FogSystem } from '../FogSystem';
import { EditorToolbar, EditorMode } from '../editor/EditorToolbar';
import { WaypointManager } from '../editor/WaypointManager';
import { EditorHistory, EditorActions } from '../editor/EditorHistory';

export class EditorScene extends BaseScene {
    private game: Game;
    private map: MapManager;
    private fog: FogSystem;
    private toolbar!: EditorToolbar;
    private controlsContainer!: HTMLElement;
    private waypointMgr!: WaypointManager;
    private history!: EditorHistory;

    private mode: EditorMode = 'paint_road';

    // FEATURE: Saved maps panel
    private mapsPanel!: HTMLElement;
    private mapsPanelExpanded: boolean = false;
    private currentMapName: string = '';

    // Track previous mouse state for click detection (not hold)
    private prevMouseDown: boolean = false;
    private lastClickedTile: { col: number; row: number } | null = null;

    constructor(game: Game) {
        super();
        this.game = game;

        // –°–æ–∑–¥–∞–µ–º –ø—É—Å—Ç—É—é —Å–µ—Ç–∫—É
        const cols = Math.ceil(game.canvas.width / CONFIG.TILE_SIZE);
        const rows = Math.ceil(game.canvas.height / CONFIG.TILE_SIZE);
        const emptyTiles = Array(rows)
            .fill(0)
            .map(() => Array(cols).fill(0));

        const emptyData: IMapData = {
            width: cols,
            height: rows,
            tiles: emptyTiles,
            waypoints: [],
            objects: [],
        };

        this.map = new MapManager(emptyData);
        this.fog = new FogSystem(emptyData);
        this.waypointMgr = new WaypointManager();
        this.history = new EditorHistory();
        this.createUI();
        this.createMapsPanel();
        this.setupHotkeys();
    }

    public onEnter() {
        this.toolbar.show();
        this.controlsContainer.style.display = 'flex';
        this.mapsPanel.style.display = 'block';
        const uiLayer = document.getElementById('ui-layer');
        if (uiLayer) uiLayer.style.display = 'none';

        // Initial fog render
        this.fog.update(0);
    }

    public onExit() {
        this.toolbar.hide();
        this.controlsContainer.style.display = 'none';
        this.mapsPanel.style.display = 'none';
        if (this.toolbar) this.toolbar.destroy();
        if (this.controlsContainer.parentNode) this.controlsContainer.parentNode.removeChild(this.controlsContainer);
        if (this.mapsPanel.parentNode) this.mapsPanel.parentNode.removeChild(this.mapsPanel);
    }

    public update() {
        // Don't update fog animation in editor - only static rendering
        const input = this.game.input;

        // Handle mouse input - works on hold
        if (input.isMouseDown && input.hoverCol >= 0 && input.hoverRow >= 0) {
            // Check if clicked on a different tile
            const isDifferentTile =
                !this.lastClickedTile ||
                this.lastClickedTile.col !== input.hoverCol ||
                this.lastClickedTile.row !== input.hoverRow;

            if (isDifferentTile) {
                this.handleInput(input.hoverCol, input.hoverRow);
                this.lastClickedTile = { col: input.hoverCol, row: input.hoverRow };

                // Trigger fog re-render after data change (static, no animation)
                this.fog.update(0);
            }
        }

        // Update previous state
        this.prevMouseDown = input.isMouseDown;

        // Reset last clicked tile when mouse is released
        if (!input.isMouseDown) {
            this.lastClickedTile = null;
        }
    }

    private handleInput(col: number, row: number) {
        if (col >= this.map.cols || row >= this.map.rows) return;

        const oldTileType = this.map.grid[row][col].type;
        const oldFogDensity = this.fog.getFog(col, row);

        if (this.mode === 'paint_road') {
            if (oldTileType !== 1) {
                this.history.push(EditorActions.createTileAction(this.map.grid, col, row, oldTileType, 1));
                this.map.grid[row][col].type = 1;
                this.map.grid[row][col].decor = null;
            }
        } else if (this.mode === 'paint_grass') {
            if (oldTileType !== 0) {
                this.history.push(EditorActions.createTileAction(this.map.grid, col, row, oldTileType, 0));
                this.map.grid[row][col].type = 0;
            }
        } else if (this.mode === 'eraser') {
            // FEATURE: Eraser - reset to grass, remove fog, and remove objects
            const hasObject = this.map.objects.find(obj => {
                const size = obj.size || 1;
                return col >= obj.x && col < obj.x + size &&
                    row >= obj.y && row < obj.y + size;
            });

            if (oldTileType !== 0 || oldFogDensity !== 0 || hasObject) {
                // –°–±—Ä–æ—Å —Ç–∞–π–ª–∞ –≤ —Ç—Ä–∞–≤—É
                if (oldTileType !== 0) {
                    this.history.push(EditorActions.createTileAction(this.map.grid, col, row, oldTileType, 0));
                    this.map.grid[row][col].type = 0;
                    this.map.grid[row][col].decor = null;
                }
                // –£–¥–∞–ª–µ–Ω–∏–µ —Ç—É–º–∞–Ω–∞
                if (oldFogDensity !== 0) {
                    this.history.push(EditorActions.createFogAction(this.fog, col, row, oldFogDensity, 0));
                    this.fog.setFog(col, row, 0);
                }
                // –£–¥–∞–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ (–≤—Å–µ –æ–±—ä–µ–∫—Ç—ã, –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—é—â–∏–µ —ç—Ç–æ—Ç —Ç–∞–π–ª)
                if (hasObject) {
                    this.map.objects = this.map.objects.filter(obj => {
                        const size = obj.size || 1;
                        const overlaps = col >= obj.x && col < obj.x + size &&
                            row >= obj.y && row < obj.y + size;
                        return !overlaps;
                    });
                }
            }
        } else if (this.mode === 'set_start') {
            const oldState = {
                start: this.waypointMgr.getStart(),
                end: this.waypointMgr.getEnd(),
                waypoints: this.waypointMgr.getWaypoints()
            };
            this.history.push(EditorActions.createWaypointAction(this.waypointMgr, 'setStart', { x: col, y: row }, oldState));
            this.waypointMgr.setStart({ x: col, y: row });
            this.map.grid[row][col].type = 1;
        } else if (this.mode === 'set_end') {
            const oldState = {
                start: this.waypointMgr.getStart(),
                end: this.waypointMgr.getEnd(),
                waypoints: this.waypointMgr.getWaypoints()
            };
            this.history.push(EditorActions.createWaypointAction(this.waypointMgr, 'setEnd', { x: col, y: row }, oldState));
            this.waypointMgr.setEnd({ x: col, y: row });
            this.map.grid[row][col].type = 1;
        } else if (this.mode === 'place_waypoint') {
            if (this.waypointMgr.canAddWaypoint()) {
                const oldState = {
                    start: this.waypointMgr.getStart(),
                    end: this.waypointMgr.getEnd(),
                    waypoints: this.waypointMgr.getWaypoints()
                };
                this.history.push(EditorActions.createWaypointAction(this.waypointMgr, 'addWaypoint', { x: col, y: row }, oldState));
                this.waypointMgr.addWaypoint({ x: col, y: row });
            }
        } else if (this.mode === 'paint_fog') {
            // Cycle fog density: 0 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 0
            this.fog.cycleFogDensity(col, row);
            const newFogDensity = this.fog.getFog(col, row);
            if (oldFogDensity !== newFogDensity) {
                this.history.push(EditorActions.createFogAction(this.fog, col, row, oldFogDensity, newFogDensity));
            }
        } else if (this.mode === 'place_stone') {
            this.placeObject(col, row, 'stone', 1);
        } else if (this.mode === 'place_rock') {
            // –°–∫–∞–ª—ã - —Ä–∞–Ω–¥–æ–º–Ω—ã–π —Ä–∞–∑–º–µ—Ä 2-3 —Ç–∞–π–ª–∞
            const size = Math.random() > 0.5 ? 3 : 2;
            this.placeObject(col, row, 'rock', size);
        } else if (this.mode === 'place_tree') {
            this.placeObject(col, row, 'tree', 1);
        } else if (this.mode === 'place_wheat') {
            this.placeObject(col, row, 'wheat', 1);
        } else if (this.mode === 'place_flowers') {
            this.placeObject(col, row, 'flowers', 1);
        }
    }

    /**
     * Place an object on the map
     */
    private placeObject(col: number, row: number, type: string, size: number): void {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
        if (col + size > this.map.cols || row + size > this.map.rows) {
            return; // –í—ã—Ö–æ–¥–∏—Ç –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã
        }

        // –£–¥–∞–ª–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –æ–±—ä–µ–∫—Ç—ã –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏
        this.map.objects = this.map.objects.filter(obj => {
            const objSize = obj.size || 1;
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
            const overlaps = !(col + size <= obj.x || col >= obj.x + objSize ||
                row + size <= obj.y || row >= obj.y + objSize);
            return !overlaps;
        });

        // –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç
        const newObj = {
            type,
            x: col,
            y: row,
            properties: {},
            size: size > 1 ? size : undefined
        };
        this.map.objects.push(newObj);
    }

    public draw(ctx: CanvasRenderingContext2D) {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);

        for (let y = 0; y < this.map.rows; y++) {
            for (let x = 0; x < this.map.cols; x++) {
                this.map.tiles[y][x] = this.map.grid[y][x].type;
            }
        }

        // We do NOT overwrite map.waypoints here every frame anymore.
        // It prevents saving them correctly.
        this.map.draw(ctx);
        this.fog.draw(ctx);

        // Draw waypoints with WaypointManager
        this.waypointMgr.draw(ctx);


        const input = this.game.input;
        if (input.hoverCol >= 0) {
            const x = input.hoverCol * CONFIG.TILE_SIZE;
            const y = input.hoverRow * CONFIG.TILE_SIZE;

            ctx.strokeStyle = 'yellow';
            if (this.mode === 'paint_grass') ctx.strokeStyle = 'red';
            if (this.mode === 'eraser') ctx.strokeStyle = '#ff6600';
            if (this.mode === 'set_start') ctx.strokeStyle = 'cyan';
            if (this.mode === 'set_end') ctx.strokeStyle = 'magenta';
            if (this.mode === 'place_waypoint') ctx.strokeStyle = '#00ff00';

            if (this.mode === 'paint_fog') {
                // Show current fog density with color intensity
                const density = this.fog.getFog(input.hoverCol, input.hoverRow);
                const intensity = density * 40 + 80; // 80-280 range
                ctx.strokeStyle = `rgb(${intensity}, ${intensity + 30}, ${intensity + 50})`;

                // Draw density indicator
                ctx.fillStyle = `rgba(200, 215, 230, ${density * 0.15})`;
                ctx.fillRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);

                // Draw density number
                if (density > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(density.toString(), x + CONFIG.TILE_SIZE / 2, y + CONFIG.TILE_SIZE / 2);
                }
            }

            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
        }
    }

    private openWaveConfig() {
        // Use WaypointManager's full path
        if (this.waypointMgr.isValid()) {
            this.map.waypoints = this.waypointMgr.getFullPath();
        } else {
            alert('Set Start and End points first!');
            return;
        }

        const currentWaves = (this.map as any).waves || [];

        new WaveEditor(
            currentWaves,
            (waves) => {
                this.saveMap(waves);
            },
            () => {
                // Cancelled
            },
        );
    }

    private saveMap(waves: any[]) {
        // [FIX] Ensure map waves are updated before serialization
        (this.map as any).waves = waves;

        const data = serializeMap(this.map);
        data.fogData = this.fog.getFogData();
        data.manualPath = this.waypointMgr.isValid(); // Using waypoint manager

        const name = prompt('Enter map name:', this.currentMapName || 'MyMap');
        if (!name) return;

        if (saveMapToStorage(name, data)) {
            this.currentMapName = name; // Update current name
            alert(`Map "${name}" saved successfully!`);
            this.refreshMapsPanel(); // Refresh UI
        } else {
            alert('Failed to save map (Storage full?)');
        }
    }

    private createUI() {
        // Create new modular toolbar
        this.toolbar = new EditorToolbar((mode) => {
            this.mode = mode;
        });

        // Create controls container for additional buttons (WAVES, MENU, Clear Path)
        this.controlsContainer = UIUtils.createContainer({
            position: 'absolute',
            top: '20px',
            right: '20px',
            display: 'flex',
            flexDirection: 'column',
            gap: '8px',
            padding: '10px',
            background: 'rgba(0,0,0,0.85)',
            borderRadius: '8px',
            zIndex: '1000'
        });

        const addBtn = (text: string, onClick: () => void, color: string = '#444') => {
            UIUtils.createButton(this.controlsContainer, text, onClick, {
                background: color,
                border: '1px solid #666',
                padding: '10px 16px',
                borderRadius: '6px',
                fontSize: '14px',
                fontWeight: 'bold',
                width: '100%'
            });
        };

        addBtn('üóëÔ∏è Clear Path', () => {
            this.waypointMgr.clearAll();
        }, '#e91e63');

        addBtn('‚öôÔ∏è WAVES & SAVE', () => this.openWaveConfig(), '#ff9800');
        addBtn('üö™ MENU', () => this.game.toMenu(), '#d32f2f');

        document.body.appendChild(this.controlsContainer);
    }

    // FEATURE: Create saved maps panel
    private createMapsPanel() {
        this.mapsPanel = UIUtils.createContainer({
            position: 'absolute',
            top: '20px',
            left: '20px',
            background: 'rgba(0, 0, 0, 0.9)',
            borderRadius: '8px',
            padding: '10px',
            maxWidth: '300px',
            maxHeight: '80vh',
            overflowY: 'auto',
            display: 'none',
            zIndex: '2000'
        });

        const header = document.createElement('div');
        Object.assign(header.style, {
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: '10px',
            cursor: 'pointer',
            color: '#fff',
            fontWeight: 'bold',
        });

        header.innerHTML = `
            <span>üìÅ SAVED MAPS</span>
            <span style="font-size: 20px;">${this.mapsPanelExpanded ? '‚ñº' : '‚ñ∂'}</span>
        `;

        header.onclick = () => {
            this.mapsPanelExpanded = !this.mapsPanelExpanded;
            this.refreshMapsPanel();
        };

        this.mapsPanel.appendChild(header);
        document.body.appendChild(this.mapsPanel);
        this.refreshMapsPanel();
    }

    private refreshMapsPanel() {
        console.log('Refreshing Maps Panel. Raw Storage:', localStorage.getItem('NEWTOWER_MAPS'));
        const maps = getSavedMaps();
        console.log('Parsed Maps:', maps);
        // Clear current content except header
        while (this.mapsPanel.children.length > 1) {
            this.mapsPanel.removeChild(this.mapsPanel.lastChild!);
        }

        // Update toggle icon
        const header = this.mapsPanel.children[0] as HTMLElement;
        header.innerHTML = `
            <span>üìÅ SAVED MAPS</span>
            <span style="font-size: 20px;">${this.mapsPanelExpanded ? '‚ñº' : '‚ñ∂'}</span>
        `;

        if (!this.mapsPanelExpanded) return;


        const mapNames = Object.keys(maps);

        if (mapNames.length === 0) {
            const empty = document.createElement('div');
            empty.style.color = '#888';
            empty.style.padding = '10px';
            empty.innerText = 'No saved maps';
            this.mapsPanel.appendChild(empty);
            return;
        }

        mapNames.forEach((name) => {
            const item = document.createElement('div');
            Object.assign(item.style, {
                background: '#222',
                padding: '10px',
                marginBottom: '5px',
                borderRadius: '4px',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
            });

            const nameSpan = document.createElement('span');
            nameSpan.style.color = '#fff';
            nameSpan.style.flex = '1';
            nameSpan.innerText = name;

            const btnContainer = document.createElement('div');
            btnContainer.style.display = 'flex';
            btnContainer.style.gap = '5px';

            const loadBtn = document.createElement('button');
            loadBtn.innerText = 'üìÇ Load';
            Object.assign(loadBtn.style, {
                background: '#4caf50',
                color: '#fff',
                border: 'none',
                padding: '5px 10px',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '12px',
            });
            loadBtn.onclick = () => this.loadMap(name, maps[name]);

            const delBtn = document.createElement('button');
            delBtn.innerText = 'üóëÔ∏è';
            Object.assign(delBtn.style, {
                background: '#f44336',
                color: '#fff',
                border: 'none',
                padding: '5px 10px',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '12px',
            });
            delBtn.onclick = () => this.deleteMap(name);

            btnContainer.appendChild(loadBtn);
            btnContainer.appendChild(delBtn);

            item.appendChild(nameSpan);
            item.appendChild(btnContainer);
            this.mapsPanel.appendChild(item);
        });
    }

    private loadMap(name: string, data: any) {
        if (!confirm(`Load map "${name}"? Current work will be lost.`)) return;

        // Load map data into editor
        this.currentMapName = name; // [FIX] Track loaded map name
        this.map = new MapManager(data);
        this.fog = new FogSystem(data);

        // Load waypoints into WaypointManager
        this.waypointMgr.clearAll();
        if (data.waypoints && data.waypoints.length > 0) {
            // First point is always Start
            this.waypointMgr.setStart(data.waypoints[0]);

            // Last point is always End (if more than 1)
            if (data.waypoints.length > 1) {
                this.waypointMgr.setEnd(data.waypoints[data.waypoints.length - 1]);
            }

            // Middle points are waypoints
            for (let i = 1; i < data.waypoints.length - 1; i++) {
                this.waypointMgr.addWaypoint(data.waypoints[i]);
            }
        }

        // Render loaded fog
        this.fog.update(0);
    }

    private deleteMap(name: string) {
        if (!confirm(`Delete map "${name}"? This cannot be undone.`)) return;

        deleteMapFromStorage(name);
        this.refreshMapsPanel();
    }

    private setupHotkeys() {
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input fields
            if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
                return;
            }

            // Ctrl+Z - Undo
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                if (this.history.undo()) {
                    this.fog.update(0); // Re-render fog after undo
                }
                return;
            }

            // Ctrl+Shift+Z - Redo
            if (e.ctrlKey && e.shiftKey && e.key === 'Z') {
                e.preventDefault();
                if (this.history.redo()) {
                    this.fog.update(0); // Re-render fog after redo
                }
                return;
            }

            // Ctrl+S - Save
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                this.openWaveConfig();
                return;
            }

            // E - Eraser mode
            if (e.key === 'e' || e.key === 'E') {
                this.mode = 'eraser';
                return;
            }

            // 1-3 - Category selection
            if (e.key >= '1' && e.key <= '3') {
                const categoryIndex = parseInt(e.key) - 1;
                this.toolbar.selectCategory(categoryIndex);
                return;
            }
        });
    }

}
</file>

<file path="src/Utils.ts">
import { MapManager } from './Map';
import { IMapData, IWaveConfig } from './MapData';
import { CONFIG } from './Config';

export function generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0,
            v = c == 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}

export class ObjectPool<T> {
    private createFn: () => T;
    private pool: T[] = [];
    constructor(createFn: () => T) {
        this.createFn = createFn;
    }
    public obtain(): T {
        return this.pool.length > 0 ? this.pool.pop()! : this.createFn();
    }
    public free(obj: T): void {
        // Type-safe check for reset method
        if (obj && typeof obj === 'object' && 'reset' in obj && typeof (obj as any).reset === 'function') {
            (obj as any).reset();
        }
        this.pool.push(obj);
    }
}

export function generateDefaultWaves(count: number = 10): IWaveConfig[] {
    const waves: IWaveConfig[] = [];
    for (let i = 1; i <= count; i++) {
        const waveEnemies: { type: string; count: number }[] = [];
        if (i <= 3) {
            waveEnemies.push({ type: 'grunt', count: 3 + i * 2 });
        } else {
            waveEnemies.push({ type: 'grunt', count: 5 + i });
            waveEnemies.push({ type: 'scout', count: Math.floor(i / 2) });
        }
        waves.push({ enemies: waveEnemies });
    }
    return waves;
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∏ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –≤–æ–ª–Ω—ã –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
 * –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –æ–±—Ä–∞—Ç–Ω—É—é —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è–º–∏
 */
export function normalizeWaveConfig(wave: any): IWaveConfig {
    if (!wave || !wave.enemies || !Array.isArray(wave.enemies)) {
        return { enemies: [] };
    }

    return {
        enemies: wave.enemies.map((group: any) => ({
            type: group.type || 'GRUNT',
            count: Math.max(1, parseInt(group.count) || 1),
            spawnPattern: (['normal', 'random', 'swarm'].includes(group.spawnPattern))
                ? group.spawnPattern
                : 'normal',
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—ã–µ –ø–æ–ª—è –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
            speed: group.speed,
            spawnRate: group.spawnRate
        }))
    };
}


export function serializeMap(map: MapManager): IMapData {
    const simpleTiles: number[][] = [];
    for (let y = 0; y < map.rows; y++) {
        const row: number[] = [];
        for (let x = 0; x < map.cols; x++) {
            row.push(map.grid[y][x].type);
        }
        simpleTiles.push(row);
    }
    return {
        width: map.cols,
        height: map.rows,
        tiles: simpleTiles,
        waypoints: map.waypoints.map((wp) => ({ x: wp.x, y: wp.y })),
        objects: map.objects || [], // Include objects from map
        waves: map.waves && map.waves.length > 0 ? map.waves : generateDefaultWaves(15),
        startingMoney: CONFIG.PLAYER.START_MONEY,
        startingLives: CONFIG.PLAYER.START_LIVES,
    };
}

export function validateMap(data: any): boolean {
    if (!data) return false;
    if (!data.tiles || !Array.isArray(data.tiles) || data.tiles.length === 0) {
        console.error('Map Validation Failed: No tiles data');
        return false;
    }
    if (!data.waypoints || !Array.isArray(data.waypoints)) {
        console.error('Map Validation Failed: No waypoints array');
        return false;
    }
    if (data.waypoints.length < 2) {
        console.error('Map Validation Failed: Path too short (<2 waypoints)');
        return false;
    }
    return true;
}

// --- STORAGE UTILS ---

export function getSavedMaps(): Record<string, IMapData> {
    try {
        const raw = localStorage.getItem('NEWTOWER_MAPS');
        if (!raw) return {};

        const maps = JSON.parse(raw);

        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –≤–æ–ª–Ω –≤–æ –≤—Å–µ—Ö –∫–∞—Ä—Ç–∞—Ö –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        Object.keys(maps).forEach(mapName => {
            const mapData = maps[mapName];
            if (mapData.waves && Array.isArray(mapData.waves)) {
                mapData.waves = mapData.waves.map(normalizeWaveConfig);
            }
        });

        return maps;
    } catch (e) {
        console.error('Failed to load maps', e);
        return {};
    }
}

export function saveMapToStorage(name: string, data: IMapData): boolean {
    try {
        const maps = getSavedMaps();
        maps[name] = data;
        localStorage.setItem('NEWTOWER_MAPS', JSON.stringify(maps));
        return true;
    } catch (e) {
        console.error('Failed to save map', e);
        return false;
    }
}

export function deleteMapFromStorage(name: string): void {
    const maps = getSavedMaps();
    delete maps[name];
    localStorage.setItem('NEWTOWER_MAPS', JSON.stringify(maps));
}
</file>

<file path="src/Enemy.ts">
import { CONFIG, getEnemyType } from './Config';
import { RendererFactory } from './RendererFactory';
import { Assets } from './Assets';
import { Projectile } from './Projectile';
import { EnemyRenderer } from './renderers/EnemyRenderer';

export interface IEnemyConfig {
    id: string;
    health: number;
    speed: number;
    armor?: number;
    x?: number;
    y?: number;
    path: { x: number; y: number }[];
}

interface IStatus {
    type: 'slow' | 'burn';
    duration: number;
    power: number;
}

export class Enemy {
    public id: string;
    public typeId: string = 'grunt';

    public currentHealth: number;
    public maxHealth: number;
    public baseSpeed: number;
    public armor: number;
    public reward: number = 5; // Reward for killing this enemy

    public x: number;
    public y: number;

    public path: { x: number; y: number }[];
    public pathIndex: number = 0;
    public finished: boolean = false;

    public statuses: IStatus[] = [];
    public damageModifier: number = 1.0;     // Damage multiplier (e.g., 1.2 = +20% damage)
    public killedByProjectile: Projectile | null = null;   // Track what projectile killed this enemy
    public hitFlashTimer: number = 0;        // Timer for white flash on hit

    constructor(config?: IEnemyConfig) {
        if (config) {
            this.init(config);
        }
    }

    public init(config: IEnemyConfig) {
        this.id = config.id;
        this.maxHealth = config.health;
        this.currentHealth = config.health;
        this.baseSpeed = config.speed;
        this.armor = config.armor || 0;

        this.x = config.x || 0;
        this.y = config.y || 0;
        this.path = config.path;
        this.pathIndex = 0;
        this.finished = false;

        this.damageModifier = 1.0;
        this.killedByProjectile = null;
    }

    public reset() {
        this.statuses = [];
        this.hitFlashTimer = 0;
        this.pathIndex = 0;
        this.finished = false;
        this.damageModifier = 1.0;
        this.killedByProjectile = null;
        this.x = -1000; // Move offscreen
        this.y = -1000;
    }

    public setType(id: string) {
        this.typeId = id;
    }

    public takeDamage(amount: number, projectile?: Projectile): void {
        // Apply damage modifier (from slow effects, etc.)
        const modifiedAmount = amount * this.damageModifier;
        const actualDamage = Math.max(1, modifiedAmount - this.armor);
        this.currentHealth -= actualDamage;
        if (this.currentHealth < 0) this.currentHealth = 0;

        // Visual Feedback: Hit Flash
        this.hitFlashTimer = 5; // 5 frames ~ 80ms

        // Track what killed this enemy
        if (!this.isAlive() && projectile) {
            this.killedByProjectile = projectile;
        }
    }

    // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –º–µ—Ç–æ–¥ —Å—Ç–∞–ª public
    public move(): void {
        let speedMod = 1;
        const slow = this.statuses.find((s) => s.type === 'slow');
        if (slow) speedMod -= slow.power;

        const currentSpeed = Math.max(0, this.baseSpeed * speedMod);

        if (this.pathIndex >= this.path.length) {
            this.finished = true;
            return;
        }

        const node = this.path[this.pathIndex];
        const targetX = node.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const targetY = node.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const dist = Math.hypot(dx, dy);

        if (dist <= currentSpeed) {
            this.x = targetX;
            this.y = targetY;
            this.pathIndex++;
        } else {
            const angle = Math.atan2(dy, dx);
            this.x += Math.cos(angle) * currentSpeed;
            this.y += Math.sin(angle) * currentSpeed;
        }
    }

    public isAlive(): boolean {
        return this.currentHealth > 0;
    }

    public getHealthPercent(): number {
        return this.currentHealth / this.maxHealth;
    }

    public applyStatus(type: 'slow' | 'burn', duration: number, power: number, damageBonus?: number) {
        const existing = this.statuses.find((s) => s.type === type);
        if (existing) {
            existing.duration = duration;
            existing.power = power;
        } else {
            this.statuses.push({ type, duration, power });
        }

        // Apply damage modifier for slowed enemies (Ice level 2+)
        if (type === 'slow' && damageBonus) {
            this.damageModifier = damageBonus;
        }
    }

    public update(): void {
        // Update status durations
        this.statuses = this.statuses.filter((s) => {
            s.duration--;
            return s.duration > 0;
        });

        // Reset damage modifier if no slow status
        if (!this.statuses.some(s => s.type === 'slow')) {
            this.damageModifier = 1.0;
        }

        // Update flash timer
        if (this.hitFlashTimer > 0) this.hitFlashTimer--;
    }

    public draw(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawEnemy(ctx, this);
    }
}
</file>

<file path="src/Projectile.ts">
import { ICardEffect } from './cards';
import { Assets } from './Assets';
import { RendererFactory } from './RendererFactory';

export interface IProjectileStats {
    dmg: number;
    speed: number;
    color: string;
    effects: ICardEffect[];
    pierce: number;
    critChance?: number;           // Critical hit chance (0-1)
    isCrit?: boolean;               // Is this projectile a crit
    explodeOnDeath?: boolean;       // Fire level 3 effect
    explosionDamage?: number;       // Damage from explosion
    explosionRadius?: number;       // Radius of explosion
    projectileType?: string;        // Visual type: standard, ice, fire, sniper, split
    towerLevel?: number;            // Tower's max card level (for trail effects)
}

export class Projectile {
    public x: number = 0;
    public y: number = 0;
    public vx: number = 0;
    public vy: number = 0;
    public radius: number = 4;
    public alive: boolean = false;

    public damage: number = 0;
    public life: number = 0;
    public color: string = '#fff';
    public effects: ICardEffect[] = [];
    public pierce: number = 0;
    public hitList: string[] = [];
    public isCrit: boolean = false;           // Is this a critical hit
    public explodeOnDeath: boolean = false;   // Should explode on enemy death
    public explosionDamage: number = 0;       // Damage from explosion
    public explosionRadius: number = 0;       // Radius of explosion
    public projectileType: string = 'standard'; // Visual type
    public towerLevel: number = 1;            // Tower's max card level (for trails)

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –ø—É—Å—Ç–æ–π!
    constructor() { }

    // –ú–µ—Ç–æ–¥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ –ø—É–ª–∞)
    public init(x: number, y: number, target: { x: number; y: number }, stats: IProjectileStats) {
        this.x = x;
        this.y = y;
        this.alive = true;
        this.damage = stats.dmg;
        this.color = stats.color;
        this.effects = stats.effects;
        this.pierce = stats.pierce || 0;
        this.hitList = [];
        this.projectileType = stats.projectileType || 'standard';
        this.towerLevel = stats.towerLevel || 1;

        // Handle critical hits
        const critChance = stats.critChance || 0;
        this.isCrit = Math.random() < critChance;
        if (this.isCrit) {
            this.damage *= 2; // Critical hits deal 2x damage
        }

        // Handle explosion on death effect (Fire level 3)
        const explodeEffect = stats.effects.find((e: any) => e.type === 'explodeOnDeath');
        if (explodeEffect) {
            this.explodeOnDeath = true;
            this.explosionDamage = stats.dmg * (explodeEffect.explosionDamagePercent || 0.5);
            this.explosionRadius = explodeEffect.explosionRadius || 40;
        } else {
            this.explodeOnDeath = false;
            this.explosionDamage = 0;
            this.explosionRadius = 0;
        }

        const angle = Math.atan2(target.y - y, target.x - x);
        this.vx = Math.cos(angle) * stats.speed;
        this.vy = Math.sin(angle) * stats.speed;

        this.life = 120; // 2 —Å–µ–∫—É–Ω–¥—ã –∂–∏–∑–Ω–∏

        // Adjust life for sniper (faster = less time needed)
        if (this.projectileType === 'sniper') this.life = 60;
    }

    public update(effects?: any) { // Type 'any' to avoid strict circular import issues if EffectSystem isn't imported, but normally it should be fine. Using any for safety here or import it.
        if (!this.alive) return;

        this.x += this.vx;
        this.y += this.vy;
        this.life--;

        // --- TRAIL EFFECTS ---
        if (effects && this.life % 2 === 0) { // Spawn every 2 frames
            const type = this.projectileType || 'standard';

            // Fire Trail (Smoke/Embers)
            if (type === 'fire') {
                effects.add({
                    type: 'particle',
                    x: this.x + (Math.random() - 0.5) * 4,
                    y: this.y + (Math.random() - 0.5) * 4,
                    vx: -this.vx * 0.2 + (Math.random() - 0.5),
                    vy: -this.vy * 0.2 + (Math.random() - 0.5),
                    life: 15 + Math.random() * 10,
                    radius: 2 + Math.random() * 2,
                    color: Math.random() > 0.5 ? 'rgba(255, 100, 0, 0.5)' : 'rgba(100, 100, 100, 0.3)'
                });
            }
            // Ice Trail (Snow/Sparkle)
            else if (type === 'ice') {
                effects.add({
                    type: 'particle',
                    x: this.x,
                    y: this.y,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    life: 20,
                    radius: 1.5,
                    color: '#e1f5fe'
                });
            }
            // Sniper Trail (handled by draw mostly, but particles are nice)
            else if (type === 'sniper') {
                // Sniper is fast, maybe no particles needed, leaving trail line in draw()
            }
            // Level 3 Trail (Glow)
            if (this.towerLevel >= 3) {
                effects.add({
                    type: 'particle',
                    x: this.x,
                    y: this.y,
                    vx: 0,
                    vy: 0,
                    life: 10,
                    radius: 2,
                    color: this.color
                });
            }
        }

        if (this.life <= 0 || this.x < -100 || this.x > 2000 || this.y < -100 || this.y > 2000) {
            this.alive = false;
        }
    }

    public draw(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawProjectile(ctx, this);
    }

    public reset() {
        this.alive = false;
        this.hitList = [];
    }
}
</file>

<file path="src/Map.ts">
import { CONFIG } from './Config';
import { IMapData, Cell, IMapObject } from './MapData';
import { Assets } from './Assets';
import { Pathfinder } from './Pathfinder';
import { LightingSystem } from './systems/LightingSystem';
import { ObjectRenderer, ObjectType } from './ObjectRenderer';

export class MapManager {
    public cols!: number;
    public rows!: number;

    public grid: Cell[][] = [];

    public tiles: number[][] = [];
    public waypoints: { x: number; y: number }[] = [];
    public waves: any[] = [];
    public lighting?: LightingSystem;
    public objects: IMapObject[] = []; // Objects for decoration and blocking

    constructor(data: IMapData) {
        this.loadMap(data);
    }

    public loadMap(data: IMapData) {
        this.cols = data.width;
        this.rows = data.height;
        this.tiles = data.tiles;
        this.waypoints = data.waypoints;
        this.waves = data.waves || [];
        this.objects = data.objects || []; // Load objects

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–±—ä–µ–∫—Ç–∞ grid –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Ä–µ–¥–∞–∫—Ç–æ—Ä–æ–º
        this.grid = [];
        for (let y = 0; y < this.rows; y++) {
            const row: Cell[] = [];
            for (let x = 0; x < this.cols; x++) {
                const type = this.tiles[y][x];
                let decor = null;
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–µ–∫–æ—Ä –≤–∏–∑—É–∞–ª—å–Ω–æ
                if (type === 2) decor = Math.random() > 0.5 ? 'tree' : 'rock';
                row.push({ type, x, y, decor });
            }
            this.grid.push(row);
        }

        // If waypoints only contain start and end, expand to full path
        if (this.waypoints.length === 2) {
            const fullPath = Pathfinder.findPath(this.grid, this.waypoints[0], this.waypoints[1]);
            if (fullPath.length > 0) {
                this.waypoints = fullPath;
            }
        }
    }

    public isBuildable(col: number, row: number): boolean {
        if (col < 0 || col >= this.cols || row < 0 || row >= this.rows) return false;
        if (this.tiles[row][col] !== 0) return false; // Only grass is buildable

        // Check if any object occupies this tile
        const hasObject = this.objects.some(obj => {
            const size = obj.size || 1;
            return col >= obj.x && col < obj.x + size &&
                row >= obj.y && row < obj.y + size;
        });

        return !hasObject;
    }

    public draw(ctx: CanvasRenderingContext2D) {
        const TS = CONFIG.TILE_SIZE;

        for (let y = 0; y < this.rows; y++) {
            for (let x = 0; x < this.cols; x++) {
                const type = this.tiles[y][x];
                const px = x * TS;
                const py = y * TS;

                // –†–∏—Å—É–µ–º —Ç–∞–π–ª
                if (type === 1) {
                    // PATH
                    this.drawTile(ctx, 'path', px, py);
                } else {
                    // GRASS (0) - —Ç–∏–ø 2 –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
                    this.drawTile(ctx, 'grass', px, py);
                    // –°–µ—Ç–∫–∞ (REMOVED: User requested polish, no grid lines)
                    // ctx.strokeStyle = 'rgba(0,0,0,0.05)';
                    // ctx.lineWidth = 1;
                    // ctx.strokeRect(px, py, TS, TS);
                }
            }
        }

        // Draw objects
        for (const obj of this.objects) {
            const px = obj.x * TS;
            const py = obj.y * TS;
            ObjectRenderer.draw(ctx, obj.type as ObjectType, px, py, obj.size || 1);
        }

        if (this.waypoints.length > 0) {
            const start = this.waypoints[0];
            const end = this.waypoints[this.waypoints.length - 1];
            this.drawIcon(ctx, '‚ò†Ô∏è', start.x, start.y);
            this.drawIcon(ctx, 'üè∞', end.x, end.y);
        }
    }

    // [NEW] Draw Torches overlay (called from GameScene after main draw)
    public drawTorches(ctx: CanvasRenderingContext2D, time: number = 0) {
        if (!this.lighting) return;

        // Always active, but intensity might vary if we want them to look "on" all the time
        // User requested: "flame on torches disappeared... fix it"
        // We removed the ambientLight check so they are always drawn.

        const TS = CONFIG.TILE_SIZE;
        // Intensity: Always full flame visibility
        const intensity = 1.0;

        // Light radius: 1.5 tiles
        const radiusVal = TS * 1.5;

        const checkGrass = (cx: number, cy: number) => {
            if (cx < 0 || cx >= this.cols || cy < 0 || cy >= this.rows) return true; // Edge is grass-like
            return this.tiles[cy][cx] !== 1; // 1 is path
        };

        for (let y = 0; y < this.rows; y++) {
            for (let x = 0; x < this.cols; x++) {
                if (this.tiles[y][x] === 1) { // Path

                    // Identify borders with grass
                    const top = checkGrass(x, y - 1);
                    const bottom = checkGrass(x, y + 1);
                    const left = checkGrass(x - 1, y);
                    const right = checkGrass(x + 1, y);

                    // Place torch if border exists
                    // Throttle placement (one torch per N valid spots)
                    // We use distinct hashes for different sides so they don't sync up perfectly

                    const drawTorchAt = (tx: number, ty: number, colorHash: number) => {
                        // Smooth flicker using Sine waves
                        // Combine 2 sines for non-repeating feel
                        const flickerBase = Math.sin(time * 0.1 + colorHash) * 0.05 + Math.sin(time * 0.03 + colorHash * 2) * 0.05;
                        // Occasional "pop"
                        const pop = (Math.random() > 0.98) ? (Math.random() * 0.1) : 0;

                        const flickerLocal = 1.0 + flickerBase + pop;

                        // Torch Stick
                        ctx.fillStyle = '#5d4037';
                        ctx.fillRect(tx - 2, ty, 4, 6);

                        // Flame
                        // Always visible now
                        const size = (8 + flickerBase * 4);
                        ctx.fillStyle = `rgba(255, 87, 34, ${0.8 + flickerBase})`;
                        ctx.beginPath();
                        ctx.arc(tx, ty + 2, size / 2, 0, Math.PI * 2);
                        ctx.fill();

                        // Inner Flame
                        ctx.fillStyle = `rgba(255, 235, 59, ${0.8 + flickerBase})`;
                        ctx.beginPath();
                        ctx.arc(tx, ty + 2, size / 4, 0, Math.PI * 2);
                        ctx.fill();

                        // Light
                        // User: "torch gives a circle of light... bright near torch and fades to edge... radius 1.5 tiles"
                        // We use the LightingSystem to add the light.
                        // LightingSystem uses additive blending or 'destination-out' depending on logic.
                        // Assuming LightingSystem adds light to the dark overlay.

                        const lightRadius = radiusVal + flickerBase * 5;

                        // We want the light to be noticeable. 
                        this.lighting!.addLight(tx, ty, lightRadius, '#ff9100', 0.8 * flickerLocal);
                    };

                    const spacing = 4; // Every 4th valid spot roughly

                    if (top && (x + y * 7) % spacing === 0) {
                        drawTorchAt(x * TS + TS / 2, y * TS + 4, 0);
                    }
                    if (bottom && (x + y * 13) % spacing === 0) {
                        drawTorchAt(x * TS + TS / 2, y * TS + TS - 4, 1);
                    }
                    if (left && (y + x * 11) % spacing === 0) {
                        drawTorchAt(x * TS + 4, y * TS + TS / 2, 2);
                    }
                    if (right && (y + x * 17) % spacing === 0) {
                        drawTorchAt(x * TS + TS - 4, y * TS + TS / 2, 3);
                    }
                }
            }
        }
    }

    private drawTile(ctx: CanvasRenderingContext2D, key: string, x: number, y: number) {
        // Phase 2: Bitmasking –¥–ª—è path
        if (key === 'path') {
            // –í—ã—á–∏—Å–ª–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–∞–π–ª–∞
            const col = Math.floor(x / CONFIG.TILE_SIZE);
            const row = Math.floor(y / CONFIG.TILE_SIZE);

            // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–æ—Å–µ–¥–µ–π (–¥–ª—è –±–∏—Ç–º–∞—Å–∫–∞)
            const NORTH = (row > 0 && this.tiles[row - 1][col] === 1) ? 1 : 0;
            const WEST = (col > 0 && this.tiles[row][col - 1] === 1) ? 1 : 0;
            const EAST = (col < this.cols - 1 && this.tiles[row][col + 1] === 1) ? 1 : 0;
            const SOUTH = (row < this.rows - 1 && this.tiles[row + 1][col] === 1) ? 1 : 0;

            // –í—ã—á–∏—Å–ª–∏—Ç—å –∏–Ω–¥–µ–∫—Å –±–∏—Ç–º–∞—Å–∫–∞ (0-15)
            const bitmask = NORTH | (WEST << 1) | (EAST << 2) | (SOUTH << 3);

            // –ü–æ–ª—É—á–∏—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π path tile
            const pathTile = Assets.get(`path_${bitmask}`);

            if (pathTile) {
                ctx.drawImage(pathTile, x, y);
            } else {
                // Fallback - –ø—Ä–æ—Å—Ç–æ–π path
                const fallback = Assets.get('path');
                if (fallback) {
                    ctx.drawImage(fallback, x, y);
                } else {
                    ctx.fillStyle = '#c5b8a1'; // –§–ê–ó–ê 1: –ö–∞–º–µ–Ω–Ω—ã–π fallback

                    ctx.fillRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                }
            }
            return;
        }

        // Grass (—Å –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å—é)
        // FIX: Use deterministic variant to prevent flickering (Assets.get is random)
        let img: HTMLCanvasElement | HTMLImageElement | undefined;

        if (key === 'grass') {
            const variantCount = Assets.getVariantCount('grass');
            if (variantCount > 0) {
                // Deterministic index based on position
                const index = Math.abs((x * 73 + y * 37)) % variantCount;
                img = Assets.getVariant('grass', index);
            } else {
                img = Assets.get('grass');
            }
        } else {
            img = Assets.get(key);
        }

        if (img) {
            // –î–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è —Ç—Ä–∞–≤—ã - —Å–ª—É—á–∞–π–Ω–æ–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ
            if (key === 'grass') {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–π "—Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏"
                const seed = x * 73 + y * 37;
                const flipH = (seed % 2) === 0;
                const flipV = (Math.floor(seed / 2) % 2) === 0;

                ctx.save();
                ctx.translate(x + CONFIG.TILE_SIZE / 2, y + CONFIG.TILE_SIZE / 2);
                ctx.scale(flipH ? -1 : 1, flipV ? -1 : 1);
                ctx.drawImage(img, -CONFIG.TILE_SIZE / 2, -CONFIG.TILE_SIZE / 2);
                ctx.restore();
            } else {
                ctx.drawImage(img, x, y);
            }
        } else {
            ctx.fillStyle = key === 'path' ? '#ded29e' : '#8bc34a';
            ctx.fillRect(x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
        }
    }

    private drawIcon(ctx: CanvasRenderingContext2D, icon: string, col: number, row: number) {
        const halfTile = CONFIG.TILE_SIZE / 2;
        const x = col * CONFIG.TILE_SIZE + halfTile;
        const y = row * CONFIG.TILE_SIZE + halfTile;
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(icon, x, y);
    }

    public validatePath(_start: { x: number; y: number }, _end: { x: number; y: number }): { x: number; y: number }[] {
        return [];
    }
}
</file>

<file path="src/WaveManager.ts">
import { IGameScene } from './scenes/IGameScene';
import { CONFIG } from './Config';
import { IWaveConfig, SpawnPattern } from './MapData';
import { SoundManager, SoundPriority } from './SoundManager';
import { EventBus, Events } from './EventBus';

/**
 * –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –æ –≤—Ä–∞–≥–µ –≤ –æ—á–µ—Ä–µ–¥–∏ —Å–ø–∞–≤–Ω–∞
 */
interface SpawnQueueEntry {
    type: string;
    pattern: SpawnPattern;
    baseInterval: number;
}

/**
 * Manages wave logic, spawning enemies, and tracking wave progress.
 */
export class WaveManager {
    private scene: IGameScene;
    public isWaveActive: boolean = false;

    // –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ –≤–º–µ—Å—Ç–æ –ø—Ä–æ—Å—Ç–æ–≥–æ –º–∞—Å—Å–∏–≤–∞ —Å—Ç—Ä–æ–∫
    private spawnQueue: SpawnQueueEntry[] = [];
    private spawnTimer: number = 0;
    private currentPattern: SpawnPattern = 'normal';
    private currentBaseInterval: number = 40;
    private currentIndex: number = 0; // –ò–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–≥–æ –≤—Ä–∞–≥–∞ –≤ –æ—á–µ—Ä–µ–¥–∏

    // Card reward tracking - track last wave number that received a card
    private lastCardGivenForWave: number = 0;

    constructor(scene: IGameScene) {
        this.scene = scene;
    }

    /**
     * Starts the next wave. If already active, adds bonus.
     */
    public startWave() {
        // ALLOW EARLY WAVE START
        // If wave is active, we just increment and add more enemies to the queue

        this.scene.wave++;
        EventBus.getInstance().emit(Events.WAVE_STARTED, this.scene.wave);

        // If not active, activate. If active, we just continue.
        if (!this.isWaveActive) {
            this.isWaveActive = true;
        } else {
            // Early wave bonus!
            // Early wave bonus!
            this.scene.addMoney(CONFIG.ECONOMY.EARLY_WAVE_BONUS);
            this.scene.metrics.trackMoneyEarned(CONFIG.ECONOMY.EARLY_WAVE_BONUS);
            this.scene.showFloatingText(`EARLY! +${CONFIG.ECONOMY.EARLY_WAVE_BONUS}üí∞`, this.scene.game.canvas.width / 2, 300, 'gold');
        }

        this.generateWave(this.scene.wave);
        this.scene.metrics.trackWaveReached(this.scene.wave);



        // Wave visuals now handled by NotificationSystem via EventBus
        // this.scene.ui.update(); // EventBus handles UI
    }

    public update() {
        if (!this.isWaveActive) return;

        // –°–ø–∞–≤–Ω –≤—Ä–∞–≥–æ–≤ –∏–∑ –æ—á–µ—Ä–µ–¥–∏
        if (this.spawnQueue.length > 0) {
            this.spawnTimer++;

            // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω–∞
            const requiredDelay = this.getNextSpawnDelay();

            if (this.spawnTimer >= requiredDelay) {
                const entry = this.spawnQueue.shift()!;
                this.scene.spawnEnemy(entry.type);

                // Sound: Boss Spawn
                if (entry.type.toUpperCase() === 'SPIDER' || entry.type.toUpperCase() === 'TANK') {
                    SoundManager.play('boss_spawn', SoundPriority.HIGH);
                }

                this.spawnTimer = 0;

                // –û–±–Ω–æ–≤–∏—Ç—å –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –≤—Ä–∞–≥–∞
                this.updateCurrentPattern();
            }
        } else {
            // –ï—Å–ª–∏ –æ—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞ –ò –≤—Ä–∞–≥–æ–≤ –Ω–∞ –∫–∞—Ä—Ç–µ –Ω–µ—Ç -> –ø–æ–±–µ–¥–∞ –≤ –≤–æ–ª–Ω–µ
            if (this.scene.enemies.length === 0) {
                this.endWave();
            }
        }
    }

    private endWave() {
        this.isWaveActive = false;
        EventBus.getInstance().emit(Events.WAVE_COMPLETED, this.scene.wave);
        // Wave clear visuals now handled by NotificationSystem via EventBus

        // Progressive economy: Base reward + scaling per wave
        const reward = CONFIG.ECONOMY.WAVE_BASE_REWARD + (this.scene.wave * CONFIG.ECONOMY.WAVE_SCALING_FACTOR);
        this.scene.addMoney(reward);

        // Perfect wave bonus (no lives lost this game/wave - strictly checking if at max lives)
        // Note: This checks if current lives equals starting lives. 
        // If we want per-wave perfection, we'd need to snapshot lives at wave start.
        // Assuming "Perfect Wave" means "No leaks currently" or "Full Health".
        // Let's go with: If player has full health (startingLives), give bonus.
        if (this.scene.lives >= this.scene.startingLives) {
            this.scene.addMoney(CONFIG.ECONOMY.PERFECT_WAVE_BONUS);
            this.scene.metrics.trackMoneyEarned(CONFIG.ECONOMY.PERFECT_WAVE_BONUS);
            this.scene.showFloatingText(
                `PERFECT! +${CONFIG.ECONOMY.PERFECT_WAVE_BONUS}üí∞`,
                this.scene.game.canvas.width / 2,
                350,
                '#00ffff' // Cyan for perfect
            );
        }

        // Give card for this completed wave (only once per wave number)
        // This ensures card is given even if wave was started early
        if (this.scene.wave > this.lastCardGivenForWave) {
            this.scene.giveRandomCard();
            this.lastCardGivenForWave = this.scene.wave;
        }

        // this.scene.ui.update(); // EventBus handles UI
    }

    private generateWave(waveNum: number) {
        this.spawnQueue = [];
        this.currentIndex = 0;

        let waveConfig: IWaveConfig | null = null;

        // 1. –ü—ã—Ç–∞–µ–º—Å—è –≤–∑—è—Ç—å –≤–æ–ª–Ω—É –∏–∑ –ö–∞—Ä—Ç—ã (–∏–∑ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞)
        if (this.scene.mapData && this.scene.mapData.waves && this.scene.mapData.waves.length > 0) {
            const idx = Math.min(waveNum - 1, this.scene.mapData.waves.length - 1);
            waveConfig = this.scene.mapData.waves[idx];
        }

        // 2. –ï—Å–ª–∏ –≤ –∫–∞—Ä—Ç–µ –ø—É—Å—Ç–æ, –±–µ—Ä–µ–º –∏–∑ Config (—Ñ–æ–ª–±–µ–∫)
        if (!waveConfig) {
            const idx = Math.min(waveNum - 1, CONFIG.WAVES.length - 1);
            const rawData = CONFIG.WAVES[idx];

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º: –µ—Å–ª–∏ rawData —ç—Ç–æ –º–∞—Å—Å–∏–≤, —Ç–æ –æ–±–æ—Ä–∞—á–∏–≤–∞–µ–º –µ–≥–æ –≤—Ä—É—á–Ω—É—é
            if (Array.isArray(rawData)) {
                // @ts-ignore - TS thinks rawData is readonly array which works for us
                waveConfig = { enemies: rawData };
            } else {
                // –ò–Ω–∞—á–µ —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ —ç—Ç–æ —É–∂–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç
                waveConfig = rawData as unknown as IWaveConfig;
            }
        }

        // –†–∞–∑–±–æ—Ä –∫–æ–Ω—Ñ–∏–≥–∞ –∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—á–µ—Ä–µ–¥–∏ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
        if (waveConfig && waveConfig.enemies) {
            waveConfig.enemies.forEach((group) => {
                // –ú–∏–≥—Ä–∞—Ü–∏—è –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–∞
                const migrated = this.migrateGroupConfig(group);
                const baseInterval = this.getBaseIntervalFromRate(group.spawnRate);

                for (let i = 0; i < migrated.count; i++) {
                    this.spawnQueue.push({
                        type: migrated.type,
                        pattern: migrated.pattern,
                        baseInterval: baseInterval
                    });
                }
            });
        }

        // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –≤—Ä–∞–≥–æ–≤ –≤ –≤–æ–ª–Ω–µ, —á—Ç–æ–±—ã –±—ã–ª–æ –≤–µ—Å–µ–ª–µ–µ
        this.spawnQueue.sort(() => Math.random() - 0.5);

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω –ø–µ—Ä–≤–æ–≥–æ –≤—Ä–∞–≥–∞
        if (this.spawnQueue.length > 0) {
            this.currentPattern = this.spawnQueue[0].pattern;
            this.currentBaseInterval = this.spawnQueue[0].baseInterval;
        }
    }

    /**
     * –ú–∏–≥—Ä–∏—Ä—É–µ—Ç —Å—Ç–∞—Ä—ã–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∫ –Ω–æ–≤–æ–º—É —Ñ–æ—Ä–º–∞—Ç—É
     * –ë–µ–∑–æ–ø–∞—Å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–æ–ª—è
     */
    private migrateGroupConfig(group: any): { type: string; count: number; pattern: SpawnPattern } {
        // –ï—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å –Ω–æ–≤–æ–µ –ø–æ–ª–µ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
        if (group.spawnPattern) {
            return {
                type: group.type,
                count: group.count,
                pattern: group.spawnPattern as SpawnPattern
            };
        }

        // –ú–∏–≥—Ä–∞—Ü–∏—è –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞
        // –≠–≤—Ä–∏—Å—Ç–∏–∫–∞: –µ—Å–ª–∏ –±—ã–ª–æ –º–Ω–æ–≥–æ –≤—Ä–∞–≥–æ–≤ —Å fast - –¥–µ–ª–∞–µ–º swarm
        let defaultPattern: SpawnPattern = 'normal';
        if (group.spawnRate === 'fast' && group.count > 15) {
            defaultPattern = 'swarm';
        }

        return {
            type: group.type,
            count: group.count,
            pattern: defaultPattern
        };
    }

    /**
     * –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å—Ç–∞—Ä—ã–π spawnRate –≤ –±–∞–∑–æ–≤—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
     */
    private getBaseIntervalFromRate(rate?: 'fast' | 'medium' | 'slow'): number {
        switch (rate) {
            case 'fast': return 25;
            case 'slow': return 60;
            case 'medium':
            default: return 40;
        }
    }

    /**
     * –í—ã—á–∏—Å–ª—è–µ—Ç —Å–ª–µ–¥—É—é—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª —Å–ø–∞–≤–Ω–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω–∞
     */
    private getNextSpawnDelay(): number {
        const baseInterval = Math.max(5, this.currentBaseInterval);

        switch (this.currentPattern) {
            case 'normal':
                // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
                return baseInterval;

            case 'random':
                // –†–∞–Ω–¥–æ–º–∏–∑–∞—Ü–∏—è ¬±30% –æ—Ç –±–∞–∑–æ–≤–æ–≥–æ
                const variance = baseInterval * 0.3;
                const randomDelay = baseInterval + (Math.random() - 0.5) * 2 * variance;
                return Math.max(5, Math.floor(randomDelay));

            case 'swarm':
                // –û—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã (10-25% –æ—Ç –±–∞–∑–æ–≤–æ–≥–æ)
                const swarmBase = baseInterval * 0.15;
                const swarmVariance = swarmBase * 0.5;
                const swarmDelay = swarmBase + Math.random() * swarmVariance;
                return Math.max(3, Math.floor(swarmDelay));

            default:
                console.warn('[WaveManager] Unknown spawn pattern:', this.currentPattern);
                return baseInterval;
        }
    }

    /**
     * –û–±–Ω–æ–≤–ª—è–µ—Ç —Ç–µ–∫—É—â–∏–π –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –≤—Ä–∞–≥–∞ –≤ –æ—á–µ—Ä–µ–¥–∏
     */
    private updateCurrentPattern(): void {
        if (this.spawnQueue.length > 0) {
            const next = this.spawnQueue[0];
            this.currentPattern = next.pattern;
            this.currentBaseInterval = next.baseInterval;
        }
    }
}
</file>

<file path="src/CardSystem.ts">
import { IGameScene } from './scenes/IGameScene';
import { CONFIG } from './Config';
import { generateUUID } from './Utils';

export interface ICard {
    id: string;
    type: any;
    level: number;
    isDragging: boolean;
}

export class CardSystem {
    private scene: IGameScene;
    public hand: ICard[] = [];

    // Dragging state
    public dragCard: ICard | null = null;
    private ghostEl: HTMLElement;

    private handContainer: HTMLElement;

    constructor(scene: IGameScene, startingCards: string[] = ['FIRE', 'ICE', 'SNIPER']) {
        this.scene = scene;
        this.handContainer = document.getElementById('hand')!;

        this.ghostEl = document.getElementById('drag-ghost')!;
        this.ghostEl.style.pointerEvents = 'none';

        // Add starting cards
        startingCards.forEach(cardKey => this.addCard(cardKey, 1));
    }

    public startDrag(card: ICard, e: PointerEvent) {
        if (this.scene.forge.isForging) return;
        this.dragCard = card;
        card.isDragging = true;

        this.ghostEl.style.display = 'block';
        this.ghostEl.innerHTML = `<div style="font-size:32px;">${card.type.icon}</div>`;
        this.updateDrag(e.clientX, e.clientY);

        this.render();
    }

    public updateDrag(x: number, y: number) {
        if (!this.dragCard) return;
        this.ghostEl.style.left = `${x}px`;
        this.ghostEl.style.top = `${y}px`;
    }

    public endDrag(e: PointerEvent) {
        if (!this.dragCard) return;

        // Check forge slots FIRST via ForgeSystem
        const droppedInForge = this.scene.forge.tryDropCard(e.clientX, e.clientY, this.dragCard);

        if (!droppedInForge) {
            // Drop on Canvas
            const rect = this.scene.game.canvas.getBoundingClientRect();
            const inCanvas =
                e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;

            if (inCanvas) {
                const x = (e.clientX - rect.left) * (this.scene.game.canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (this.scene.game.canvas.height / rect.height);
                this.scene.events.emit('CARD_DROPPED', { card: this.dragCard, x, y });
            }
        }

        this.dragCard.isDragging = false;
        this.dragCard = null;
        this.ghostEl.style.display = 'none';
        this.render();
    }

    public addCard(typeKey: string, level: number = 1) {
        if (this.hand.length >= CONFIG.PLAYER.HAND_LIMIT) {
            this.scene.showFloatingText('Hand Full!', window.innerWidth / 2, window.innerHeight - 100, 'red');
            return;
        }

        const type = CONFIG.CARD_TYPES[typeKey];
        if (!type) {
            console.warn(`Unknown card type: ${typeKey}`);
            return;
        }

        const card: ICard = {
            id: generateUUID(),
            type: type,
            level: level,
            isDragging: false,
        };
        this.hand.push(card);
        this.render();
        this.scene.ui.update();
    }

    public addRandomCardToHand() {
        const keys = Object.keys(CONFIG.CARD_TYPES);
        const randomKey = keys[Math.floor(Math.random() * keys.length)];
        this.addCard(randomKey, 1);
    }

    public removeCardFromHand(card: ICard) {
        const index = this.hand.indexOf(card);
        if (index !== -1) {
            this.hand.splice(index, 1);
            this.render();
            this.scene.ui.update();
        }
    }

    public render() {
        this.handContainer.innerHTML = '';
        this.hand.forEach((card) => {
            const el = CardSystem.createCardElement(card);
            el.onpointerdown = (e: any) => this.startDrag(card, e);
            if (card.isDragging) el.classList.add('dragging-placeholder');
            this.handContainer.appendChild(el);
        });
    }

    public static createCardElement(card: ICard): HTMLElement {
        const el = document.createElement('div');
        el.className = `card type-${card.type.id} level-${card.level}`;

        // Star rating
        let stars = '‚òÖ'.repeat(card.level);

        // Stats HTML
        let statsHTML = this.getCardStatsHTML(card);

        el.innerHTML = `
            <div class="card-level">${stars}</div>
            <div class="card-icon">${card.type.icon}</div>
            <div class="card-stats">${statsHTML}</div>
        `;
        return el;
    }

    public static getCardStatsHTML(card: ICard): string {
        const type = card.type.id;
        const level = card.level;

        switch (type) {
            case 'fire':
                if (level === 1) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +15</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 50</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +30</div><div class="card-stat-line">–í–∑—Ä—ã–≤ 85</div>`;
                } else {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +30</div><div class="card-stat-line">–í–∑—Ä—ã–≤ + üíÄ</div>`;
                }

            case 'ice':
                if (level === 1) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +3</div><div class="card-stat-line">‚ùÑÔ∏è 30%</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +6</div><div class="card-stat-line">‚ùÑÔ∏è 45%</div>`;
                } else {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +9</div><div class="card-stat-line">‚ùÑÔ∏è 75% + ‚õìÔ∏è</div>`;
                }

            case 'sniper':
                if (level === 1) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +14</div><div class="card-stat-line">üéØ +80</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +24</div><div class="card-stat-line">üéØ +160</div>`;
                } else {
                    return `<div class="card-stat-primary">–£—Ä–æ–Ω +46</div><div class="card-stat-line">üéØ +240 üí´</div>`;
                }

            case 'multi':
                if (level === 1) {
                    return `<div class="card-stat-primary">2 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.8x —É—Ä–æ–Ω</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">3 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.6x —É—Ä–æ–Ω</div>`;
                } else {
                    return `<div class="card-stat-primary">4 —Å–Ω–∞—Ä—è–¥–∞</div><div class="card-stat-line">0.45x —É—Ä–æ–Ω</div>`;
                }

            case 'minigun':
                if (level === 1) {
                    return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+3 —É—Ä–æ–Ω/—Å</div>`;
                } else if (level === 2) {
                    return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">+—É—Ä–æ–Ω +–∫—Ä–∏—Ç</div>`;
                } else {
                    return `<div class="card-stat-primary">‚ö° –†–∞—Å–∫—Ä—É—Ç–∫–∞</div><div class="card-stat-line">–¥–æ +30 —É—Ä–æ–Ω</div>`;
                }

            default:
                return `<div class="card-stat-line">${card.type.desc}</div>`;
        }
    }
}
</file>

<file path="src/Config.ts">
import type { ICardTypeConfig, IEnemyTypeConfig } from './types';

export const CONFIG = {
    // Configuration flags for safe refactoring
    USE_NEW_RENDERER: true, // Toggle this to enable new modular renderers
    VISUAL_STYLE: 'SPRITE' as 'SPRITE' | 'INK', // 'SPRITE' | 'INK' - Styling mode

    TILE_SIZE: 64,

    AMBIENT: {
        DAY_SPEED: 0.0005,
        NIGHT_SPEED_MULTIPLIER: 1.5,
        LIGHTING: {
            FIRE: '#ff5722',
            ICE: '#00bcd4',
            SNIPER: '#4caf50',
            MINIGUN: '#e040fb',
            STANDARD: '#ffeb3b',
        }
    },

    COLORS: {
        GRASS: '#8bc34a',
        PATH: '#ded29e',
        BASE: '#3f51b5',
        SPAWN: '#d32f2f',
        TOWER_BASE: '#9e9e9e',
        DECOR_BG: '#558b2f',
        DECOR_TREE: '#2e7d32',
        DECOR_ROCK: '#78909c',
    },

    PLAYER: {
        START_MONEY: 250,
        START_LIVES: 20,
        HAND_LIMIT: 7,
    },

    ECONOMY: {
        WAVE_CLEAR_REWARD: 2,
        WAVE_BASE_REWARD: 20,          // NEW: Base reward for completing a wave
        WAVE_SCALING_FACTOR: 2,        // NEW: Additional reward per wave number (+2 per wave)
        DROP_CHANCE: 0.15,
        EARLY_WAVE_BONUS: 15,          // Reduced from 30 to 15
        PERFECT_WAVE_BONUS: 10,        // NEW: Bonus for no enemy leaks
        TOWER_COST: 55,
        FORGE_COST_LVL1: 50,           // LVL1‚Üí2 forge cost
        FORGE_COST_LVL2: 65,           // LVL2‚Üí3 forge cost (was FORGE_COST: 50)
        SHOP_COST: 100,
        SHOP_REROLL_COST: 25,          // Increased from 15 to 25
        SELL_REFUND: 0.5,
        CARD_SELL_PRICES: [0, 5, 10, 25], // Index = level (0 unused, 1-3 are actual prices)
    },

    TOWER: {
        BASE_RANGE: 120,
        BASE_DMG: 5,
        BASE_CD: 54, // Increased for balance (was 45)
        BUILD_TIME: 60,
        MAX_CARDS: 3,
        BARREL_LENGTH: 22,
        TURN_SPEED: 0.15, // Radians per frame (~8.5 degrees)
        AIM_TOLERANCE: 0.1, // ~5 degrees error allowed to shoot
    },

    TARGETING_MODES: {
        FIRST: { id: 'first', name: '–ü–µ—Ä–≤—ã–π', icon: 'üèÉ', desc: '–ë–ª–∏–∂–µ –∫ —Ü–µ–ª–∏' },
        CLOSEST: { id: 'closest', name: '–ë–ª–∏–∂–∞–π—à–∏–π', icon: 'üìç', desc: '–†—è–¥–æ–º —Å –±–∞—à–Ω–µ–π' },
        STRONGEST: { id: 'strongest', name: '–°–∏–ª—å–Ω—ã–π', icon: 'üí™', desc: '–ú–∞–∫—Å. –∑–¥–æ—Ä–æ–≤—å–µ' },
        WEAKEST: { id: 'weakest', name: '–°–ª–∞–±—ã–π', icon: 'üíî', desc: '–ú–∏–Ω. –∑–¥–æ—Ä–æ–≤—å–µ' },
        LAST: { id: 'last', name: '–ü–æ—Å–ª–µ–¥–Ω–∏–π', icon: 'üê¢', desc: '–î–∞–ª—å—à–µ –æ—Ç —Ü–µ–ª–∏' },
    },

    UI: {
        HP_BAR_WIDTH: 40,
        HP_BAR_HEIGHT: 4,
        HP_BAR_OFFSET: -30,
        FLOATING_TEXT_LIFE: 60,
    },

    CARD_TYPES: {
        FIRE: { id: 'fire', name: '–ú–æ—Ä—Ç–∏—Ä–∞', icon: 'üî•', color: '#f44336', desc: '–£—Ä–æ–Ω –ø–æ –ø–ª–æ—â–∞–¥–∏' },
        ICE: { id: 'ice', name: '–°—Ç—É–∂–∞', icon: '‚ùÑÔ∏è', color: '#00bcd4', desc: '–ó–∞–º–µ–¥–ª—è–µ—Ç –≤—Ä–∞–≥–æ–≤' },
        SNIPER: { id: 'sniper', name: '–°–Ω–∞–π–ø–µ—Ä', icon: 'üéØ', color: '#4caf50', desc: '–î–∞–ª—å–Ω—è—è —Å—Ç—Ä–µ–ª—å–±–∞' },
        MULTISHOT: { id: 'multi', name: '–ó–∞–ª–ø', icon: 'üí•', color: '#ff9800', desc: '+1 —Å–Ω–∞—Ä—è–¥, -—É—Ä–æ–Ω' },
        MINIGUN: { id: 'minigun', name: '–ü—É–ª–µ–º—ë—Ç', icon: '‚ö°', color: '#9c27b0', desc: '–ë—ã—Å—Ç—Ä–∞—è —Å—Ç—Ä–µ–ª—å–±–∞, —É—Ä–æ–Ω —Ä–∞—Å—Ç—ë—Ç' },
    } as Readonly<Record<string, ICardTypeConfig>>,

    ENEMY: { BASE_HP: 25, HP_GROWTH: 1.2 },

    ENEMY_TYPES: {
        GRUNT: {
            id: 'grunt',
            name: '–°–∫–µ–ª–µ—Ç',
            symbol: 'üíÄ',
            hpMod: 1.2,
            speed: 1.5,
            reward: 4,
            color: '#e0e0e0',
            desc: '–û–±—ã—á–Ω—ã–π —Å–∫–µ–ª–µ—Ç',
            archetype: 'SKELETON',
            scale: 1.0,
        },
        SCOUT: {
            id: 'scout',
            name: '–í–æ–ª–∫',
            symbol: 'üê∫',
            hpMod: 0.85,
            speed: 2.8,
            reward: 2,
            color: '#795548',
            desc: '–ë—ã—Å—Ç—Ä—ã–π —Ö–∏—â–Ω–∏–∫',
            archetype: 'WOLF',
            scale: 0.9,
        },
        TANK: {
            id: 'tank',
            name: '–¢—Ä–æ–ª–ª—å',
            symbol: 'üëπ',
            hpMod: 3.65,
            speed: 0.8,
            reward: 10,
            color: '#558b2f',
            desc: '–¢—è–∂–µ–ª—ã–π —Ç–∞–Ω–∫',
            archetype: 'TROLL',
            scale: 1.2,
        },
        BOSS: {
            id: 'boss',
            name: '–ü–∞—É—á–∏—Ö–∞',
            symbol: 'üï∑Ô∏è',
            hpMod: 25.0,
            speed: 0.6,
            reward: 175,
            color: '#311b92',
            desc: '–ú–∞—Ç–∫–∞ —Ä–æ—è',
            archetype: 'SPIDER',
            scale: 1.8,
        },
        // --- NEW VARIANTS ---
        SKELETON_COMMANDER: {
            id: 'skeleton_commander',
            name: '–ö–æ–º–∞–Ω–¥–∏—Ä',
            symbol: 'üëë',
            hpMod: 2.5,
            speed: 1.6,
            reward: 8,
            color: '#ffd700',
            desc: '–õ–∏–¥–µ—Ä —Å–∫–µ–ª–µ—Ç–æ–≤',
            archetype: 'SKELETON',
            scale: 1.2,
            props: ['prop_helmet', 'prop_weapon'],
            tint: '#ffd700'
        },
        SPIDER_POISON: {
            id: 'spider_poison',
            name: '–Ø–¥–æ–≤–∏—Ç—ã–π',
            symbol: 'üß™',
            hpMod: 1.4,
            speed: 2.2,
            reward: 6,
            color: '#76ff03',
            desc: '–Ø–¥–æ–≤–∏—Ç—ã–π –ø–∞—É–∫',
            archetype: 'SPIDER',
            scale: 0.7,
            tint: '#76ff03'
        },
        TROLL_ARMORED: {
            id: 'troll_armored',
            name: '–õ–∞—Ç–Ω–∏–∫',
            symbol: 'üõ°Ô∏è',
            hpMod: 7.0,
            speed: 0.7,
            reward: 15,
            color: '#424242',
            desc: '–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç—Ä–æ–ª–ª—å',
            archetype: 'TROLL',
            scale: 1.3,
            props: ['prop_shield'],
            tint: '#616161'
        }
    } as const,

    WAVES: [
        // –í–æ–ª–Ω–∞ 1: –û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
        {
            enemies: [
                { type: 'GRUNT', count: 10, spawnPattern: 'normal' }
            ]
        },
        // –í–æ–ª–Ω–∞ 2: –†–∞–Ω–¥–æ–º–Ω—ã–π —Ä–µ–∂–∏–º –¥–ª—è –Ω–µ–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ—Å—Ç–∏
        {
            enemies: [
                { type: 'SCOUT', count: 12, spawnPattern: 'random' }
            ]
        },
        // –í–æ–ª–Ω–∞ 3: –ö–æ–º–±–∏–Ω–∞—Ü–∏—è –æ–±—ã—á–Ω–æ–≥–æ –∏ —Ä–æ—è
        {
            enemies: [
                { type: 'GRUNT', count: 15, spawnPattern: 'normal' },
                { type: 'TANK', count: 2, spawnPattern: 'normal' }
            ]
        },
        // –í–æ–ª–Ω–∞ 4: –†–æ–π —Å–∫–∞—É—Ç–æ–≤ + —Ç–∞–Ω–∫–∏ —Ä–∞–Ω–¥–æ–º–Ω–æ
        {
            enemies: [
                { type: 'SCOUT', count: 20, spawnPattern: 'swarm' },
                { type: 'TANK', count: 3, spawnPattern: 'random' }
            ]
        },
        // –í–æ–ª–Ω–∞ 5: –§–∏–Ω–∞–ª—å–Ω–∞—è –≤–æ–ª–Ω–∞ —Å –±–æ—Å—Å–æ–º
        {
            enemies: [
                { type: 'GRUNT', count: 25, spawnPattern: 'random' },
                { type: 'BOSS', count: 1, spawnPattern: 'normal' }
            ]
        }
    ],
};

/**
 * Type-safe helper to get card type configuration
 */
export function getCardType(key: string): ICardTypeConfig | undefined {
    return CONFIG.CARD_TYPES[key];
}

/**
 * Type-safe helper to get enemy type configuration
 */
export function getEnemyType(key: string): IEnemyTypeConfig | undefined {
    // @ts-ignore
    return CONFIG.ENEMY_TYPES[key];
}
</file>

<file path="src/scenes/GameScene.ts">
import { Game } from '../Game';
import { BaseScene } from '../BaseScene';
import { IGameScene } from './IGameScene';
import { MapManager } from '../Map';
import { UIManager } from '../UIManager';
import { CONFIG } from '../Config';
import { CardSystem, ICard } from '../CardSystem';
import { EventEmitter } from '../Events';
import { InputSystem } from '../InputSystem';
import { EffectSystem } from '../EffectSystem';
// import { DebugSystem } from '../DebugSystem';
import { DevConsole } from '../ui/DevConsole';
import { Logger, LogChannel } from '../utils/Logger';
import { Tower } from '../Tower';
import { SoundManager } from '../SoundManager';
import { WaveManager } from '../WaveManager';
import { ForgeSystem } from '../ForgeSystem';
import { CollisionSystem } from '../CollisionSystem';
import { InspectorSystem } from '../InspectorSystem';
import { BestiarySystem } from '../BestiarySystem';
import { IMapData, DEMO_MAP } from '../MapData';
import { MetricsSystem } from '../MetricsSystem';
import { WeaponSystem } from '../WeaponSystem';
import { FogSystem } from '../FogSystem';
import { LightingSystem } from '../systems/LightingSystem';
import { NotificationSystem } from '../systems/NotificationSystem';
import { DayNightCycle } from '../DayNightCycle';
import { AtmosphereSystem } from '../systems/AtmosphereSystem';

import { GameController } from './GameController';
import { GameState } from './GameState';
import { EntityManager } from './EntityManager';
import { RendererFactory } from '../RendererFactory';

/**
 * Main game scene - REFACTORED VERSION
 * Orchestrates game systems using modular components.
 * Implements IGameScene interface to decouple systems.
 */
export class GameScene extends BaseScene implements IGameScene {
    // Core references
    public game: Game;
    public mapData: IMapData;
    public readonly startingLives: number;

    // Modular components
    public gameState: GameState;
    public entityManager: EntityManager;
    public gameController: GameController;

    // Ambient cycle
    private dayTime: number = 0;

    // Map & rendering
    public map: MapManager;
    public fog: FogSystem;
    public lighting: LightingSystem;

    // Systems
    public ui: UIManager;
    public cardSys: CardSystem;
    public waveManager: WaveManager;
    public events: EventEmitter;
    public input: InputSystem;
    public effects: EffectSystem;
    public devConsole: DevConsole;
    public forge: ForgeSystem;
    public collision: CollisionSystem;
    public inspector: InspectorSystem;
    public bestiary: BestiarySystem;
    public metrics: MetricsSystem;
    public weaponSystem: WeaponSystem;
    public notifications: NotificationSystem;
    private dayNightCycle!: DayNightCycle;
    private atmosphere!: AtmosphereSystem;

    // IGameScene compatibility properties (delegate to gameState)
    public get wave(): number { return this.gameState.wave; }
    public set wave(value: number) { this.gameState.wave = value; }

    public get money(): number { return this.gameState.money; }

    public get lives(): number { return this.gameState.lives; }

    public get paused(): boolean { return this.gameState.paused; }

    public get selectedTower(): Tower | null { return this.gameState.selectedTower; }
    public set selectedTower(value: Tower | null) { this.gameState.selectTower(value); }

    public get enemies() { return this.gameState.enemies; }
    public get towers() { return this.gameState.towers; }
    public get projectiles() { return this.gameState.projectiles; }
    public get projectilePool() { return this.gameState.projectilePool; }
    public get enemyPool() { return this.gameState.enemyPool; }

    constructor(game: Game, mapData: IMapData) {
        super();
        this.game = game;
        this.mapData = mapData || DEMO_MAP;

        // Initialize core state
        this.gameState = new GameState();
        this.startingLives = CONFIG.PLAYER.START_LIVES;

        // Initialize map and rendering
        this.map = new MapManager(this.mapData);
        this.fog = new FogSystem(this.mapData);
        this.lighting = new LightingSystem(game.canvas.width, game.canvas.height);
        this.map.lighting = this.lighting; // [NEW] Link lighting
        this.dayNightCycle = new DayNightCycle(); // Default cycle (4 min)
        this.atmosphere = new AtmosphereSystem(this.dayNightCycle); // Default config
        // Set world size for cloud positioning (map dimensions in pixels)
        const worldWidth = this.mapData.width * CONFIG.TILE_SIZE;
        const worldHeight = this.mapData.height * CONFIG.TILE_SIZE;
        this.atmosphere.setWorldSize(worldWidth, worldHeight);
        this.events = new EventEmitter();
        this.effects = new EffectSystem(game.ctx);
        this.input = game.input;

        // Initialize systems
        this.weaponSystem = new WeaponSystem();
        this.metrics = new MetricsSystem();
        this.notifications = new NotificationSystem(this.effects, game.canvas);
        this.waveManager = new WaveManager(this);

        // Initialize entity manager
        this.entityManager = new EntityManager(
            this.gameState,
            this.effects,
            this.metrics,
        );

        // Initialize UI and card systems
        // Get starting cards from selection or use default
        // CHANGED: Start with ALL 5 card types
        const startingCards = (window as any)._STARTING_CARDS || ['FIRE', 'ICE', 'SNIPER', 'MULTISHOT', 'MINIGUN'];
        delete (window as any)._STARTING_CARDS; // Cleanup after use

        this.ui = new UIManager(this);
        this.cardSys = new CardSystem(this, startingCards);
        this.forge = new ForgeSystem(this);
        this.devConsole = new DevConsole(this);
        this.collision = new CollisionSystem(this.effects); // Debug removed

        Logger.info(LogChannel.GAME, 'GameScene Initialized');
        this.inspector = new InspectorSystem(this);
        this.bestiary = new BestiarySystem(this);

        // Initialize game controller
        this.gameController = new GameController(
            this.gameState,
            this.entityManager,
            this.effects,
            this.inspector,
            this.ui,
            this.metrics,
            this.mapData,
            (col, row) => this.map.isBuildable(col, row),
            this.cardSys,
            this.events,
        );
    }

    public onEnter() {
        const ui = document.getElementById('ui-layer');
        if (ui) ui.style.display = 'block';
        const hand = document.getElementById('hand-container');
        if (hand) hand.style.display = 'flex';

        this.ui.update();
        window.addEventListener('keydown', this.onKeyDown);
    }

    public onExit() {
        const ui = document.getElementById('ui-layer');
        if (ui) ui.style.display = 'none';
        window.removeEventListener('keydown', this.onKeyDown);
    }

    private onKeyDown = (e: KeyboardEvent) => {
        this.gameController.handleKeyDown(e);
    };

    public update() {
        if (!this.gameState.isRunning) return;
        if (this.gameState.paused) return;

        this.gameState.frames++;

        // Time scale support (1x or 2x speed)
        const loops = (this.gameState.timeScale >= 2) ? 2 : 1;

        // Day/Night Cycle (Simple Sine Wave)
        // Cycle duration: approx 60 seconds (3600 frames)

        // Determine current phase (Sine Wave)
        // Math.sin(this.dayTime) -> -1 (Night) to 1 (Day)
        const currentSin = Math.sin(this.dayTime);
        const isNight = currentSin < 0;

        // Modulate speed: Night passes 50% faster, Day is normal
        const speedMultiplier = isNight ? 1.5 : 1.0;

        this.dayTime += 0.0005 * loops * speedMultiplier;

        // Update DayNightCycle system
        const deltaTime = (1 / 60) * loops; // Approximate deltaTime
        this.dayNightCycle.update(deltaTime);
        this.atmosphere.update(deltaTime);

        // Oscillate between 0.5 (Darkest evening) and 0.95 (Brightest day)
        // Math.sin goes -1 to 1. 
        // We want range [0.5, 0.95]. Center is 0.725, Amplitude is 0.225
        const brightness = 0.75 + currentSin * 0.20;
        this.lighting.ambientLight = brightness;

        for (let l = 0; l < loops; l++) {
            this.waveManager.update();
            this.fog.update(0.016);
            // Lighting doesn't need explicit update logic for now, just render

            // Update projectiles
            this.entityManager.updateProjectiles();

            // Update weapon system (tower shooting)
            this.weaponSystem.update(
                this.gameState.towers,
                this.gameState.enemies,
                this.gameState.projectiles,
                this.gameState.projectilePool,
                this.effects
            );

            // Update tower visual states
            this.gameState.towers.forEach((t) => t.updateBuilding(this.effects));

            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –®–ê–ì 1: –î—É–±–ª–∏–∫–∞—Ç weaponSystem.update() –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω
            // –°–∏—Å—Ç–µ–º–∞ –æ—Ä—É–∂–∏—è —É–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –≤—ã—à–µ (—Å—Ç—Ä–æ–∫–∏ 222-228)
            // –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —ç—Ç—É —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–∫–∞—Ç–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π:
            // this.weaponSystem.update(this.gameState.towers, this.gameState.enemies, this.gameState.projectiles, this.gameState.projectilePool, this.effects);
            this.collision.update(this.gameState.projectiles, this.gameState.enemies);
            this.entityManager.updateEnemies();
            // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –®–ê–ì 2: –î—É–±–ª–∏–∫–∞—Ç updateProjectiles() –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω
            // –°–Ω–∞—Ä—è–¥—ã —É–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –≤—ã—à–µ (—Å—Ç—Ä–æ–∫–∞ 219)
            // –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —ç—Ç—É —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–∫–∞—Ç–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π:
            // this.entityManager.updateProjectiles();
            this.effects.update();

            // Update enemy counter in HUD
            this.ui.hud.updateEnemyCounter(this.gameState.enemies.length);
        }
        // Update shake (once per frame, not per loop)
        this.gameState.updateShake();
        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –®–ê–ì 3: –î—É–±–ª–∏–∫–∞—Ç effects.update() –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω
        // –≠—Ñ—Ñ–µ–∫—Ç—ã —É–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –≤ —Ü–∏–∫–ª–µ –≤—ã—à–µ (—Å—Ç—Ä–æ–∫–∞ 237)
        // –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —ç—Ç—É —Å—Ç—Ä–æ–∫—É –¥–ª—è –æ—Ç–∫–∞—Ç–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π:
        // this.effects.update();
    }

    public draw(ctx: CanvasRenderingContext2D) {
        ctx.save();

        // Apply screen shake
        if (this.gameState.shakeTimer > 0) {
            const dx = (Math.random() - 0.5) * this.gameState.shakeIntensity;
            const dy = (Math.random() - 0.5) * this.gameState.shakeIntensity;
            ctx.translate(dx, dy);
        }

        // World Render
        RendererFactory.drawMap(ctx, this.map);
        // ... (rest of drawing)

        // (Assuming render continues...)
        // We need to inject code where the scene is actually drawn or create a post-process overlay
        // The draw method here just sets up shake. The rest of the draw sequence is separate?
        // Wait, looking at GameScene.ts structure... 
        // I see the start of draw(ctx).
        // Let's scroll down to find where I can insert the overlay.
        // Actually, looking at the previous view_file, GameScene.ts has a `draw` method that delegates to map, entities etc.
        // I need to insert the Vignette AT THE VERY END of the `draw` method.
        // I'll assume lines 250+ (which I saw earlier) were the start.
        // I need to view the END of GameScene.draw to insert the overlay.

        // Let me first view the end of GameScene.ts to find the right spot.
        // Aborting this specific tool call to View File first.


        // Clear screen
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);

        // Draw map and fog
        // Draw map and fog
        RendererFactory.drawMap(ctx, this.map);
        // Torches
        this.map.drawTorches(ctx, this.gameState.frames); // [NEW] Draw torches with time

        // === PHASE 6: VIGNETTE (Cinematic Polish) ===
        // Draw a subtle dark gradient at the edges
        // const w = this.game.canvas.width;
        // const h = this.game.canvas.height;
        //
        // ctx.save();
        // const gradient = ctx.createRadialGradient(w / 2, h / 2, h * 0.45, w / 2, h / 2, h * 0.9);
        // gradient.addColorStop(0, 'rgba(0,0,0,0)');
        // gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
        // ctx.fillStyle = gradient;
        // ctx.fillRect(0, 0, w, h);
        // ctx.restore();
        // === END VIGNETTE ===

        this.fog.draw(ctx);

        // Draw path preview
        this.drawPathPreview(ctx);

        // Draw hover highlight
        this.drawHoverHighlight(ctx);

        // Draw entities
        this.gameState.towers.forEach((t) => t.draw(ctx));
        this.drawSelectedTowerRange(ctx);

        // Draw targeting mode tooltip for hovered tower
        this.drawTargetingModeTooltip(ctx);

        this.gameState.enemies.forEach((e) => e.draw(ctx));
        // Draw effects
        this.effects.draw();

        // Draw lighting (over everything except UI)
        // Update size if needed
        if (this.game.canvas.width !== this.lighting['width'] || this.game.canvas.height !== this.lighting['height']) {
            this.lighting.resize(this.game.canvas.width, this.game.canvas.height);
        }
        // Reset lights
        this.lighting.clear();
        // Add dynamic lights...
        this.lighting.render(ctx);

        // Draw atmosphere effects (sunlight, moonlight, stars, etc)
        this.atmosphere.draw(ctx);

        ctx.restore();
    }

    private drawPathPreview(ctx: CanvasRenderingContext2D) {
        if (this.map.waypoints && this.map.waypoints.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 10]);

            const start = this.map.waypoints[0];
            const ts = CONFIG.TILE_SIZE;
            const half = ts / 2;

            ctx.moveTo(start.x * ts + half, start.y * ts + half);
            for (let i = 1; i < this.map.waypoints.length; i++) {
                const wp = this.map.waypoints[i];
                ctx.lineTo(wp.x * ts + half, wp.y * ts + half);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    private drawHoverHighlight(ctx: CanvasRenderingContext2D) {
        if (this.input.hoverCol >= 0) {
            const hx = this.input.hoverCol * CONFIG.TILE_SIZE;
            const hy = this.input.hoverRow * CONFIG.TILE_SIZE;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(hx, hy, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
        }
    }

    private drawSelectedTowerRange(ctx: CanvasRenderingContext2D) {
        if (this.gameState.selectedTower) {
            const stats = this.gameState.selectedTower.getStats();
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
            ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(
                this.gameState.selectedTower.x,
                this.gameState.selectedTower.y,
                stats.range,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.stroke();
        }
    }

    private drawTargetingModeTooltip(ctx: CanvasRenderingContext2D) {
        // Find tower under mouse cursor
        if (this.input.hoverCol < 0 || this.input.hoverRow < 0) return;

        const hoverX = this.input.hoverCol * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const hoverY = this.input.hoverRow * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

        const hoveredTower = this.gameState.towers.find((t) => {
            const dist = Math.hypot(t.x - hoverX, t.y - hoverY);
            return dist < 32; // Within tower radius
        });

        if (hoveredTower && !hoveredTower.isBuilding) {
            const modeKey = hoveredTower.targetingMode.toUpperCase();
            const mode = Object.values(CONFIG.TARGETING_MODES).find((m: any) => m.id === hoveredTower.targetingMode);
            if (mode) {
                // Draw small icon above tower
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';

                // Background circle
                ctx.fillStyle = 'rgba(50, 50, 70, 0.95)';
                ctx.beginPath();
                ctx.arc(hoveredTower.x, hoveredTower.y - 45, 18, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = '#4caf50';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();

                // Icon
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(mode.icon, hoveredTower.x, hoveredTower.y - 45);

                // Tooltip text below
                ctx.font = '12px Arial';
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(mode.name, hoveredTower.x, hoveredTower.y - 22);
                ctx.fillText(mode.name, hoveredTower.x, hoveredTower.y - 22);
            }
        }
    }

    // === IGameScene Implementation (Delegate to modules) ===

    public addMoney(amount: number): void {
        this.gameState.addMoney(amount);
    }

    public spendMoney(amount: number): boolean {
        return this.gameState.spendMoney(amount);
    }

    public loseLife(amount: number = 1): void {
        this.gameState.loseLife(amount);
    }

    public spawnEnemy(type: string): void {
        this.entityManager.spawnEnemy(type, this.map.waypoints);
    }

    public startBuildingTower(col: number, row: number): void {
        this.gameController.startBuildingTower(col, row);
    }

    public handleGridClick(col: number, row: number): void {
        this.gameController.handleGridClick(col, row);
    }

    public showFloatingText(text: string, x: number, y: number, color: string = '#fff'): void {
        this.gameController.showFloatingText(text, x, y, color);
    }

    public handleCardDrop(card: ICard, x: number, y: number): boolean {
        return this.gameController.handleCardDrop(card, x, y);
    }

    public giveRandomCard(): void {
        this.gameController.giveRandomCard();
    }

    public sellTower(tower: Tower): void {
        this.gameController.sellTower(tower);
    }

    public sellCardFromTower(tower: Tower, cardIndex: number): void {
        this.gameController.sellCardFromTower(tower, cardIndex);
    }

    public restart(): void {
        this.game.changeScene(new GameScene(this.game, this.mapData));
    }

    public togglePause(): void {
        this.gameState.togglePause();
        this.ui.updatePauseMenu(this.gameState.paused);
    }

    public gameOver(): void {
        this.gameState.endGame();
        this.metrics.endGame(false);
        this.ui.showGameOver(this.gameState.wave);
    }

    public triggerShake(duration: number, intensity: number): void {
        this.gameState.triggerShake(duration, intensity);
    }
}
</file>

<file path="src/Tower.ts">
import { CONFIG } from './Config';
import { RendererFactory } from './RendererFactory';
import { ICard } from './CardSystem';
import { Enemy } from './Enemy';
import { Projectile, IProjectileStats } from './Projectile';
import { ObjectPool } from './Utils';
import { EffectSystem } from './EffectSystem';
import { Assets } from './Assets';
import { VISUALS } from './VisualConfig';
import { getCardUpgrade, getMultishotConfig, ICardEffect } from './cards';
import { mergeCardsWithStacking } from './CardStackingSystem';
import { TowerRenderer } from './renderers/TowerRenderer';

export class Tower {
    public col: number;
    public row: number;
    public x: number;
    public y: number;

    public cards: ICard[] = [];
    public cooldown: number = 0;
    public angle: number = 0;
    public targetingMode: string = 'first'; // Targeting priority: first, closest, strongest, weakest, last

    public isBuilding: boolean = false;
    public buildProgress: number = 0;
    public maxBuildProgress: number = CONFIG.TOWER.BUILD_TIME;

    public costSpent: number = 0;

    // Spinup state (for Minigun cards)
    public spinupFrames: number = 0;        // Frames spent firing continuously
    public maxHeat: number = 300;           // Max frames before overheat (default 5s)
    public isOverheated: boolean = false;   // Whether tower is overheated
    public overheatCooldown: number = 0;    // Frames remaining in overheat lockout

    // Visual state (Phase 3)
    public recoilFrames: number = 0;        // Recoil animation timer
    public recoilIntensity: number = 0;     // Recoil strength

    constructor(c: number, r: number) {
        this.col = c;
        this.row = r;
        this.x = c * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        this.y = r * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        this.costSpent = CONFIG.ECONOMY.TOWER_COST;
    }

    public static getPreviewStats(cards: ICard[]): any {
        const dummy = new Tower(0, 0);
        dummy.cards = cards;
        return dummy.getStats();
    }

    getStats(): IProjectileStats & { range: number; cd: number; projCount: number; spread: number; projectileType: string } {
        // Start with base stats
        let range = CONFIG.TOWER.BASE_RANGE;
        let damage = CONFIG.TOWER.BASE_DMG;
        let attackSpeed = CONFIG.TOWER.BASE_CD;
        let speed = 8;
        let color = VISUALS.PROJECTILES.STANDARD;
        let critChance = 0;
        let pierce = 0;
        let projectileType = 'standard';

        // Use new card stacking system
        const { modifiers: mergedMods, effects: allEffects } = mergeCardsWithStacking(this.cards);

        // Calculate damage with proper order:
        // 1. Collect base damage and flat bonuses
        const baseDamage = CONFIG.TOWER.BASE_DMG;
        const flatDamageBonuses = mergedMods.damage || 0;

        // 2. Apply damageMultiplier if present (Minigun)
        //    This affects both base and bonuses for better balance
        if (mergedMods.damageMultiplier !== undefined) {
            damage = (baseDamage + flatDamageBonuses) * mergedMods.damageMultiplier;
        } else {
            damage = baseDamage + flatDamageBonuses;
        }

        // Apply range modifiers
        range += mergedMods.range || 0;
        range *= mergedMods.rangeMultiplier || 1.0;

        // Apply attack speed
        attackSpeed = attackSpeed / (mergedMods.attackSpeedMultiplier || 1.0);

        // Apply crit chance
        critChance = mergedMods.critChance || 0;

        // Handle multishot cards
        let projCount = 1;
        let damageMultiplier = 1.0;
        let spread = 0;
        const multiCards = this.cards.filter((c) => c.type.id === 'multi');

        // Get visual overrides from first card (data-driven approach)
        const mainCard = this.cards[0];
        if (mainCard) {
            const upgrade = getCardUpgrade(mainCard.type.id, mainCard.level);
            if (upgrade?.visualOverrides) {
                projectileType = upgrade.visualOverrides.projectileType || 'standard';
                color = upgrade.visualOverrides.projectileColor || VISUALS.PROJECTILES.STANDARD;
                speed = upgrade.visualOverrides.projectileSpeed || 8;
            } else if (mainCard.type.id === 'multi') {
                // Fallback for multishot (no visual overrides needed, it modifies count)
                projectileType = 'split';
                color = VISUALS.PROJECTILES.SPLIT;
            }
        }

        if (multiCards.length > 0) {
            // Use highest level multishot card
            const maxLevel = Math.max(...multiCards.map((c) => c.level));
            const multiConfig = getMultishotConfig(maxLevel);
            projCount = multiConfig.projectileCount;
            damageMultiplier = multiConfig.damageMultiplier;
            spread = multiConfig.spread; // NEW: Get spread from config

            // If main card is NOT multishot, but we have multishot upgrades, 
            // the projectile type stays as main card (e.g. Ice + Split = 3 Ice Shards)
            // But if Multishot is the FIRST card, then it's a "Split Tower"
        }

        // Apply multishot damage penalty
        damage *= damageMultiplier;

        // Find pierce effect
        const pierceEffect = allEffects.find(e => e.type === 'pierce');
        if (pierceEffect) {
            pierce = pierceEffect.pierceCount || 0;
        }

        // === SPINUP MECHANIC ===
        // Find spinup effect and apply bonuses based on current spinupFrames
        const spinupEffect = allEffects.find(e => e.type === 'spinup');
        if (spinupEffect) {
            const spinupSeconds = this.spinupFrames / 60; // Convert frames to seconds

            // Apply damage bonus
            if (spinupEffect.spinupSteps) {
                // Stepped damage (Level 3) - optimized to find max applicable step
                let maxStepDamage = 0;
                for (const step of spinupEffect.spinupSteps) {
                    if (spinupSeconds >= step.threshold) {
                        maxStepDamage = step.damage;
                    } else {
                        // Steps are ordered, so no need to check further
                        break;
                    }
                }
                damage = damage + maxStepDamage;
            } else if (spinupEffect.spinupDamagePerSecond) {
                // Linear damage (Level 1-2)
                const bonusDamage = spinupEffect.spinupDamagePerSecond * spinupSeconds;
                damage += bonusDamage;
            }

            // Apply crit chance bonus
            if (spinupEffect.spinupCritPerSecond) {
                const bonusCrit = spinupEffect.spinupCritPerSecond * spinupSeconds;
                critChance += bonusCrit;
            }

            // Cap spinup at max seconds
            // (actual capping happens in WeaponSystem)
        }

        return {
            range: Math.round(range),
            dmg: damage,
            cd: Math.round(attackSpeed),
            speed,
            color,
            effects: allEffects,
            pierce,
            projCount,
            spread,
            critChance,
            projectileType
        };
    }

    addCard(c: ICard): boolean {
        if (this.cards.length < CONFIG.TOWER.MAX_CARDS) {
            this.cards.push(c);
            // this.costSpent += 100; // Removed cost tracking for cards
            return true;
        }
        return false;
    }

    removeCard(index: number): ICard | null {
        if (index < 0 || index >= this.cards.length) return null;
        const card = this.cards.splice(index, 1)[0];
        return card || null;
    }

    updateBuilding(effects: EffectSystem) {
        if (this.isBuilding) {
            this.buildProgress++;

            // Spawn dust particles during construction (every 10 frames)
            if (this.buildProgress % 10 === 0) {
                effects.add({
                    type: 'particle',
                    x: this.x + (Math.random() - 0.5) * 30,
                    y: this.y + 15,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -Math.random() * 2,
                    life: 20 + Math.random() * 10,
                    color: '#a69060',
                    radius: 2 + Math.random() * 2
                });
            }

            if (this.buildProgress >= this.maxBuildProgress) {
                this.isBuilding = false;

                // Completion burst - dust cloud
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    effects.add({
                        type: 'particle',
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3 - 1,
                        life: 25 + Math.random() * 10,
                        color: '#c0a060',
                        radius: 3 + Math.random() * 2
                    });
                }

                // Flash effect
                effects.add({ type: 'explosion', x: this.x, y: this.y, radius: 25, life: 15, color: '#ffd700' });
            }
        }
    }

    draw(ctx: CanvasRenderingContext2D) {
        RendererFactory.drawTower(ctx, this);
    }
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <title>NewTower v1.4 Alpha</title>
    <!-- Import Google Font for Ink Mode -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
    <style>
        /* --- INK MODE STYLES (Paper UI) --- */
        body.ink-mode {
            background: #f4e4bc url('https://www.transparenttextures.com/patterns/old-paper.png');
            color: #2d1b0e;
            font-family: 'MedievalSharp', cursive;
        }

        /* Common Paper Panel Style */
        body.ink-mode .top-bar,
        body.ink-mode .ui-panel,
        body.ink-mode #hand {
            background: #fff8e1 url('https://www.transparenttextures.com/patterns/cream-paper.png');
            border: none;
            box-shadow: 2px 3px 10px rgba(45, 27, 14, 0.4);
            color: #2d1b0e;
            position: relative;
            transform: rotate(-0.5deg);
            /* Slight organic tilt */
        }

        /* Fix Top Bar Sizing & alignment */
        body.ink-mode .top-bar {
            width: auto;
            min-width: 400px;
            max-width: 80vw;
            padding: 5px 20px;
            border-radius: 2px 255px 5px 25px / 255px 5px 225px 255px;
            justify-content: center;
            /* Combine transforms: Centering (-50%) + Tilt (-0.5deg) */
            transform: translateX(-50%) rotate(-0.5deg);
        }

        /* Torn Edge Effect using border-image or simple rough border */
        /* For simplicity and performance, we use a sketch-like border */
        body.ink-mode .ui-panel,
        body.ink-mode #hand {
            border: 2px solid #5d4037;
            border-radius: 2px 255px 5px 25px / 255px 5px 225px 255px;
            /* Irregular radius */
        }

        /* Specific fix for top-bar border to match others if needed,
           but we defined it above with sizing. Let's ensure it has the border too. */
        body.ink-mode .top-bar {
            border: 2px solid #5d4037;
        }

        /* PIN - Visual "Push Pin" */
        body.ink-mode .top-bar::after,
        body.ink-mode .ui-panel::after {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 16px;
            background: #c62828;
            /* Red pin head */
            border-radius: 50%;
            box-shadow: 1px 2px 4px rgba(0, 0, 0, 0.5), inset -2px -2px 4px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        /* Pin shadow */
        body.ink-mode .top-bar::before,
        body.ink-mode .ui-panel::before {
            content: '';
            position: absolute;
            top: -5px;
            left: 50%;
            margin-left: 2px;
            width: 4px;
            height: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
        }

        body.ink-mode .panel-title {
            color: #3e2723;
            border-bottom: 2px solid rgba(93, 64, 55, 0.3);
            font-family: 'MedievalSharp', cursive;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        body.ink-mode .slot {
            border: 2px dashed #8d6e63;
            color: #5d4037;
            font-family: 'MedievalSharp', cursive;
            background: rgba(255, 255, 255, 0.3);
        }

        body.ink-mode button {
            font-family: 'MedievalSharp', cursive;
            border: 2px solid #3e2723;
            text-transform: uppercase;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
            border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px;
        }

        body.ink-mode #shop-btn {
            background: #5d99c6;
            color: #fff;
        }

        body.ink-mode #forge-btn {
            background: #d87c4a;
            color: #fff;
        }

        body.ink-mode #start-wave-btn {
            background: #c62828;
            border: 3px double #fff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border-radius: 50% !important;
            /* Keep circle */
        }

        /* Ink Mode Cards - Sketch Style */
        body.ink-mode .card {
            border: 2px solid #2d1b0e;
            background: #fff;
            box-shadow: 1px 2px 4px rgba(45, 27, 14, 0.3);
            border-radius: 2px 10px 4px 8px;
            /* Slightly irregular */
        }

        /* Remove colorful gradients in Ink Mode, replace with sketchy color washes */
        /* We use pseudo-element for color wash */
        body.ink-mode .card.type-fire {
            background: #fffcf0;
        }

        body.ink-mode .card.type-ice {
            background: #f0fbff;
        }

        body.ink-mode .card.type-sniper {
            background: #f1f8e9;
        }

        body.ink-mode .card.type-multi {
            background: #fff8e1;
        }

        body.ink-mode .card.type-minigun {
            background: #f3e5f5;
        }

        body.ink-mode .card-icon {
            filter: grayscale(100%) contrast(150%);
            opacity: 0.8;
        }

        /* Add wash splash behind icon */
        body.ink-mode .card::before {
            content: '';
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            opacity: 0.2;
            z-index: 0;
            filter: blur(5px);
        }

        body.ink-mode .card.type-fire::before {
            background: #c62828;
        }

        body.ink-mode .card.type-ice::before {
            background: #0288d1;
        }

        body.ink-mode .card.type-sniper::before {
            background: #558b2f;
        }

        body.ink-mode .card.type-multi::before {
            background: #ffb300;
        }

        body.ink-mode .card.type-minigun::before {
            background: #8e24aa;
        }

        /* IMPROVED CARD READABILITY */
        body.ink-mode .card-stats {
            background: rgba(255, 255, 255, 0.85);
            /* Whiter background for contrast */
            color: #000;
            /* Pitch black text */
            border-top: 1px solid rgba(0, 0, 0, 0.2);
            padding: 6px 4px;
            /* More padding */
        }

        body.ink-mode .card-stat-primary,
        body.ink-mode .card-stat-line {
            color: #000;
            /* Pitch black */
            text-shadow: none;
            font-family: 'Segoe UI', sans-serif;
            /* Cleaner font than Courier */
            font-weight: 800;
            /* Extra bold */
            font-size: 10px;
            /* Larger */
            line-height: 1.2;
        }

        /* Default Mode */
        body {
            margin: 0;
            overflow: hidden;
            background: #222;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
            /* Reduced from 30px/0.5 */
            border-radius: 4px;
        }

        /* UI –°–ª–æ–π */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å */
        .top-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 30px;
            border-radius: 20px;
            display: flex;
            gap: 30px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }

        /* --- –ö–û–õ–û–ù–ö–ò –ò–ù–¢–ï–†–§–ï–ô–°–ê (–í–∞—Ä–∏–∞–Ω—Ç –ë: –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã) --- */
        .ui-column {
            position: absolute;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: none;
            /* –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–ª–∏–∫–∏ —Å–∫–≤–æ–∑—å –ø—É—Å—Ç–æ—Ç—É */
        }

        /* –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –°—Ç–∞—Ä—Ç, –ë–µ—Å—Ç–∏–∞—Ä–∏–π, –ö—É–∑–Ω–∏—Ü–∞ */
        #ui-left {
            left: 20px;
            align-items: flex-start;
        }

        /* –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –ò–Ω—Å–ø–µ–∫—Ç–æ—Ä, –ú–∞–≥–∞–∑–∏–Ω */
        #ui-right {
            right: 20px;
            align-items: flex-end;
        }

        /* –≠–ª–µ–º–µ–Ω—Ç—ã –≤–Ω—É—Ç—Ä–∏ –∫–æ–ª–æ–Ω–æ–∫ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–º–∏ */
        .ui-column>* {
            pointer-events: auto;
        }

        /* --- –≠–õ–ï–ú–ï–ù–¢–´ --- */
        #start-wave-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #d32f2f;
            border: 4px solid #b71c1c;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s;
        }

        #start-wave-btn:active {
            transform: scale(0.95);
        }

        #pause-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            transition: 0.2s;
            padding: 0;
            color: white;
        }

        #pause-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        /* –†—É–∫–∞ (–ø–æ —Ü–µ–Ω—Ç—Ä—É) */
        #hand-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40vw;
            pointer-events: auto;
        }

        #hand {
            display: flex;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            justify-content: center;
        }

        /* –ü–∞–Ω–µ–ª–∏ (–ú–∞–≥–∞–∑–∏–Ω, –ö—É–∑–Ω–∏—Ü–∞) */
        .ui-panel {
            padding: 15px;
            border-radius: 15px;
            background: rgba(40, 40, 50, 0.95);
            border: 2px solid #444;
            width: 250px;
        }

        .panel-title {
            color: #ddd;
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
            font-size: 14px;
            text-align: center;
        }

        .slots-container {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            justify-content: center;
        }

        .slot {
            width: 84px;
            height: 124px;
            border: 2px dashed #666;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #555;
            font-size: 24px;
        }

        .slot.shop-slot {
            border-color: gold;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        /* Default Neon Selection */
        .slot.shop-slot.selected {
            border: 2px solid #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }

        .slot.shop-slot:hover {
            transform: scale(1.08);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6), 0 4px 12px rgba(0, 0, 0, 0.4);
            border-color: #ffd700;
        }

        /* Ink Mode Selection (Red Marker Circle) */
        body.ink-mode .slot.shop-slot.selected {
            border: 3px solid #d32f2f;
            /* Red ink */
            background: rgba(211, 47, 47, 0.1);
            box-shadow: none;
            border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px;
            /* Irregular circle */
            transform: scale(1.02) rotate(-1deg);
        }

        body.ink-mode .slot.shop-slot:hover {
            border-color: #d32f2f;
            transform: scale(1.05);
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* –ö–Ω–æ–ø–∫–∏ */
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            color: white;
            background: #555;
            font-size: 16px;
            transition: 0.2s;
            width: 100%;
        }

        #forge-btn {
            background: #e65100;
        }

        #shop-btn {
            background: #1976d2;
        }

        button:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }

        /* –ö–∞—Ä—Ç—ã */
        .card {
            width: 80px;
            height: 120px;
            background: #fff;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            position: relative;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            cursor: grab;
            border: 3px solid rgba(0, 0, 0, 0.1);
            padding: 6px;
            transition: transform 0.2s, box-shadow 0.2s;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-3px);
        }

        /* –¢–∏–ø—ã –∫–∞—Ä—Ç - –±–∞–∑–æ–≤—ã–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã */
        .card.type-fire {
            background: linear-gradient(135deg, #ffcdd2, #e57373);
            border-color: #b71c1c;
        }

        .card.type-ice {
            background: linear-gradient(135deg, #b3e5fc, #4fc3f7);
            border-color: #0288d1;
        }

        .card.type-sniper {
            background: linear-gradient(135deg, #c8e6c9, #81c784);
            border-color: #388e3c;
        }

        .card.type-multi {
            background: linear-gradient(135deg, #ffe0b2, #ffb74d);
            border-color: #f57c00;
        }

        .card.type-minigun {
            background: linear-gradient(135deg, #e1bee7, #ba68c8);
            border-color: #8e24aa;
        }

        /* –£—Ä–æ–≤–µ–Ω—å 1 - —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π */
        .card.level-1 {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        /* –£—Ä–æ–≤–µ–Ω—å 2 - –ª—ë–≥–∫–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ —Å –ø—É–ª—å—Å–∞—Ü–∏–µ–π */
        .card.level-2 {
            border-width: 3px;
            animation: level2glow 3s ease-in-out infinite;
        }

        @keyframes level2glow {

            0%,
            100% {
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4),
                    0 0 15px var(--card-glow-color, rgba(255, 255, 255, 0.3));
            }

            50% {
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5),
                    0 0 25px var(--card-glow-color, rgba(255, 255, 255, 0.5));
            }
        }

        .card.type-fire.level-2 {
            --card-glow-color: rgba(255, 87, 34, 0.4);
        }

        .card.type-ice.level-2 {
            --card-glow-color: rgba(0, 188, 212, 0.4);
        }

        .card.type-sniper.level-2 {
            --card-glow-color: rgba(76, 175, 80, 0.4);
        }

        .card.type-multi.level-2 {
            --card-glow-color: rgba(255, 152, 0, 0.4);
        }

        .card.type-minigun.level-2 {
            --card-glow-color: rgba(156, 39, 176, 0.4);
        }

        /* –£—Ä–æ–≤–µ–Ω—å 3 - –õ–ï–ì–ï–ù–î–ê–†–ù–´–ô —ç—Ñ—Ñ–µ–∫—Ç */
        .card.level-3 {
            border-width: 4px;
            border-color: #ffd700;
            animation: level3legendary 2s ease-in-out infinite;
        }

        .card.level-3::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: linear-gradient(45deg,
                    #ffd700 0%,
                    #ff8c00 25%,
                    #ffd700 50%,
                    #ff8c00 75%,
                    #ffd700 100%);
            border-radius: 10px;
            z-index: -1;
            background-size: 200% 200%;
            animation: legendaryBorder 3s linear infinite;
        }

        @keyframes level3legendary {

            0%,
            100% {
                box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6),
                    0 0 30px rgba(255, 215, 0, 0.4),
                    inset 0 0 20px rgba(255, 215, 0, 0.1);
            }

            50% {
                box-shadow: 0 8px 30px rgba(255, 215, 0, 0.8),
                    0 0 50px rgba(255, 140, 0, 0.6),
                    inset 0 0 30px rgba(255, 215, 0, 0.2);
            }
        }

        @keyframes legendaryBorder {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        /* –ó–≤—ë–∑–¥–æ—á–∫–∏ —É—Ä–æ–≤–Ω—è - –≤–µ—Ä—Ö–Ω–∏–π –ª–µ–≤—ã–π —É–≥–æ–ª */
        .card-level {
            position: absolute;
            top: 4px;
            left: 6px;
            font-weight: bold;
            font-size: 11px;
            color: #333;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
            line-height: 1;
        }

        .card.level-3 .card-level {
            color: #ffd700;
            text-shadow: 0 0 4px rgba(255, 215, 0, 0.8), 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* –ò–∫–æ–Ω–∫–∞ - —Ü–µ–Ω—Ç—Ä */
        .card-icon {
            font-size: 36px;
            margin-top: 8px;
            margin-bottom: 4px;
            filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.2));
        }

        /* –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –∫–∞—Ä—Ç—ã - —Å–Ω–∏–∑—É */
        .card-stats {
            margin-top: auto;
            width: calc(100% + 12px);
            margin-left: -6px;
            margin-bottom: -6px;
            text-align: center;
            font-size: 9px;
            line-height: 1.3;
            color: #fff;
            font-weight: 700;
            background: rgba(0, 0, 0, 0.55);
            padding: 4px 6px;
            border-radius: 0 0 7px 7px;
            backdrop-filter: blur(2px);
        }

        .card-stat-line {
            white-space: nowrap;
            margin: 1px 0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .card-stat-primary {
            font-size: 10px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.9);
        }

        #drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            display: none;
            opacity: 0.8;
            transform: scale(1.1);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .shaking {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }

            100% {
                transform: translateX(0);
            }
        }

        @keyframes forging {
            0% {
                box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.9), 0 0 50px rgba(255, 152, 0, 0.5);
                transform: scale(1.05);
            }

            100% {
                box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
                transform: scale(1);
            }
        }

        .slot.forging {
            animation: forging 0.4s ease-in-out infinite;
            border-color: #ffd700 !important;
            background: rgba(255, 215, 0, 0.2) !important;
        }

        /* –≠–∫—Ä–∞–Ω —Å–º–µ—Ä—Ç–∏ –∏ Game Over */
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10000;
        }

        /* Card Selection Overlay */
        #card-selection-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            animation: fadeIn 0.3s ease-out;
        }

        #card-selection-overlay.show {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .selection-title {
            color: #fff;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
        }

        .selection-subtitle {
            color: #aaa;
            font-size: 16px;
            margin-bottom: 30px;
            text-align: center;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 20px;
            max-width: 800px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .selection-card {
            width: 100px;
            height: 140px;
            background: #fff;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
            animation: slideUp 0.4s ease-out backwards;
        }

        .selection-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.6);
        }

        .selection-card.selected {
            border-color: #4caf50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
        }

        .selection-card.type-minigun {
            background: linear-gradient(135deg, #e1bee7, #ba68c8);
            border-color: #8e24aa;
            box-shadow: 0 4px 12px rgba(142, 36, 170, 0.5), 0 0 15px rgba(156, 39, 176, 0.4);
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .selection-card-icon {
            font-size: 48px;
            margin-bottom: 8px;
        }

        .selection-card-name {
            font-size: 12px;
            font-weight: bold;
            color: #333;
            text-align: center;
        }

        .selection-counter {
            color: #fff;
            font-size: 24px;
            margin-bottom: 20px;
        }

        #start-game-btn {
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            border: none;
            border-radius: 12px;
            background: #4caf50;
            color: white;
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }

        #start-game-btn:hover:not(:disabled) {
            background: #66bb6a;
            transform: scale(1.05);
        }

        #start-game-btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }

        /* Selected card in card selection screen */
        .card.selected {
            transform: translateY(-10px) !important;
            border-color: #4caf50 !important;
            border-width: 4px !important;
            box-shadow: 0 8px 20px rgba(76, 175, 80, 0.6),
                0 0 30px rgba(76, 175, 80, 0.4) !important;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <div id="ui-layer">
            <div class="top-bar">
                <div>üí∞ <span id="money">0</span></div>
                <div>‚ù§Ô∏è <span id="lives">20</span></div>
                <div>‚öîÔ∏è <span id="wave">1</span></div>

                <div>üëπ <span id="enemy-counter">0/0</span></div>
                <button id="theme-btn"
                    style="padding: 5px 10px; font-size: 16px; width: auto; background: #444;">üé®</button>
            </div>

            <div id="ui-left" class="ui-column">
                <button id="start-wave-btn" style="pointer-events: auto;">‚öîÔ∏è</button>
                <div id="forge-container" class="ui-panel">
                    <div class="panel-title">‚öíÔ∏è –ö–£–ó–ù–ò–¶–ê (Forge)</div>
                    <div class="slots-container">
                        <div class="slot" id="forge-slot-0">1</div>
                        <div class="slot" id="forge-slot-1">2</div>
                    </div>
                    <button id="forge-btn" disabled><span>‚öíÔ∏è</span> –ù–ï–¢ –ö–ê–†–¢</button>
                </div>
            </div>

            <div id="hand-container">
                <div id="hand"></div>
            </div>

            <div id="ui-right" class="ui-column">
                <div id="shop-container" class="ui-panel">
                    <div class="panel-title">üõí –ú–ê–ì–ê–ó–ò–ù (Shop)</div>
                    <div class="slots-container" id="shop-slots">
                        <div class="slot shop-slot">?</div>
                        <div class="slot shop-slot">?</div>
                        <div class="slot shop-slot">?</div>
                    </div>
                    <!-- CHANGED: Split into Refresh + Buy -->
                    <div style="display: flex; gap: 10px;">
                        <button id="shop-refresh-btn" style="background: #7b1fa2; flex: 1;">‚Üª 25üí∞</button>
                        <button id="shop-btn" disabled style="background: #1976d2; flex: 2;"><span>üõí</span>
                            100üí∞</button>
                    </div>
                </div>
            </div>

            <div id="game-over">
                <h1>GAME OVER</h1>
                <p>Wave reached: <span id="final-wave">0</span></p>
                <br>
                <button id="restart-btn" style="width: 200px;">Try Again</button>
            </div>
        </div>

        <div id="drag-ghost" class="card"></div>
    </div>

    <!-- Card Selection Overlay -->
    <div id="card-selection-overlay">
        <div class="selection-title">–í—ã–±–µ—Ä–∏—Ç–µ 5 —Å—Ç–∞—Ä—Ç–æ–≤—ã—Ö –∫–∞—Ä—Ç</div>
        <div class="selection-subtitle">–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—ã –¥–ª—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã. –ú–æ–∂–Ω–æ –≤—ã–±–∏—Ä–∞—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ.</div>
        <div class="cards-grid" id="card-selection-grid"></div>
        <div class="selection-counter">–í—ã–±—Ä–∞–Ω–æ: <span id="selected-count">0</span>/5</div>
        <button id="start-game-btn" disabled>–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
    </div>

    <script type="module" src="/src/index.ts"></script>
</body>

</html>
</file>

<file path="src/Game.ts">
import { Assets } from './Assets';
import { IMapData } from './MapData';
import { Scene } from './Scene';
import { MenuScene } from './scenes/MenuScene';
import { InputSystem } from './InputSystem';
import { SoundManager } from './SoundManager';
import { CardSelectionUI } from './CardSelectionUI';

export class Game {
    public canvas: HTMLCanvasElement;
    public ctx: CanvasRenderingContext2D;

    public input: InputSystem;
    public currentScene: Scene | null = null;
    private lastTime: number = 0;
    private cardSelection: CardSelectionUI;

    constructor(canvasId: string) {
        const canvas = document.getElementById(canvasId) as HTMLCanvasElement;
        if (!canvas) throw new Error('Canvas not found!');
        this.canvas = canvas;
        this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;

        this.input = new InputSystem(this);
        this.loop = this.loop.bind(this);
    }

    public async start() {
        this.drawLoadingScreen();

        try {
            await SoundManager.init();

            // Global Audio Resume logic (Deduplicated from UIManager)
            const resumeAudio = () => {
                SoundManager.resume();
            };
            window.addEventListener('click', resumeAudio, { once: true });
            window.addEventListener('keydown', resumeAudio, { once: true });

            await Assets.loadAll();

            // FIXED: Initialize card selection UI AFTER Assets loaded (DOM is ready)
            this.cardSelection = new CardSelectionUI((selectedCards) => {
                // Callback: when selection is complete, load the game with selected cards
                this.startGameWithCards(selectedCards);
            });

            console.log('Game started!');
            this.toMenu();
            this.loop(0);
        } catch (e) {
            console.error('FATAL ERROR: Failed to load assets', e);
            this.ctx.fillStyle = 'red';
            this.ctx.fillText('FAILED TO LOAD ASSETS', 50, 50);
        }
    }

    private drawLoadingScreen() {
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.fillStyle = '#fff';
        this.ctx.font = '30px Segoe UI';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('LOADING ASSETS...', this.canvas.width / 2, this.canvas.height / 2);
    }

    public changeScene(newScene: Scene) {
        if (this.currentScene) {
            this.currentScene.onExit();
        }
        this.currentScene = newScene;
        this.currentScene.onEnter();
    }

    public toMenu() {
        this.changeScene(new MenuScene(this));
    }

    private pendingMapData?: IMapData;

    public toGame(mapData?: IMapData) {
        // Store map data and show card selection
        this.pendingMapData = mapData;
        this.cardSelection.show();
    }

    private startGameWithCards(selectedCards: string[]) {
        import('./scenes/GameScene')
            .then(({ GameScene }) => {
                // Pass selected cards to GameScene via global or constructor
                (window as any)._STARTING_CARDS = selectedCards;
                this.changeScene(new GameScene(this, this.pendingMapData));
            })
            .catch((err) => {
                console.error('Failed to load GameScene:', err);
                this.drawError('Failed to load GameScene. Check console.');
                setTimeout(() => this.toMenu(), 3000);
            });
    }

    public toEditor() {
        import('./scenes/EditorScene')
            .then(({ EditorScene }) => {
                this.changeScene(new EditorScene(this));
            })
            .catch((err) => {
                console.error('Failed to load EditorScene:', err);
                this.drawError('Failed to load EditorScene. Check console.');
                setTimeout(() => this.toMenu(), 3000);
            });
    }

    private loop(timestamp: number) {
        this.lastTime = timestamp;

        this.input.update();

        if (this.currentScene) {
            this.currentScene.update();
            this.currentScene.draw(this.ctx);
        }

        requestAnimationFrame(this.loop);
    }
    private drawError(msg: string) {
        this.ctx.fillStyle = 'rgba(0,0,0,0.8)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = 'red';
        this.ctx.font = '30px Segoe UI';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(msg, this.canvas.width / 2, this.canvas.height / 2);
    }
}
</file>

</files>
